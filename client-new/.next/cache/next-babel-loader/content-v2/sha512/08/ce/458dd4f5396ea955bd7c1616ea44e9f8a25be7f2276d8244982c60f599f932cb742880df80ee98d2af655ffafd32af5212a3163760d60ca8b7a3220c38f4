{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useState, useEffect } from 'react';\nimport http from './httpInstance';\nimport axios from 'axios';\nconst memStore = {};\n\nconst useFetch = (url, props = {}, axiosOptions = {}) => {\n  const {\n    0: data,\n    1: setData\n  } = useState(null);\n  const {\n    0: isLoading,\n    1: setIsLoading\n  } = useState(false);\n  const {\n    0: error,\n    1: setError\n  } = useState(null);\n  const {\n    0: shouldRefetch,\n    1: reFetch\n  } = useState({});\n  useEffect(() => {\n    let unmounted = false;\n    let source = axios.CancelToken.source();\n\n    const getData = async () => {\n      setIsLoading(true);\n\n      try {\n        let httpConfig = _objectSpread(_objectSpread({\n          method: 'GET',\n          url: url\n        }, axiosOptions), {}, {\n          cancelToken: source.token\n        });\n\n        let res = await http(httpConfig);\n\n        if (!unmounted) {\n          setIsLoading(false);\n          setData(res.data);\n          if (props.cache) memStore[url] = res.data;\n        }\n      } catch (err) {\n        if (!unmounted) {\n          setIsLoading(false);\n          setError(err);\n        }\n      }\n    };\n\n    if (memStore[url] && !unmounted) {\n      setIsLoading(false);\n      setData(memStore[url]);\n    } else {\n      getData();\n    }\n\n    return () => {\n      unmounted = true;\n      source.cancel(`${url} canceled`);\n    };\n  }, [url, shouldRefetch]);\n  return [data, isLoading, error, reFetch];\n};\n\nexport default useFetch;","map":{"version":3,"sources":["C:/Users/2012b/WebstormProjects/ecommerce-MERN/client-new/src/hooks/useFetch.ts"],"names":["useState","useEffect","http","axios","memStore","useFetch","url","props","axiosOptions","data","setData","isLoading","setIsLoading","error","setError","shouldRefetch","reFetch","unmounted","source","CancelToken","getData","httpConfig","method","cancelToken","token","res","cache","err","cancel"],"mappings":";;;;;;AAAA,SAAgBA,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AACA,OAAOC,IAAP,MAAiB,gBAAjB;AACA,OAAOC,KAAP,MAA0C,OAA1C;AAKA,MAAMC,QAAuB,GAAG,EAAhC;;AAYA,MAAMC,QAAuB,GAAG,CAACC,GAAD,EAAMC,KAAK,GAAG,EAAd,EAAkBC,YAAY,GAAG,EAAjC,KAAwC;AACpE,QAAM;AAAA,OAACC,IAAD;AAAA,OAAOC;AAAP,MAAkBV,QAAQ,CAAM,IAAN,CAAhC;AACA,QAAM;AAAA,OAACW,SAAD;AAAA,OAAYC;AAAZ,MAA4BZ,QAAQ,CAAU,KAAV,CAA1C;AACA,QAAM;AAAA,OAACa,KAAD;AAAA,OAAQC;AAAR,MAAoBd,QAAQ,CAAM,IAAN,CAAlC;AACA,QAAM;AAAA,OAACe,aAAD;AAAA,OAAgBC;AAAhB,MAA2BhB,QAAQ,CAAC,EAAD,CAAzC;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIgB,SAAS,GAAG,KAAhB;AACA,QAAIC,MAAM,GAAGf,KAAK,CAACgB,WAAN,CAAkBD,MAAlB,EAAb;;AACA,UAAME,OAAO,GAAG,YAAY;AACxBR,MAAAA,YAAY,CAAC,IAAD,CAAZ;;AACA,UAAI;AACA,YAAIS,UAA8B;AAC9BC,UAAAA,MAAM,EAAE,KADsB;AAE9BhB,UAAAA,GAAG,EAAEA;AAFyB,WAG3BE,YAH2B;AAI9Be,UAAAA,WAAW,EAAEL,MAAM,CAACM;AAJU,UAAlC;;AAMA,YAAIC,GAAG,GAAG,MAAMvB,IAAI,CAACmB,UAAD,CAApB;;AACA,YAAI,CAACJ,SAAL,EAAgB;AACZL,UAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,UAAAA,OAAO,CAACe,GAAG,CAAChB,IAAL,CAAP;AACA,cAAIF,KAAK,CAACmB,KAAV,EAAiBtB,QAAQ,CAACE,GAAD,CAAR,GAAgBmB,GAAG,CAAChB,IAApB;AACpB;AACJ,OAbD,CAaE,OAAOkB,GAAP,EAAY;AACV,YAAI,CAACV,SAAL,EAAgB;AACZL,UAAAA,YAAY,CAAC,KAAD,CAAZ;AACAE,UAAAA,QAAQ,CAACa,GAAD,CAAR;AACH;AACJ;AACJ,KArBD;;AAuBA,QAAIvB,QAAQ,CAACE,GAAD,CAAR,IAAiB,CAACW,SAAtB,EAAiC;AAC7BL,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,MAAAA,OAAO,CAACN,QAAQ,CAACE,GAAD,CAAT,CAAP;AACH,KAHD,MAGO;AACHc,MAAAA,OAAO;AACV;;AAED,WAAO,MAAM;AACTH,MAAAA,SAAS,GAAG,IAAZ;AACAC,MAAAA,MAAM,CAACU,MAAP,CAAe,GAAEtB,GAAI,WAArB;AACH,KAHD;AAIH,GArCQ,EAqCN,CAACA,GAAD,EAAMS,aAAN,CArCM,CAAT;AAuCA,SAAO,CAACN,IAAD,EAAOE,SAAP,EAAkBE,KAAlB,EAAyBG,OAAzB,CAAP;AACH,CA9CD;;AAgDA,eAAeX,QAAf","sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport http from './httpInstance';\r\nimport axios, { AxiosRequestConfig } from 'axios';\r\n\r\ninterface memStoreTypes {\r\n    [x: string]: string;\r\n}\r\nconst memStore: memStoreTypes = {};\r\n\r\ninterface useFetchProps {\r\n    (\r\n        url: string,\r\n        props?: {\r\n            cache?: boolean;\r\n        },\r\n        axiosOptions?: AxiosRequestConfig\r\n    ): [any, boolean, any, React.Dispatch<React.SetStateAction<{}>>];\r\n}\r\n\r\nconst useFetch: useFetchProps = (url, props = {}, axiosOptions = {}) => {\r\n    const [data, setData] = useState<any>(null);\r\n    const [isLoading, setIsLoading] = useState<boolean>(false);\r\n    const [error, setError] = useState<any>(null);\r\n    const [shouldRefetch, reFetch] = useState({});\r\n\r\n    useEffect(() => {\r\n        let unmounted = false;\r\n        let source = axios.CancelToken.source();\r\n        const getData = async () => {\r\n            setIsLoading(true);\r\n            try {\r\n                let httpConfig: AxiosRequestConfig = {\r\n                    method: 'GET',\r\n                    url: url,\r\n                    ...axiosOptions,\r\n                    cancelToken: source.token\r\n                };\r\n                let res = await http(httpConfig);\r\n                if (!unmounted) {\r\n                    setIsLoading(false);\r\n                    setData(res.data);\r\n                    if (props.cache) memStore[url] = res.data;\r\n                }\r\n            } catch (err) {\r\n                if (!unmounted) {\r\n                    setIsLoading(false);\r\n                    setError(err);\r\n                }\r\n            }\r\n        };\r\n\r\n        if (memStore[url] && !unmounted) {\r\n            setIsLoading(false);\r\n            setData(memStore[url]);\r\n        } else {\r\n            getData();\r\n        }\r\n\r\n        return () => {\r\n            unmounted = true;\r\n            source.cancel(`${url} canceled`);\r\n        };\r\n    }, [url, shouldRefetch]);\r\n\r\n    return [data, isLoading, error, reFetch];\r\n};\r\n\r\nexport default useFetch;\r\n"]},"metadata":{},"sourceType":"module"}