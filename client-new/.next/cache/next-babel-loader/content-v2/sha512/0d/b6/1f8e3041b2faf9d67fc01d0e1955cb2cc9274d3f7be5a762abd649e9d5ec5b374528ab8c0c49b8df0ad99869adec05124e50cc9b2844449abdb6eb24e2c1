{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/2012b/WebstormProjects/ecommerce-MERN/client-new/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"C:/Users/2012b/WebstormProjects/ecommerce-MERN/client-new/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"C:/Users/2012b/WebstormProjects/ecommerce-MERN/client-new/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useState, useEffect } from 'react';\nimport http from './httpInstance';\nimport axios from 'axios';\nvar memStore = {};\n\nvar useFetch = function useFetch(url) {\n  _s();\n\n  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var axiosOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _useState = useState(null),\n      data = _useState[0],\n      setData = _useState[1];\n\n  var _useState2 = useState(false),\n      isLoading = _useState2[0],\n      setIsLoading = _useState2[1];\n\n  var _useState3 = useState(null),\n      error = _useState3[0],\n      setError = _useState3[1];\n\n  var _useState4 = useState({}),\n      shouldRefetch = _useState4[0],\n      reFetch = _useState4[1];\n\n  useEffect(function () {\n    var unmounted = false;\n    var source = axios.CancelToken.source();\n\n    var getData = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var httpConfig, res;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                setIsLoading(true);\n                _context.prev = 1;\n                httpConfig = _objectSpread(_objectSpread({\n                  method: 'GET',\n                  url: url\n                }, axiosOptions), {}, {\n                  cancelToken: source.token\n                });\n                _context.next = 5;\n                return http(httpConfig);\n\n              case 5:\n                res = _context.sent;\n\n                if (!unmounted) {\n                  setIsLoading(false);\n                  setData(res.data);\n                  if (props.cache) memStore[url] = res.data;\n                }\n\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!unmounted) {\n                  setIsLoading(false);\n                  setError(_context.t0);\n                }\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 9]]);\n      }));\n\n      return function getData() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    if (memStore[url] && !unmounted) {\n      setIsLoading(false);\n      setData(memStore[url]);\n    } else {\n      getData();\n    }\n\n    return function () {\n      unmounted = true;\n      source.cancel(\"\".concat(url, \" canceled\"));\n    };\n  }, [url, shouldRefetch]);\n  return [data, isLoading, error, reFetch];\n};\n\n_s(useFetch, \"uAdi348ATLP2XhEdsvverculOcw=\");\n\nexport default useFetch;","map":{"version":3,"sources":["C:/Users/2012b/WebstormProjects/ecommerce-MERN/client-new/src/hooks/useFetch.ts"],"names":["useState","useEffect","http","axios","memStore","useFetch","url","props","axiosOptions","data","setData","isLoading","setIsLoading","error","setError","shouldRefetch","reFetch","unmounted","source","CancelToken","getData","httpConfig","method","cancelToken","token","res","cache","cancel"],"mappings":";;;;;;;;;;AAAA,SAAgBA,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AACA,OAAOC,IAAP,MAAiB,gBAAjB;AACA,OAAOC,KAAP,MAA0C,OAA1C;AAKA,IAAMC,QAAuB,GAAG,EAAhC;;AAYA,IAAMC,QAAuB,GAAG,SAA1BA,QAA0B,CAACC,GAAD,EAAwC;AAAA;;AAAA,MAAlCC,KAAkC,uEAA1B,EAA0B;AAAA,MAAtBC,YAAsB,uEAAP,EAAO;;AAAA,kBAC5CR,QAAQ,CAAM,IAAN,CADoC;AAAA,MAC7DS,IAD6D;AAAA,MACvDC,OADuD;;AAAA,mBAElCV,QAAQ,CAAU,KAAV,CAF0B;AAAA,MAE7DW,SAF6D;AAAA,MAElDC,YAFkD;;AAAA,mBAG1CZ,QAAQ,CAAM,IAAN,CAHkC;AAAA,MAG7Da,KAH6D;AAAA,MAGtDC,QAHsD;;AAAA,mBAInCd,QAAQ,CAAC,EAAD,CAJ2B;AAAA,MAI7De,aAJ6D;AAAA,MAI9CC,OAJ8C;;AAMpEf,EAAAA,SAAS,CAAC,YAAM;AACZ,QAAIgB,SAAS,GAAG,KAAhB;AACA,QAAIC,MAAM,GAAGf,KAAK,CAACgB,WAAN,CAAkBD,MAAlB,EAAb;;AACA,QAAME,OAAO;AAAA,0EAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACZR,gBAAAA,YAAY,CAAC,IAAD,CAAZ;AADY;AAGJS,gBAAAA,UAHI;AAIJC,kBAAAA,MAAM,EAAE,KAJJ;AAKJhB,kBAAAA,GAAG,EAAEA;AALD,mBAMDE,YANC;AAOJe,kBAAAA,WAAW,EAAEL,MAAM,CAACM;AAPhB;AAAA;AAAA,uBASQtB,IAAI,CAACmB,UAAD,CATZ;;AAAA;AASJI,gBAAAA,GATI;;AAUR,oBAAI,CAACR,SAAL,EAAgB;AACZL,kBAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,kBAAAA,OAAO,CAACe,GAAG,CAAChB,IAAL,CAAP;AACA,sBAAIF,KAAK,CAACmB,KAAV,EAAiBtB,QAAQ,CAACE,GAAD,CAAR,GAAgBmB,GAAG,CAAChB,IAApB;AACpB;;AAdO;AAAA;;AAAA;AAAA;AAAA;;AAgBR,oBAAI,CAACQ,SAAL,EAAgB;AACZL,kBAAAA,YAAY,CAAC,KAAD,CAAZ;AACAE,kBAAAA,QAAQ,aAAR;AACH;;AAnBO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAH;;AAAA,sBAAPM,OAAO;AAAA;AAAA;AAAA,OAAb;;AAuBA,QAAIhB,QAAQ,CAACE,GAAD,CAAR,IAAiB,CAACW,SAAtB,EAAiC;AAC7BL,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,MAAAA,OAAO,CAACN,QAAQ,CAACE,GAAD,CAAT,CAAP;AACH,KAHD,MAGO;AACHc,MAAAA,OAAO;AACV;;AAED,WAAO,YAAM;AACTH,MAAAA,SAAS,GAAG,IAAZ;AACAC,MAAAA,MAAM,CAACS,MAAP,WAAiBrB,GAAjB;AACH,KAHD;AAIH,GArCQ,EAqCN,CAACA,GAAD,EAAMS,aAAN,CArCM,CAAT;AAuCA,SAAO,CAACN,IAAD,EAAOE,SAAP,EAAkBE,KAAlB,EAAyBG,OAAzB,CAAP;AACH,CA9CD;;GAAMX,Q;;AAgDN,eAAeA,QAAf","sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport http from './httpInstance';\r\nimport axios, { AxiosRequestConfig } from 'axios';\r\n\r\ninterface memStoreTypes {\r\n    [x: string]: string;\r\n}\r\nconst memStore: memStoreTypes = {};\r\n\r\ninterface useFetchProps {\r\n    (\r\n        url: string,\r\n        props?: {\r\n            cache?: boolean;\r\n        },\r\n        axiosOptions?: AxiosRequestConfig\r\n    ): [any, boolean, any, React.Dispatch<React.SetStateAction<{}>>];\r\n}\r\n\r\nconst useFetch: useFetchProps = (url, props = {}, axiosOptions = {}) => {\r\n    const [data, setData] = useState<any>(null);\r\n    const [isLoading, setIsLoading] = useState<boolean>(false);\r\n    const [error, setError] = useState<any>(null);\r\n    const [shouldRefetch, reFetch] = useState({});\r\n\r\n    useEffect(() => {\r\n        let unmounted = false;\r\n        let source = axios.CancelToken.source();\r\n        const getData = async () => {\r\n            setIsLoading(true);\r\n            try {\r\n                let httpConfig: AxiosRequestConfig = {\r\n                    method: 'GET',\r\n                    url: url,\r\n                    ...axiosOptions,\r\n                    cancelToken: source.token\r\n                };\r\n                let res = await http(httpConfig);\r\n                if (!unmounted) {\r\n                    setIsLoading(false);\r\n                    setData(res.data);\r\n                    if (props.cache) memStore[url] = res.data;\r\n                }\r\n            } catch (err) {\r\n                if (!unmounted) {\r\n                    setIsLoading(false);\r\n                    setError(err);\r\n                }\r\n            }\r\n        };\r\n\r\n        if (memStore[url] && !unmounted) {\r\n            setIsLoading(false);\r\n            setData(memStore[url]);\r\n        } else {\r\n            getData();\r\n        }\r\n\r\n        return () => {\r\n            unmounted = true;\r\n            source.cancel(`${url} canceled`);\r\n        };\r\n    }, [url, shouldRefetch]);\r\n\r\n    return [data, isLoading, error, reFetch];\r\n};\r\n\r\nexport default useFetch;\r\n"]},"metadata":{},"sourceType":"module"}