{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useState, useEffect } from 'react';\nimport http from './httpInstance';\nimport axios from 'axios';\nconst memStore = {};\n\nconst useFetch = (url, props = {}, axiosOptions = {}) => {\n  const {\n    0: data,\n    1: setData\n  } = useState(null);\n  const {\n    0: isLoading,\n    1: setIsLoading\n  } = useState(false);\n  const {\n    0: error,\n    1: setError\n  } = useState(null);\n  const {\n    0: shouldRefetch,\n    1: reFetch\n  } = useState({});\n  useEffect(() => {\n    let unmounted = false;\n    let source = axios.CancelToken.source();\n\n    const getData = async () => {\n      setIsLoading(true);\n\n      try {\n        let httpConfig = _objectSpread(_objectSpread({\n          method: 'GET',\n          url: url\n        }, axiosOptions), {}, {\n          cancelToken: source.token\n        });\n\n        let res = await http(httpConfig);\n        console.log(res);\n\n        if (!unmounted) {\n          setIsLoading(false);\n          setData(res.data);\n          if (props.cache) memStore[url] = res.data;\n        }\n      } catch (err) {\n        if (!unmounted) {\n          console.log(err);\n          setIsLoading(false);\n          setError(err);\n        }\n      }\n    };\n\n    if (memStore[url] && !unmounted) {\n      setIsLoading(false);\n      setData(memStore[url]);\n    } else {\n      getData();\n    }\n\n    return () => {\n      unmounted = true;\n      source.cancel(`${url} canceled`);\n    };\n  }, [url, shouldRefetch]);\n  return [data, isLoading, error, reFetch];\n};\n\nexport default useFetch;","map":{"version":3,"sources":["/home/hari/WebstormProjects/ecommerce-MERN/client-new/src/hooks/useFetch.ts"],"names":["useState","useEffect","http","axios","memStore","useFetch","url","props","axiosOptions","data","setData","isLoading","setIsLoading","error","setError","shouldRefetch","reFetch","unmounted","source","CancelToken","getData","httpConfig","method","cancelToken","token","res","console","log","cache","err","cancel"],"mappings":";;;;;;AAAA,SAAgBA,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AACA,OAAOC,IAAP,MAAiB,gBAAjB;AACA,OAAOC,KAAP,MAA0C,OAA1C;AAKA,MAAMC,QAAuB,GAAG,EAAhC;;AAYA,MAAMC,QAAuB,GAAG,CAACC,GAAD,EAAMC,KAAK,GAAG,EAAd,EAAkBC,YAAY,GAAG,EAAjC,KAAwC;AACpE,QAAM;AAAA,OAACC,IAAD;AAAA,OAAOC;AAAP,MAAkBV,QAAQ,CAAM,IAAN,CAAhC;AACA,QAAM;AAAA,OAACW,SAAD;AAAA,OAAYC;AAAZ,MAA4BZ,QAAQ,CAAU,KAAV,CAA1C;AACA,QAAM;AAAA,OAACa,KAAD;AAAA,OAAQC;AAAR,MAAoBd,QAAQ,CAAM,IAAN,CAAlC;AACA,QAAM;AAAA,OAACe,aAAD;AAAA,OAAgBC;AAAhB,MAA2BhB,QAAQ,CAAC,EAAD,CAAzC;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIgB,SAAS,GAAG,KAAhB;AACA,QAAIC,MAAM,GAAGf,KAAK,CAACgB,WAAN,CAAkBD,MAAlB,EAAb;;AACA,UAAME,OAAO,GAAG,YAAY;AACxBR,MAAAA,YAAY,CAAC,IAAD,CAAZ;;AACA,UAAI;AACA,YAAIS,UAA8B;AAC9BC,UAAAA,MAAM,EAAE,KADsB;AAE9BhB,UAAAA,GAAG,EAAEA;AAFyB,WAG3BE,YAH2B;AAI9Be,UAAAA,WAAW,EAAEL,MAAM,CAACM;AAJU,UAAlC;;AAMA,YAAIC,GAAG,GAAG,MAAMvB,IAAI,CAACmB,UAAD,CAApB;AACAK,QAAAA,OAAO,CAACC,GAAR,CAAYF,GAAZ;;AACA,YAAI,CAACR,SAAL,EAAgB;AACZL,UAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,UAAAA,OAAO,CAACe,GAAG,CAAChB,IAAL,CAAP;AACA,cAAIF,KAAK,CAACqB,KAAV,EAAiBxB,QAAQ,CAACE,GAAD,CAAR,GAAgBmB,GAAG,CAAChB,IAApB;AACpB;AACJ,OAdD,CAcE,OAAOoB,GAAP,EAAY;AACV,YAAI,CAACZ,SAAL,EAAgB;AACZS,UAAAA,OAAO,CAACC,GAAR,CAAYE,GAAZ;AACAjB,UAAAA,YAAY,CAAC,KAAD,CAAZ;AACAE,UAAAA,QAAQ,CAACe,GAAD,CAAR;AACH;AACJ;AACJ,KAvBD;;AAyBA,QAAIzB,QAAQ,CAACE,GAAD,CAAR,IAAiB,CAACW,SAAtB,EAAiC;AAC7BL,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,MAAAA,OAAO,CAACN,QAAQ,CAACE,GAAD,CAAT,CAAP;AACH,KAHD,MAGO;AACHc,MAAAA,OAAO;AACV;;AAED,WAAO,MAAM;AACTH,MAAAA,SAAS,GAAG,IAAZ;AACAC,MAAAA,MAAM,CAACY,MAAP,CAAe,GAAExB,GAAI,WAArB;AACH,KAHD;AAIH,GAvCQ,EAuCN,CAACA,GAAD,EAAMS,aAAN,CAvCM,CAAT;AAyCA,SAAO,CAACN,IAAD,EAAOE,SAAP,EAAkBE,KAAlB,EAAyBG,OAAzB,CAAP;AACH,CAhDD;;AAkDA,eAAeX,QAAf","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport http from './httpInstance';\nimport axios, { AxiosRequestConfig } from 'axios';\n\ninterface memStoreTypes {\n    [x: string]: string;\n}\nconst memStore: memStoreTypes = {};\n\ninterface useFetchProps {\n    (\n        url: string,\n        props?: {\n            cache?: boolean;\n        },\n        axiosOptions?: AxiosRequestConfig\n    ): [any, boolean, any, React.Dispatch<React.SetStateAction<{}>>];\n}\n\nconst useFetch: useFetchProps = (url, props = {}, axiosOptions = {}) => {\n    const [data, setData] = useState<any>(null);\n    const [isLoading, setIsLoading] = useState<boolean>(false);\n    const [error, setError] = useState<any>(null);\n    const [shouldRefetch, reFetch] = useState({});\n\n    useEffect(() => {\n        let unmounted = false;\n        let source = axios.CancelToken.source();\n        const getData = async () => {\n            setIsLoading(true);\n            try {\n                let httpConfig: AxiosRequestConfig = {\n                    method: 'GET',\n                    url: url,\n                    ...axiosOptions,\n                    cancelToken: source.token\n                };\n                let res = await http(httpConfig);\n                console.log(res)\n                if (!unmounted) {\n                    setIsLoading(false);\n                    setData(res.data);\n                    if (props.cache) memStore[url] = res.data;\n                }\n            } catch (err) {\n                if (!unmounted) {\n                    console.log(err);\n                    setIsLoading(false);\n                    setError(err);\n                }\n            }\n        };\n\n        if (memStore[url] && !unmounted) {\n            setIsLoading(false);\n            setData(memStore[url]);\n        } else {\n            getData();\n        }\n\n        return () => {\n            unmounted = true;\n            source.cancel(`${url} canceled`);\n        };\n    }, [url, shouldRefetch]);\n\n    return [data, isLoading, error, reFetch];\n};\n\nexport default useFetch;\n"]},"metadata":{},"sourceType":"module"}