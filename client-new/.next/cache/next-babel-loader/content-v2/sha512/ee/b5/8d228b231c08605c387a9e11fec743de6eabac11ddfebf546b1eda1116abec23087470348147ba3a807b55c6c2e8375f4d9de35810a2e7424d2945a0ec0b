{"ast":null,"code":"import _regeneratorRuntime from \"/Users/hari/WebstormProjects/ecommerce-MERN/client-new/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"/Users/hari/WebstormProjects/ecommerce-MERN/client-new/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"/Users/hari/WebstormProjects/ecommerce-MERN/client-new/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useState, useEffect } from 'react';\nimport http from './httpInstance';\nimport axios from 'axios';\nvar memStore = {};\n\nvar useFetch = function useFetch(url) {\n  _s();\n\n  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var axiosOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _useState = useState(null),\n      data = _useState[0],\n      setData = _useState[1];\n\n  var _useState2 = useState(false),\n      isLoading = _useState2[0],\n      setIsLoading = _useState2[1];\n\n  var _useState3 = useState(null),\n      error = _useState3[0],\n      setError = _useState3[1];\n\n  var _useState4 = useState({}),\n      shouldRefetch = _useState4[0],\n      reFetch = _useState4[1];\n\n  useEffect(function () {\n    var unmounted = false;\n    var source = axios.CancelToken.source();\n\n    var getData = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var httpConfig, res;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                setIsLoading(true);\n                _context.prev = 1;\n                httpConfig = _objectSpread(_objectSpread({\n                  method: 'GET',\n                  url: url\n                }, axiosOptions), {}, {\n                  cancelToken: source.token\n                });\n                _context.next = 5;\n                return http(httpConfig);\n\n              case 5:\n                res = _context.sent;\n\n                if (!unmounted) {\n                  setIsLoading(false);\n                  setData(res.data);\n                  if (props.cache) memStore[url] = res.data;\n                }\n\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!unmounted) {\n                  console.log(_context.t0);\n                  setIsLoading(false);\n                  setError(_context.t0);\n                }\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 9]]);\n      }));\n\n      return function getData() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    if (memStore[url] && !unmounted) {\n      setIsLoading(false);\n      setData(memStore[url]);\n    } else {\n      getData();\n    }\n\n    return function () {\n      unmounted = true;\n      source.cancel(\"\".concat(url, \" canceled\"));\n    };\n  }, [url, shouldRefetch]);\n  return [data, isLoading, error, reFetch];\n};\n\n_s(useFetch, \"uAdi348ATLP2XhEdsvverculOcw=\");\n\nexport default useFetch;","map":{"version":3,"sources":["/Users/hari/WebstormProjects/ecommerce-MERN/client-new/src/hooks/useFetch.ts"],"names":["useState","useEffect","http","axios","memStore","useFetch","url","props","axiosOptions","data","setData","isLoading","setIsLoading","error","setError","shouldRefetch","reFetch","unmounted","source","CancelToken","getData","httpConfig","method","cancelToken","token","res","cache","console","log","cancel"],"mappings":";;;;;;;;;;AAAA,SAAgBA,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AACA,OAAOC,IAAP,MAAiB,gBAAjB;AACA,OAAOC,KAAP,MAA0C,OAA1C;AAKA,IAAMC,QAAuB,GAAG,EAAhC;;AAYA,IAAMC,QAAuB,GAAG,SAA1BA,QAA0B,CAACC,GAAD,EAAwC;AAAA;;AAAA,MAAlCC,KAAkC,uEAA1B,EAA0B;AAAA,MAAtBC,YAAsB,uEAAP,EAAO;;AAAA,kBAC5CR,QAAQ,CAAM,IAAN,CADoC;AAAA,MAC7DS,IAD6D;AAAA,MACvDC,OADuD;;AAAA,mBAElCV,QAAQ,CAAU,KAAV,CAF0B;AAAA,MAE7DW,SAF6D;AAAA,MAElDC,YAFkD;;AAAA,mBAG1CZ,QAAQ,CAAM,IAAN,CAHkC;AAAA,MAG7Da,KAH6D;AAAA,MAGtDC,QAHsD;;AAAA,mBAInCd,QAAQ,CAAC,EAAD,CAJ2B;AAAA,MAI7De,aAJ6D;AAAA,MAI9CC,OAJ8C;;AAMpEf,EAAAA,SAAS,CAAC,YAAM;AACZ,QAAIgB,SAAS,GAAG,KAAhB;AACA,QAAIC,MAAM,GAAGf,KAAK,CAACgB,WAAN,CAAkBD,MAAlB,EAAb;;AACA,QAAME,OAAO;AAAA,0EAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AACZR,gBAAAA,YAAY,CAAC,IAAD,CAAZ;AADY;AAGJS,gBAAAA,UAHI;AAIJC,kBAAAA,MAAM,EAAE,KAJJ;AAKJhB,kBAAAA,GAAG,EAAEA;AALD,mBAMDE,YANC;AAOJe,kBAAAA,WAAW,EAAEL,MAAM,CAACM;AAPhB;AAAA;AAAA,uBASQtB,IAAI,CAACmB,UAAD,CATZ;;AAAA;AASJI,gBAAAA,GATI;;AAUR,oBAAI,CAACR,SAAL,EAAgB;AACZL,kBAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,kBAAAA,OAAO,CAACe,GAAG,CAAChB,IAAL,CAAP;AACA,sBAAIF,KAAK,CAACmB,KAAV,EAAiBtB,QAAQ,CAACE,GAAD,CAAR,GAAgBmB,GAAG,CAAChB,IAApB;AACpB;;AAdO;AAAA;;AAAA;AAAA;AAAA;;AAgBR,oBAAI,CAACQ,SAAL,EAAgB;AACZU,kBAAAA,OAAO,CAACC,GAAR;AACAhB,kBAAAA,YAAY,CAAC,KAAD,CAAZ;AACAE,kBAAAA,QAAQ,aAAR;AACH;;AApBO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAH;;AAAA,sBAAPM,OAAO;AAAA;AAAA;AAAA,OAAb;;AAwBA,QAAIhB,QAAQ,CAACE,GAAD,CAAR,IAAiB,CAACW,SAAtB,EAAiC;AAC7BL,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACAF,MAAAA,OAAO,CAACN,QAAQ,CAACE,GAAD,CAAT,CAAP;AACH,KAHD,MAGO;AACHc,MAAAA,OAAO;AACV;;AAED,WAAO,YAAM;AACTH,MAAAA,SAAS,GAAG,IAAZ;AACAC,MAAAA,MAAM,CAACW,MAAP,WAAiBvB,GAAjB;AACH,KAHD;AAIH,GAtCQ,EAsCN,CAACA,GAAD,EAAMS,aAAN,CAtCM,CAAT;AAwCA,SAAO,CAACN,IAAD,EAAOE,SAAP,EAAkBE,KAAlB,EAAyBG,OAAzB,CAAP;AACH,CA/CD;;GAAMX,Q;;AAiDN,eAAeA,QAAf","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport http from './httpInstance';\nimport axios, { AxiosRequestConfig } from 'axios';\n\ninterface memStoreTypes {\n    [x: string]: string;\n}\nconst memStore: memStoreTypes = {};\n\ninterface useFetchProps {\n    (\n        url: string,\n        props?: {\n            cache?: boolean;\n        },\n        axiosOptions?: AxiosRequestConfig\n    ): [any, boolean, any, React.Dispatch<React.SetStateAction<{}>>];\n}\n\nconst useFetch: useFetchProps = (url, props = {}, axiosOptions = {}) => {\n    const [data, setData] = useState<any>(null);\n    const [isLoading, setIsLoading] = useState<boolean>(false);\n    const [error, setError] = useState<any>(null);\n    const [shouldRefetch, reFetch] = useState({});\n\n    useEffect(() => {\n        let unmounted = false;\n        let source = axios.CancelToken.source();\n        const getData = async () => {\n            setIsLoading(true);\n            try {\n                let httpConfig: AxiosRequestConfig = {\n                    method: 'GET',\n                    url: url,\n                    ...axiosOptions,\n                    cancelToken: source.token\n                };\n                let res = await http(httpConfig);\n                if (!unmounted) {\n                    setIsLoading(false);\n                    setData(res.data);\n                    if (props.cache) memStore[url] = res.data;\n                }\n            } catch (err) {\n                if (!unmounted) {\n                    console.log(err);\n                    setIsLoading(false);\n                    setError(err);\n                }\n            }\n        };\n\n        if (memStore[url] && !unmounted) {\n            setIsLoading(false);\n            setData(memStore[url]);\n        } else {\n            getData();\n        }\n\n        return () => {\n            unmounted = true;\n            source.cancel(`${url} canceled`);\n        };\n    }, [url, shouldRefetch]);\n\n    return [data, isLoading, error, reFetch];\n};\n\nexport default useFetch;\n"]},"metadata":{},"sourceType":"module"}