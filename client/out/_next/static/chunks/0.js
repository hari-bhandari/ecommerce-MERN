(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[0],{

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createSuper.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createSuper; });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js");
/* harmony import */ var _possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./possibleConstructorReturn.js */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");



function _createSuper(Derived) {
  var hasNativeReflectConstruct = Object(_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
  return function _createSuperInternal() {
    var Super = Object(_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = Object(_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return Object(_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this, result);
  };
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _getPrototypeOf; });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inherits; });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object(_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isNativeReflectConstruct; });
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectSpread2; });
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");


function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        Object(_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutProperties; });
/* harmony import */ var _objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = Object(_objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _possibleConstructorReturn; });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Object(_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return Object(_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || Object(_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _typeof; });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _unsupportedIterableToArray; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inheritsLoose.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inheritsLoose.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf(subClass, superClass);
}

module.exports = _inheritsLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/closeSvg.js":
/*!*******************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/closeSvg.js ***!
  \*******************************************************/
/*! exports provided: CloseIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CloseIcon", function() { return CloseIcon; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var CloseIcon = function CloseIcon() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32"
    },
    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      id: "_ionicons_svg_ios-close_5_",
      "data-name": "_ionicons_svg_ios-close (5)",
      d: "M179.418,175.84l10.925-10.925a2.56,2.56,0,0,0-3.62-3.62L175.8,172.22l-10.925-10.925a2.56,2.56,0,1,0-3.62,3.62l10.925,10.925-10.925,10.925a2.56,2.56,0,0,0,3.62,3.62L175.8,179.46l10.925,10.925a2.56,2.56,0,0,0,3.62-3.62Z",
      transform: "translate(-160.5 -160.55)",
      fill: "currentColor"
    })
  );
};

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/hooks/useClickOutside.js":
/*!********************************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/hooks/useClickOutside.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useClickOutside; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);



function useClickOutside(_ref) {
  var modalRef = _ref.modalRef,
      dispatch = _ref.dispatch,
      closeOnClickOutside = _ref.closeOnClickOutside;

  var handleClickOutside = function handleClickOutside(event) {
    var area = react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(modalRef.current);
    if (area && !area.contains(event.target)) {
      if (closeOnClickOutside) dispatch({});
    }
  };

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    document.addEventListener('mousedown', handleClickOutside);
    return function () {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
}

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/hooks/useComponentSize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/hooks/useComponentSize.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var getSize = function getSize(el) {
  if (!el) {
    return {
      width: 0,
      height: 0
    };
  }

  return {
    width: el.offsetWidth,
    height: el.offsetHeight
  };
};

var useComponentSize = function useComponentSize(ref) {
  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(getSize(ref ? ref.current : {})),
      ComponentSize = _useState[0],
      setComponentSize = _useState[1];

  var handleResize = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function handleResize() {
    if (ref.current) {
      setComponentSize(getSize(ref.current));
    }
  }, [ref]);

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"])(function () {
    if (!ref.current) {
      return;
    }

    handleResize();

    if (typeof ResizeObserver === 'function') {
      var resizeObserver = new ResizeObserver(function () {
        return handleResize();
      });
      resizeObserver.observe(ref.current);

      return function () {
        resizeObserver.disconnect(ref.current);
        resizeObserver = null;
      };
    } else {
      window.addEventListener('resize', handleResize);

      return function () {
        window.removeEventListener('resize', handleResize);
      };
    }
  }, [ref.current]);

  return ComponentSize;
};

/* harmony default export */ __webpack_exports__["default"] = (useComponentSize);

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/hooks/usePortal.js":
/*!**************************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/hooks/usePortal.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return usePortal; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);



function usePortal() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(null),
      container = _useState[0],
      setContainer = _useState[1];

  var id = props.id;

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    if (false) {}
    var divId = window.document.getElementById(id || '__next'); //id = '__next' for next js
    if (!divId) divId = document.body;
    if (!divId) return null;
    var container = window.document.createElement('div');
    divId.appendChild(container);
    setContainer(container);
    return function () {
      divId.removeChild(container);
    };
  }, []);

  return function Portal(props) {
    return container ? react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.createPortal(props.children, container) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      react__WEBPACK_IMPORTED_MODULE_0__["Fragment"],
      null,
      props.children
    );
  };
}

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/hooks/useReactSpring.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/hooks/useReactSpring.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useReactSpring; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_spring_renderprops_cjs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-spring/renderprops.cjs.js */ "./node_modules/react-spring/renderprops.cjs.js");
/* harmony import */ var react_spring_renderprops_cjs_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_spring_renderprops_cjs_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _useClickOutside__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useClickOutside */ "./node_modules/@redq/reuse-modal/es/hooks/useClickOutside.js");
/* harmony import */ var _useWindowSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWindowSize */ "./node_modules/@redq/reuse-modal/es/hooks/useWindowSize.js");
/* harmony import */ var _useComponentSize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useComponentSize */ "./node_modules/@redq/reuse-modal/es/hooks/useComponentSize.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };







function useReactSpring() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var dispatch = props.dispatch,
      closeOnClickOutside = props.closeOnClickOutside;


  var size =  true && Object(_useWindowSize__WEBPACK_IMPORTED_MODULE_3__["default"])();

  return function RSpring(props) {
    var modalRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();

    var compSize = Object(_useComponentSize__WEBPACK_IMPORTED_MODULE_4__["default"])(modalRef);

    Object(_useClickOutside__WEBPACK_IMPORTED_MODULE_2__["default"])({ modalRef: modalRef, dispatch: dispatch, closeOnClickOutside: closeOnClickOutside });
    var configs = props.configs,
        style = props.style;


    var defaultFrom = {
      transform: 'scale(0.3)'
    };
    var defaultTo = {
      transform: 'scale(1)'
    };
    var springConfig = _extends({}, configs, {
      className: 'reuseModalHolder ' + configs.className,
      maxHeight: size.height - 60,
      maxWidth: size.width - 40,
      width: configs.width ? configs.width : configs.default.width,
      height: configs.height ? configs.height : configs.default.height,
      x: configs.default.x ? configs.default.x : configs.x ? configs.x : (configs.width ? configs.width : configs.default.width) <= size.width ? (size.width - (configs.width ? configs.width : configs.default.width)) / 2 : compSize.width <= size.width ? (size.width - compSize.width) / 2 : 20,
      y: configs.default.y ? configs.default.y : configs.y ? configs.y : (configs.height ? configs.height : configs.default.height) <= size.height ? (size.height - (configs.height ? configs.height : configs.default.height)) / 2 : compSize.height <= size.height ? (size.height - compSize.height) / 2 : 30,
      animationFrom: configs.animationFrom ? configs.animationFrom : defaultFrom,
      animationTo: configs.animationTo ? configs.animationTo : defaultTo,
      transition: configs.transition ? configs.transition : {
        mass: 1,
        tension: 130,
        friction: 26
      }
    });

    var springStyle = {
      maxWidth: springConfig.maxWidth,
      maxHeight: springConfig.maxHeight,
      width: springConfig.width,
      height: springConfig.height,
      position: 'absolute',
      left: springConfig.x,
      top: springConfig.y
    };

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      react_spring_renderprops_cjs_js__WEBPACK_IMPORTED_MODULE_1__["Spring"],
      {
        from: _extends({}, springConfig.animationFrom),
        to: _extends({}, springConfig.animationTo),
        config: springConfig.transition
      },
      function (springProps) {
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
          'div',
          {
            ref: modalRef,
            className: springConfig.className,
            style: _extends({}, springStyle, style, springProps)
          },
          react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
            'div',
            { className: 'innerRndComponent' },
            props.children
          )
        );
      }
    );
  };
}

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/hooks/useRnd.js":
/*!***********************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/hooks/useRnd.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useRnd; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_rnd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-rnd */ "./node_modules/@redq/reuse-modal/node_modules/react-rnd/lib/index.js");
/* harmony import */ var _useClickOutside__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useClickOutside */ "./node_modules/@redq/reuse-modal/es/hooks/useClickOutside.js");
/* harmony import */ var _useWindowSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWindowSize */ "./node_modules/@redq/reuse-modal/es/hooks/useWindowSize.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






function useRnd() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var dispatch = props.dispatch,
      closeOnClickOutside = props.closeOnClickOutside;


  var size =  true && Object(_useWindowSize__WEBPACK_IMPORTED_MODULE_3__["default"])();
  return function RND(props) {
    var modalRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
    Object(_useClickOutside__WEBPACK_IMPORTED_MODULE_2__["default"])({ modalRef: modalRef, dispatch: dispatch, closeOnClickOutside: closeOnClickOutside });
    var config = props.config;

    var rndConfig = _extends({}, config, {
      className: 'reuseModalHolder ' + config.className,
      maxWidth: size.width - 40,
      maxHeight: size.height - 60,
      default: {
        width: config.default.width,
        height: config.default.height,
        x: config.default.x ? config.default.x : config.default.width <= size.width ? (size.width - config.default.width) / 2 : 20,
        y: config.default.y ? config.default.y : config.default.height <= size.height ? (size.height - config.default.height) / 2 : 30
      }
    });

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      react_rnd__WEBPACK_IMPORTED_MODULE_1__["Rnd"],
      _extends({}, rndConfig, { ref: modalRef }),
      react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        'div',
        { className: 'innerRndComponent' },
        props.children
      )
    );
  };
}

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/hooks/useWindowSize.js":
/*!******************************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/hooks/useWindowSize.js ***!
  \******************************************************************/
/*! exports provided: throttle, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_device_detect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-device-detect */ "./node_modules/react-device-detect/main.js");
/* harmony import */ var react_device_detect__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_device_detect__WEBPACK_IMPORTED_MODULE_1__);


var events = new Set();
var onResize = function onResize() {
  return events.forEach(function (fn) {
    return fn();
  });
};

var useWindowSize = function useWindowSize() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _options$throttleMs = options.throttleMs,
      throttleMs = _options$throttleMs === undefined ? 100 : _options$throttleMs;

  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default.a.useState({
    width: window.innerWidth,
    height: window.innerHeight
  }),
      size = _React$useState[0],
      setSize = _React$useState[1];

  var handle = throttle(function () {
    setSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  }, throttleMs);

  if (!react_device_detect__WEBPACK_IMPORTED_MODULE_1__["isMobile"]) {
    react__WEBPACK_IMPORTED_MODULE_0___default.a.useEffect(function () {
      if (events.size === 0) {
        window.addEventListener('resize', onResize, true);
      }

      events.add(handle);

      return function () {
        events.delete(handle);

        if (events.size === 0) {
          window.removeEventListener('resize', onResize, true);
        }
      };
    }, []);
  }

  return size;
};

function throttle(func) {
  var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
  var scope = arguments[2];

  var last = void 0,
      deferTimer = void 0;
  return function () {
    var context = scope || this;

    var now = Date.now(),
        args = arguments;
    if (last && now < last + threshhold) {
      // hold on to it
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function () {
        last = now;
        func.apply(context, args);
      }, threshhold);
    } else {
      last = now;
      func.apply(context, args);
    }
  };
}
/* harmony default export */ __webpack_exports__["default"] = (useWindowSize);

/***/ }),

/***/ "./node_modules/@redq/reuse-modal/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/es/index.js ***!
  \****************************************************/
/*! exports provided: Modal, openModal, closeModal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Modal", function() { return Modal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openModal", function() { return openModal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closeModal", function() { return closeModal; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hooks_usePortal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hooks/usePortal */ "./node_modules/@redq/reuse-modal/es/hooks/usePortal.js");
/* harmony import */ var _hooks_useRnd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks/useRnd */ "./node_modules/@redq/reuse-modal/es/hooks/useRnd.js");
/* harmony import */ var _hooks_useReactSpring__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hooks/useReactSpring */ "./node_modules/@redq/reuse-modal/es/hooks/useReactSpring.js");
/* harmony import */ var _closeSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./closeSvg */ "./node_modules/@redq/reuse-modal/es/closeSvg.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var openModal = void 0,
    closeModal = void 0;

var initialData = {
  show: false,
  springState: false,
  component: null,
  closeOnClickOutside: true,
  closeComponent: null,
  componentProps: {},
  overlayClassName: '',
  withRnd: false,
  springStyle: '',
  config: {
    default: {
      width: 500,
      height: 300
    },
    className: '',
    minWidth: 300,
    minHeight: 'auto',
    lockAspectRatio: true,
    disableDragging: true,
    bounds: '.reuseModalParentWrapper',
    enableResizing: {
      bottom: false,
      bottomLeft: false,
      bottomRight: false,
      left: false,
      right: false,
      top: false,
      topLeft: false,
      topRight: false
    }
  }
};

function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}

var ModalReducer = function ModalReducer(state) {
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return _extends({}, state, {
    show: action.show !== undefined ? action.show : !state.show,
    springState: action.springState !== undefined ? action.springState : !state.springState,
    withRnd: action.withRnd !== undefined ? action.withRnd : state.withRnd,
    springStyle: action.springStyle !== undefined ? action.springStyle : state.springStyle,
    overlayClassName: action.overlayClassName !== undefined ? action.overlayClassName : state.overlayClassName,
    component: action.component !== undefined ? action.component : null,
    componentProps: action.componentProps !== undefined ? action.componentProps : {},
    closeComponent: action.closeComponent !== undefined ? action.closeComponent : null,
    closeOnClickOutside: action.closeOnClickOutside !== undefined ? action.closeOnClickOutside : state.closeOnClickOutside,
    config: action.config !== undefined ? _extends({}, state.config, action.config) : state.config
  });
};

function Modal(_ref) {
  var children = _ref.children;

  var Portal = Object(_hooks_usePortal__WEBPACK_IMPORTED_MODULE_1__["default"])();

  var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"])(ModalReducer, initialData),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  openModal = dispatch;
  closeModal = dispatch;

  var show = state.show,
      component = state.component,
      closeComponent = state.closeComponent,
      overlayClassName = state.overlayClassName,
      withRnd = state.withRnd,
      springStyle = state.springStyle,
      springState = state.springState;

  var Rnd = Object(_hooks_useRnd__WEBPACK_IMPORTED_MODULE_2__["default"])({
    dispatch: dispatch,
    closeOnClickOutside: state.closeOnClickOutside
  });

  var ReactSpring = Object(_hooks_useReactSpring__WEBPACK_IMPORTED_MODULE_3__["default"])({
    dispatch: dispatch,
    closeOnClickOutside: state.closeOnClickOutside
  });
  var ModalComponent = component;
  var defaultCloseComponent = function defaultCloseComponent() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      'button',
      { className: 'reuseModalCloseBtn', onClick: function onClick() {
          return dispatch({});
        } },
      react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_closeSvg__WEBPACK_IMPORTED_MODULE_4__["CloseIcon"], null)
    );
  };
  var Close = closeComponent ? closeComponent : defaultCloseComponent;

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    react__WEBPACK_IMPORTED_MODULE_0__["Fragment"],
    null,
    show && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      react__WEBPACK_IMPORTED_MODULE_0__["Fragment"],
      null,
      !canUseDOM ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        Portal,
        null,
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('div', { className: 'reuseModalOverlay ' + overlayClassName }),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Close, null),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
          'div',
          { className: 'reuseModalParrentWrapper' },
          react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
            Rnd,
            { config: state.config },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ModalComponent, state.componentProps)
          )
        )
      ) : withRnd ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        react__WEBPACK_IMPORTED_MODULE_0__["Fragment"],
        null,
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('div', { className: 'reuseModalOverlay ' + overlayClassName }),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Close, null),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
          'div',
          { className: 'reuseModalParentWrapper' },
          react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
            Rnd,
            { config: state.config },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ModalComponent, state.componentProps)
          )
        )
      ) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        react__WEBPACK_IMPORTED_MODULE_0__["Fragment"],
        null,
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('div', { className: 'reuseModalOverlay ' + overlayClassName }),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Close, null),
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
          'div',
          { className: 'reuseModalParentWrapper' },
          react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
            ReactSpring,
            {
              configs: state.config,
              springState: springState,
              style: springStyle
            },
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ModalComponent, state.componentProps)
          )
        )
      )
    ),
    children
  );
}



/***/ }),

/***/ "./node_modules/@redq/reuse-modal/node_modules/react-rnd/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@redq/reuse-modal/node_modules/react-rnd/lib/index.js ***!
  \****************************************************************************/
/*! exports provided: Rnd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rnd", function() { return Rnd; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var re_resizable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! re-resizable */ "./node_modules/re-resizable/lib/index.js");
/* harmony import */ var re_resizable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(re_resizable__WEBPACK_IMPORTED_MODULE_1__);



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

var Draggable = __webpack_require__(/*! react-draggable */ "./node_modules/react-draggable/dist/react-draggable.js");
var resizableStyle = {
    width: "auto",
    height: "auto",
    display: "inline-block",
    position: "absolute",
    top: 0,
    left: 0,
};
var Rnd = /** @class */ (function (_super) {
    __extends(Rnd, _super);
    function Rnd(props) {
        var _this = _super.call(this, props) || this;
        _this.isResizing = false;
        _this.state = {
            original: {
                x: 0,
                y: 0,
            },
            bounds: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
            },
            maxWidth: props.maxWidth,
            maxHeight: props.maxHeight,
        };
        _this.onResizeStart = _this.onResizeStart.bind(_this);
        _this.onResize = _this.onResize.bind(_this);
        _this.onResizeStop = _this.onResizeStop.bind(_this);
        _this.onDragStart = _this.onDragStart.bind(_this);
        _this.onDrag = _this.onDrag.bind(_this);
        _this.onDragStop = _this.onDragStop.bind(_this);
        _this.getMaxSizesFromProps = _this.getMaxSizesFromProps.bind(_this);
        return _this;
    }
    Rnd.prototype.componentDidMount = function () {
        var _a = this.getOffsetFromParent(), left = _a.left, top = _a.top;
        var _b = this.getDraggablePosition(), x = _b.x, y = _b.y;
        this.draggable.setState({
            x: x - left,
            y: y - top,
        });
        // HACK: Apply position adjustment
        this.forceUpdate();
    };
    // HACK: To get `react-draggable` state x and y.
    Rnd.prototype.getDraggablePosition = function () {
        var _a = this.draggable.state, x = _a.x, y = _a.y;
        return { x: x, y: y };
    };
    Rnd.prototype.getParent = function () {
        return this.resizable && this.resizable.parentNode;
    };
    Rnd.prototype.getParentSize = function () {
        return this.resizable.getParentSize();
    };
    Rnd.prototype.getMaxSizesFromProps = function () {
        var maxWidth = typeof this.props.maxWidth === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth;
        var maxHeight = typeof this.props.maxHeight === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
        return { maxWidth: maxWidth, maxHeight: maxHeight };
    };
    Rnd.prototype.getSelfElement = function () {
        return this.resizable && this.resizable.resizable;
    };
    Rnd.prototype.getOffsetHeight = function (boundary) {
        var scale = this.props.scale;
        switch (this.props.bounds) {
            case "window":
                return window.innerHeight / scale;
            case "body":
                return document.body.offsetHeight / scale;
            default:
                return boundary.offsetHeight;
        }
    };
    Rnd.prototype.getOffsetWidth = function (boundary) {
        var scale = this.props.scale;
        switch (this.props.bounds) {
            case "window":
                return window.innerWidth / scale;
            case "body":
                return document.body.offsetWidth / scale;
            default:
                return boundary.offsetWidth;
        }
    };
    Rnd.prototype.onDragStart = function (e, data) {
        if (this.props.onDragStart) {
            this.props.onDragStart(e, data);
        }
        if (!this.props.bounds)
            return;
        var parent = this.getParent();
        var scale = this.props.scale;
        var boundary;
        if (this.props.bounds === "parent") {
            boundary = parent;
        }
        else if (this.props.bounds === "body") {
            var parentRect_1 = parent.getBoundingClientRect();
            var parentLeft_1 = parentRect_1.left;
            var parentTop_1 = parentRect_1.top;
            var bodyRect = document.body.getBoundingClientRect();
            var left_1 = -(parentLeft_1 - parent.offsetLeft * scale - bodyRect.left) / scale;
            var top_1 = -(parentTop_1 - parent.offsetTop * scale - bodyRect.top) / scale;
            var right = (document.body.offsetWidth - this.resizable.size.width * scale) / scale + left_1;
            var bottom = (document.body.offsetHeight - this.resizable.size.height * scale) / scale + top_1;
            return this.setState({ bounds: { top: top_1, right: right, bottom: bottom, left: left_1 } });
        }
        else if (this.props.bounds === "window") {
            if (!this.resizable)
                return;
            var parentRect_2 = parent.getBoundingClientRect();
            var parentLeft_2 = parentRect_2.left;
            var parentTop_2 = parentRect_2.top;
            var left_2 = -(parentLeft_2 - parent.offsetLeft * scale) / scale;
            var top_2 = -(parentTop_2 - parent.offsetTop * scale) / scale;
            var right = (window.innerWidth - this.resizable.size.width * scale) / scale + left_2;
            var bottom = (window.innerHeight - this.resizable.size.height * scale) / scale + top_2;
            return this.setState({ bounds: { top: top_2, right: right, bottom: bottom, left: left_2 } });
        }
        else {
            boundary = document.querySelector(this.props.bounds);
        }
        if (!(boundary instanceof HTMLElement) || !(parent instanceof HTMLElement)) {
            return;
        }
        var boundaryRect = boundary.getBoundingClientRect();
        var boundaryLeft = boundaryRect.left;
        var boundaryTop = boundaryRect.top;
        var parentRect = parent.getBoundingClientRect();
        var parentLeft = parentRect.left;
        var parentTop = parentRect.top;
        var left = (boundaryLeft - parentLeft) / scale;
        var top = boundaryTop - parentTop;
        if (!this.resizable)
            return;
        var offset = this.getOffsetFromParent();
        this.setState({
            bounds: {
                top: top - offset.top,
                right: left + (boundary.offsetWidth - this.resizable.size.width) - offset.left / scale,
                bottom: top + (boundary.offsetHeight - this.resizable.size.height) - offset.top,
                left: left - offset.left / scale,
            },
        });
    };
    Rnd.prototype.onDrag = function (e, data) {
        if (this.props.onDrag) {
            var offset = this.getOffsetFromParent();
            this.props.onDrag(e, __assign({}, data, { x: data.x - offset.left, y: data.y - offset.top }));
        }
    };
    Rnd.prototype.onDragStop = function (e, data) {
        if (this.props.onDragStop) {
            var _a = this.getOffsetFromParent(), left = _a.left, top_3 = _a.top;
            return this.props.onDragStop(e, __assign({}, data, { x: data.x + left, y: data.y + top_3 }));
        }
    };
    Rnd.prototype.onResizeStart = function (e, dir, elementRef) {
        e.stopPropagation();
        this.isResizing = true;
        var scale = this.props.scale;
        this.setState({
            original: this.getDraggablePosition(),
        });
        if (this.props.bounds) {
            var parent_1 = this.getParent();
            var boundary = void 0;
            if (this.props.bounds === "parent") {
                boundary = parent_1;
            }
            else if (this.props.bounds === "body") {
                boundary = document.body;
            }
            else if (this.props.bounds === "window") {
                boundary = window;
            }
            else {
                boundary = document.querySelector(this.props.bounds);
            }
            var self_1 = this.getSelfElement();
            if (self_1 instanceof Element &&
                (boundary instanceof HTMLElement || boundary === window) &&
                parent_1 instanceof HTMLElement) {
                var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;
                var parentSize = this.getParentSize();
                if (maxWidth && typeof maxWidth === "string") {
                    if (maxWidth.endsWith("%")) {
                        var ratio = Number(maxWidth.replace("%", "")) / 100;
                        maxWidth = parentSize.width * ratio;
                    }
                    else if (maxWidth.endsWith("px")) {
                        maxWidth = Number(maxWidth.replace("px", ""));
                    }
                }
                if (maxHeight && typeof maxHeight === "string") {
                    if (maxHeight.endsWith("%")) {
                        var ratio = Number(maxHeight.replace("%", "")) / 100;
                        maxHeight = parentSize.width * ratio;
                    }
                    else if (maxHeight.endsWith("px")) {
                        maxHeight = Number(maxHeight.replace("px", ""));
                    }
                }
                var selfRect = self_1.getBoundingClientRect();
                var selfLeft = selfRect.left;
                var selfTop = selfRect.top;
                var boundaryRect = this.props.bounds === "window" ? { left: 0, top: 0 } : boundary.getBoundingClientRect();
                var boundaryLeft = boundaryRect.left;
                var boundaryTop = boundaryRect.top;
                var offsetWidth = this.getOffsetWidth(boundary);
                var offsetHeight = this.getOffsetHeight(boundary);
                var hasLeft = dir.toLowerCase().endsWith("left");
                var hasRight = dir.toLowerCase().endsWith("right");
                var hasTop = dir.startsWith("top");
                var hasBottom = dir.startsWith("bottom");
                if (hasLeft && this.resizable) {
                    var max = (selfLeft - boundaryLeft) / scale + this.resizable.size.width;
                    this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
                }
                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.
                if (hasRight || (this.props.lockAspectRatio && !hasLeft)) {
                    var max = offsetWidth + (boundaryLeft - selfLeft) / scale;
                    this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
                }
                if (hasTop && this.resizable) {
                    var max = (selfTop - boundaryTop) / scale + this.resizable.size.height;
                    this.setState({
                        maxHeight: max > Number(maxHeight) ? maxHeight : max,
                    });
                }
                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.
                if (hasBottom || (this.props.lockAspectRatio && !hasTop)) {
                    var max = offsetHeight + (boundaryTop - selfTop) / scale;
                    this.setState({
                        maxHeight: max > Number(maxHeight) ? maxHeight : max,
                    });
                }
            }
        }
        else {
            this.setState({
                maxWidth: this.props.maxWidth,
                maxHeight: this.props.maxHeight,
            });
        }
        if (this.props.onResizeStart) {
            this.props.onResizeStart(e, dir, elementRef);
        }
    };
    Rnd.prototype.onResize = function (e, direction, elementRef, delta) {
        var x;
        var y;
        var offset = this.getOffsetFromParent();
        if (/left/i.test(direction)) {
            x = this.state.original.x - delta.width;
            // INFO: If uncontrolled component, apply x position by resize to draggable.
            if (!this.props.position) {
                this.draggable.setState({ x: x });
            }
            x += offset.left;
        }
        if (/top/i.test(direction)) {
            y = this.state.original.y - delta.height;
            // INFO: If uncontrolled component, apply y position by resize to draggable.
            if (!this.props.position) {
                this.draggable.setState({ y: y });
            }
            y += offset.top;
        }
        if (this.props.onResize) {
            if (typeof x === "undefined") {
                x = this.getDraggablePosition().x + offset.left;
            }
            if (typeof y === "undefined") {
                y = this.getDraggablePosition().y + offset.top;
            }
            this.props.onResize(e, direction, elementRef, delta, {
                x: x,
                y: y,
            });
        }
    };
    Rnd.prototype.onResizeStop = function (e, direction, elementRef, delta) {
        this.isResizing = false;
        var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;
        this.setState({ maxWidth: maxWidth, maxHeight: maxHeight });
        if (this.props.onResizeStop) {
            var position = this.getDraggablePosition();
            this.props.onResizeStop(e, direction, elementRef, delta, position);
        }
    };
    Rnd.prototype.updateSize = function (size) {
        if (!this.resizable)
            return;
        this.resizable.updateSize({ width: size.width, height: size.height });
    };
    Rnd.prototype.updatePosition = function (position) {
        this.draggable.setState(position);
    };
    Rnd.prototype.getOffsetFromParent = function () {
        var scale = this.props.scale;
        var parent = this.getParent();
        var self = this.getSelfElement();
        if (!parent || self === null) {
            return {
                top: 0,
                left: 0,
            };
        }
        var parentRect = parent.getBoundingClientRect();
        var parentLeft = parentRect.left;
        var parentTop = parentRect.top;
        var selfRect = self.getBoundingClientRect();
        var position = this.getDraggablePosition();
        return {
            left: selfRect.left - parentLeft - position.x * scale,
            top: selfRect.top - parentTop - position.y * scale,
        };
    };
    Rnd.prototype.render = function () {
        var _this = this;
        var _a = this.props, disableDragging = _a.disableDragging, style = _a.style, dragHandleClassName = _a.dragHandleClassName, position = _a.position, onMouseDown = _a.onMouseDown, dragAxis = _a.dragAxis, dragGrid = _a.dragGrid, bounds = _a.bounds, enableUserSelectHack = _a.enableUserSelectHack, cancel = _a.cancel, children = _a.children, onResizeStart = _a.onResizeStart, onResize = _a.onResize, onResizeStop = _a.onResizeStop, onDragStart = _a.onDragStart, onDrag = _a.onDrag, onDragStop = _a.onDragStop, resizeHandleStyles = _a.resizeHandleStyles, resizeHandleClasses = _a.resizeHandleClasses, enableResizing = _a.enableResizing, resizeGrid = _a.resizeGrid, resizeHandleWrapperClass = _a.resizeHandleWrapperClass, resizeHandleWrapperStyle = _a.resizeHandleWrapperStyle, scale = _a.scale, resizableProps = __rest(_a, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale"]);
        var defaultValue = this.props.default ? __assign({}, this.props.default) : undefined;
        // Remove unknown props, see also https://reactjs.org/warnings/unknown-prop.html
        delete resizableProps.default;
        var cursorStyle = disableDragging || dragHandleClassName ? { cursor: "auto" } : { cursor: "move" };
        var innerStyle = __assign({}, resizableStyle, cursorStyle, style);
        var _b = this.getOffsetFromParent(), left = _b.left, top = _b.top;
        var draggablePosition;
        if (position) {
            draggablePosition = {
                x: position.x - left,
                y: position.y - top,
            };
        }
        return (Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(Draggable, { ref: function (c) {
                if (!c)
                    return;
                _this.draggable = c;
            }, handle: dragHandleClassName ? "." + dragHandleClassName : undefined, defaultPosition: defaultValue, onMouseDown: onMouseDown, onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop, axis: dragAxis, disabled: disableDragging, grid: dragGrid, bounds: bounds ? this.state.bounds : undefined, position: draggablePosition, enableUserSelectHack: enableUserSelectHack, cancel: cancel, scale: scale },
            Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(re_resizable__WEBPACK_IMPORTED_MODULE_1__["Resizable"], __assign({}, resizableProps, { ref: function (c) {
                    if (c) {
                        _this.resizable = c;
                    }
                }, defaultSize: defaultValue, size: this.props.size, enable: enableResizing, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: innerStyle, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.isResizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.isResizing ? this.state.maxHeight : this.props.maxHeight, grid: resizeGrid, handleWrapperClass: resizeHandleWrapperClass, handleWrapperStyle: resizeHandleWrapperStyle, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: resizeHandleStyles, handleClasses: resizeHandleClasses, scale: this.props.scale }), children)));
    };
    Rnd.defaultProps = {
        maxWidth: Number.MAX_SAFE_INTEGER,
        maxHeight: Number.MAX_SAFE_INTEGER,
        scale: 1,
        onResizeStart: function () { },
        onResize: function () { },
        onResizeStop: function () { },
        onDragStart: function () { },
        onDrag: function () { },
        onDragStop: function () { },
    };
    return Rnd;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));




/***/ }),

/***/ "./node_modules/fast-memoize/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/fast-memoize/src/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//
// Main
//

function memoize (fn, options) {
  var cache = options && options.cache
    ? options.cache
    : cacheDefault

  var serializer = options && options.serializer
    ? options.serializer
    : serializerDefault

  var strategy = options && options.strategy
    ? options.strategy
    : strategyDefault

  return strategy(fn, {
    cache: cache,
    serializer: serializer
  })
}

//
// Strategy
//

function isPrimitive (value) {
  return value == null || typeof value === 'number' || typeof value === 'boolean' // || typeof value === "string" 'unsafe' primitive for our needs
}

function monadic (fn, cache, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg)

  var computedValue = cache.get(cacheKey)
  if (typeof computedValue === 'undefined') {
    computedValue = fn.call(this, arg)
    cache.set(cacheKey, computedValue)
  }

  return computedValue
}

function variadic (fn, cache, serializer) {
  var args = Array.prototype.slice.call(arguments, 3)
  var cacheKey = serializer(args)

  var computedValue = cache.get(cacheKey)
  if (typeof computedValue === 'undefined') {
    computedValue = fn.apply(this, args)
    cache.set(cacheKey, computedValue)
  }

  return computedValue
}

function assemble (fn, context, strategy, cache, serialize) {
  return strategy.bind(
    context,
    fn,
    cache,
    serialize
  )
}

function strategyDefault (fn, options) {
  var strategy = fn.length === 1 ? monadic : variadic

  return assemble(
    fn,
    this,
    strategy,
    options.cache.create(),
    options.serializer
  )
}

function strategyVariadic (fn, options) {
  var strategy = variadic

  return assemble(
    fn,
    this,
    strategy,
    options.cache.create(),
    options.serializer
  )
}

function strategyMonadic (fn, options) {
  var strategy = monadic

  return assemble(
    fn,
    this,
    strategy,
    options.cache.create(),
    options.serializer
  )
}

//
// Serializer
//

function serializerDefault () {
  return JSON.stringify(arguments)
}

//
// Cache
//

function ObjectWithoutPrototypeCache () {
  this.cache = Object.create(null)
}

ObjectWithoutPrototypeCache.prototype.has = function (key) {
  return (key in this.cache)
}

ObjectWithoutPrototypeCache.prototype.get = function (key) {
  return this.cache[key]
}

ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
  this.cache[key] = value
}

var cacheDefault = {
  create: function create () {
    return new ObjectWithoutPrototypeCache()
  }
}

//
// API
//

module.exports = memoize
module.exports.strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
}


/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/overlayscrollbars/css/OverlayScrollbars.css":
/*!******************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-5-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-5-2!./node_modules/overlayscrollbars/css/OverlayScrollbars.css ***!
  \******************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.i, "/*!\r\n * OverlayScrollbars\r\n * https://github.com/KingSora/OverlayScrollbars\r\n *\r\n * Version: 1.13.0\r\n *\r\n * Copyright KingSora | Rene Haas.\r\n * https://github.com/KingSora\r\n *\r\n * Released under the MIT license.\r\n * Date: 02.08.2020\r\n */\r\n\r\n/*\r\nOVERLAY SCROLLBARS CORE:\r\n*/\r\n\r\nhtml.os-html,\r\nhtml.os-html > .os-host {\r\n    display: block;\r\n    overflow: hidden;\r\n    -webkit-box-sizing: border-box;\r\n            box-sizing: border-box;\r\n    height: 100% !important;\r\n    width: 100% !important;\r\n    min-width: 100% !important;\r\n    min-height: 100% !important;\r\n    margin: 0 !important;\r\n    position: absolute !important; /* could be position: fixed; but it causes issues on iOS (-webkit-overflow-scrolling: touch) */\r\n}\r\nhtml.os-html > .os-host > .os-padding {\r\n    position: absolute; /* could be position: fixed; but it causes issues on iOS (-webkit-overflow-scrolling: touch) */\r\n}\r\nbody.os-dragging,\r\nbody.os-dragging * {\r\n    cursor: default;\r\n}\r\n.os-host,\r\n.os-host-textarea {\r\n    position: relative;\r\n    overflow: visible !important;\r\n    flex-direction: column;\r\n    flex-wrap: nowrap;\r\n    justify-content: flex-start;\r\n    align-content: flex-start;\r\n    -webkit-box-align: start;\r\n        -ms-flex-align: start;\r\n                -ms-grid-row-align: flex-start;\r\n            align-items: flex-start;\r\n}\r\n.os-host-flexbox {\r\n    overflow: hidden !important;\r\n    display: flex;\r\n}\r\n.os-host-flexbox > .os-size-auto-observer {\r\n    height: inherit !important;\r\n}\r\n.os-host-flexbox > .os-content-glue {\r\n    flex-grow: 1;\r\n    flex-shrink: 0;\r\n}\r\n.os-host-flexbox > .os-size-auto-observer,\r\n.os-host-flexbox > .os-content-glue {\r\n    min-height: 0;\r\n    min-width: 0;\r\n    flex-grow: 0;\r\n    flex-shrink: 1;\r\n    flex-basis: auto;\r\n}\r\n#os-dummy-scrollbar-size {\r\n    position: fixed;\r\n    opacity: 0;\r\n    -ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=0)';\r\n    visibility: hidden;\r\n    overflow: scroll;\r\n    height: 500px;\r\n    width: 500px;\r\n}\r\n#os-dummy-scrollbar-size > div {\r\n    width: 200%;\r\n    height: 200%; \r\n    margin: 10px 0;\r\n}\r\n/* fix restricted measuring */\r\n#os-dummy-scrollbar-size:before,\r\n#os-dummy-scrollbar-size:after,\r\n.os-content:before,\r\n.os-content:after {\r\n    content: '';\r\n    display: table;\r\n    width: 0.01px;\r\n    height: 0.01px;\r\n    line-height: 0;\r\n    font-size: 0;\r\n    flex-grow: 0;\r\n    flex-shrink: 0;\r\n    visibility: hidden;\r\n}\r\n#os-dummy-scrollbar-size,\r\n.os-viewport {\r\n    -ms-overflow-style: scrollbar !important;\r\n}\r\n.os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size,\r\n.os-viewport-native-scrollbars-invisible.os-viewport {\r\n    scrollbar-width: none !important;\r\n}\r\n.os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar,\r\n.os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar,\r\n.os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar-corner,\r\n.os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar-corner {\r\n    display: none !important;\r\n    width: 0px !important;\r\n    height: 0px !important;\r\n    visibility: hidden !important;\r\n    background: transparent !important;\r\n}\r\n.os-content-glue {\r\n    -webkit-box-sizing: inherit;\r\n            box-sizing: inherit;\r\n    max-height: 100%;\r\n    max-width: 100%;\r\n    width: 100%;\r\n    pointer-events: none;\r\n}\r\n.os-padding {\r\n    -webkit-box-sizing: inherit;\r\n            box-sizing: inherit;\r\n    direction: inherit;\r\n    position: absolute;\r\n    overflow: visible;\r\n    padding: 0;\r\n    margin: 0;\r\n    left: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    right: 0;\r\n    width: auto !important;\r\n    height: auto !important;\r\n\tz-index: 0;\r\n}\r\n.os-host-overflow > .os-padding {\r\n    overflow: hidden;\r\n}\r\n.os-viewport {\r\n    direction: inherit !important;\r\n    -webkit-box-sizing: inherit !important;\r\n            box-sizing: inherit !important;\r\n    resize: none !important;\r\n    outline: none !important;\r\n    position: absolute;\r\n    overflow: hidden;\r\n    top: 0;\r\n    left: 0;\r\n    bottom: 0;\r\n    right: 0;\r\n    padding: 0;\r\n    margin: 0;\r\n    -webkit-overflow-scrolling: touch;\r\n}\r\n.os-content-arrange {\r\n    position: absolute;\r\n    z-index: -1;\r\n    min-height: 1px;\r\n    min-width: 1px;\r\n    pointer-events: none;\r\n}\r\n.os-content {\r\n    direction: inherit;\r\n    -webkit-box-sizing: border-box !important;\r\n            box-sizing: border-box !important;\r\n    position: relative;\r\n    display: block;\r\n    height: 100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    width: 100%;\r\n    visibility: visible;\r\n}\r\n.os-content > .os-textarea {\r\n    -webkit-box-sizing: border-box !important;\r\n            box-sizing: border-box !important;\r\n    direction: inherit !important;\r\n    background: transparent !important;\r\n    outline: 0px none transparent !important;\r\n    overflow: hidden !important;\r\n    position: absolute !important;\r\n    display: block !important;\r\n    top: 0 !important;\r\n    left: 0 !important;\r\n    margin: 0 !important;\r\n    border-radius: 0px !important;\r\n    float: none !important;\r\n    filter: none !important;\r\n    border: none !important;\r\n    resize: none !important;\r\n    -webkit-transform: none !important;\r\n            transform: none !important;\r\n    max-width: none !important;\r\n    max-height: none !important;\r\n    -webkit-box-shadow: none !important;\r\n            box-shadow: none !important;\r\n    -webkit-perspective: none !important;\r\n            perspective: none !important;\r\n    opacity: 1 !important;\r\n    z-index: 1 !important;\r\n    clip: auto !important;\r\n    vertical-align: baseline !important;\r\n    padding: 0px;\r\n}\r\n.os-host-rtl > .os-padding > .os-viewport > .os-content > .os-textarea {\r\n    right: 0 !important;\r\n}\r\n.os-content > .os-textarea-cover {\r\n    z-index: -1;\r\n    pointer-events: none;\r\n}\r\n.os-content > .os-textarea[wrap='off'] {\r\n    white-space: pre !important;\r\n    margin: 0px !important;\r\n}\r\n.os-text-inherit {\r\n    font-family: inherit;\r\n    font-size: inherit;\r\n    font-weight: inherit;\r\n    font-style: inherit;\r\n    font-feature-settings: inherit;\r\n    font-variant: inherit;\r\n    text-transform: inherit;\r\n    text-decoration: inherit;\r\n    text-indent: inherit;\r\n    text-align: inherit;\r\n    text-shadow: inherit;\r\n    text-overflow: inherit;\r\n    letter-spacing: inherit;\r\n    word-spacing: inherit;\r\n    line-height: inherit;\r\n    unicode-bidi: inherit;\r\n    direction: inherit;\r\n    color: inherit;\r\n    cursor: text;\r\n}\r\n.os-resize-observer,\r\n.os-resize-observer-host {\r\n    -webkit-box-sizing: inherit;\r\n            box-sizing: inherit;\r\n    display: block;\r\n    visibility: hidden;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow: hidden;\r\n    pointer-events: none;\r\n    z-index: -1;\r\n}\r\n.os-resize-observer-host {\r\n    padding: inherit;\r\n    border: inherit;\r\n    border-color: transparent;\r\n    border-style: solid;\r\n    -webkit-box-sizing: border-box;\r\n            box-sizing: border-box;\r\n}\r\n.os-resize-observer-host.observed {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n.os-resize-observer-host > .os-resize-observer,\r\n.os-resize-observer-host.observed > .os-resize-observer {\r\n    height: 200%;\r\n    width: 200%;\r\n    padding: inherit;\r\n    border: inherit;\r\n    margin: 0;\r\n    display: block;\r\n    -webkit-box-sizing: content-box;\r\n            box-sizing: content-box;\r\n}\r\n.os-resize-observer-host.observed > .os-resize-observer,\r\n.os-resize-observer-host.observed > .os-resize-observer:before {\r\n    display: flex;\r\n    position: relative;\r\n    flex-grow: 1;\r\n    flex-shrink: 0;\r\n    flex-basis: auto;\r\n    -webkit-box-sizing: border-box;\r\n            box-sizing: border-box;\r\n}\r\n.os-resize-observer-host.observed > .os-resize-observer:before {\r\n    content: '';\r\n    -webkit-box-sizing: content-box;\r\n            box-sizing: content-box;\r\n    padding: inherit;\r\n    border: inherit;\r\n    margin: 0;\r\n}\r\n.os-size-auto-observer {\r\n    -webkit-box-sizing: inherit !important;\r\n            box-sizing: inherit !important;\r\n    height: 100%;\r\n    width: inherit;\r\n    max-width: 1px;\r\n    position: relative;\r\n    float: left;\r\n    max-height: 1px;\r\n    overflow: hidden;\r\n    z-index: -1;\r\n    padding: 0;\r\n    margin: 0;\r\n    pointer-events: none;\r\n    flex-grow: inherit;\r\n    flex-shrink: 0;\r\n    flex-basis: 0;\r\n}\r\n.os-size-auto-observer > .os-resize-observer {\r\n    width: 1000%;\r\n    height: 1000%;\r\n    min-height: 1px;\r\n    min-width: 1px;\r\n}\r\n.os-resize-observer-item {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    overflow: hidden;\r\n    z-index: -1;\r\n    opacity: 0;\r\n    direction: ltr !important;\r\n    flex: none !important;\r\n}\r\n.os-resize-observer-item-final {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    -webkit-transition: none !important;\r\n    transition: none !important;\r\n    flex: none !important;\r\n}\r\n.os-resize-observer {\r\n    -webkit-animation-duration: 0.001s;\r\n    animation-duration: 0.001s;\r\n    -webkit-animation-name: os-resize-observer-dummy-animation;\r\n    animation-name: os-resize-observer-dummy-animation;\r\n}\r\nobject.os-resize-observer {\r\n    -webkit-box-sizing: border-box !important;\r\n            box-sizing: border-box !important;\r\n}\r\n@-webkit-keyframes os-resize-observer-dummy-animation {\r\n    from {\r\n        z-index: 0;\r\n    }\r\n    to {\r\n        z-index: -1;\r\n    }\r\n}\r\n@keyframes os-resize-observer-dummy-animation {\r\n    from {\r\n        z-index: 0;\r\n    }\r\n    to {\r\n        z-index: -1;\r\n    }\r\n}\r\n\r\n/*\r\nCUSTOM SCROLLBARS AND CORNER CORE:\r\n*/\r\n\r\n.os-host-transition > .os-scrollbar,\r\n.os-host-transition > .os-scrollbar-corner {\r\n    -webkit-transition: opacity 0.3s, visibility 0.3s, top 0.3s, right 0.3s, bottom 0.3s, left 0.3s;\r\n    transition: opacity 0.3s, visibility 0.3s, top 0.3s, right 0.3s, bottom 0.3s, left 0.3s;\r\n}\r\nhtml.os-html > .os-host > .os-scrollbar {\r\n    position: absolute; /* could be position: fixed; but it causes issues on iOS (-webkit-overflow-scrolling: touch) */\r\n    z-index: 999999; /* highest z-index of the page */\r\n}\r\n.os-scrollbar,\r\n.os-scrollbar-corner {\r\n    position: absolute;\r\n    opacity: 1;\r\n    -ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\r\n    z-index: 1;\r\n}\r\n.os-scrollbar-corner {\r\n    bottom: 0;\r\n    right: 0;\r\n}\r\n.os-scrollbar {\r\n    pointer-events: none;\r\n}\r\n.os-scrollbar-track {\r\n    pointer-events: auto;\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    padding: 0 !important;\r\n    border: none !important;\r\n}\r\n.os-scrollbar-handle {\r\n    pointer-events: auto;\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n.os-scrollbar-handle-off,\r\n.os-scrollbar-track-off {\r\n    pointer-events: none;\r\n}\r\n.os-scrollbar.os-scrollbar-unusable,\r\n.os-scrollbar.os-scrollbar-unusable * {\r\n    pointer-events: none !important;\r\n}\r\n.os-scrollbar.os-scrollbar-unusable .os-scrollbar-handle {\r\n    opacity: 0 !important;\r\n}\r\n.os-scrollbar-horizontal {\r\n    bottom: 0;\r\n    left: 0;\r\n}\r\n.os-scrollbar-vertical {\r\n    top: 0;\r\n    right: 0;\r\n}\r\n.os-host-rtl > .os-scrollbar-horizontal {\r\n    right: 0;\r\n}\r\n.os-host-rtl > .os-scrollbar-vertical {\r\n    right: auto;\r\n    left: 0;\r\n}\r\n.os-host-rtl > .os-scrollbar-corner {\r\n    right: auto;\r\n    left: 0;\r\n}\r\n.os-scrollbar-auto-hidden,\r\n.os-padding + .os-scrollbar-corner,\r\n.os-host-resize-disabled.os-host-scrollbar-horizontal-hidden > .os-scrollbar-corner,\r\n.os-host-scrollbar-horizontal-hidden > .os-scrollbar-horizontal,\r\n.os-host-resize-disabled.os-host-scrollbar-vertical-hidden > .os-scrollbar-corner,\r\n.os-host-scrollbar-vertical-hidden > .os-scrollbar-vertical,\r\n.os-scrollbar-horizontal.os-scrollbar-auto-hidden + .os-scrollbar-vertical + .os-scrollbar-corner,\r\n.os-scrollbar-horizontal + .os-scrollbar-vertical.os-scrollbar-auto-hidden + .os-scrollbar-corner,\r\n.os-scrollbar-horizontal.os-scrollbar-auto-hidden + .os-scrollbar-vertical.os-scrollbar-auto-hidden + .os-scrollbar-corner {\r\n    opacity: 0;\r\n    visibility: hidden;\r\n    pointer-events: none;\r\n}\r\n.os-scrollbar-corner-resize-both {\r\n    cursor: nwse-resize;\r\n}\r\n.os-host-rtl > .os-scrollbar-corner-resize-both {\r\n    cursor: nesw-resize;\r\n}\r\n.os-scrollbar-corner-resize-horizontal {\r\n    cursor: ew-resize;\r\n}\r\n.os-scrollbar-corner-resize-vertical {\r\n    cursor: ns-resize;\r\n}\r\n.os-dragging .os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    cursor: default;\r\n}\r\n.os-host-resize-disabled.os-host-scrollbar-horizontal-hidden > .os-scrollbar-vertical {\r\n    top: 0;\r\n    bottom: 0;\r\n}\r\n.os-host-resize-disabled.os-host-scrollbar-vertical-hidden > .os-scrollbar-horizontal,\r\n.os-host-rtl.os-host-resize-disabled.os-host-scrollbar-vertical-hidden > .os-scrollbar-horizontal {\r\n    right: 0;\r\n    left: 0;\r\n}\r\n.os-scrollbar:hover,\r\n.os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    opacity: 1 !important;\r\n    visibility: visible !important;\r\n}\r\n.os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgICB3aWR0aD0iMTAiICAgaGVpZ2h0PSIxMCIgICB2ZXJzaW9uPSIxLjEiPiAgPGcgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsLTEwNDIuMzYyMikiICAgICBzdHlsZT0iZGlzcGxheTppbmxpbmUiPiAgICA8cGF0aCAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eTowLjQ5NDExNzY1O2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIiAgICAgICBkPSJtIDcuNDI0MjE4NywxMDQyLjM2MjIgYyAtMC43MjM1NzkyLDAgLTEuMzEwMTU2MiwwLjU4NjYgLTEuMzEwMTU2MiwxLjMxMDIgMCwwLjI5OSAwLjEwNDM0MTksMC41NzEgMC4yNzI5NDkyLDAuNzkxNSAwLjIwOTEwMjQsMC4xNDEzIDAuNDY1NjIwNiwwLjIxODQgMC43MzY5NjI5LDAuMjE4NCAwLjcyMzU3OTMsMCAxLjMxMDE1NjMsLTAuNTg2NiAxLjMxMDE1NjMsLTEuMzEwMiAwLC0wLjI3MTMgLTAuMDc3MDkzLC0wLjUyNzggLTAuMjE4MzU5NCwtMC43MzcgLTAuMjIwNDk0MSwtMC4xNjg2IC0wLjQ5MjU0NDMsLTAuMjcyOSAtMC43OTE1NTI4LC0wLjI3MjkgeiBtIDAsMy4wODQzIGMgLTAuNzIzNTc5MiwwIC0xLjMxMDE1NjIsMC41ODY2IC0xLjMxMDE1NjIsMS4zMTAyIDAsMC4yOTkgMC4xMDQzNDE5LDAuNTcxIDAuMjcyOTQ5MiwwLjc5MTUgMC4yMDkxMDI0LDAuMTQxMyAwLjQ2NTYyMDYsMC4yMTg0IDAuNzM2OTYyOSwwLjIxODQgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjYgMS4zMTAxNTYzLC0xLjMxMDIgMCwtMC4yNzEzIC0wLjA3NzA5MywtMC41Mjc4IC0wLjIxODM1OTQsLTAuNzM2OSAtMC4yMjA0OTQxLC0wLjE2ODYgLTAuNDkyNTQ0MywtMC4yNzMgLTAuNzkxNTUyOCwtMC4yNzMgeiBtIC0zLjA4NDMyNjEsMCBjIC0wLjcyMzU3OTMsMCAtMS4zMTAxNTYzLDAuNTg2NiAtMS4zMTAxNTYzLDEuMzEwMiAwLDAuMjk5IDAuMTA0MzQxOSwwLjU3MSAwLjI3Mjk0OTIsMC43OTE1IDAuMjA5MTAyNCwwLjE0MTMgMC40NjU2MjA3LDAuMjE4NCAwLjczNjk2MjksMC4yMTg0IDAuNzIzNTc5MywwIDEuMzEwMTU2MywtMC41ODY2IDEuMzEwMTU2MywtMS4zMTAyIDAsLTAuMjcxMyAtMC4wNzcwOTMsLTAuNTI3OCAtMC4yMTgzNTk0LC0wLjczNjkgLTAuMjIwNDk0LC0wLjE2ODYgLTAuNDkyNTQ0MiwtMC4yNzMgLTAuNzkxNTUyNywtMC4yNzMgeiBtIC0zLjAyOTczNjQsMy4wMjk4IEMgMC41ODY1NzY5MywxMDQ4LjQ3NjMgMCwxMDQ5LjA2MjggMCwxMDQ5Ljc4NjQgYyAwLDAuMjk5IDAuMTA0MzQxOSwwLjU3MTEgMC4yNzI5NDkyMiwwLjc5MTYgMC4yMDkxMDIyOSwwLjE0MTIgMC40NjU2MjA2NSwwLjIxODMgMC43MzY5NjI4OCwwLjIxODMgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjUgMS4zMTAxNTYzLC0xLjMxMDEgMCwtMC4yNzE0IC0wLjA3NzA5MywtMC41Mjc5IC0wLjIxODM1OTQsLTAuNzM3IC0wLjIyMDQ5NDEsLTAuMTY4NiAtMC40OTI1NDQzLC0wLjI3MjkgLTAuNzkxNTUyOCwtMC4yNzI5IHogbSAzLjAyOTczNjQsMCBjIC0wLjcyMzU3OTMsMCAtMS4zMTAxNTYzLDAuNTg2NSAtMS4zMTAxNTYzLDEuMzEwMSAwLDAuMjk5IDAuMTA0MzQxOSwwLjU3MTEgMC4yNzI5NDkyLDAuNzkxNiAwLjIwOTEwMjQsMC4xNDEyIDAuNDY1NjIwNywwLjIxODMgMC43MzY5NjI5LDAuMjE4MyAwLjcyMzU3OTMsMCAxLjMxMDE1NjMsLTAuNTg2NSAxLjMxMDE1NjMsLTEuMzEwMSAwLC0wLjI3MTQgLTAuMDc3MDkzLC0wLjUyNzkgLTAuMjE4MzU5NCwtMC43MzcgLTAuMjIwNDk0LC0wLjE2ODYgLTAuNDkyNTQ0MiwtMC4yNzI5IC0wLjc5MTU1MjcsLTAuMjcyOSB6IG0gMy4wODQzMjYxLDAgYyAtMC43MjM1NzkyLDAgLTEuMzEwMTU2MiwwLjU4NjUgLTEuMzEwMTU2MiwxLjMxMDEgMCwwLjI5OSAwLjEwNDM0MTksMC41NzExIDAuMjcyOTQ5MiwwLjc5MTYgMC4yMDkxMDI0LDAuMTQxMiAwLjQ2NTYyMDYsMC4yMTgzIDAuNzM2OTYyOSwwLjIxODMgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjUgMS4zMTAxNTYzLC0xLjMxMDEgMCwtMC4yNzE0IC0wLjA3NzA5MywtMC41Mjc5IC0wLjIxODM1OTQsLTAuNzM3IC0wLjIyMDQ5NDEsLTAuMTY4NiAtMC40OTI1NDQzLC0wLjI3MjkgLTAuNzkxNTUyOCwtMC4yNzI5IHoiLz4gIDwvZz4gIDxnICAgICBzdHlsZT0iZGlzcGxheTppbmxpbmUiPiAgICA8cGF0aCAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIiAgICAgICBkPSJtIDguMjE1NzcxNSwwLjI3Mjk0OTIyIGMgMC4xNDEyNjY3LDAuMjA5MTAyMjkgMC4yMTgzNTk0LDAuNDY1NjIwNjUgMC4yMTgzNTk0LDAuNzM2OTYyODggMCwwLjcyMzU3OTMgLTAuNTg2NTc3LDEuMzEwMTU2MyAtMS4zMTAxNTYzLDEuMzEwMTU2MyAtMC4yNzEzNDIzLDAgLTAuNTI3ODYwNSwtMC4wNzcwOTMgLTAuNzM2OTYyOSwtMC4yMTgzNTk0IDAuMjM5NDEwNCwwLjMxMzA4NTkgMC42MTI2MzYyLDAuNTE4NjAzNSAxLjAzNzIwNywwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDc2IC0wLjIwNTUxNzYsLTAuNzk3Nzk2NTkgLTAuNTE4NjAzNSwtMS4wMzcyMDY5OCB6IG0gMCwzLjA4NDMyNjE4IGMgMC4xNDEyNjY3LDAuMjA5MTAyMyAwLjIxODM1OTQsMC40NjU2MjA2IDAuMjE4MzU5NCwwLjczNjk2MjkgMCwwLjcyMzU3OTMgLTAuNTg2NTc3LDEuMzEwMTU2MiAtMS4zMTAxNTYzLDEuMzEwMTU2MiAtMC4yNzEzNDIzLDAgLTAuNTI3ODYwNSwtMC4wNzcwOTMgLTAuNzM2OTYyOSwtMC4yMTgzNTkzIDAuMjM5NDEwNCwwLjMxMzA4NTkgMC42MTI2MzYyLDAuNTE4NjAzNSAxLjAzNzIwNywwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NiwtMC43OTc3OTY3IC0wLjUxODYwMzUsLTEuMDM3MjA3IHogbSAtMy4wODQzMjYyLDAgYyAwLjE0MTI2NjcsMC4yMDkxMDIzIDAuMjE4MzU5NCwwLjQ2NTYyMDYgMC4yMTgzNTk0LDAuNzM2OTYyOSAwLDAuNzIzNTc5MyAtMC41ODY1NzcsMS4zMTAxNTYyIC0xLjMxMDE1NjMsMS4zMTAxNTYyIC0wLjI3MTM0MjIsMCAtMC41Mjc4NjA1LC0wLjA3NzA5MyAtMC43MzY5NjI5LC0wLjIxODM1OTMgMC4yMzk0MTA0LDAuMzEzMDg1OSAwLjYxMjYzNjMsMC41MTg2MDM1IDEuMDM3MjA3MSwwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYyLC0wLjU4NjU3NyAxLjMxMDE1NjIsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NSwtMC43OTc3OTY3IC0wLjUxODYwMzUsLTEuMDM3MjA3IHogTSAyLjEwMTcwOSw2LjM4NzAxMTcgYyAwLjE0MTI2NjcsMC4yMDkxMDI0IDAuMjE4MzU5NCwwLjQ2NTYyMDYgMC4yMTgzNTk0LDAuNzM2OTYyOSAwLDAuNzIzNTc5MyAtMC41ODY1NzcsMS4zMTAxNTYzIC0xLjMxMDE1NjMsMS4zMTAxNTYzIC0wLjI3MTM0MjIzLDAgLTAuNTI3ODYwNTksLTAuMDc3MDkzIC0wLjczNjk2Mjg4LC0wLjIxODM1OTQgMC4yMzk0MTAzOSwwLjMxMzA4NTkgMC42MTI2MzYyMiwwLjUxODYwMzUgMS4wMzcyMDY5OCwwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NiwtMC43OTc3OTY2IC0wLjUxODYwMzUsLTEuMDM3MjA3IHogbSAzLjAyOTczNjMsMCBjIDAuMTQxMjY2NywwLjIwOTEwMjQgMC4yMTgzNTk0LDAuNDY1NjIwNiAwLjIxODM1OTQsMC43MzY5NjI5IDAsMC43MjM1NzkzIC0wLjU4NjU3NywxLjMxMDE1NjMgLTEuMzEwMTU2MywxLjMxMDE1NjMgLTAuMjcxMzQyMiwwIC0wLjUyNzg2MDUsLTAuMDc3MDkzIC0wLjczNjk2MjksLTAuMjE4MzU5NCAwLjIzOTQxMDQsMC4zMTMwODU5IDAuNjEyNjM2MywwLjUxODYwMzUgMS4wMzcyMDcxLDAuNTE4NjAzNSAwLjcyMzU3OTMsMCAxLjMxMDE1NjIsLTAuNTg2NTc3IDEuMzEwMTU2MiwtMS4zMTAxNTYzIDAsLTAuNDI0NTcwOCAtMC4yMDU1MTc1LC0wLjc5Nzc5NjYgLTAuNTE4NjAzNSwtMS4wMzcyMDcgeiBtIDMuMDg0MzI2MiwwIGMgMC4xNDEyNjY3LDAuMjA5MTAyNCAwLjIxODM1OTQsMC40NjU2MjA2IDAuMjE4MzU5NCwwLjczNjk2MjkgMCwwLjcyMzU3OTMgLTAuNTg2NTc3LDEuMzEwMTU2MyAtMS4zMTAxNTYzLDEuMzEwMTU2MyAtMC4yNzEzNDIzLDAgLTAuNTI3ODYwNSwtMC4wNzcwOTMgLTAuNzM2OTYyOSwtMC4yMTgzNTk0IDAuMjM5NDEwNCwwLjMxMzA4NTkgMC42MTI2MzYyLDAuNTE4NjAzNSAxLjAzNzIwNywwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NiwtMC43OTc3OTY2IC0wLjUxODYwMzUsLTEuMDM3MjA3IHoiIC8+ICA8L2c+PC9zdmc+);\r\n    background-repeat: no-repeat;\r\n    background-position: 100% 100%;\r\n    pointer-events: auto !important;\r\n}\r\n.os-host-rtl > .os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    -webkit-transform: scale(-1, 1);\r\n    transform: scale(-1, 1);\r\n}\r\n.os-host-overflow {\r\n    overflow: hidden !important;\r\n}\r\n.os-host-overflow-x {\r\n} \r\n.os-host-overflow-y {\r\n} \r\n\r\n/*\r\nTHEMES:\r\n*/\r\n\r\n/* NONE THEME: */\r\n.os-theme-none > .os-scrollbar-horizontal,\r\n.os-theme-none > .os-scrollbar-vertical,\r\n.os-theme-none > .os-scrollbar-corner {\r\n    display: none !important;\r\n}\r\n.os-theme-none > .os-scrollbar-corner-resize {\r\n    display: block !important;\r\n    min-width: 10px;\r\n    min-height: 10px;\r\n}\r\n/* DARK & LIGHT THEME: */\r\n.os-theme-dark > .os-scrollbar-horizontal,\r\n.os-theme-light > .os-scrollbar-horizontal {\r\n    right: 10px;\r\n    height: 10px;\r\n}\r\n.os-theme-dark > .os-scrollbar-vertical,\r\n.os-theme-light > .os-scrollbar-vertical {\r\n    bottom: 10px;\r\n    width: 10px;\r\n}\r\n.os-theme-dark.os-host-rtl > .os-scrollbar-horizontal,\r\n.os-theme-light.os-host-rtl > .os-scrollbar-horizontal {\r\n    left: 10px;\r\n    right: 0;\r\n}\r\n.os-theme-dark > .os-scrollbar-corner,\r\n.os-theme-light > .os-scrollbar-corner {\r\n    height: 10px;\r\n    width: 10px;\r\n}\r\n.os-theme-dark > .os-scrollbar-corner,\r\n.os-theme-light > .os-scrollbar-corner {\r\n    background-color: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar,\r\n.os-theme-light > .os-scrollbar {\r\n    padding: 2px;\r\n    -webkit-box-sizing: border-box;\r\n            box-sizing: border-box;\r\n    background: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar.os-scrollbar-unusable,\r\n.os-theme-light > .os-scrollbar.os-scrollbar-unusable {\r\n    background: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track,\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track {\r\n    background: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar-horizontal > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light > .os-scrollbar-horizontal > .os-scrollbar-track > .os-scrollbar-handle {\r\n    min-width: 30px;\r\n}\r\n.os-theme-dark > .os-scrollbar-vertical > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light > .os-scrollbar-vertical > .os-scrollbar-track > .os-scrollbar-handle {\r\n    min-height: 30px;\r\n}\r\n.os-theme-dark.os-host-transition > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light.os-host-transition > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle {\r\n    -webkit-transition: background-color 0.3s;\r\n    transition: background-color 0.3s;\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track,\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track {\r\n    border-radius: 10px;\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(0, 0, 0, 0.4);\r\n}\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(255, 255, 255, 0.4);\r\n}\r\n.os-theme-dark > .os-scrollbar:hover > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(0, 0, 0, .55);\r\n}\r\n.os-theme-light > .os-scrollbar:hover > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(255, 255, 255, .55);\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle.active {\r\n    background: rgba(0, 0, 0, .7);\r\n}\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle.active {\r\n    background: rgba(255, 255, 255, .7);\r\n}\r\n.os-theme-dark > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-dark > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    content: '';\r\n    position: absolute;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    display: block;\r\n}\r\n.os-theme-dark.os-host-scrollbar-horizontal-hidden > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-dark.os-host-scrollbar-vertical-hidden > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-theme-light.os-host-scrollbar-horizontal-hidden > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-light.os-host-scrollbar-vertical-hidden > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    display: none;\r\n}\r\n.os-theme-dark > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-horizontal .os-scrollbar-handle:before {\r\n    top: -6px;\r\n    bottom: -2px;\r\n}\r\n.os-theme-dark > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    left: -6px;\r\n    right: -2px;\r\n}\r\n.os-host-rtl.os-theme-dark > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-host-rtl.os-theme-light > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    right: -6px;\r\n    left: -2px;\r\n}\r\n", "",{"version":3,"sources":["webpack://node_modules/overlayscrollbars/css/OverlayScrollbars.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;EAWE;;AAEF;;CAEC;;AAED;;IAEI,cAAc;IACd,gBAAgB;IAChB,8BAAsB;YAAtB,sBAAsB;IACtB,uBAAuB;IACvB,sBAAsB;IACtB,0BAA0B;IAC1B,2BAA2B;IAC3B,oBAAoB;IACpB,6BAA6B,EAAE,8FAA8F;AACjI;AACA;IACI,kBAAkB,EAAE,8FAA8F;AACtH;AACA;;IAEI,eAAe;AACnB;AACA;;IAEI,kBAAkB;IAClB,4BAA4B;IAIpB,sBAAsB;IAE1B,iBAAiB;IAGb,2BAA2B;IAE/B,yBAAyB;IAC7B,wBAAwB;QACpB,qBAAqB;gBACb,8BAA8B;YAClC,uBAAuB;AACnC;AACA;IACI,2BAA2B;IAG3B,aAAa;AACjB;AACA;IACI,0BAA0B;AAC9B;AACA;IAGY,YAAY;IAEhB,cAAc;AACtB;AACA;;IAEI,aAAa;IACb,YAAY;IAGJ,YAAY;IAEhB,cAAc;IAEd,gBAAgB;AACxB;AACA;IACI,eAAe;IACf,UAAU;IACV,gEAAgE;IAChE,kBAAkB;IAClB,gBAAgB;IAChB,aAAa;IACb,YAAY;AAChB;AACA;IACI,WAAW;IACX,YAAY;IACZ,cAAc;AAClB;AACA,6BAA6B;AAC7B;;;;IAII,WAAW;IACX,cAAc;IACd,aAAa;IACb,cAAc;IACd,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,kBAAkB;AACtB;AACA;;IAEI,wCAAwC;AAC5C;AACA;;IAEI,gCAAgC;AACpC;AACA;;;;IAII,wBAAwB;IACxB,qBAAqB;IACrB,sBAAsB;IACtB,6BAA6B;IAC7B,kCAAkC;AACtC;AACA;IACI,2BAAmB;YAAnB,mBAAmB;IACnB,gBAAgB;IAChB,eAAe;IACf,WAAW;IACX,oBAAoB;AACxB;AACA;IACI,2BAAmB;YAAnB,mBAAmB;IACnB,kBAAkB;IAClB,kBAAkB;IAClB,iBAAiB;IACjB,UAAU;IACV,SAAS;IACT,OAAO;IACP,MAAM;IACN,SAAS;IACT,QAAQ;IACR,sBAAsB;IACtB,uBAAuB;CAC1B,UAAU;AACX;AACA;IACI,gBAAgB;AACpB;AACA;IACI,6BAA6B;IAC7B,sCAA8B;YAA9B,8BAA8B;IAC9B,uBAAuB;IACvB,wBAAwB;IACxB,kBAAkB;IAClB,gBAAgB;IAChB,MAAM;IACN,OAAO;IACP,SAAS;IACT,QAAQ;IACR,UAAU;IACV,SAAS;IACT,iCAAiC;AACrC;AACA;IACI,kBAAkB;IAClB,WAAW;IACX,eAAe;IACf,cAAc;IACd,oBAAoB;AACxB;AACA;IACI,kBAAkB;IAClB,yCAAiC;YAAjC,iCAAiC;IACjC,kBAAkB;IAClB,cAAc;IACd,YAAY;IACZ,WAAW;IACX,YAAY;IACZ,WAAW;IACX,mBAAmB;AACvB;AACA;IACI,yCAAiC;YAAjC,iCAAiC;IACjC,6BAA6B;IAC7B,kCAAkC;IAClC,wCAAwC;IACxC,2BAA2B;IAC3B,6BAA6B;IAC7B,yBAAyB;IACzB,iBAAiB;IACjB,kBAAkB;IAClB,oBAAoB;IACpB,6BAA6B;IAC7B,sBAAsB;IAEd,uBAAuB;IAC/B,uBAAuB;IACvB,uBAAuB;IACvB,kCAAkC;YAC1B,0BAA0B;IAClC,0BAA0B;IAC1B,2BAA2B;IAC3B,mCAA2B;YAA3B,2BAA2B;IAC3B,oCAAoC;YAC5B,4BAA4B;IACpC,qBAAqB;IACrB,qBAAqB;IACrB,qBAAqB;IACrB,mCAAmC;IACnC,YAAY;AAChB;AACA;IACI,mBAAmB;AACvB;AACA;IACI,WAAW;IACX,oBAAoB;AACxB;AACA;IACI,2BAA2B;IAC3B,sBAAsB;AAC1B;AACA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,oBAAoB;IACpB,mBAAmB;IACnB,8BAAqB;IAArB,qBAAqB;IACrB,uBAAuB;IACvB,wBAAwB;IACxB,oBAAoB;IACpB,mBAAmB;IACnB,oBAAoB;IACpB,sBAAsB;IACtB,uBAAuB;IACvB,qBAAqB;IACrB,oBAAoB;IACpB,qBAAqB;IACrB,kBAAkB;IAClB,cAAc;IACd,YAAY;AAChB;AACA;;IAEI,2BAAmB;YAAnB,mBAAmB;IACnB,cAAc;IACd,kBAAkB;IAClB,kBAAkB;IAClB,MAAM;IACN,OAAO;IACP,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,oBAAoB;IACpB,WAAW;AACf;AACA;IACI,gBAAgB;IAChB,eAAe;IACf,yBAAyB;IACzB,mBAAmB;IACnB,8BAAsB;YAAtB,sBAAsB;AAC1B;AACA;IACI,aAAa;IACb,sBAAsB;IACtB,2BAA2B;IAC3B,uBAAuB;AAC3B;AACA;;IAEI,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,eAAe;IACf,SAAS;IACT,cAAc;IACd,+BAAuB;YAAvB,uBAAuB;AAC3B;AACA;;IAEI,aAAa;IACb,kBAAkB;IAClB,YAAY;IACZ,cAAc;IACd,gBAAgB;IAChB,8BAAsB;YAAtB,sBAAsB;AAC1B;AACA;IACI,WAAW;IACX,+BAAuB;YAAvB,uBAAuB;IACvB,gBAAgB;IAChB,eAAe;IACf,SAAS;AACb;AACA;IACI,sCAA8B;YAA9B,8BAA8B;IAC9B,YAAY;IACZ,cAAc;IACd,cAAc;IACd,kBAAkB;IAClB,WAAW;IACX,eAAe;IACf,gBAAgB;IAChB,WAAW;IACX,UAAU;IACV,SAAS;IACT,oBAAoB;IAGZ,kBAAkB;IAEtB,cAAc;IAEd,aAAa;AACrB;AACA;IACI,YAAY;IACZ,aAAa;IACb,eAAe;IACf,cAAc;AAClB;AACA;IACI,kBAAkB;IAClB,MAAM;IACN,QAAQ;IACR,SAAS;IACT,OAAO;IACP,gBAAgB;IAChB,WAAW;IACX,UAAU;IACV,yBAAyB;IAGzB,qBAAqB;AACzB;AACA;IACI,kBAAkB;IAClB,OAAO;IACP,MAAM;IACN,mCAAmC;IACnC,2BAA2B;IAG3B,qBAAqB;AACzB;AACA;IACI,kCAAkC;IAClC,0BAA0B;IAC1B,0DAA0D;IAC1D,kDAAkD;AACtD;AACA;IACI,yCAAiC;YAAjC,iCAAiC;AACrC;AACA;IACI;QACI,UAAU;IACd;IACA;QACI,WAAW;IACf;AACJ;AACA;IACI;QACI,UAAU;IACd;IACA;QACI,WAAW;IACf;AACJ;;AAEA;;CAEC;;AAED;;IAEI,+FAA+F;IAC/F,uFAAuF;AAC3F;AACA;IACI,kBAAkB,EAAE,8FAA8F;IAClH,eAAe,EAAE,gCAAgC;AACrD;AACA;;IAEI,kBAAkB;IAClB,UAAU;IACV,kEAAkE;IAClE,UAAU;AACd;AACA;IACI,SAAS;IACT,QAAQ;AACZ;AACA;IACI,oBAAoB;AACxB;AACA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,YAAY;IACZ,WAAW;IACX,qBAAqB;IACrB,uBAAuB;AAC3B;AACA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,WAAW;IACX,YAAY;AAChB;AACA;;IAEI,oBAAoB;AACxB;AACA;;IAEI,+BAA+B;AACnC;AACA;IACI,qBAAqB;AACzB;AACA;IACI,SAAS;IACT,OAAO;AACX;AACA;IACI,MAAM;IACN,QAAQ;AACZ;AACA;IACI,QAAQ;AACZ;AACA;IACI,WAAW;IACX,OAAO;AACX;AACA;IACI,WAAW;IACX,OAAO;AACX;AACA;;;;;;;;;IASI,UAAU;IACV,kBAAkB;IAClB,oBAAoB;AACxB;AACA;IACI,mBAAmB;AACvB;AACA;IACI,mBAAmB;AACvB;AACA;IACI,iBAAiB;AACrB;AACA;IACI,iBAAiB;AACrB;AACA;IACI,eAAe;AACnB;AACA;IACI,MAAM;IACN,SAAS;AACb;AACA;;IAEI,QAAQ;IACR,OAAO;AACX;AACA;;IAEI,qBAAqB;IACrB,8BAA8B;AAClC;AACA;IACI,qpMAAqpM;IACrpM,4BAA4B;IAC5B,8BAA8B;IAC9B,+BAA+B;AACnC;AACA;IACI,+BAA+B;IAC/B,uBAAuB;AAC3B;AACA;IACI,2BAA2B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;CAEC;;AAED,gBAAgB;AAChB;;;IAGI,wBAAwB;AAC5B;AACA;IACI,yBAAyB;IACzB,eAAe;IACf,gBAAgB;AACpB;AACA,wBAAwB;AACxB;;IAEI,WAAW;IACX,YAAY;AAChB;AACA;;IAEI,YAAY;IACZ,WAAW;AACf;AACA;;IAEI,UAAU;IACV,QAAQ;AACZ;AACA;;IAEI,YAAY;IACZ,WAAW;AACf;AACA;;IAEI,6BAA6B;AACjC;AACA;;IAEI,YAAY;IACZ,8BAAsB;YAAtB,sBAAsB;IACtB,uBAAuB;AAC3B;AACA;;IAEI,uBAAuB;AAC3B;AACA;;IAEI,uBAAuB;AAC3B;AACA;;IAEI,eAAe;AACnB;AACA;;IAEI,gBAAgB;AACpB;AACA;;IAEI,yCAAyC;IACzC,iCAAiC;AACrC;AACA;;;;IAII,mBAAmB;AACvB;AACA;IACI,8BAA8B;AAClC;AACA;IACI,oCAAoC;AACxC;AACA;IACI,8BAA8B;AAClC;AACA;IACI,oCAAoC;AACxC;AACA;IACI,6BAA6B;AACjC;AACA;IACI,mCAAmC;AACvC;AACA;;;;IAII,WAAW;IACX,kBAAkB;IAClB,OAAO;IACP,QAAQ;IACR,MAAM;IACN,SAAS;IACT,cAAc;AAClB;AACA;;;;IAII,aAAa;AACjB;AACA;;IAEI,SAAS;IACT,YAAY;AAChB;AACA;;IAEI,UAAU;IACV,WAAW;AACf;AACA;;IAEI,WAAW;IACX,UAAU;AACd","sourcesContent":["/*!\r\n * OverlayScrollbars\r\n * https://github.com/KingSora/OverlayScrollbars\r\n *\r\n * Version: 1.13.0\r\n *\r\n * Copyright KingSora | Rene Haas.\r\n * https://github.com/KingSora\r\n *\r\n * Released under the MIT license.\r\n * Date: 02.08.2020\r\n */\r\n\r\n/*\r\nOVERLAY SCROLLBARS CORE:\r\n*/\r\n\r\nhtml.os-html,\r\nhtml.os-html > .os-host {\r\n    display: block;\r\n    overflow: hidden;\r\n    box-sizing: border-box;\r\n    height: 100% !important;\r\n    width: 100% !important;\r\n    min-width: 100% !important;\r\n    min-height: 100% !important;\r\n    margin: 0 !important;\r\n    position: absolute !important; /* could be position: fixed; but it causes issues on iOS (-webkit-overflow-scrolling: touch) */\r\n}\r\nhtml.os-html > .os-host > .os-padding {\r\n    position: absolute; /* could be position: fixed; but it causes issues on iOS (-webkit-overflow-scrolling: touch) */\r\n}\r\nbody.os-dragging,\r\nbody.os-dragging * {\r\n    cursor: default;\r\n}\r\n.os-host,\r\n.os-host-textarea {\r\n    position: relative;\r\n    overflow: visible !important;\r\n    -webkit-box-orient: vertical;\r\n    -webkit-box-direction: normal;\r\n        -ms-flex-direction: column;\r\n            flex-direction: column;\r\n    -ms-flex-wrap: nowrap;\r\n        flex-wrap: nowrap;\r\n    -webkit-box-pack: start;\r\n        -ms-flex-pack: start;\r\n            justify-content: flex-start;\r\n    -ms-flex-line-pack: start;\r\n        align-content: flex-start;\r\n    -webkit-box-align: start;\r\n        -ms-flex-align: start;\r\n                -ms-grid-row-align: flex-start;\r\n            align-items: flex-start;\r\n}\r\n.os-host-flexbox {\r\n    overflow: hidden !important;\r\n    display: -webkit-box;\r\n    display: -ms-flexbox;\r\n    display: flex;\r\n}\r\n.os-host-flexbox > .os-size-auto-observer {\r\n    height: inherit !important;\r\n}\r\n.os-host-flexbox > .os-content-glue {\r\n    -webkit-box-flex: 1;\r\n        -ms-flex-positive: 1;\r\n            flex-grow: 1;\r\n    -ms-flex-negative: 0;\r\n        flex-shrink: 0;\r\n}\r\n.os-host-flexbox > .os-size-auto-observer,\r\n.os-host-flexbox > .os-content-glue {\r\n    min-height: 0;\r\n    min-width: 0;\r\n    -webkit-box-flex: 0;\r\n        -ms-flex-positive: 0;\r\n            flex-grow: 0;\r\n    -ms-flex-negative: 1;\r\n        flex-shrink: 1;\r\n    -ms-flex-preferred-size: auto;\r\n        flex-basis: auto;\r\n}\r\n#os-dummy-scrollbar-size {\r\n    position: fixed;\r\n    opacity: 0;\r\n    -ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=0)';\r\n    visibility: hidden;\r\n    overflow: scroll;\r\n    height: 500px;\r\n    width: 500px;\r\n}\r\n#os-dummy-scrollbar-size > div {\r\n    width: 200%;\r\n    height: 200%; \r\n    margin: 10px 0;\r\n}\r\n/* fix restricted measuring */\r\n#os-dummy-scrollbar-size:before,\r\n#os-dummy-scrollbar-size:after,\r\n.os-content:before,\r\n.os-content:after {\r\n    content: '';\r\n    display: table;\r\n    width: 0.01px;\r\n    height: 0.01px;\r\n    line-height: 0;\r\n    font-size: 0;\r\n    flex-grow: 0;\r\n    flex-shrink: 0;\r\n    visibility: hidden;\r\n}\r\n#os-dummy-scrollbar-size,\r\n.os-viewport {\r\n    -ms-overflow-style: scrollbar !important;\r\n}\r\n.os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size,\r\n.os-viewport-native-scrollbars-invisible.os-viewport {\r\n    scrollbar-width: none !important;\r\n}\r\n.os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar,\r\n.os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar,\r\n.os-viewport-native-scrollbars-invisible#os-dummy-scrollbar-size::-webkit-scrollbar-corner,\r\n.os-viewport-native-scrollbars-invisible.os-viewport::-webkit-scrollbar-corner {\r\n    display: none !important;\r\n    width: 0px !important;\r\n    height: 0px !important;\r\n    visibility: hidden !important;\r\n    background: transparent !important;\r\n}\r\n.os-content-glue {\r\n    box-sizing: inherit;\r\n    max-height: 100%;\r\n    max-width: 100%;\r\n    width: 100%;\r\n    pointer-events: none;\r\n}\r\n.os-padding {\r\n    box-sizing: inherit;\r\n    direction: inherit;\r\n    position: absolute;\r\n    overflow: visible;\r\n    padding: 0;\r\n    margin: 0;\r\n    left: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    right: 0;\r\n    width: auto !important;\r\n    height: auto !important;\r\n\tz-index: 0;\r\n}\r\n.os-host-overflow > .os-padding {\r\n    overflow: hidden;\r\n}\r\n.os-viewport {\r\n    direction: inherit !important;\r\n    box-sizing: inherit !important;\r\n    resize: none !important;\r\n    outline: none !important;\r\n    position: absolute;\r\n    overflow: hidden;\r\n    top: 0;\r\n    left: 0;\r\n    bottom: 0;\r\n    right: 0;\r\n    padding: 0;\r\n    margin: 0;\r\n    -webkit-overflow-scrolling: touch;\r\n}\r\n.os-content-arrange {\r\n    position: absolute;\r\n    z-index: -1;\r\n    min-height: 1px;\r\n    min-width: 1px;\r\n    pointer-events: none;\r\n}\r\n.os-content {\r\n    direction: inherit;\r\n    box-sizing: border-box !important;\r\n    position: relative;\r\n    display: block;\r\n    height: 100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    width: 100%;\r\n    visibility: visible;\r\n}\r\n.os-content > .os-textarea {\r\n    box-sizing: border-box !important;\r\n    direction: inherit !important;\r\n    background: transparent !important;\r\n    outline: 0px none transparent !important;\r\n    overflow: hidden !important;\r\n    position: absolute !important;\r\n    display: block !important;\r\n    top: 0 !important;\r\n    left: 0 !important;\r\n    margin: 0 !important;\r\n    border-radius: 0px !important;\r\n    float: none !important;\r\n    -webkit-filter: none !important;\r\n            filter: none !important;\r\n    border: none !important;\r\n    resize: none !important;\r\n    -webkit-transform: none !important;\r\n            transform: none !important;\r\n    max-width: none !important;\r\n    max-height: none !important;\r\n    box-shadow: none !important;\r\n    -webkit-perspective: none !important;\r\n            perspective: none !important;\r\n    opacity: 1 !important;\r\n    z-index: 1 !important;\r\n    clip: auto !important;\r\n    vertical-align: baseline !important;\r\n    padding: 0px;\r\n}\r\n.os-host-rtl > .os-padding > .os-viewport > .os-content > .os-textarea {\r\n    right: 0 !important;\r\n}\r\n.os-content > .os-textarea-cover {\r\n    z-index: -1;\r\n    pointer-events: none;\r\n}\r\n.os-content > .os-textarea[wrap='off'] {\r\n    white-space: pre !important;\r\n    margin: 0px !important;\r\n}\r\n.os-text-inherit {\r\n    font-family: inherit;\r\n    font-size: inherit;\r\n    font-weight: inherit;\r\n    font-style: inherit;\r\n    font-variant: inherit;\r\n    text-transform: inherit;\r\n    text-decoration: inherit;\r\n    text-indent: inherit;\r\n    text-align: inherit;\r\n    text-shadow: inherit;\r\n    text-overflow: inherit;\r\n    letter-spacing: inherit;\r\n    word-spacing: inherit;\r\n    line-height: inherit;\r\n    unicode-bidi: inherit;\r\n    direction: inherit;\r\n    color: inherit;\r\n    cursor: text;\r\n}\r\n.os-resize-observer,\r\n.os-resize-observer-host {\r\n    box-sizing: inherit;\r\n    display: block;\r\n    visibility: hidden;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow: hidden;\r\n    pointer-events: none;\r\n    z-index: -1;\r\n}\r\n.os-resize-observer-host {\r\n    padding: inherit;\r\n    border: inherit;\r\n    border-color: transparent;\r\n    border-style: solid;\r\n    box-sizing: border-box;\r\n}\r\n.os-resize-observer-host.observed {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n.os-resize-observer-host > .os-resize-observer,\r\n.os-resize-observer-host.observed > .os-resize-observer {\r\n    height: 200%;\r\n    width: 200%;\r\n    padding: inherit;\r\n    border: inherit;\r\n    margin: 0;\r\n    display: block;\r\n    box-sizing: content-box;\r\n}\r\n.os-resize-observer-host.observed > .os-resize-observer,\r\n.os-resize-observer-host.observed > .os-resize-observer:before {\r\n    display: flex;\r\n    position: relative;\r\n    flex-grow: 1;\r\n    flex-shrink: 0;\r\n    flex-basis: auto;\r\n    box-sizing: border-box;\r\n}\r\n.os-resize-observer-host.observed > .os-resize-observer:before {\r\n    content: '';\r\n    box-sizing: content-box;\r\n    padding: inherit;\r\n    border: inherit;\r\n    margin: 0;\r\n}\r\n.os-size-auto-observer {\r\n    box-sizing: inherit !important;\r\n    height: 100%;\r\n    width: inherit;\r\n    max-width: 1px;\r\n    position: relative;\r\n    float: left;\r\n    max-height: 1px;\r\n    overflow: hidden;\r\n    z-index: -1;\r\n    padding: 0;\r\n    margin: 0;\r\n    pointer-events: none;\r\n    -webkit-box-flex: inherit;\r\n        -ms-flex-positive: inherit;\r\n            flex-grow: inherit;\r\n    -ms-flex-negative: 0;\r\n        flex-shrink: 0;\r\n    -ms-flex-preferred-size: 0;\r\n        flex-basis: 0;\r\n}\r\n.os-size-auto-observer > .os-resize-observer {\r\n    width: 1000%;\r\n    height: 1000%;\r\n    min-height: 1px;\r\n    min-width: 1px;\r\n}\r\n.os-resize-observer-item {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    overflow: hidden;\r\n    z-index: -1;\r\n    opacity: 0;\r\n    direction: ltr !important;\r\n    -webkit-box-flex: 0 !important;\r\n    -ms-flex: none !important;\r\n    flex: none !important;\r\n}\r\n.os-resize-observer-item-final {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    -webkit-transition: none !important;\r\n    transition: none !important;\r\n    -webkit-box-flex: 0 !important;\r\n    -ms-flex: none !important;\r\n    flex: none !important;\r\n}\r\n.os-resize-observer {\r\n    -webkit-animation-duration: 0.001s;\r\n    animation-duration: 0.001s;\r\n    -webkit-animation-name: os-resize-observer-dummy-animation;\r\n    animation-name: os-resize-observer-dummy-animation;\r\n}\r\nobject.os-resize-observer {\r\n    box-sizing: border-box !important;\r\n}\r\n@-webkit-keyframes os-resize-observer-dummy-animation {\r\n    from {\r\n        z-index: 0;\r\n    }\r\n    to {\r\n        z-index: -1;\r\n    }\r\n}\r\n@keyframes os-resize-observer-dummy-animation {\r\n    from {\r\n        z-index: 0;\r\n    }\r\n    to {\r\n        z-index: -1;\r\n    }\r\n}\r\n\r\n/*\r\nCUSTOM SCROLLBARS AND CORNER CORE:\r\n*/\r\n\r\n.os-host-transition > .os-scrollbar,\r\n.os-host-transition > .os-scrollbar-corner {\r\n    -webkit-transition: opacity 0.3s, visibility 0.3s, top 0.3s, right 0.3s, bottom 0.3s, left 0.3s;\r\n    transition: opacity 0.3s, visibility 0.3s, top 0.3s, right 0.3s, bottom 0.3s, left 0.3s;\r\n}\r\nhtml.os-html > .os-host > .os-scrollbar {\r\n    position: absolute; /* could be position: fixed; but it causes issues on iOS (-webkit-overflow-scrolling: touch) */\r\n    z-index: 999999; /* highest z-index of the page */\r\n}\r\n.os-scrollbar,\r\n.os-scrollbar-corner {\r\n    position: absolute;\r\n    opacity: 1;\r\n    -ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\r\n    z-index: 1;\r\n}\r\n.os-scrollbar-corner {\r\n    bottom: 0;\r\n    right: 0;\r\n}\r\n.os-scrollbar {\r\n    pointer-events: none;\r\n}\r\n.os-scrollbar-track {\r\n    pointer-events: auto;\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    padding: 0 !important;\r\n    border: none !important;\r\n}\r\n.os-scrollbar-handle {\r\n    pointer-events: auto;\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n.os-scrollbar-handle-off,\r\n.os-scrollbar-track-off {\r\n    pointer-events: none;\r\n}\r\n.os-scrollbar.os-scrollbar-unusable,\r\n.os-scrollbar.os-scrollbar-unusable * {\r\n    pointer-events: none !important;\r\n}\r\n.os-scrollbar.os-scrollbar-unusable .os-scrollbar-handle {\r\n    opacity: 0 !important;\r\n}\r\n.os-scrollbar-horizontal {\r\n    bottom: 0;\r\n    left: 0;\r\n}\r\n.os-scrollbar-vertical {\r\n    top: 0;\r\n    right: 0;\r\n}\r\n.os-host-rtl > .os-scrollbar-horizontal {\r\n    right: 0;\r\n}\r\n.os-host-rtl > .os-scrollbar-vertical {\r\n    right: auto;\r\n    left: 0;\r\n}\r\n.os-host-rtl > .os-scrollbar-corner {\r\n    right: auto;\r\n    left: 0;\r\n}\r\n.os-scrollbar-auto-hidden,\r\n.os-padding + .os-scrollbar-corner,\r\n.os-host-resize-disabled.os-host-scrollbar-horizontal-hidden > .os-scrollbar-corner,\r\n.os-host-scrollbar-horizontal-hidden > .os-scrollbar-horizontal,\r\n.os-host-resize-disabled.os-host-scrollbar-vertical-hidden > .os-scrollbar-corner,\r\n.os-host-scrollbar-vertical-hidden > .os-scrollbar-vertical,\r\n.os-scrollbar-horizontal.os-scrollbar-auto-hidden + .os-scrollbar-vertical + .os-scrollbar-corner,\r\n.os-scrollbar-horizontal + .os-scrollbar-vertical.os-scrollbar-auto-hidden + .os-scrollbar-corner,\r\n.os-scrollbar-horizontal.os-scrollbar-auto-hidden + .os-scrollbar-vertical.os-scrollbar-auto-hidden + .os-scrollbar-corner {\r\n    opacity: 0;\r\n    visibility: hidden;\r\n    pointer-events: none;\r\n}\r\n.os-scrollbar-corner-resize-both {\r\n    cursor: nwse-resize;\r\n}\r\n.os-host-rtl > .os-scrollbar-corner-resize-both {\r\n    cursor: nesw-resize;\r\n}\r\n.os-scrollbar-corner-resize-horizontal {\r\n    cursor: ew-resize;\r\n}\r\n.os-scrollbar-corner-resize-vertical {\r\n    cursor: ns-resize;\r\n}\r\n.os-dragging .os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    cursor: default;\r\n}\r\n.os-host-resize-disabled.os-host-scrollbar-horizontal-hidden > .os-scrollbar-vertical {\r\n    top: 0;\r\n    bottom: 0;\r\n}\r\n.os-host-resize-disabled.os-host-scrollbar-vertical-hidden > .os-scrollbar-horizontal,\r\n.os-host-rtl.os-host-resize-disabled.os-host-scrollbar-vertical-hidden > .os-scrollbar-horizontal {\r\n    right: 0;\r\n    left: 0;\r\n}\r\n.os-scrollbar:hover,\r\n.os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    opacity: 1 !important;\r\n    visibility: visible !important;\r\n}\r\n.os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgICB3aWR0aD0iMTAiICAgaGVpZ2h0PSIxMCIgICB2ZXJzaW9uPSIxLjEiPiAgPGcgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsLTEwNDIuMzYyMikiICAgICBzdHlsZT0iZGlzcGxheTppbmxpbmUiPiAgICA8cGF0aCAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eTowLjQ5NDExNzY1O2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIiAgICAgICBkPSJtIDcuNDI0MjE4NywxMDQyLjM2MjIgYyAtMC43MjM1NzkyLDAgLTEuMzEwMTU2MiwwLjU4NjYgLTEuMzEwMTU2MiwxLjMxMDIgMCwwLjI5OSAwLjEwNDM0MTksMC41NzEgMC4yNzI5NDkyLDAuNzkxNSAwLjIwOTEwMjQsMC4xNDEzIDAuNDY1NjIwNiwwLjIxODQgMC43MzY5NjI5LDAuMjE4NCAwLjcyMzU3OTMsMCAxLjMxMDE1NjMsLTAuNTg2NiAxLjMxMDE1NjMsLTEuMzEwMiAwLC0wLjI3MTMgLTAuMDc3MDkzLC0wLjUyNzggLTAuMjE4MzU5NCwtMC43MzcgLTAuMjIwNDk0MSwtMC4xNjg2IC0wLjQ5MjU0NDMsLTAuMjcyOSAtMC43OTE1NTI4LC0wLjI3MjkgeiBtIDAsMy4wODQzIGMgLTAuNzIzNTc5MiwwIC0xLjMxMDE1NjIsMC41ODY2IC0xLjMxMDE1NjIsMS4zMTAyIDAsMC4yOTkgMC4xMDQzNDE5LDAuNTcxIDAuMjcyOTQ5MiwwLjc5MTUgMC4yMDkxMDI0LDAuMTQxMyAwLjQ2NTYyMDYsMC4yMTg0IDAuNzM2OTYyOSwwLjIxODQgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjYgMS4zMTAxNTYzLC0xLjMxMDIgMCwtMC4yNzEzIC0wLjA3NzA5MywtMC41Mjc4IC0wLjIxODM1OTQsLTAuNzM2OSAtMC4yMjA0OTQxLC0wLjE2ODYgLTAuNDkyNTQ0MywtMC4yNzMgLTAuNzkxNTUyOCwtMC4yNzMgeiBtIC0zLjA4NDMyNjEsMCBjIC0wLjcyMzU3OTMsMCAtMS4zMTAxNTYzLDAuNTg2NiAtMS4zMTAxNTYzLDEuMzEwMiAwLDAuMjk5IDAuMTA0MzQxOSwwLjU3MSAwLjI3Mjk0OTIsMC43OTE1IDAuMjA5MTAyNCwwLjE0MTMgMC40NjU2MjA3LDAuMjE4NCAwLjczNjk2MjksMC4yMTg0IDAuNzIzNTc5MywwIDEuMzEwMTU2MywtMC41ODY2IDEuMzEwMTU2MywtMS4zMTAyIDAsLTAuMjcxMyAtMC4wNzcwOTMsLTAuNTI3OCAtMC4yMTgzNTk0LC0wLjczNjkgLTAuMjIwNDk0LC0wLjE2ODYgLTAuNDkyNTQ0MiwtMC4yNzMgLTAuNzkxNTUyNywtMC4yNzMgeiBtIC0zLjAyOTczNjQsMy4wMjk4IEMgMC41ODY1NzY5MywxMDQ4LjQ3NjMgMCwxMDQ5LjA2MjggMCwxMDQ5Ljc4NjQgYyAwLDAuMjk5IDAuMTA0MzQxOSwwLjU3MTEgMC4yNzI5NDkyMiwwLjc5MTYgMC4yMDkxMDIyOSwwLjE0MTIgMC40NjU2MjA2NSwwLjIxODMgMC43MzY5NjI4OCwwLjIxODMgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjUgMS4zMTAxNTYzLC0xLjMxMDEgMCwtMC4yNzE0IC0wLjA3NzA5MywtMC41Mjc5IC0wLjIxODM1OTQsLTAuNzM3IC0wLjIyMDQ5NDEsLTAuMTY4NiAtMC40OTI1NDQzLC0wLjI3MjkgLTAuNzkxNTUyOCwtMC4yNzI5IHogbSAzLjAyOTczNjQsMCBjIC0wLjcyMzU3OTMsMCAtMS4zMTAxNTYzLDAuNTg2NSAtMS4zMTAxNTYzLDEuMzEwMSAwLDAuMjk5IDAuMTA0MzQxOSwwLjU3MTEgMC4yNzI5NDkyLDAuNzkxNiAwLjIwOTEwMjQsMC4xNDEyIDAuNDY1NjIwNywwLjIxODMgMC43MzY5NjI5LDAuMjE4MyAwLjcyMzU3OTMsMCAxLjMxMDE1NjMsLTAuNTg2NSAxLjMxMDE1NjMsLTEuMzEwMSAwLC0wLjI3MTQgLTAuMDc3MDkzLC0wLjUyNzkgLTAuMjE4MzU5NCwtMC43MzcgLTAuMjIwNDk0LC0wLjE2ODYgLTAuNDkyNTQ0MiwtMC4yNzI5IC0wLjc5MTU1MjcsLTAuMjcyOSB6IG0gMy4wODQzMjYxLDAgYyAtMC43MjM1NzkyLDAgLTEuMzEwMTU2MiwwLjU4NjUgLTEuMzEwMTU2MiwxLjMxMDEgMCwwLjI5OSAwLjEwNDM0MTksMC41NzExIDAuMjcyOTQ5MiwwLjc5MTYgMC4yMDkxMDI0LDAuMTQxMiAwLjQ2NTYyMDYsMC4yMTgzIDAuNzM2OTYyOSwwLjIxODMgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjUgMS4zMTAxNTYzLC0xLjMxMDEgMCwtMC4yNzE0IC0wLjA3NzA5MywtMC41Mjc5IC0wLjIxODM1OTQsLTAuNzM3IC0wLjIyMDQ5NDEsLTAuMTY4NiAtMC40OTI1NDQzLC0wLjI3MjkgLTAuNzkxNTUyOCwtMC4yNzI5IHoiLz4gIDwvZz4gIDxnICAgICBzdHlsZT0iZGlzcGxheTppbmxpbmUiPiAgICA8cGF0aCAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIiAgICAgICBkPSJtIDguMjE1NzcxNSwwLjI3Mjk0OTIyIGMgMC4xNDEyNjY3LDAuMjA5MTAyMjkgMC4yMTgzNTk0LDAuNDY1NjIwNjUgMC4yMTgzNTk0LDAuNzM2OTYyODggMCwwLjcyMzU3OTMgLTAuNTg2NTc3LDEuMzEwMTU2MyAtMS4zMTAxNTYzLDEuMzEwMTU2MyAtMC4yNzEzNDIzLDAgLTAuNTI3ODYwNSwtMC4wNzcwOTMgLTAuNzM2OTYyOSwtMC4yMTgzNTk0IDAuMjM5NDEwNCwwLjMxMzA4NTkgMC42MTI2MzYyLDAuNTE4NjAzNSAxLjAzNzIwNywwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDc2IC0wLjIwNTUxNzYsLTAuNzk3Nzk2NTkgLTAuNTE4NjAzNSwtMS4wMzcyMDY5OCB6IG0gMCwzLjA4NDMyNjE4IGMgMC4xNDEyNjY3LDAuMjA5MTAyMyAwLjIxODM1OTQsMC40NjU2MjA2IDAuMjE4MzU5NCwwLjczNjk2MjkgMCwwLjcyMzU3OTMgLTAuNTg2NTc3LDEuMzEwMTU2MiAtMS4zMTAxNTYzLDEuMzEwMTU2MiAtMC4yNzEzNDIzLDAgLTAuNTI3ODYwNSwtMC4wNzcwOTMgLTAuNzM2OTYyOSwtMC4yMTgzNTkzIDAuMjM5NDEwNCwwLjMxMzA4NTkgMC42MTI2MzYyLDAuNTE4NjAzNSAxLjAzNzIwNywwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NiwtMC43OTc3OTY3IC0wLjUxODYwMzUsLTEuMDM3MjA3IHogbSAtMy4wODQzMjYyLDAgYyAwLjE0MTI2NjcsMC4yMDkxMDIzIDAuMjE4MzU5NCwwLjQ2NTYyMDYgMC4yMTgzNTk0LDAuNzM2OTYyOSAwLDAuNzIzNTc5MyAtMC41ODY1NzcsMS4zMTAxNTYyIC0xLjMxMDE1NjMsMS4zMTAxNTYyIC0wLjI3MTM0MjIsMCAtMC41Mjc4NjA1LC0wLjA3NzA5MyAtMC43MzY5NjI5LC0wLjIxODM1OTMgMC4yMzk0MTA0LDAuMzEzMDg1OSAwLjYxMjYzNjMsMC41MTg2MDM1IDEuMDM3MjA3MSwwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYyLC0wLjU4NjU3NyAxLjMxMDE1NjIsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NSwtMC43OTc3OTY3IC0wLjUxODYwMzUsLTEuMDM3MjA3IHogTSAyLjEwMTcwOSw2LjM4NzAxMTcgYyAwLjE0MTI2NjcsMC4yMDkxMDI0IDAuMjE4MzU5NCwwLjQ2NTYyMDYgMC4yMTgzNTk0LDAuNzM2OTYyOSAwLDAuNzIzNTc5MyAtMC41ODY1NzcsMS4zMTAxNTYzIC0xLjMxMDE1NjMsMS4zMTAxNTYzIC0wLjI3MTM0MjIzLDAgLTAuNTI3ODYwNTksLTAuMDc3MDkzIC0wLjczNjk2Mjg4LC0wLjIxODM1OTQgMC4yMzk0MTAzOSwwLjMxMzA4NTkgMC42MTI2MzYyMiwwLjUxODYwMzUgMS4wMzcyMDY5OCwwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NiwtMC43OTc3OTY2IC0wLjUxODYwMzUsLTEuMDM3MjA3IHogbSAzLjAyOTczNjMsMCBjIDAuMTQxMjY2NywwLjIwOTEwMjQgMC4yMTgzNTk0LDAuNDY1NjIwNiAwLjIxODM1OTQsMC43MzY5NjI5IDAsMC43MjM1NzkzIC0wLjU4NjU3NywxLjMxMDE1NjMgLTEuMzEwMTU2MywxLjMxMDE1NjMgLTAuMjcxMzQyMiwwIC0wLjUyNzg2MDUsLTAuMDc3MDkzIC0wLjczNjk2MjksLTAuMjE4MzU5NCAwLjIzOTQxMDQsMC4zMTMwODU5IDAuNjEyNjM2MywwLjUxODYwMzUgMS4wMzcyMDcxLDAuNTE4NjAzNSAwLjcyMzU3OTMsMCAxLjMxMDE1NjIsLTAuNTg2NTc3IDEuMzEwMTU2MiwtMS4zMTAxNTYzIDAsLTAuNDI0NTcwOCAtMC4yMDU1MTc1LC0wLjc5Nzc5NjYgLTAuNTE4NjAzNSwtMS4wMzcyMDcgeiBtIDMuMDg0MzI2MiwwIGMgMC4xNDEyNjY3LDAuMjA5MTAyNCAwLjIxODM1OTQsMC40NjU2MjA2IDAuMjE4MzU5NCwwLjczNjk2MjkgMCwwLjcyMzU3OTMgLTAuNTg2NTc3LDEuMzEwMTU2MyAtMS4zMTAxNTYzLDEuMzEwMTU2MyAtMC4yNzEzNDIzLDAgLTAuNTI3ODYwNSwtMC4wNzcwOTMgLTAuNzM2OTYyOSwtMC4yMTgzNTk0IDAuMjM5NDEwNCwwLjMxMzA4NTkgMC42MTI2MzYyLDAuNTE4NjAzNSAxLjAzNzIwNywwLjUxODYwMzUgMC43MjM1NzkzLDAgMS4zMTAxNTYzLC0wLjU4NjU3NyAxLjMxMDE1NjMsLTEuMzEwMTU2MyAwLC0wLjQyNDU3MDggLTAuMjA1NTE3NiwtMC43OTc3OTY2IC0wLjUxODYwMzUsLTEuMDM3MjA3IHoiIC8+ICA8L2c+PC9zdmc+);\r\n    background-repeat: no-repeat;\r\n    background-position: 100% 100%;\r\n    pointer-events: auto !important;\r\n}\r\n.os-host-rtl > .os-scrollbar-corner.os-scrollbar-corner-resize {\r\n    -webkit-transform: scale(-1, 1);\r\n    transform: scale(-1, 1);\r\n}\r\n.os-host-overflow {\r\n    overflow: hidden !important;\r\n}\r\n.os-host-overflow-x {\r\n} \r\n.os-host-overflow-y {\r\n} \r\n\r\n/*\r\nTHEMES:\r\n*/\r\n\r\n/* NONE THEME: */\r\n.os-theme-none > .os-scrollbar-horizontal,\r\n.os-theme-none > .os-scrollbar-vertical,\r\n.os-theme-none > .os-scrollbar-corner {\r\n    display: none !important;\r\n}\r\n.os-theme-none > .os-scrollbar-corner-resize {\r\n    display: block !important;\r\n    min-width: 10px;\r\n    min-height: 10px;\r\n}\r\n/* DARK & LIGHT THEME: */\r\n.os-theme-dark > .os-scrollbar-horizontal,\r\n.os-theme-light > .os-scrollbar-horizontal {\r\n    right: 10px;\r\n    height: 10px;\r\n}\r\n.os-theme-dark > .os-scrollbar-vertical,\r\n.os-theme-light > .os-scrollbar-vertical {\r\n    bottom: 10px;\r\n    width: 10px;\r\n}\r\n.os-theme-dark.os-host-rtl > .os-scrollbar-horizontal,\r\n.os-theme-light.os-host-rtl > .os-scrollbar-horizontal {\r\n    left: 10px;\r\n    right: 0;\r\n}\r\n.os-theme-dark > .os-scrollbar-corner,\r\n.os-theme-light > .os-scrollbar-corner {\r\n    height: 10px;\r\n    width: 10px;\r\n}\r\n.os-theme-dark > .os-scrollbar-corner,\r\n.os-theme-light > .os-scrollbar-corner {\r\n    background-color: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar,\r\n.os-theme-light > .os-scrollbar {\r\n    padding: 2px;\r\n    box-sizing: border-box;\r\n    background: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar.os-scrollbar-unusable,\r\n.os-theme-light > .os-scrollbar.os-scrollbar-unusable {\r\n    background: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track,\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track {\r\n    background: transparent;\r\n}\r\n.os-theme-dark > .os-scrollbar-horizontal > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light > .os-scrollbar-horizontal > .os-scrollbar-track > .os-scrollbar-handle {\r\n    min-width: 30px;\r\n}\r\n.os-theme-dark > .os-scrollbar-vertical > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light > .os-scrollbar-vertical > .os-scrollbar-track > .os-scrollbar-handle {\r\n    min-height: 30px;\r\n}\r\n.os-theme-dark.os-host-transition > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light.os-host-transition > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle {\r\n    -webkit-transition: background-color 0.3s;\r\n    transition: background-color 0.3s;\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle,\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track,\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track {\r\n    border-radius: 10px;\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(0, 0, 0, 0.4);\r\n}\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(255, 255, 255, 0.4);\r\n}\r\n.os-theme-dark > .os-scrollbar:hover > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(0, 0, 0, .55);\r\n}\r\n.os-theme-light > .os-scrollbar:hover > .os-scrollbar-track > .os-scrollbar-handle {\r\n    background: rgba(255, 255, 255, .55);\r\n}\r\n.os-theme-dark > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle.active {\r\n    background: rgba(0, 0, 0, .7);\r\n}\r\n.os-theme-light > .os-scrollbar > .os-scrollbar-track > .os-scrollbar-handle.active {\r\n    background: rgba(255, 255, 255, .7);\r\n}\r\n.os-theme-dark > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-dark > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    content: '';\r\n    position: absolute;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    display: block;\r\n}\r\n.os-theme-dark.os-host-scrollbar-horizontal-hidden > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-dark.os-host-scrollbar-vertical-hidden > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-theme-light.os-host-scrollbar-horizontal-hidden > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-light.os-host-scrollbar-vertical-hidden > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    display: none;\r\n}\r\n.os-theme-dark > .os-scrollbar-horizontal .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-horizontal .os-scrollbar-handle:before {\r\n    top: -6px;\r\n    bottom: -2px;\r\n}\r\n.os-theme-dark > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-theme-light > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    left: -6px;\r\n    right: -2px;\r\n}\r\n.os-host-rtl.os-theme-dark > .os-scrollbar-vertical .os-scrollbar-handle:before,\r\n.os-host-rtl.os-theme-light > .os-scrollbar-vertical .os-scrollbar-handle:before {\r\n    right: -6px;\r\n    left: -2px;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/extends.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js ***!
  \**********************************************************************************/
/*! exports provided: OverlayScrollbarsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OverlayScrollbarsComponent", function() { return OverlayScrollbarsComponent; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! overlayscrollbars */ "./node_modules/overlayscrollbars/js/OverlayScrollbars.js");
/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__);



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

class OverlayScrollbarsComponent extends react__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    constructor(props) {
        super(props);
        this._osInstance = null;
        this._osTargetRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef();
    }
    osInstance() {
        return this._osInstance;
    }
    osTarget() {
        return this._osTargetRef.current || null;
    }
    componentDidMount() {
        this._osInstance = overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default()(this.osTarget(), this.props.options || {}, this.props.extensions);
        mergeHostClassNames(this._osInstance, this.props.className);
    }
    componentWillUnmount() {
        if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default.a.valid(this._osInstance)) {
            this._osInstance.destroy();
            this._osInstance = null;
        }
    }
    componentDidUpdate(prevProps) {
        if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default.a.valid(this._osInstance)) {
            this._osInstance.options(this.props.options);
            if (prevProps.className !== this.props.className) {
                mergeHostClassNames(this._osInstance, this.props.className);
            }
        }
    }
    render() {
        const _a = this.props, divProps = __rest(_a, ["options", "extensions", "children", "className"]);
        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", Object.assign({ className: "os-host" }, divProps, { ref: this._osTargetRef }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-resize-observer-host" }),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-padding" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-viewport" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-content" }, this.props.children))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-scrollbar os-scrollbar-horizontal " },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-scrollbar-track" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-scrollbar-handle" }))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-scrollbar os-scrollbar-vertical" },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-scrollbar-track" },
                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-scrollbar-handle" }))),
            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: "os-scrollbar-corner" })));
    }
}
function mergeHostClassNames(osInstance, className) {
    if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default.a.valid(osInstance)) {
        const { host } = osInstance.getElements();
        const regex = new RegExp(`(^os-host([-_].+|)$)|${osInstance.options().className.replace(/\s/g, "$|")}$`, 'g');
        const osClassNames = host.className.split(' ')
            .filter(name => name.match(regex))
            .join(' ');
        host.className = `${osClassNames} ${className || ''}`;
    }
}


//# sourceMappingURL=overlayscrollbars-react.esm.js.map


/***/ }),

/***/ "./node_modules/overlayscrollbars/css/OverlayScrollbars.css":
/*!******************************************************************!*\
  !*** ./node_modules/overlayscrollbars/css/OverlayScrollbars.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-5-1!../../next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-5-2!./OverlayScrollbars.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/overlayscrollbars/css/OverlayScrollbars.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-5-1!../../next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-5-2!./OverlayScrollbars.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/overlayscrollbars/css/OverlayScrollbars.css",
      function () {
        content = __webpack_require__(/*! !../../next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-5-1!../../next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-5-2!./OverlayScrollbars.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/overlayscrollbars/css/OverlayScrollbars.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/overlayscrollbars/js/OverlayScrollbars.js":
/*!****************************************************************!*\
  !*** ./node_modules/overlayscrollbars/js/OverlayScrollbars.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.0
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 02.08.2020
 */

(function (global, factory) {
    if (true)
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return factory(global, global.document, undefined); }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    else {}
}(typeof window !== 'undefined' ? window : this,
    function (window, document, undefined) {
        'use strict';
        var PLUGINNAME = 'OverlayScrollbars';
        var TYPES = {
            o: 'object',
            f: 'function',
            a: 'array',
            s: 'string',
            b: 'boolean',
            n: 'number',
            u: 'undefined',
            z: 'null'
            //d : 'date',
            //e : 'error',
            //r : 'regexp',
            //y : 'symbol'
        };
        var LEXICON = {
            c: 'class',
            s: 'style',
            i: 'id',
            l: 'length',
            p: 'prototype',
            ti: 'tabindex',
            oH: 'offsetHeight',
            cH: 'clientHeight',
            sH: 'scrollHeight',
            oW: 'offsetWidth',
            cW: 'clientWidth',
            sW: 'scrollWidth',
            hOP: 'hasOwnProperty',
            bCR: 'getBoundingClientRect'
        };
        var VENDORS = (function () {
            //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
            var jsCache = {};
            var cssCache = {};
            var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];
            var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];
            function firstLetterToUpper(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }

            return {
                _cssPrefixes: cssPrefixes,
                _jsPrefixes: jsPrefixes,
                _cssProperty: function (name) {
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var uppercasedName = firstLetterToUpper(name);
                    var elmStyle = document.createElement('div')[LEXICON.s];
                    var resultPossibilities;
                    var i = 0;
                    var v;
                    var currVendorWithoutDashes;

                    for (; i < cssPrefixes.length; i++) {
                        currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');
                        resultPossibilities = [
                            name, //transition
                            cssPrefixes[i] + name, //-webkit-transition
                            currVendorWithoutDashes + uppercasedName, //webkitTransition
                            firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition
                        ];
                        for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
                            if (elmStyle[resultPossibilities[v]] !== undefined) {
                                result = resultPossibilities[v];
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _cssPropertyValue: function (property, values, suffix) {
                    var name = property + ' ' + values;
                    var result = cssCache[name];

                    if (cssCache[LEXICON.hOP](name))
                        return result;

                    var dummyStyle = document.createElement('div')[LEXICON.s];
                    var possbleValues = values.split(' ');
                    var preparedSuffix = suffix || '';
                    var i = 0;
                    var v = -1;
                    var prop;

                    for (; i < possbleValues[LEXICON.l]; i++) {
                        for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
                            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
                            dummyStyle.cssText = property + ':' + prop + preparedSuffix;
                            if (dummyStyle[LEXICON.l]) {
                                result = prop;
                                break;
                            }
                        }
                    }

                    cssCache[name] = result;
                    return result;
                },
                _jsAPI: function (name, isInterface, fallback) {
                    var i = 0;
                    var result = jsCache[name];

                    if (!jsCache[LEXICON.hOP](name)) {
                        result = window[name];
                        for (; i < jsPrefixes[LEXICON.l]; i++)
                            result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];
                        jsCache[name] = result;
                    }
                    return result || fallback;
                }
            }
        })();
        var COMPATIBILITY = (function () {
            function windowSize(x) {
                return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
            }
            function bind(func, thisObj) {
                if (typeof func != TYPES.f) {
                    throw "Can't bind function!";
                    // closest thing possible to the ECMAScript 5
                    // internal IsCallable function
                    //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                }
                var proto = LEXICON.p;
                var aArgs = Array[proto].slice.call(arguments, 2);
                var fNOP = function () { };
                var fBound = function () { return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments))); };

                if (func[proto])
                    fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property
                fBound[proto] = new fNOP();

                return fBound;
            }

            return {
                /**
                 * Gets the current window width.
                 * @returns {Number|number} The current window width in pixel.
                 */
                wW: bind(windowSize, 0, true),

                /**
                 * Gets the current window height.
                 * @returns {Number|number} The current window height in pixel.
                 */
                wH: bind(windowSize, 0),

                /**
                 * Gets the MutationObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
                 */
                mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),

                /**
                 * Gets the ResizeObserver Object or undefined if not supported.
                 * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
                 */
                rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),

                /**
                 * Gets the RequestAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
                 */
                rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) { return window.setTimeout(func, 1000 / 60); }),

                /**
                 * Gets the CancelAnimationFrame method or it's corresponding polyfill.
                 * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
                 */
                cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),

                /**
                 * Gets the current time.
                 * @returns {number} The current time.
                 */
                now: function () {
                    return Date.now && Date.now() || new Date().getTime();
                },

                /**
                 * Stops the propagation of the given event.
                 * @param event The event of which the propagation shall be stoped.
                 */
                stpP: function (event) {
                    if (event.stopPropagation)
                        event.stopPropagation();
                    else
                        event.cancelBubble = true;
                },

                /**
                 * Prevents the default action of the given event.
                 * @param event The event of which the default action shall be prevented.
                 */
                prvD: function (event) {
                    if (event.preventDefault && event.cancelable)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                },

                /**
                 * Gets the pageX and pageY values of the given mouse event.
                 * @param event The mouse event of which the pageX and pageX shall be got.
                 * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
                 */
                page: function (event) {
                    event = event.originalEvent || event;

                    var strPage = 'page';
                    var strClient = 'client';
                    var strX = 'X';
                    var strY = 'Y';
                    var target = event.target || event.srcElement || document;
                    var eventDoc = target.ownerDocument || document;
                    var doc = eventDoc.documentElement;
                    var body = eventDoc.body;

                    //if touch event return return pageX/Y of it
                    if (event.touches !== undefined) {
                        var touch = event.touches[0];
                        return {
                            x: touch[strPage + strX],
                            y: touch[strPage + strY]
                        }
                    }

                    // Calculate pageX/Y if not native supported
                    if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {

                        return {
                            x: event[strClient + strX] +
                                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                                (doc && doc.clientLeft || body && body.clientLeft || 0),
                            y: event[strClient + strY] +
                                (doc && doc.scrollTop || body && body.scrollTop || 0) -
                                (doc && doc.clientTop || body && body.clientTop || 0)
                        }
                    }
                    return {
                        x: event[strPage + strX],
                        y: event[strPage + strY]
                    };
                },

                /**
                 * Gets the clicked mouse button of the given mouse event.
                 * @param event The mouse event of which the clicked button shal be got.
                 * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
                 */
                mBtn: function (event) {
                    var button = event.button;
                    if (!event.which && button !== undefined)
                        return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                    else
                        return event.which;
                },

                /**
                 * Checks whether a item is in the given array and returns its index.
                 * @param item The item of which the position in the array shall be determined.
                 * @param arr The array.
                 * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
                 */
                inA: function (item, arr) {
                    for (var i = 0; i < arr[LEXICON.l]; i++)
                        //Sometiems in IE a "SCRIPT70" Permission denied error occurs if HTML elements in a iFrame are compared
                        try {
                            if (arr[i] === item)
                                return i;
                        }
                        catch (e) { }
                    return -1;
                },

                /**
                 * Returns true if the given value is a array.
                 * @param arr The potential array.
                 * @returns {boolean} True if the given value is a array, false otherwise.
                 */
                isA: function (arr) {
                    var def = Array.isArray;
                    return def ? def(arr) : this.type(arr) == TYPES.a;
                },

                /**
                 * Determine the internal JavaScript [[Class]] of the given object.
                 * @param obj The object of which the type shall be determined.
                 * @returns {string} The type of the given object.
                 */
                type: function (obj) {
                    if (obj === undefined)
                        return obj + '';
                    if (obj === null)
                        return obj + '';
                    return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
                },


                bind: bind

                /**
                 * Gets the vendor-prefixed CSS property by the given name.
                 * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
                 * @param propName The unprefixed CSS property name.
                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.

                cssProp: function(propName) {
                    return VENDORS._cssProperty(propName);
                }
                */
            }
        })();


        var MATH = Math;
        var JQUERY = window.jQuery;
        var EASING = (function () {
            var _easingsMath = {
                p: MATH.PI,
                c: MATH.cos,
                s: MATH.sin,
                w: MATH.pow,
                t: MATH.sqrt,
                n: MATH.asin,
                a: MATH.abs,
                o: 1.70158
            };

            /*
             x : current percent (0 - 1),
             t : current time (duration * percent),
             b : start value (from),
             c : end value (to),
             d : duration

             easingName : function(x, t, b, c, d) { return easedValue; }
             */

            return {
                swing: function (x, t, b, c, d) {
                    return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
                },
                linear: function (x, t, b, c, d) {
                    return x;
                },
                easeInQuad: function (x, t, b, c, d) {
                    return c * (t /= d) * t + b;
                },
                easeOutQuad: function (x, t, b, c, d) {
                    return -c * (t /= d) * (t - 2) + b;
                },
                easeInOutQuad: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t + b : -c / 2 * ((--t) * (t - 2) - 1) + b;
                },
                easeInCubic: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t + b;
                },
                easeOutCubic: function (x, t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t + 1) + b;
                },
                easeInOutCubic: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
                },
                easeInQuart: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t * t + b;
                },
                easeOutQuart: function (x, t, b, c, d) {
                    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
                },
                easeInOutQuart: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
                },
                easeInQuint: function (x, t, b, c, d) {
                    return c * (t /= d) * t * t * t * t + b;
                },
                easeOutQuint: function (x, t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
                },
                easeInOutQuint: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
                },
                easeInSine: function (x, t, b, c, d) {
                    return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
                },
                easeOutSine: function (x, t, b, c, d) {
                    return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
                },
                easeInOutSine: function (x, t, b, c, d) {
                    return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
                },
                easeInExpo: function (x, t, b, c, d) {
                    return (t == 0) ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
                },
                easeOutExpo: function (x, t, b, c, d) {
                    return (t == d) ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
                },
                easeInOutExpo: function (x, t, b, c, d) {
                    if (t == 0) return b;
                    if (t == d) return b + c;
                    if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;
                    return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
                },
                easeInCirc: function (x, t, b, c, d) {
                    return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
                },
                easeOutCirc: function (x, t, b, c, d) {
                    return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
                },
                easeInOutCirc: function (x, t, b, c, d) {
                    return ((t /= d / 2) < 1) ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
                },
                easeInElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3;
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
                },
                easeOutElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b;
                    if ((t /= d) == 1) return b + c;
                    if (!p) p = d * .3;
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;
                },
                easeInOutElastic: function (x, t, b, c, d) {
                    var s = _easingsMath.o; var p = 0; var a = c;
                    if (t == 0) return b;
                    if ((t /= d / 2) == 2) return b + c;
                    if (!p) p = d * (.3 * 1.5);
                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }
                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);
                    if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
                    return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;
                },
                easeInBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return c * (t /= d) * t * ((s + 1) * t - s) + b;
                },
                easeOutBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
                },
                easeInOutBack: function (x, t, b, c, d, s) {
                    s = s || _easingsMath.o;
                    return ((t /= d / 2) < 1) ? c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
                },
                easeInBounce: function (x, t, b, c, d) {
                    return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
                },
                easeOutBounce: function (x, t, b, c, d) {
                    var o = 7.5625;
                    if ((t /= d) < (1 / 2.75)) {
                        return c * (o * t * t) + b;
                    } else if (t < (2 / 2.75)) {
                        return c * (o * (t -= (1.5 / 2.75)) * t + .75) + b;
                    } else if (t < (2.5 / 2.75)) {
                        return c * (o * (t -= (2.25 / 2.75)) * t + .9375) + b;
                    } else {
                        return c * (o * (t -= (2.625 / 2.75)) * t + .984375) + b;
                    }
                },
                easeInOutBounce: function (x, t, b, c, d) {
                    return (t < d / 2) ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;
                }
            };
            /*
             *
             * TERMS OF USE - EASING EQUATIONS
             * 
             * Open source under the BSD License. 
             * 
             * Copyright  2001 Robert Penner
             * All rights reserved.
             * 
             * Redistribution and use in source and binary forms, with or without modification, 
             * are permitted provided that the following conditions are met:
             * 
             * Redistributions of source code must retain the above copyright notice, this list of 
             * conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice, this list 
             * of conditions and the following disclaimer in the documentation and/or other materials 
             * provided with the distribution.
             * 
             * Neither the name of the author nor the names of contributors may be used to endorse 
             * or promote products derived from this software without specific prior written permission.
             * 
             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
             * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
             * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
             *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
             *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
             *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
             * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
             *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
             * OF THE POSSIBILITY OF SUCH DAMAGE. 
             *
             */
        })();
        var FRAMEWORK = (function () {
            var _rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
            var _strSpace = ' ';
            var _strEmpty = '';
            var _strScrollLeft = 'scrollLeft';
            var _strScrollTop = 'scrollTop';
            var _animations = [];
            var _type = COMPATIBILITY.type;
            var _cssNumber = {
                animationIterationCount: true,
                columnCount: true,
                fillOpacity: true,
                flexGrow: true,
                flexShrink: true,
                fontWeight: true,
                lineHeight: true,
                opacity: true,
                order: true,
                orphans: true,
                widows: true,
                zIndex: true,
                zoom: true
            };

            function extend() {
                var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},
                    i = 1,
                    length = arguments[LEXICON.l],
                    deep = false;

                // Handle a deep copy situation
                if (_type(target) == TYPES.b) {
                    deep = target;
                    target = arguments[1] || {};
                    // skip the boolean and the target
                    i = 2;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {
                    target = {};
                }

                // extend jQuery itself if only one argument is passed
                if (length === i) {
                    target = FakejQuery;
                    --i;
                }

                for (; i < length; i++) {
                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {
                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && COMPATIBILITY.isA(src) ? src : [];

                                } else {
                                    clone = src && isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            function inArray(item, arr, fromIndex) {
                for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)
                    if (arr[i] === item)
                        return i;
                return -1;
            }

            function isFunction(obj) {
                return _type(obj) == TYPES.f;
            };

            function isEmptyObject(obj) {
                for (var name in obj)
                    return false;
                return true;
            };

            function isPlainObject(obj) {
                if (!obj || _type(obj) != TYPES.o)
                    return false;

                var key;
                var proto = LEXICON.p;
                var hasOwnProperty = Object[proto].hasOwnProperty;
                var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');
                var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');

                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                    return false;
                }


                for (key in obj) { /**/ }

                return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
            };

            function each(obj, callback) {
                var i = 0;

                if (isArrayLike(obj)) {
                    for (; i < obj[LEXICON.l]; i++) {
                        if (callback.call(obj[i], i, obj[i]) === false)
                            break;
                    }
                }
                else {
                    for (i in obj) {
                        if (callback.call(obj[i], i, obj[i]) === false)
                            break;
                    }
                }

                return obj;
            };

            function isArrayLike(obj) {
                var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];
                var t = _type(obj);
                return isFunction(t) ? false : (t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && (length - 1) in obj);
            }

            function stripAndCollapse(value) {
                var tokens = value.match(_rnothtmlwhite) || [];
                return tokens.join(_strSpace);
            }

            function matches(elem, selector) {
                var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];
                var i = nodeList[LEXICON.l];

                while (i--)
                    if (nodeList[i] == elem)
                        return true;

                return false;
            }

            function insertAdjacentElement(el, strategy, child) {
                if (COMPATIBILITY.isA(child)) {
                    for (var i = 0; i < child[LEXICON.l]; i++)
                        insertAdjacentElement(el, strategy, child[i]);
                }
                else if (_type(child) == TYPES.s)
                    el.insertAdjacentHTML(strategy, child);
                else
                    el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
            }

            function setCSSVal(el, prop, val) {
                try {
                    if (el[LEXICON.s][prop] !== undefined)
                        el[LEXICON.s][prop] = parseCSSVal(prop, val);
                } catch (e) { }
            }

            function parseCSSVal(prop, val) {
                if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)
                    val += 'px';
                return val;
            }

            function startNextAnimationInQ(animObj, removeFromQ) {
                var index;
                var nextAnim;
                if (removeFromQ !== false)
                    animObj.q.splice(0, 1);
                if (animObj.q[LEXICON.l] > 0) {
                    nextAnim = animObj.q[0];
                    animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
                }
                else {
                    index = inArray(animObj, _animations);
                    if (index > -1)
                        _animations.splice(index, 1);
                }
            }

            function setAnimationValue(el, prop, value) {
                if (prop === _strScrollLeft || prop === _strScrollTop)
                    el[prop] = value;
                else
                    setCSSVal(el, prop, value);
            }

            function animate(el, props, options, easing, complete, guaranteedNext) {
                var hasOptions = isPlainObject(options);
                var from = {};
                var to = {};
                var i = 0;
                var key;
                var animObj;
                var start;
                var progress;
                var step;
                var specialEasing;
                var duration;
                if (hasOptions) {
                    easing = options.easing;
                    start = options.start;
                    progress = options.progress;
                    step = options.step;
                    specialEasing = options.specialEasing;
                    complete = options.complete;
                    duration = options.duration;
                }
                else
                    duration = options;
                specialEasing = specialEasing || {};
                duration = duration || 400;
                easing = easing || 'swing';
                guaranteedNext = guaranteedNext || false;

                for (; i < _animations[LEXICON.l]; i++) {
                    if (_animations[i].el === el) {
                        animObj = _animations[i];
                        break;
                    }
                }

                if (!animObj) {
                    animObj = {
                        el: el,
                        q: []
                    };
                    _animations.push(animObj);
                }

                for (key in props) {
                    if (key === _strScrollLeft || key === _strScrollTop)
                        from[key] = el[key];
                    else
                        from[key] = FakejQuery(el).css(key);
                }

                for (key in from) {
                    if (from[key] !== props[key] && props[key] !== undefined)
                        to[key] = props[key];
                }

                if (!isEmptyObject(to)) {
                    var timeNow;
                    var end;
                    var percent;
                    var fromVal;
                    var toVal;
                    var easedVal;
                    var timeStart;
                    var frame;
                    var elapsed;
                    var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
                    var qObj = {
                        props: to,
                        duration: hasOptions ? options : duration,
                        easing: easing,
                        complete: complete
                    };
                    if (qPos === -1) {
                        qPos = animObj.q[LEXICON.l];
                        animObj.q.push(qObj);
                    }

                    if (qPos === 0) {
                        if (duration > 0) {
                            timeStart = COMPATIBILITY.now();
                            frame = function () {
                                timeNow = COMPATIBILITY.now();
                                elapsed = (timeNow - timeStart);
                                end = qObj.stop || elapsed >= duration;
                                percent = 1 - ((MATH.max(0, timeStart + duration - timeNow) / duration) || 0);

                                for (key in to) {
                                    fromVal = parseFloat(from[key]);
                                    toVal = parseFloat(to[key]);
                                    easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;
                                    setAnimationValue(el, key, easedVal);
                                    if (isFunction(step)) {
                                        step(easedVal, {
                                            elem: el,
                                            prop: key,
                                            start: fromVal,
                                            now: easedVal,
                                            end: toVal,
                                            pos: percent,
                                            options: {
                                                easing: easing,
                                                speacialEasing: specialEasing,
                                                duration: duration,
                                                complete: complete,
                                                step: step
                                            },
                                            startTime: timeStart
                                        });
                                    }
                                }

                                if (isFunction(progress))
                                    progress({}, percent, MATH.max(0, duration - elapsed));

                                if (end) {
                                    startNextAnimationInQ(animObj);
                                    if (isFunction(complete))
                                        complete();
                                }
                                else
                                    qObj.frame = COMPATIBILITY.rAF()(frame);
                            };
                            qObj.frame = COMPATIBILITY.rAF()(frame);
                        }
                        else {
                            for (key in to)
                                setAnimationValue(el, key, to[key]);
                            startNextAnimationInQ(animObj);
                        }
                    }
                }
                else if (guaranteedNext)
                    startNextAnimationInQ(animObj);
            }

            function stop(el, clearQ, jumpToEnd) {
                var animObj;
                var qObj;
                var key;
                var i = 0;
                for (; i < _animations[LEXICON.l]; i++) {
                    animObj = _animations[i];
                    if (animObj.el === el) {
                        if (animObj.q[LEXICON.l] > 0) {
                            qObj = animObj.q[0];
                            qObj.stop = true;
                            COMPATIBILITY.cAF()(qObj.frame);
                            animObj.q.splice(0, 1);

                            if (jumpToEnd)
                                for (key in qObj.props)
                                    setAnimationValue(el, key, qObj.props[key]);

                            if (clearQ)
                                animObj.q = [];
                            else
                                startNextAnimationInQ(animObj, false);
                        }
                        break;
                    }
                }
            }

            function elementIsVisible(el) {
                return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
            }

            function FakejQuery(selector) {
                if (arguments[LEXICON.l] === 0)
                    return this;

                var base = new FakejQuery();
                var elements = selector;
                var i = 0;
                var elms;
                var el;

                if (_type(selector) == TYPES.s) {
                    elements = [];
                    if (selector.charAt(0) === '<') {
                        el = document.createElement('div');
                        el.innerHTML = selector;
                        elms = el.children;
                    }
                    else {
                        elms = document.querySelectorAll(selector);
                    }

                    for (; i < elms[LEXICON.l]; i++)
                        elements.push(elms[i]);
                }

                if (elements) {
                    if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self))
                        elements = [elements];

                    for (i = 0; i < elements[LEXICON.l]; i++)
                        base[i] = elements[i];

                    base[LEXICON.l] = elements[LEXICON.l];
                }

                return base;
            };

            FakejQuery[LEXICON.p] = {

                //EVENTS:

                on: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                    var eventNameLength = eventName[LEXICON.l];
                    var i = 0;
                    var el;
                    return this.each(function () {
                        el = this;
                        try {
                            if (el.addEventListener) {
                                for (; i < eventNameLength; i++)
                                    el.addEventListener(eventName[i], handler);
                            }
                            else if (el.detachEvent) {
                                for (; i < eventNameLength; i++)
                                    el.attachEvent('on' + eventName[i], handler);
                            }
                        } catch (e) { }
                    });
                },

                off: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];

                    var eventNameLength = eventName[LEXICON.l];
                    var i = 0;
                    var el;
                    return this.each(function () {
                        el = this;
                        try {
                            if (el.removeEventListener) {
                                for (; i < eventNameLength; i++)
                                    el.removeEventListener(eventName[i], handler);
                            }
                            else if (el.detachEvent) {
                                for (; i < eventNameLength; i++)
                                    el.detachEvent('on' + eventName[i], handler);
                            }
                        } catch (e) { }
                    });
                },

                one: function (eventName, handler) {
                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
                    return this.each(function () {
                        var el = FakejQuery(this);
                        FakejQuery.each(eventName, function (i, oneEventName) {
                            var oneHandler = function (e) {
                                handler.call(this, e);
                                el.off(oneEventName, oneHandler);
                            };
                            el.on(oneEventName, oneHandler);
                        });
                    });
                },

                trigger: function (eventName) {
                    var el;
                    var event;
                    return this.each(function () {
                        el = this;
                        if (document.createEvent) {
                            event = document.createEvent('HTMLEvents');
                            event.initEvent(eventName, true, false);
                            el.dispatchEvent(event);
                        }
                        else {
                            el.fireEvent('on' + eventName);
                        }
                    });
                },

                //DOM NODE INSERTING / REMOVING:

                append: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'beforeend', child); });
                },

                prepend: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'afterbegin', child); });
                },

                before: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'beforebegin', child); });
                },

                after: function (child) {
                    return this.each(function () { insertAdjacentElement(this, 'afterend', child); });
                },

                remove: function () {
                    return this.each(function () {
                        var el = this;
                        var parentNode = el.parentNode;
                        if (parentNode != null)
                            parentNode.removeChild(el);
                    });
                },

                unwrap: function () {
                    var parents = [];
                    var i;
                    var el;
                    var parent;

                    this.each(function () {
                        parent = this.parentNode;
                        if (inArray(parent, parents) === - 1)
                            parents.push(parent);
                    });

                    for (i = 0; i < parents[LEXICON.l]; i++) {
                        el = parents[i];
                        parent = el.parentNode;
                        while (el.firstChild)
                            parent.insertBefore(el.firstChild, el);
                        parent.removeChild(el);
                    }

                    return this;
                },

                wrapAll: function (wrapperHTML) {
                    var i;
                    var nodes = this;
                    var wrapper = FakejQuery(wrapperHTML)[0];
                    var deepest = wrapper;
                    var parent = nodes[0].parentNode;
                    var previousSibling = nodes[0].previousSibling;
                    while (deepest.childNodes[LEXICON.l] > 0)
                        deepest = deepest.childNodes[0];

                    for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)
                        deepest.appendChild(nodes[i]);

                    var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
                    parent.insertBefore(wrapper, nextSibling);

                    return this;
                },

                wrapInner: function (wrapperHTML) {
                    return this.each(function () {
                        var el = FakejQuery(this);
                        var contents = el.contents();

                        if (contents[LEXICON.l])
                            contents.wrapAll(wrapperHTML);
                        else
                            el.append(wrapperHTML);
                    });
                },

                wrap: function (wrapperHTML) {
                    return this.each(function () { FakejQuery(this).wrapAll(wrapperHTML); });
                },


                //DOM NODE MANIPULATION / INFORMATION:

                css: function (styles, val) {
                    var el;
                    var key;
                    var cptStyle;
                    var getCptStyle = window.getComputedStyle;
                    if (_type(styles) == TYPES.s) {
                        if (val === undefined) {
                            el = this[0];
                            cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];

                            //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)
                            return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;
                        }
                        else {
                            return this.each(function () {
                                setCSSVal(this, styles, val);
                            });
                        }
                    }
                    else {
                        return this.each(function () {
                            for (key in styles)
                                setCSSVal(this, key, styles[key]);
                        });
                    }
                },

                hasClass: function (className) {
                    var elem, i = 0;
                    var classNamePrepared = _strSpace + className + _strSpace;
                    var classList;

                    while ((elem = this[i++])) {
                        classList = elem.classList;
                        if (classList && classList.contains(className))
                            return true;
                        else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)
                            return true;
                    }

                    return false;
                },

                addClass: function (className) {
                    var classes;
                    var elem;
                    var cur;
                    var curValue;
                    var clazz;
                    var finalValue;
                    var supportClassList;
                    var elmClassList;
                    var i = 0;
                    var v = 0;

                    if (className) {
                        classes = className.match(_rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            elmClassList = elem.classList;
                            if (supportClassList === undefined)
                                supportClassList = elmClassList !== undefined;

                            if (supportClassList) {
                                while ((clazz = classes[v++]))
                                    elmClassList.add(clazz);
                            }
                            else {
                                curValue = elem.className + _strEmpty;
                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                                if (cur) {
                                    while ((clazz = classes[v++]))
                                        if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)
                                            cur += clazz + _strSpace;

                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue)
                                        elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function (className) {
                    var classes;
                    var elem;
                    var cur;
                    var curValue;
                    var clazz;
                    var finalValue;
                    var supportClassList;
                    var elmClassList;
                    var i = 0;
                    var v = 0;

                    if (className) {
                        classes = className.match(_rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            elmClassList = elem.classList;
                            if (supportClassList === undefined)
                                supportClassList = elmClassList !== undefined;

                            if (supportClassList) {
                                while ((clazz = classes[v++]))
                                    elmClassList.remove(clazz);
                            }
                            else {
                                curValue = elem.className + _strEmpty;
                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);

                                if (cur) {
                                    while ((clazz = classes[v++]))
                                        while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)
                                            cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);

                                    finalValue = stripAndCollapse(cur);
                                    if (curValue !== finalValue)
                                        elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                hide: function () {
                    return this.each(function () { this[LEXICON.s].display = 'none'; });
                },

                show: function () {
                    return this.each(function () { this[LEXICON.s].display = 'block'; });
                },

                attr: function (attrName, value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el.getAttribute(attrName);
                        el.setAttribute(attrName, value);
                    }
                    return this;
                },

                removeAttr: function (attrName) {
                    return this.each(function () { this.removeAttribute(attrName); });
                },

                offset: function () {
                    var el = this[0];
                    var rect = el[LEXICON.bCR]();
                    var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];
                    var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];
                    return {
                        top: rect.top + scrollTop,
                        left: rect.left + scrollLeft
                    };
                },

                position: function () {
                    var el = this[0];
                    return {
                        top: el.offsetTop,
                        left: el.offsetLeft
                    };
                },

                scrollLeft: function (value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el[_strScrollLeft];
                        el[_strScrollLeft] = value;
                    }
                    return this;
                },

                scrollTop: function (value) {
                    var i = 0;
                    var el;
                    while (el = this[i++]) {
                        if (value === undefined)
                            return el[_strScrollTop];
                        el[_strScrollTop] = value;
                    }
                    return this;
                },

                val: function (value) {
                    var el = this[0];
                    if (!value)
                        return el.value;
                    el.value = value;
                    return this;
                },


                //DOM TRAVERSAL / FILTERING:

                first: function () {
                    return this.eq(0);
                },

                last: function () {
                    return this.eq(-1);
                },

                eq: function (index) {
                    return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);
                },

                find: function (selector) {
                    var children = [];
                    var i;
                    this.each(function () {
                        var el = this;
                        var ch = el.querySelectorAll(selector);
                        for (i = 0; i < ch[LEXICON.l]; i++)
                            children.push(ch[i]);
                    });
                    return FakejQuery(children);
                },

                children: function (selector) {
                    var children = [];
                    var el;
                    var ch;
                    var i;

                    this.each(function () {
                        ch = this.children;
                        for (i = 0; i < ch[LEXICON.l]; i++) {
                            el = ch[i];
                            if (selector) {
                                if ((el.matches && el.matches(selector)) || matches(el, selector))
                                    children.push(el);
                            }
                            else
                                children.push(el);
                        }
                    });
                    return FakejQuery(children);
                },

                parent: function (selector) {
                    var parents = [];
                    var parent;
                    this.each(function () {
                        parent = this.parentNode;
                        if (selector ? FakejQuery(parent).is(selector) : true)
                            parents.push(parent);
                    });
                    return FakejQuery(parents);
                },

                is: function (selector) {

                    var el;
                    var i;
                    for (i = 0; i < this[LEXICON.l]; i++) {
                        el = this[i];
                        if (selector === ':visible')
                            return elementIsVisible(el);
                        if (selector === ':hidden')
                            return !elementIsVisible(el);
                        if ((el.matches && el.matches(selector)) || matches(el, selector))
                            return true;
                    }
                    return false;
                },

                contents: function () {
                    var contents = [];
                    var childs;
                    var i;

                    this.each(function () {
                        childs = this.childNodes;
                        for (i = 0; i < childs[LEXICON.l]; i++)
                            contents.push(childs[i]);
                    });

                    return FakejQuery(contents);
                },

                each: function (callback) {
                    return each(this, callback);
                },


                //ANIMATION:

                animate: function (props, duration, easing, complete) {
                    return this.each(function () { animate(this, props, duration, easing, complete); });
                },

                stop: function (clearQ, jump) {
                    return this.each(function () { stop(this, clearQ, jump); });
                }
            };

            extend(FakejQuery, {
                extend: extend,
                inArray: inArray,
                isEmptyObject: isEmptyObject,
                isPlainObject: isPlainObject,
                each: each
            });

            return FakejQuery;
        })();
        var INSTANCES = (function () {
            var _targets = [];
            var _instancePropertyString = '__overlayScrollbars__';

            /**
             * Register, unregister or get a certain (or all) instances.
             * Register: Pass the target and the instance.
             * Unregister: Pass the target and null.
             * Get Instance: Pass the target from which the instance shall be got.
             * Get Targets: Pass no arguments.
             * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got
             * @param instance The instance.
             * @returns {*|void} Returns the instance from the given target.
             */
            return function (target, instance) {
                var argLen = arguments[LEXICON.l];
                if (argLen < 1) {
                    //return all targets
                    return _targets;
                }
                else {
                    if (instance) {
                        //register instance
                        target[_instancePropertyString] = instance;
                        _targets.push(target);
                    }
                    else {
                        var index = COMPATIBILITY.inA(target, _targets);
                        if (index > -1) {
                            if (argLen > 1) {
                                //unregister instance
                                delete target[_instancePropertyString];
                                _targets.splice(index, 1);
                            }
                            else {
                                //get instance from target
                                return _targets[index][_instancePropertyString];
                            }
                        }
                    }
                }
            }
        })();
        var PLUGIN = (function () {
            var _plugin;
            var _pluginsGlobals;
            var _pluginsAutoUpdateLoop;
            var _pluginsExtensions = [];
            var _pluginsOptions = (function () {
                var type = COMPATIBILITY.type;
                var possibleTemplateTypes = [
                    TYPES.b, //boolean
                    TYPES.n, //number
                    TYPES.s, //string
                    TYPES.a, //array
                    TYPES.o, //object
                    TYPES.f, //function
                    TYPES.z  //null
                ];
                var restrictedStringsSplit = ' ';
                var restrictedStringsPossibilitiesSplit = ':';
                var classNameAllowedValues = [TYPES.z, TYPES.s];
                var numberAllowedValues = TYPES.n;
                var booleanNullAllowedValues = [TYPES.z, TYPES.b];
                var booleanTrueTemplate = [true, TYPES.b];
                var booleanFalseTemplate = [false, TYPES.b];
                var callbackTemplate = [null, [TYPES.z, TYPES.f]];
                var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];
                var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];
                var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';
                var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';
                var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';
                var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';
                var optionsDefaultsAndTemplate = {
                    className: ['os-theme-dark', classNameAllowedValues],                //null || string
                    resize: ['none', resizeAllowedValues],                               //none || both  || horizontal || vertical || n || b || h || v
                    sizeAutoCapable: booleanTrueTemplate,                                //true || false
                    clipAlways: booleanTrueTemplate,                                     //true || false
                    normalizeRTL: booleanTrueTemplate,                                   //true || false
                    paddingAbsolute: booleanFalseTemplate,                               //true || false
                    autoUpdate: [null, booleanNullAllowedValues],                        //true || false || null
                    autoUpdateInterval: [33, numberAllowedValues],                       //number
                    updateOnLoad: updateOnLoadTemplate,                                  //string || array || null
                    nativeScrollbarsOverlaid: {
                        showNativeScrollbars: booleanFalseTemplate,                      //true || false
                        initialize: booleanTrueTemplate                                  //true || false
                    },
                    overflowBehavior: {
                        x: ['scroll', overflowBehaviorAllowedValues],                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                        y: ['scroll', overflowBehaviorAllowedValues]                     //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
                    },
                    scrollbars: {
                        visibility: ['auto', scrollbarsVisibilityAllowedValues],         //visible || hidden || auto || v || h || a
                        autoHide: ['never', scrollbarsAutoHideAllowedValues],            //never || scroll || leave || move || n || s || l || m
                        autoHideDelay: [800, numberAllowedValues],                       //number
                        dragScrolling: booleanTrueTemplate,                              //true || false
                        clickScrolling: booleanFalseTemplate,                            //true || false
                        touchSupport: booleanTrueTemplate,                               //true || false
                        snapHandle: booleanFalseTemplate                                 //true || false
                    },
                    textarea: {
                        dynWidth: booleanFalseTemplate,                                  //true || false
                        dynHeight: booleanFalseTemplate,                                 //true || false
                        inheritedAttrs: inheritedAttrsTemplate                           //string || array || null
                    },
                    callbacks: {
                        onInitialized: callbackTemplate,                                 //null || function
                        onInitializationWithdrawn: callbackTemplate,                     //null || function
                        onDestroyed: callbackTemplate,                                   //null || function
                        onScrollStart: callbackTemplate,                                 //null || function
                        onScroll: callbackTemplate,                                      //null || function
                        onScrollStop: callbackTemplate,                                  //null || function
                        onOverflowChanged: callbackTemplate,                             //null || function
                        onOverflowAmountChanged: callbackTemplate,                       //null || function
                        onDirectionChanged: callbackTemplate,                            //null || function
                        onContentSizeChanged: callbackTemplate,                          //null || function
                        onHostSizeChanged: callbackTemplate,                             //null || function
                        onUpdated: callbackTemplate                                      //null || function
                    }
                };
                var convert = function (template) {
                    var recursive = function (obj) {
                        var key;
                        var val;
                        var valType;
                        for (key in obj) {
                            if (!obj[LEXICON.hOP](key))
                                continue;
                            val = obj[key];
                            valType = type(val);
                            if (valType == TYPES.a)
                                obj[key] = val[template ? 1 : 0];
                            else if (valType == TYPES.o)
                                obj[key] = recursive(val);
                        }
                        return obj;
                    };
                    return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
                };

                return {
                    _defaults: convert(),

                    _template: convert(true),

                    /**
                     * Validates the passed object by the passed template.
                     * @param obj The object which shall be validated.
                     * @param template The template which defines the allowed values and types.
                     * @param writeErrors True if errors shall be logged to the console.
                     * @param diffObj If a object is passed then only valid differences to this object will be returned.
                     * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
                     */
                    _validate: function (obj, template, writeErrors, diffObj) {
                        var validatedOptions = {};
                        var validatedOptionsPrepared = {};
                        var objectCopy = FRAMEWORK.extend(true, {}, obj);
                        var inArray = FRAMEWORK.inArray;
                        var isEmptyObj = FRAMEWORK.isEmptyObject;
                        var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {
                            for (var prop in template) {
                                if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                                    var isValid = false;
                                    var isDiff = false;
                                    var templateValue = template[prop];
                                    var templateValueType = type(templateValue);
                                    var templateIsComplex = templateValueType == TYPES.o;
                                    var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                                    var dataDiffValue = diffData[prop];
                                    var dataValue = data[prop];
                                    var dataValueType = type(dataValue);
                                    var propPrefix = prevPropName ? prevPropName + '.' : '';
                                    var error = "The option \"" + propPrefix + prop + "\" wasn't set, because";
                                    var errorPossibleTypes = [];
                                    var errorRestrictedStrings = [];
                                    var restrictedStringValuesSplit;
                                    var restrictedStringValuesPossibilitiesSplit;
                                    var isRestrictedValue;
                                    var mainPossibility;
                                    var currType;
                                    var i;
                                    var v;
                                    var j;

                                    dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue;

                                    //if the template has a object as value, it means that the options are complex (verschachtelt)
                                    if (templateIsComplex && dataValueType == TYPES.o) {
                                        validatedOptions[prop] = {};
                                        validatedOptionsPrepared[prop] = {};
                                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);
                                        FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {
                                            if (isEmptyObj(value[prop])) {
                                                delete value[prop];
                                            }
                                        });
                                    }
                                    else if (!templateIsComplex) {
                                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                                            currType = templateTypes[i];
                                            templateValueType = type(currType);
                                            //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix
                                            isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;
                                            if (isRestrictedValue) {
                                                errorPossibleTypes.push(TYPES.s);

                                                //split it into a array which contains all possible values for example: ["y:yes", "n:no", "m:maybe"]
                                                restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                                                errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);
                                                for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                                                    //split the possible values into their possibiliteis for example: ["y", "yes"] -> the first is always the mainPossibility
                                                    restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                                                    mainPossibility = restrictedStringValuesPossibilitiesSplit[0];
                                                    for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                                                        //if any possibility matches with the dataValue, its valid
                                                        if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                                                            isValid = true;
                                                            break;
                                                        }
                                                    }
                                                    if (isValid)
                                                        break;
                                                }
                                            }
                                            else {
                                                errorPossibleTypes.push(currType);

                                                if (dataValueType === currType) {
                                                    isValid = true;
                                                    break;
                                                }
                                            }
                                        }

                                        if (isValid) {
                                            isDiff = dataValue !== dataDiffValue;

                                            if (isDiff)
                                                validatedOptions[prop] = dataValue;

                                            if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)
                                                validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;
                                        }
                                        else if (writeErrors) {
                                            console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + " ] with the value of \"" + dataValue + "\".\r\n" +
                                                "Accepted types are: [ " + errorPossibleTypes.join(', ').toUpperCase() + " ]." +
                                                (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + " ]." : ''));
                                        }
                                        delete data[prop];
                                    }
                                }
                            }
                        };
                        checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);

                        //add values which aren't specified in the template to the finished validated object to prevent them from being discarded
                        /*
                        if(keepForeignProps) {
                            FRAMEWORK.extend(true, validatedOptions, objectCopy);
                            FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);
                        }
                        */

                        if (!isEmptyObj(objectCopy) && writeErrors)
                            console.warn('The following options are discarded due to invalidity:\r\n' + window.JSON.stringify(objectCopy, null, 2));

                        return {
                            _default: validatedOptions,
                            _prepared: validatedOptionsPrepared
                        };
                    }
                }
            }());

            /**
             * Initializes the object which contains global information about the plugin and each instance of it.
             */
            function initOverlayScrollbarsStatics() {
                if (!_pluginsGlobals)
                    _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
                if (!_pluginsAutoUpdateLoop)
                    _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
            }

            /**
             * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @param defaultOptions
             * @constructor
             */
            function OverlayScrollbarsGlobals(defaultOptions) {
                var _base = this;
                var strOverflow = 'overflow';
                var strHidden = 'hidden';
                var strScroll = 'scroll';
                var bodyElement = FRAMEWORK('body');
                var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
                var scrollbarDummyElement0 = scrollbarDummyElement[0];
                var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));

                bodyElement.append(scrollbarDummyElement);
                scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)

                var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
                var nativeScrollbarIsOverlaid = {
                    x: nativeScrollbarSize.x === 0,
                    y: nativeScrollbarSize.y === 0
                };
                var msie = (function () {
                    var ua = window.navigator.userAgent;
                    var strIndexOf = 'indexOf';
                    var strSubString = 'substring';
                    var msie = ua[strIndexOf]('MSIE ');
                    var trident = ua[strIndexOf]('Trident/');
                    var edge = ua[strIndexOf]('Edge/');
                    var rv = ua[strIndexOf]('rv:');
                    var result;
                    var parseIntFunc = parseInt;

                    // IE 10 or older => return version number
                    if (msie > 0)
                        result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);

                    // IE 11 => return version number
                    else if (trident > 0)
                        result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);

                    // Edge (IE 12+) => return version number
                    else if (edge > 0)
                        result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10);

                    // other browser
                    return result;
                })();

                FRAMEWORK.extend(_base, {
                    defaultOptions: defaultOptions,
                    msie: msie,
                    autoUpdateLoop: false,
                    autoUpdateRecommended: !COMPATIBILITY.mO(),
                    nativeScrollbarSize: nativeScrollbarSize,
                    nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,
                    nativeScrollbarStyling: (function () {
                        var result = false;
                        scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');
                        try {
                            result = (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';
                        } catch (ex) { }

                        //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.
                        //and set overflow to scroll
                        //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();
                        //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;

                        return result;
                    })(),
                    overlayScrollbarDummySize: { x: 30, y: 30 },
                    cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,
                    restrictedMeasuring: (function () {
                        //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305
                        //since 1.11.0 always false -> fixed via CSS (hopefully)
                        scrollbarDummyElement.css(strOverflow, strHidden);
                        var scrollSize = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        scrollbarDummyElement.css(strOverflow, 'visible');
                        var scrollSize2 = {
                            w: scrollbarDummyElement0[LEXICON.sW],
                            h: scrollbarDummyElement0[LEXICON.sH]
                        };
                        return (scrollSize.w - scrollSize2.w) !== 0 || (scrollSize.h - scrollSize2.h) !== 0;
                    })(),
                    rtlScrollBehavior: (function () {
                        scrollbarDummyElement.css({ 'overflow-y': strHidden, 'overflow-x': strScroll, 'direction': 'rtl' }).scrollLeft(0);
                        var dummyContainerOffset = scrollbarDummyElement.offset();
                        var dummyContainerChildOffset = dummyContainerChild.offset();
                        //https://github.com/KingSora/OverlayScrollbars/issues/187
                        scrollbarDummyElement.scrollLeft(-999);
                        var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
                        return {
                            //origin direction = determines if the zero scroll position is on the left or right side
                            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                            //true = on the left side
                            //false = on the right side
                            i: dummyContainerOffset.left === dummyContainerChildOffset.left,
                            //negative = determines if the maximum scroll is positive or negative
                            //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                            //true = negative
                            //false = positive
                            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
                        };
                    })(),
                    supportTransform: !!VENDORS._cssProperty('transform'),
                    supportTransition: !!VENDORS._cssProperty('transition'),
                    supportPassiveEvents: (function () {
                        var supportsPassive = false;
                        try {
                            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
                                get: function () {
                                    supportsPassive = true;
                                }
                            }));
                        } catch (e) { }
                        return supportsPassive;
                    })(),
                    supportResizeObserver: !!COMPATIBILITY.rO(),
                    supportMutationObserver: !!COMPATIBILITY.mO()
                });

                scrollbarDummyElement.removeAttr(LEXICON.s).remove();

                //Catch zoom event:
                (function () {
                    if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)
                        return;

                    var abs = MATH.abs;
                    var windowWidth = COMPATIBILITY.wW();
                    var windowHeight = COMPATIBILITY.wH();
                    var windowDpr = getWindowDPR();
                    var onResize = function () {
                        if (INSTANCES().length > 0) {
                            var newW = COMPATIBILITY.wW();
                            var newH = COMPATIBILITY.wH();
                            var deltaW = newW - windowWidth;
                            var deltaH = newH - windowHeight;

                            if (deltaW === 0 && deltaH === 0)
                                return;

                            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));
                            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));
                            var absDeltaW = abs(deltaW);
                            var absDeltaH = abs(deltaH);
                            var absDeltaWRatio = abs(deltaWRatio);
                            var absDeltaHRatio = abs(deltaHRatio);
                            var newDPR = getWindowDPR();

                            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
                            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
                            var dprChanged = newDPR !== windowDpr && windowDpr > 0;
                            var isZoom = deltaIsBigger && difference && dprChanged;
                            var oldScrollbarSize = _base.nativeScrollbarSize;
                            var newScrollbarSize;

                            if (isZoom) {
                                bodyElement.append(scrollbarDummyElement);
                                newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
                                scrollbarDummyElement.remove();
                                if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                                    FRAMEWORK.each(INSTANCES(), function () {
                                        if (INSTANCES(this))
                                            INSTANCES(this).update('zoom');
                                    });
                                }
                            }

                            windowWidth = newW;
                            windowHeight = newH;
                            windowDpr = newDPR;
                        }
                    };

                    function differenceIsBiggerThanOne(valOne, valTwo) {
                        var absValOne = abs(valOne);
                        var absValTwo = abs(valTwo);
                        return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
                    }

                    function getWindowDPR() {
                        var dDPI = window.screen.deviceXDPI || 0;
                        var sDPI = window.screen.logicalXDPI || 1;
                        return window.devicePixelRatio || (dDPI / sDPI);
                    }

                    FRAMEWORK(window).on('resize', onResize);
                })();

                function calcNativeScrollbarSize(measureElement) {
                    return {
                        x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
                        y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
                    };
                }
            }

            /**
             * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
             * @constructor
             */
            function OverlayScrollbarsAutoUpdateLoop(globals) {
                var _base = this;
                var _inArray = FRAMEWORK.inArray;
                var _getNow = COMPATIBILITY.now;
                var _strAutoUpdate = 'autoUpdate';
                var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';
                var _strLength = LEXICON.l;
                var _loopingInstances = [];
                var _loopingInstancesIntervalCache = [];
                var _loopIsActive = false;
                var _loopIntervalDefault = 33;
                var _loopInterval = _loopIntervalDefault;
                var _loopTimeOld = _getNow();
                var _loopID;


                /**
                 * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.
                 */
                var loop = function () {
                    if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
                        _loopID = COMPATIBILITY.rAF()(function () {
                            loop();
                        });
                        var timeNew = _getNow();
                        var timeDelta = timeNew - _loopTimeOld;
                        var lowestInterval;
                        var instance;
                        var instanceOptions;
                        var instanceAutoUpdateAllowed;
                        var instanceAutoUpdateInterval;
                        var now;

                        if (timeDelta > _loopInterval) {
                            _loopTimeOld = timeNew - (timeDelta % _loopInterval);
                            lowestInterval = _loopIntervalDefault;
                            for (var i = 0; i < _loopingInstances[_strLength]; i++) {
                                instance = _loopingInstances[i];
                                if (instance !== undefined) {
                                    instanceOptions = instance.options();
                                    instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                                    instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                                    now = _getNow();

                                    if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && (now - _loopingInstancesIntervalCache[i]) > instanceAutoUpdateInterval) {
                                        instance.update('auto');
                                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                                    }

                                    lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
                                }
                            }
                            _loopInterval = lowestInterval;
                        }
                    } else {
                        _loopInterval = _loopIntervalDefault;
                    }
                };

                /**
                 * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.add = function (instance) {
                    if (_inArray(instance, _loopingInstances) === -1) {
                        _loopingInstances.push(instance);
                        _loopingInstancesIntervalCache.push(_getNow());
                        if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
                            _loopIsActive = true;
                            globals.autoUpdateLoop = _loopIsActive;
                            loop();
                        }
                    }
                };

                /**
                 * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.
                 * @param instance The instance which shall be updated in a loop automatically.
                 */
                _base.remove = function (instance) {
                    var index = _inArray(instance, _loopingInstances);
                    if (index > -1) {
                        //remove from loopingInstances list
                        _loopingInstancesIntervalCache.splice(index, 1);
                        _loopingInstances.splice(index, 1);

                        //correct update loop behavior
                        if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
                            _loopIsActive = false;
                            globals.autoUpdateLoop = _loopIsActive;
                            if (_loopID !== undefined) {
                                COMPATIBILITY.cAF()(_loopID);
                                _loopID = -1;
                            }
                        }
                    }
                };
            }

            /**
             * A object which manages the scrollbars visibility of the target element.
             * @param pluginTargetElement The element from which the scrollbars shall be hidden.
             * @param options The custom options.
             * @param extensions The custom extensions.
             * @param globals
             * @param autoUpdateLoop
             * @returns {*}
             * @constructor
             */
            function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
                //shortcuts
                var type = COMPATIBILITY.type;
                var inArray = FRAMEWORK.inArray;
                var each = FRAMEWORK.each;

                //make correct instanceof
                var _base = new _plugin();
                var _frameworkProto = FRAMEWORK[LEXICON.p];

                //if passed element is no HTML element: skip and return
                if (!isHTMLElement(pluginTargetElement))
                    return;

                //if passed element is already initialized: set passed options if there are any and return its instance
                if (INSTANCES(pluginTargetElement)) {
                    var inst = INSTANCES(pluginTargetElement);
                    inst.options(options);
                    return inst;
                }

                //globals:
                var _nativeScrollbarIsOverlaid;
                var _overlayScrollbarDummySize;
                var _rtlScrollBehavior;
                var _autoUpdateRecommended;
                var _msieVersion;
                var _nativeScrollbarStyling;
                var _cssCalc;
                var _nativeScrollbarSize;
                var _supportTransition;
                var _supportTransform;
                var _supportPassiveEvents;
                var _supportResizeObserver;
                var _supportMutationObserver;
                var _restrictedMeasuring;

                //general readonly:
                var _initialized;
                var _destroyed;
                var _isTextarea;
                var _isBody;
                var _documentMixed;
                var _domExists;

                //general:
                var _isBorderBox;
                var _sizeAutoObserverAdded;
                var _paddingX;
                var _paddingY;
                var _borderX;
                var _borderY;
                var _marginX;
                var _marginY;
                var _isRTL;
                var _sleeping;
                var _contentBorderSize = {};
                var _scrollHorizontalInfo = {};
                var _scrollVerticalInfo = {};
                var _viewportSize = {};
                var _nativeScrollbarMinSize = {};

                //naming:	
                var _strMinusHidden = '-hidden';
                var _strMarginMinus = 'margin-';
                var _strPaddingMinus = 'padding-';
                var _strBorderMinus = 'border-';
                var _strTop = 'top';
                var _strRight = 'right';
                var _strBottom = 'bottom';
                var _strLeft = 'left';
                var _strMinMinus = 'min-';
                var _strMaxMinus = 'max-';
                var _strWidth = 'width';
                var _strHeight = 'height';
                var _strFloat = 'float';
                var _strEmpty = '';
                var _strAuto = 'auto';
                var _strSync = 'sync';
                var _strScroll = 'scroll';
                var _strHundredPercent = '100%';
                var _strX = 'x';
                var _strY = 'y';
                var _strDot = '.';
                var _strSpace = ' ';
                var _strScrollbar = 'scrollbar';
                var _strMinusHorizontal = '-horizontal';
                var _strMinusVertical = '-vertical';
                var _strScrollLeft = _strScroll + 'Left';
                var _strScrollTop = _strScroll + 'Top';
                var _strMouseTouchDownEvent = 'mousedown touchstart';
                var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';
                var _strMouseTouchMoveEvent = 'mousemove touchmove';
                var _strMouseEnter = 'mouseenter';
                var _strMouseLeave = 'mouseleave';
                var _strKeyDownEvent = 'keydown';
                var _strKeyUpEvent = 'keyup';
                var _strSelectStartEvent = 'selectstart';
                var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';
                var _strResizeObserverProperty = '__overlayScrollbarsRO__';

                //class names:	
                var _cassNamesPrefix = 'os-';
                var _classNameHTMLElement = _cassNamesPrefix + 'html';
                var _classNameHostElement = _cassNamesPrefix + 'host';
                var _classNameHostElementForeign = _classNameHostElement + '-foreign';
                var _classNameHostTextareaElement = _classNameHostElement + '-textarea';
                var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;
                var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;
                var _classNameHostTransition = _classNameHostElement + '-transition';
                var _classNameHostRTL = _classNameHostElement + '-rtl';
                var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';
                var _classNameHostScrolling = _classNameHostElement + '-scrolling';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflow = _classNameHostElement + '-overflow';
                var _classNameHostOverflowX = _classNameHostOverflow + '-x';
                var _classNameHostOverflowY = _classNameHostOverflow + '-y';
                var _classNameTextareaElement = _cassNamesPrefix + 'textarea';
                var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';
                var _classNamePaddingElement = _cassNamesPrefix + 'padding';
                var _classNameViewportElement = _cassNamesPrefix + 'viewport';
                var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';
                var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';
                var _classNameContentElement = _cassNamesPrefix + 'content';
                var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';
                var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';
                var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';
                var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';
                var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';
                var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';
                var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';
                var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;
                var _classNameScrollbarTrack = _classNameScrollbar + '-track';
                var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';
                var _classNameScrollbarHandle = _classNameScrollbar + '-handle';
                var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';
                var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';
                var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;
                var _classNameScrollbarCorner = _classNameScrollbar + '-corner';
                var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';
                var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';
                var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;
                var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;
                var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;
                var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;
                var _classNameDragging = _cassNamesPrefix + 'dragging';
                var _classNameThemeNone = _cassNamesPrefix + 'theme-none';
                var _classNamesDynamicDestroy = [
                    _classNameViewportNativeScrollbarsInvisible,
                    _classNameViewportNativeScrollbarsOverlaid,
                    _classNameScrollbarTrackOff,
                    _classNameScrollbarHandleOff,
                    _classNameScrollbarUnusable,
                    _classNameScrollbarAutoHidden,
                    _classNameScrollbarCornerResize,
                    _classNameScrollbarCornerResizeB,
                    _classNameScrollbarCornerResizeH,
                    _classNameScrollbarCornerResizeV,
                    _classNameDragging].join(_strSpace);

                //callbacks:	
                var _callbacksInitQeueue = [];

                //attrs viewport shall inherit from target	
                var _viewportAttrsFromTarget = [LEXICON.ti];

                //options:	
                var _defaultOptions;
                var _currentOptions;
                var _currentPreparedOptions;

                //extensions:	
                var _extensions = {};
                var _extensionsPrivateMethods = 'added removed on contract';

                //update	
                var _lastUpdateTime;
                var _swallowedUpdateHints = {};
                var _swallowedUpdateTimeout;
                var _swallowUpdateLag = 42;
                var _updateOnLoadEventName = 'load';
                var _updateOnLoadElms = [];

                //DOM elements:	
                var _windowElement;
                var _documentElement;
                var _htmlElement;
                var _bodyElement;
                var _targetElement;                     //the target element of this OverlayScrollbars object	
                var _hostElement;                       //the host element of this OverlayScrollbars object -> may be the same as targetElement	
                var _sizeAutoObserverElement;           //observes size auto changes	
                var _sizeObserverElement;               //observes size and padding changes	
                var _paddingElement;                    //manages the padding	
                var _viewportElement;                   //is the viewport of our scrollbar model	
                var _contentElement;                    //the element which holds the content	
                var _contentArrangeElement;             //is needed for correct sizing of the content element (only if native scrollbars are overlays)	
                var _contentGlueElement;                //has always the size of the content element	
                var _textareaCoverElement;              //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling	
                var _scrollbarCornerElement;
                var _scrollbarHorizontalElement;
                var _scrollbarHorizontalTrackElement;
                var _scrollbarHorizontalHandleElement;
                var _scrollbarVerticalElement;
                var _scrollbarVerticalTrackElement;
                var _scrollbarVerticalHandleElement;
                var _windowElementNative;
                var _documentElementNative;
                var _targetElementNative;
                var _hostElementNative;
                var _sizeAutoObserverElementNative;
                var _sizeObserverElementNative;
                var _paddingElementNative;
                var _viewportElementNative;
                var _contentElementNative;

                //Cache:	
                var _hostSizeCache;
                var _contentScrollSizeCache;
                var _arrangeContentSizeCache;
                var _hasOverflowCache;
                var _hideOverflowCache;
                var _widthAutoCache;
                var _heightAutoCache;
                var _cssBoxSizingCache;
                var _cssPaddingCache;
                var _cssBorderCache;
                var _cssMarginCache;
                var _cssDirectionCache;
                var _cssDirectionDetectedCache;
                var _paddingAbsoluteCache;
                var _clipAlwaysCache;
                var _contentGlueSizeCache;
                var _overflowBehaviorCache;
                var _overflowAmountCache;
                var _ignoreOverlayScrollbarHidingCache;
                var _autoUpdateCache;
                var _sizeAutoCapableCache;
                var _contentElementScrollSizeChangeDetectedCache;
                var _hostElementSizeChangeDetectedCache;
                var _scrollbarsVisibilityCache;
                var _scrollbarsAutoHideCache;
                var _scrollbarsClickScrollingCache;
                var _scrollbarsDragScrollingCache;
                var _resizeCache;
                var _normalizeRTLCache;
                var _classNameCache;
                var _oldClassName;
                var _textareaAutoWrappingCache;
                var _textareaInfoCache;
                var _textareaSizeCache;
                var _textareaDynHeightCache;
                var _textareaDynWidthCache;
                var _bodyMinSizeCache;
                var _updateAutoCache = {};

                //MutationObserver:	
                var _mutationObserverHost;
                var _mutationObserverContent;
                var _mutationObserverHostCallback;
                var _mutationObserverContentCallback;
                var _mutationObserversConnected;
                var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];
                var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget);

                //events:	
                var _destroyEvents = [];

                //textarea:	
                var _textareaHasFocus;

                //scrollbars:	
                var _scrollbarsAutoHideTimeoutId;
                var _scrollbarsAutoHideMoveTimeoutId;
                var _scrollbarsAutoHideDelay;
                var _scrollbarsAutoHideNever;
                var _scrollbarsAutoHideScroll;
                var _scrollbarsAutoHideMove;
                var _scrollbarsAutoHideLeave;
                var _scrollbarsHandleHovered;
                var _scrollbarsHandlesDefineScrollPos;

                //resize	
                var _resizeNone;
                var _resizeBoth;
                var _resizeHorizontal;
                var _resizeVertical;


                //==== Event Listener ====//	

                /**	
                 * Adds or removes a event listener from the given element. 	
                 * @param element The element to which the event listener shall be applied or removed.	
                 * @param eventNames The name(s) of the events.	
                 * @param listener The method which shall be called.	
                 * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.	
                 * @param passiveOrOptions The options for the event.
                 */
                function setupResponsiveEventListener(element, eventNames, listener, remove, passiveOrOptions) {
                    var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
                    var method = remove ? 'removeEventListener' : 'addEventListener';
                    var onOff = remove ? 'off' : 'on';
                    var events = collected ? false : eventNames.split(_strSpace)
                    var i = 0;

                    var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);
                    var passive = (_supportPassiveEvents && (passiveOrOptionsIsObj ? (passiveOrOptions._passive) : passiveOrOptions)) || false;
                    var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);
                    var nativeParam = _supportPassiveEvents ? {
                        passive: passive,
                        capture: capture,
                    } : capture;

                    if (collected) {
                        for (; i < eventNames[LEXICON.l]; i++)
                            setupResponsiveEventListener(element, eventNames[i], listener[i], remove, passiveOrOptions);
                    }
                    else {
                        for (; i < events[LEXICON.l]; i++) {
                            if(_supportPassiveEvents) {
                                element[0][method](events[i], listener, nativeParam);
                            }
                            else {
                                element[onOff](events[i], listener);
                            }     
                        }
                    }
                }


                function addDestroyEventListener(element, eventNames, listener, passive) {
                    setupResponsiveEventListener(element, eventNames, listener, false, passive);
                    _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
                }

                //==== Resize Observer ====//

                /**
                 * Adds or removes a resize observer from the given element.
                 * @param targetElement The element to which the resize observer shall be added or removed.
                 * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.
                 */
                function setupResizeObserver(targetElement, onElementResizedCallback) {
                    if (targetElement) {
                        var resizeObserver = COMPATIBILITY.rO();
                        var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';
                        var strChildNodes = 'childNodes';
                        var constScroll = 3333333;
                        var callback = function () {
                            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);
                            onElementResizedCallback();
                        };
                        //add resize observer:
                        if (onElementResizedCallback) {
                            if (_supportResizeObserver) {
                                var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];
                                var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
                                observer.observe(element);
                            }
                            else {
                                if (_msieVersion > 9 || !_autoUpdateRecommended) {
                                    targetElement.prepend(
                                        generateDiv(_classNameResizeObserverElement,
                                            generateDiv({ c: _classNameResizeObserverItemElement, dir: 'ltr' },
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv(_classNameResizeObserverItemFinalElement)
                                                ) +
                                                generateDiv(_classNameResizeObserverItemElement,
                                                    generateDiv({ c: _classNameResizeObserverItemFinalElement, style: 'width: 200%; height: 200%' })
                                                )
                                            )
                                        )
                                    );

                                    var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                                    var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                                    var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                                    var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                                    var widthCache = observerElement[LEXICON.oW];
                                    var heightCache = observerElement[LEXICON.oH];
                                    var isDirty;
                                    var rAFId;
                                    var currWidth;
                                    var currHeight;
                                    var factor = 2;
                                    var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!
                                    var reset = function () {
                                        /*
                                         var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                                         var expandChildCSS = {};
                                         expandChildCSS[_strWidth] = sizeResetWidth;
                                         expandChildCSS[_strHeight] = sizeResetHeight;
                                         expandElementChild.css(expandChildCSS);


                                         expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                                         */
                                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                                    };
                                    var onResized = function () {
                                        rAFId = 0;
                                        if (!isDirty)
                                            return;

                                        widthCache = currWidth;
                                        heightCache = currHeight;
                                        callback();
                                    };
                                    var onScroll = function (event) {
                                        currWidth = observerElement[LEXICON.oW];
                                        currHeight = observerElement[LEXICON.oH];
                                        isDirty = currWidth != widthCache || currHeight != heightCache;

                                        if (event && isDirty && !rAFId) {
                                            COMPATIBILITY.cAF()(rAFId);
                                            rAFId = COMPATIBILITY.rAF()(onResized);
                                        }
                                        else if (!event)
                                            onResized();

                                        reset();
                                        if (event) {
                                            COMPATIBILITY.prvD(event);
                                            COMPATIBILITY.stpP(event);
                                        }
                                        return false;
                                    };
                                    var expandChildCSS = {};
                                    var observerElementCSS = {};

                                    setTopRightBottomLeft(observerElementCSS, _strEmpty, [
                                        -((nativeScrollbarSize.y + 1) * factor),
                                        nativeScrollbarSize.x * -factor,
                                        nativeScrollbarSize.y * -factor,
                                        -((nativeScrollbarSize.x + 1) * factor)
                                    ]);

                                    FRAMEWORK(observerElement).css(observerElementCSS);
                                    expandElement.on(_strScroll, onScroll);
                                    shrinkElement.on(_strScroll, onScroll);
                                    targetElement.on(strAnimationStartEvent, function () {
                                        onScroll(false);
                                    });
                                    //lets assume that the divs will never be that large and a constant value is enough
                                    expandChildCSS[_strWidth] = constScroll;
                                    expandChildCSS[_strHeight] = constScroll;
                                    expandElementChild.css(expandChildCSS);

                                    reset();
                                }
                                else {
                                    var attachEvent = _documentElementNative.attachEvent;
                                    var isIE = _msieVersion !== undefined;
                                    if (attachEvent) {
                                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);
                                    }
                                    else {
                                        var obj = _documentElementNative.createElement(TYPES.o);
                                        obj.setAttribute(LEXICON.ti, '-1');
                                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);
                                        obj.onload = function () {
                                            var wnd = this.contentDocument.defaultView;
                                            wnd.addEventListener('resize', callback);
                                            wnd.document.documentElement.style.display = 'none';
                                        };
                                        obj.type = 'text/html';
                                        if (isIE)
                                            targetElement.prepend(obj);
                                        obj.data = 'about:blank';
                                        if (!isIE)
                                            targetElement.prepend(obj);
                                        targetElement.on(strAnimationStartEvent, callback);
                                    }
                                }
                            }

                            if (targetElement[0] === _sizeObserverElementNative) {
                                var directionChanged = function () {
                                    var dir = _hostElement.css('direction');
                                    var css = {};
                                    var scrollLeftValue = 0;
                                    var result = false;
                                    if (dir !== _cssDirectionDetectedCache) {
                                        if (dir === 'ltr') {
                                            css[_strLeft] = 0;
                                            css[_strRight] = _strAuto;
                                            scrollLeftValue = constScroll;
                                        }
                                        else {
                                            css[_strLeft] = _strAuto;
                                            css[_strRight] = 0;
                                            scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                                        }
                                        //execution order is important for IE!!!
                                        _sizeObserverElement.children().eq(0).css(css);
                                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);
                                        _cssDirectionDetectedCache = dir;
                                        result = true;
                                    }
                                    return result;
                                };
                                directionChanged();
                                addDestroyEventListener(targetElement, _strScroll, function (event) {
                                    if (directionChanged())
                                        update();
                                    COMPATIBILITY.prvD(event);
                                    COMPATIBILITY.stpP(event);
                                    return false;
                                });
                            }
                        }
                        //remove resize observer:
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                var resizeObserverObj = element[_strResizeObserverProperty];
                                if (resizeObserverObj) {
                                    resizeObserverObj.disconnect();
                                    delete element[_strResizeObserverProperty];
                                }
                            }
                            else {
                                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
                            }
                        }
                    }
                }

                /**
                 * Freezes or unfreezes the given resize observer.
                 * @param targetElement The element to which the target resize observer is applied.
                 * @param freeze True if the resize observer shall be frozen, false otherwise.
                 
                function freezeResizeObserver(targetElement, freeze) {
                    if (targetElement !== undefined) {
                        if(freeze) {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].unobserve(element);
                            }
                            else {
                                targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);
                                var w = targetElement.css(_strWidth);
                                var h = targetElement.css(_strHeight);
                                var css = {};
                                css[_strWidth] = w;
                                css[_strHeight] = h;
                                targetElement.css(css);
                            }
                        }
                        else {
                            if (_supportResizeObserver) {
                                var element = targetElement.contents()[0];
                                element[_strResizeObserverProperty].observe(element);
                            }
                            else {
                                var css = { };
                                css[_strHeight] = _strEmpty;
                                css[_strWidth] = _strEmpty;
                                targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);
                            }
                        }
                    }
                }
                */


                //==== Mutation Observers ====//

                /**
                 * Creates MutationObservers for the host and content Element if they are supported.
                 */
                function createMutationObservers() {
                    if (_supportMutationObserver) {
                        var mutationObserverContentLag = 11;
                        var mutationObserver = COMPATIBILITY.mO();
                        var contentLastUpdate = COMPATIBILITY.now();
                        var mutationTarget;
                        var mutationAttrName;
                        var mutationIsClass;
                        var oldMutationVal;
                        var newClassVal;
                        var hostClassNameRegex;
                        var contentTimeout;
                        var now;
                        var sizeAuto;
                        var action;

                        _mutationObserverHostCallback = function (mutations) {

                            var doUpdate = false;
                            var doUpdateForce = false;
                            var mutation;
                            var mutatedAttrs = [];

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    mutationTarget = mutation.target;
                                    mutationAttrName = mutation.attributeName;
                                    mutationIsClass = mutationAttrName === LEXICON.c;
                                    oldMutationVal = mutation.oldValue;
                                    newClassVal = mutationTarget.className;

                                    if (_domExists && mutationIsClass && !doUpdateForce) {
                                        // if old class value contains _classNameHostElementForeign and new class value doesn't
                                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                                            hostClassNameRegex = createHostClassNameRegExp(true);
                                            _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {
                                                return name.match(hostClassNameRegex);
                                            })).join(_strSpace);
                                            doUpdate = doUpdateForce = true;
                                        }
                                    }

                                    if (!doUpdate) {
                                        doUpdate = mutationIsClass
                                            ? hostClassNamesChanged(oldMutationVal, newClassVal)
                                            : mutationAttrName === LEXICON.s
                                                ? oldMutationVal !== mutationTarget[LEXICON.s].cssText
                                                : true;
                                    }

                                    mutatedAttrs.push(mutationAttrName);
                                });

                                updateViewportAttrsFromTarget(mutatedAttrs);

                                if (doUpdate)
                                    _base.update(doUpdateForce || _strAuto);
                            }
                            return doUpdate;
                        };
                        _mutationObserverContentCallback = function (mutations) {
                            var doUpdate = false;
                            var mutation;

                            if (_initialized && !_sleeping) {
                                each(mutations, function () {
                                    mutation = this;
                                    doUpdate = isUnknownMutation(mutation);
                                    return !doUpdate;
                                });

                                if (doUpdate) {
                                    now = COMPATIBILITY.now();
                                    sizeAuto = (_heightAutoCache || _widthAutoCache);
                                    action = function () {
                                        if (!_destroyed) {
                                            contentLastUpdate = now;

                                            //if cols, rows or wrap attr was changed
                                            if (_isTextarea)
                                                textareaUpdate();

                                            if (sizeAuto)
                                                update();
                                            else
                                                _base.update(_strAuto);
                                        }
                                    };
                                    clearTimeout(contentTimeout);
                                    if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)
                                        action();
                                    else
                                        contentTimeout = setTimeout(action, mutationObserverContentLag);
                                }
                            }
                            return doUpdate;
                        }

                        _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
                        _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
                    }
                }

                /**
                 * Connects the MutationObservers if they are supported.
                 */
                function connectMutationObservers() {
                    if (_supportMutationObserver && !_mutationObserversConnected) {
                        _mutationObserverHost.observe(_hostElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            attributeFilter: _mutationObserverAttrsHost
                        });

                        _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
                            attributes: true,
                            attributeOldValue: true,
                            subtree: !_isTextarea,
                            childList: !_isTextarea,
                            characterData: !_isTextarea,
                            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
                        });

                        _mutationObserversConnected = true;
                    }
                }

                /**
                 * Disconnects the MutationObservers if they are supported.
                 */
                function disconnectMutationObservers() {
                    if (_supportMutationObserver && _mutationObserversConnected) {
                        _mutationObserverHost.disconnect();
                        _mutationObserverContent.disconnect();

                        _mutationObserversConnected = false;
                    }
                }


                //==== Events of elements ====//

                /**
                 * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!
                 * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.
                 * If there are any size changes, the update method gets called.
                 */
                function hostOnResized() {
                    if (!_sleeping) {
                        var changed;
                        var hostSize = {
                            w: _sizeObserverElementNative[LEXICON.sW],
                            h: _sizeObserverElementNative[LEXICON.sH]
                        };

                        changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
                        _hostElementSizeChangeDetectedCache = hostSize;
                        if (changed)
                            update({ _hostSizeChanged: true });
                    }
                }

                /**
                 * The mouse enter event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseEnter() {
                    if (_scrollbarsAutoHideLeave)
                        refreshScrollbarsAutoHide(true);
                }

                /**
                 * The mouse leave event of the host element. This event is only needed for the autoHide feature.
                 */
                function hostOnMouseLeave() {
                    if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))
                        refreshScrollbarsAutoHide(false);
                }

                /**
                 * The mouse move event of the host element. This event is only needed for the autoHide "move" feature.
                 */
                function hostOnMouseMove() {
                    if (_scrollbarsAutoHideMove) {
                        refreshScrollbarsAutoHide(true);
                        clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
                        _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {
                            if (_scrollbarsAutoHideMove && !_destroyed)
                                refreshScrollbarsAutoHide(false);
                        }, 100);
                    }
                }

                /**
                 * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.
                 * @param event The select start event.
                 */
                function documentOnSelectStart(event) {
                    COMPATIBILITY.prvD(event);
                    return false;
                }

                /**	
                 * A callback which will be called after a element has loaded.	
                 */
                function updateOnLoadCallback(event) {
                    var elm = FRAMEWORK(event.target);

                    eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                        if (elm.is(updateOnLoadSelector)) {
                            update({ _contentSizeChanged: true });
                        }
                    });
                }

                /**
                * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)
                * @param destroy Indicates whether the events shall be added or removed.
                */
                function setupHostMouseTouchEvents(destroy) {
                    if (!destroy)
                        setupHostMouseTouchEvents(true);

                    setupResponsiveEventListener(_hostElement,
                        _strMouseTouchMoveEvent.split(_strSpace)[0],
                        hostOnMouseMove,
                        (!_scrollbarsAutoHideMove || destroy), true);
                    setupResponsiveEventListener(_hostElement,
                        [_strMouseEnter, _strMouseLeave],
                        [hostOnMouseEnter, hostOnMouseLeave],
                        (!_scrollbarsAutoHideLeave || destroy), true);

                    //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible
                    if (!_initialized && !destroy)
                        _hostElement.one('mouseover', hostOnMouseEnter);
                }


                //==== Update Detection ====//

                /**
                 * Measures the min width and min height of the body element and refreshes the related cache.
                 * @returns {boolean} True if the min width or min height has changed, false otherwise.
                 */
                function bodyMinSizeChanged() {
                    var bodyMinSize = {};
                    if (_isBody && _contentArrangeElement) {
                        bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
                        bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
                        bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
                        bodyMinSize.f = true; //flag for "measured at least once"
                    }
                    _bodyMinSizeCache = bodyMinSize;
                    return !!bodyMinSize.c;
                }

                /**
                 * Returns true if the class names really changed (new class without plugin host prefix)
                 * @param oldClassNames The old ClassName string or array.
                 * @param newClassNames The new ClassName string or array.
                 * @returns {boolean} True if the class names has really changed, false otherwise.
                 */
                function hostClassNamesChanged(oldClassNames, newClassNames) {
                    var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
                    var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
                    var diff = getArrayDifferences(oldClasses, currClasses);

                    // remove none theme from diff list to prevent update
                    var idx = inArray(_classNameThemeNone, diff);
                    var i;
                    var regex;

                    if (idx > -1)
                        diff.splice(idx, 1);

                    if (diff[LEXICON.l] > 0) {
                        regex = createHostClassNameRegExp(true, true);
                        for (i = 0; i < diff.length; i++) {
                            if (!diff[i].match(regex)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                /**
                 * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.
                 * @param mutation The mutation which shall be checked.
                 * @returns {boolean} True if the mutation is from a unknown element, false otherwise.
                 */
                function isUnknownMutation(mutation) {
                    var attributeName = mutation.attributeName;
                    var mutationTarget = mutation.target;
                    var mutationType = mutation.type;
                    var strClosest = 'closest';

                    if (mutationTarget === _contentElementNative)
                        return attributeName === null;
                    if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
                        //ignore className changes by the plugin	
                        if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))
                            return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);

                        //only do it of browser support it natively	
                        if (typeof mutationTarget[strClosest] != TYPES.f)
                            return true;
                        if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||
                            mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)
                            return false;
                    }
                    return true;
                }

                /**
                 * Returns true if the content size was changed since the last time this method was called.
                 * @returns {boolean} True if the content size was changed, false otherwise.
                 */
                function updateAutoContentSizeChanged() {
                    if (_sleeping)
                        return false;

                    var contentMeasureElement = getContentMeasureElement();
                    var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
                    var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
                    var css = {};
                    var float;
                    var bodyMinSizeC;
                    var changed;
                    var contentElementScrollSize;

                    if (setCSS) {
                        float = _contentElement.css(_strFloat);
                        css[_strFloat] = _isRTL ? _strRight : _strLeft;
                        css[_strWidth] = _strAuto;
                        _contentElement.css(css);
                    }
                    contentElementScrollSize = {
                        w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
                        h: contentMeasureElement[LEXICON.sH] + textareaValueLength
                    };
                    if (setCSS) {
                        css[_strFloat] = float;
                        css[_strWidth] = _strHundredPercent;
                        _contentElement.css(css);
                    }

                    bodyMinSizeC = bodyMinSizeChanged();
                    changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);

                    _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;

                    return changed || bodyMinSizeC;
                }

                /**
                 * Returns true when a attribute which the MutationObserver would observe has changed.  
                 * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.
                 */
                function meaningfulAttrsChanged() {
                    if (_sleeping || _mutationObserversConnected)
                        return;

                    var elem;
                    var curr;
                    var cache;
                    var changedAttrs = [];
                    var checks = [
                        {
                            _elem: _hostElement,
                            _attrs: _mutationObserverAttrsHost.concat(':visible')
                        },
                        {
                            _elem: _isTextarea ? _targetElement : undefined,
                            _attrs: _mutationObserverAttrsTextarea
                        }
                    ];

                    each(checks, function (index, check) {
                        elem = check._elem;
                        if (elem) {
                            each(check._attrs, function (index, attr) {
                                curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);
                                cache = _updateAutoCache[attr];

                                if (checkCache(curr, cache)) {
                                    changedAttrs.push(attr);
                                }

                                _updateAutoCache[attr] = curr;
                            });
                        }
                    });

                    updateViewportAttrsFromTarget(changedAttrs);

                    return changedAttrs[LEXICON.l] > 0;
                }

                /**
                 * Checks is a CSS Property of a child element is affecting the scroll size of the content.
                 * @param propertyName The CSS property name.
                 * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.
                 */
                function isSizeAffectingCSSProperty(propertyName) {
                    if (!_initialized)
                        return true;
                    var flexGrow = 'flex-grow';
                    var flexShrink = 'flex-shrink';
                    var flexBasis = 'flex-basis';
                    var affectingPropsX = [
                        _strWidth,
                        _strMinMinus + _strWidth,
                        _strMaxMinus + _strWidth,
                        _strMarginMinus + _strLeft,
                        _strMarginMinus + _strRight,
                        _strLeft,
                        _strRight,
                        'font-weight',
                        'word-spacing',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsXContentBox = [
                        _strPaddingMinus + _strLeft,
                        _strPaddingMinus + _strRight,
                        _strBorderMinus + _strLeft + _strWidth,
                        _strBorderMinus + _strRight + _strWidth
                    ];
                    var affectingPropsY = [
                        _strHeight,
                        _strMinMinus + _strHeight,
                        _strMaxMinus + _strHeight,
                        _strMarginMinus + _strTop,
                        _strMarginMinus + _strBottom,
                        _strTop,
                        _strBottom,
                        'line-height',
                        flexGrow,
                        flexShrink,
                        flexBasis
                    ];
                    var affectingPropsYContentBox = [
                        _strPaddingMinus + _strTop,
                        _strPaddingMinus + _strBottom,
                        _strBorderMinus + _strTop + _strWidth,
                        _strBorderMinus + _strBottom + _strWidth
                    ];
                    var _strS = 's';
                    var _strVS = 'v-s';
                    var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
                    var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
                    var sizeIsAffected = false;
                    var checkPropertyName = function (arr, name) {
                        for (var i = 0; i < arr[LEXICON.l]; i++) {
                            if (arr[i] === name)
                                return true;
                        }
                        return false;
                    };

                    if (checkY) {
                        sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
                    }
                    if (checkX && !sizeIsAffected) {
                        sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
                        if (!sizeIsAffected && !_isBorderBox)
                            sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
                    }
                    return sizeIsAffected;
                }


                //==== Update ====//

                /**
                 * Sets the attribute values of the viewport element to the values from the target element.
                 * The value of a attribute is only set if the attribute is whitelisted.
                 * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.
                 */
                function updateViewportAttrsFromTarget(attrs) {
                    attrs = attrs || _viewportAttrsFromTarget;
                    each(attrs, function (index, attr) {
                        if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
                            var targetAttr = _targetElement.attr(attr);
                            if (type(targetAttr) == TYPES.s) {
                                _viewportElement.attr(attr, targetAttr);
                            }
                            else {
                                _viewportElement.removeAttr(attr);
                            }
                        }
                    });
                }

                /**
                 * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.
                 */
                function textareaUpdate() {
                    if (!_sleeping) {
                        var wrapAttrOff = !_textareaAutoWrappingCache;
                        var minWidth = _viewportSize.w;
                        var minHeight = _viewportSize.h;
                        var css = {};
                        var doMeasure = _widthAutoCache || wrapAttrOff;
                        var origWidth;
                        var width;
                        var origHeight;
                        var height;

                        //reset min size
                        css[_strMinMinus + _strWidth] = _strEmpty;
                        css[_strMinMinus + _strHeight] = _strEmpty;

                        //set width auto
                        css[_strWidth] = _strAuto;
                        _targetElement.css(css);

                        //measure width
                        origWidth = _targetElementNative[LEXICON.oW];
                        width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
                        /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/

                        //set measured width
                        css[_strWidth] = _widthAutoCache ? _strAuto /*width*/ : _strHundredPercent;
                        css[_strMinMinus + _strWidth] = _strHundredPercent;

                        //set height auto
                        css[_strHeight] = _strAuto;
                        _targetElement.css(css);

                        //measure height
                        origHeight = _targetElementNative[LEXICON.oH];
                        height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);

                        //append correct size values
                        css[_strWidth] = width;
                        css[_strHeight] = height;
                        _textareaCoverElement.css(css);

                        //apply min width / min height to prevent textarea collapsing
                        css[_strMinMinus + _strWidth] = minWidth /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/;
                        css[_strMinMinus + _strHeight] = minHeight /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/;
                        _targetElement.css(css);

                        return {
                            _originalWidth: origWidth,
                            _originalHeight: origHeight,
                            _dynamicWidth: width,
                            _dynamicHeight: height
                        };
                    }
                }

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param updateHints A objects which contains hints for this update:
                 * {
                 *   _hostSizeChanged : boolean,
                 *   _contentSizeChanged : boolean,
                 *   _force : boolean,                             == preventSwallowing
                 *   _changedOptions : { },                        == preventSwallowing && preventSleep
                *  }
                 */
                function update(updateHints) {
                    clearTimeout(_swallowedUpdateTimeout);
                    updateHints = updateHints || {};
                    _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
                    _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
                    _swallowedUpdateHints._force |= updateHints._force;

                    var now = COMPATIBILITY.now();
                    var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
                    var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
                    var force = !!_swallowedUpdateHints._force;
                    var changedOptions = updateHints._changedOptions;
                    var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && (now - _lastUpdateTime) < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);
                    var displayIsHidden;

                    if (swallow)
                        _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);

                    //abort update due to:
                    //destroyed
                    //swallowing
                    //sleeping
                    //host is hidden or has false display
                    if (_destroyed || swallow || (_sleeping && !changedOptions) || (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) || _hostElement.css('display') === 'inline')
                        return;

                    _lastUpdateTime = now;
                    _swallowedUpdateHints = {};

                    //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.
                    if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                        //native scrollbars are hidden, so change the values to zero
                        _nativeScrollbarSize.x = 0;
                        _nativeScrollbarSize.y = 0;
                    }
                    else {
                        //refresh native scrollbar size (in case of zoom)
                        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    }

                    // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.
                    // The calculation: [scrollbar size +3 *3]
                    // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)
                    // (*3 because (1)increase / (2)decrease -button and (3)resize handle)
                    _nativeScrollbarMinSize = {
                        x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
                        y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
                    };

                    changedOptions = changedOptions || {};
                    //freezeResizeObserver(_sizeObserverElement, true);
                    //freezeResizeObserver(_sizeAutoObserverElement, true);

                    var checkCacheAutoForce = function () {
                        return checkCache.apply(this, [].slice.call(arguments).concat([force]));
                    };

                    //save current scroll offset
                    var currScroll = {
                        x: _viewportElement[_strScrollLeft](),
                        y: _viewportElement[_strScrollTop]()
                    };

                    var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
                    var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;

                    //scrollbars visibility:
                    var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
                    var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);

                    //scrollbars autoHide:
                    var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
                    var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);

                    //scrollbars click scrolling
                    var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
                    var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);

                    //scrollbars drag scrolling
                    var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
                    var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);

                    //className
                    var className = _currentPreparedOptions.className;
                    var classNameChanged = checkCacheAutoForce(className, _classNameCache);

                    //resize
                    var resize = _currentPreparedOptions.resize;
                    var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.

                    //paddingAbsolute
                    var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
                    var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);

                    //clipAlways
                    var clipAlways = _currentPreparedOptions.clipAlways;
                    var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);

                    //sizeAutoCapable
                    var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.
                    var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);

                    //showNativeScrollbars
                    var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
                    var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);

                    //autoUpdate
                    var autoUpdate = _currentPreparedOptions.autoUpdate;
                    var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);

                    //overflowBehavior
                    var overflowBehavior = _currentPreparedOptions.overflowBehavior;
                    var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);

                    //dynWidth:
                    var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
                    var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);

                    //dynHeight:
                    var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
                    var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);

                    //scrollbars visibility
                    _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';
                    _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';
                    _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';
                    _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l';

                    //scrollbars autoHideDelay
                    _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;

                    //old className
                    _oldClassName = _classNameCache;

                    //resize
                    _resizeNone = resize === 'n';
                    _resizeBoth = resize === 'b';
                    _resizeHorizontal = resize === 'h';
                    _resizeVertical = resize === 'v';

                    //normalizeRTL
                    _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;

                    //ignore overlay scrollbar hiding
                    ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);

                    //refresh options cache
                    _scrollbarsVisibilityCache = scrollbarsVisibility;
                    _scrollbarsAutoHideCache = scrollbarsAutoHide;
                    _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
                    _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
                    _classNameCache = className;
                    _resizeCache = resize;
                    _paddingAbsoluteCache = paddingAbsolute;
                    _clipAlwaysCache = clipAlways;
                    _sizeAutoCapableCache = sizeAutoCapable;
                    _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
                    _autoUpdateCache = autoUpdate;
                    _overflowBehaviorCache = extendDeep({}, overflowBehavior);
                    _textareaDynWidthCache = textareaDynWidth;
                    _textareaDynHeightCache = textareaDynHeight;
                    _hasOverflowCache = _hasOverflowCache || { x: false, y: false };

                    //set correct class name to the host element
                    if (classNameChanged) {
                        removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
                        addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);
                    }

                    //set correct auto Update
                    if (autoUpdateChanged) {
                        if (autoUpdate === true || (autoUpdate === null && _autoUpdateRecommended)) {
                            disconnectMutationObservers();
                            autoUpdateLoop.add(_base);
                        }
                        else {
                            autoUpdateLoop.remove(_base);
                            connectMutationObservers();
                        }
                    }

                    //activate or deactivate size auto capability
                    if (sizeAutoCapableChanged) {
                        if (sizeAutoCapable) {
                            if (_contentGlueElement) {
                                _contentGlueElement.show();
                            }
                            else {
                                _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));
                                _paddingElement.before(_contentGlueElement);
                            }
                            if (_sizeAutoObserverAdded) {
                                _sizeAutoObserverElement.show();
                            }
                            else {
                                _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
                                _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];

                                _contentGlueElement.before(_sizeAutoObserverElement);
                                var oldSize = { w: -1, h: -1 };
                                setupResizeObserver(_sizeAutoObserverElement, function () {
                                    var newSize = {
                                        w: _sizeAutoObserverElementNative[LEXICON.oW],
                                        h: _sizeAutoObserverElementNative[LEXICON.oH]
                                    };
                                    if (checkCache(newSize, oldSize)) {
                                        if (_initialized && (_heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {
                                            update();
                                        }
                                        else if (_initialized && (!_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {
                                            update();
                                        }
                                    }
                                    oldSize = newSize;
                                });
                                _sizeAutoObserverAdded = true;
                                //fix heightAuto detector bug if height is fixed but contentHeight is 0.
                                //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.
                                if (_cssCalc !== null)
                                    _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');
                            }
                        }
                        else {
                            if (_sizeAutoObserverAdded)
                                _sizeAutoObserverElement.hide();
                            if (_contentGlueElement)
                                _contentGlueElement.hide();
                        }
                    }

                    //if force, update all resizeObservers too
                    if (force) {
                        _sizeObserverElement.find('*').trigger(_strScroll);
                        if (_sizeAutoObserverAdded)
                            _sizeAutoObserverElement.find('*').trigger(_strScroll);
                    }

                    //display hidden:
                    displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;

                    //textarea AutoWrapping:
                    var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;
                    var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);

                    //detect direction:
                    var cssDirection = _hostElement.css('direction');
                    var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);

                    //detect box-sizing:
                    var boxSizing = _hostElement.css('box-sizing');
                    var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);

                    //detect padding:
                    var padding = getTopRightBottomLeftHost(_strPaddingMinus);

                    //width + height auto detecting var:
                    var sizeAutoObserverElementBCRect;
                    //exception occurs in IE8 sometimes (unknown exception)
                    try {
                        sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
                    } catch (ex) {
                        return;
                    }

                    _isRTL = cssDirection === 'rtl';
                    _isBorderBox = (boxSizing === 'border-box');
                    var isRTLLeft = _isRTL ? _strLeft : _strRight;
                    var isRTLRight = _isRTL ? _strRight : _strLeft;

                    //detect width auto:
                    var widthAutoResizeDetection = false;
                    var widthAutoObserverDetection = (_sizeAutoObserverAdded && (_hostElement.css(_strFloat) !== 'none' /*|| _isTextarea */)) ? (MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0) && (!paddingAbsolute ? (_hostElementNative[LEXICON.cW] - _paddingX) > 0 : true) : false;
                    if (sizeAutoCapable && !widthAutoObserverDetection) {
                        var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];
                        var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);
                        _contentGlueElement.css(_strWidth, _strAuto);

                        var tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                        _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                        widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        if (!widthAutoResizeDetection) {
                            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);
                            tmpNewHostWidth = _hostElementNative[LEXICON.oW];
                            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);
                            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
                        }
                    }
                    var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
                    var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
                    var wasWidthAuto = !widthAuto && _widthAutoCache;

                    //detect height auto:
                    var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? (MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0) /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */ : false;
                    var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
                    var wasHeightAuto = !heightAuto && _heightAutoCache;

                    //detect border:
                    //we need the border only if border box and auto size
                    var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;
                    var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;
                    var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY)

                    //detect margin:
                    var margin = getTopRightBottomLeftHost(_strMarginMinus);

                    //vars to apply correct css
                    var contentElementCSS = {};
                    var contentGlueElementCSS = {};

                    //funcs
                    var getHostSize = function () {
                        //has to be clientSize because offsetSize respect borders
                        return {
                            w: _hostElementNative[LEXICON.cW],
                            h: _hostElementNative[LEXICON.cH]
                        };
                    };
                    var getViewportSize = function () {
                        //viewport size is padding container because it never has padding, margin and a border
                        //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height
                        //if this happens add the difference to the viewportSize to compensate the rounding error
                        return {
                            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
                            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
                        };
                    };

                    //set info for padding
                    var paddingAbsoluteX = _paddingX = padding.l + padding.r;
                    var paddingAbsoluteY = _paddingY = padding.t + padding.b;
                    paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
                    paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
                    padding.c = checkCacheAutoForce(padding, _cssPaddingCache);

                    //set info for border
                    _borderX = border.l + border.r;
                    _borderY = border.t + border.b;
                    border.c = checkCacheAutoForce(border, _cssBorderCache);

                    //set info for margin
                    _marginX = margin.l + margin.r;
                    _marginY = margin.t + margin.b;
                    margin.c = checkCacheAutoForce(margin, _cssMarginCache);

                    //refresh cache
                    _textareaAutoWrappingCache = textareaAutoWrapping;
                    _cssDirectionCache = cssDirection;
                    _cssBoxSizingCache = boxSizing;
                    _widthAutoCache = widthAuto;
                    _heightAutoCache = heightAuto;
                    _cssPaddingCache = padding;
                    _cssBorderCache = border;
                    _cssMarginCache = margin;

                    //IEFix direction changed
                    if (cssDirectionChanged && _sizeAutoObserverAdded)
                        _sizeAutoObserverElement.css(_strFloat, isRTLRight);

                    //apply padding:
                    if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
                        var paddingElementCSS = {};
                        var textareaCSS = {};
                        var paddingValues = [padding.t, padding.r, padding.b, padding.l];

                        setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);
                        if (paddingAbsolute) {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
                        }
                        else {
                            setTopRightBottomLeft(paddingElementCSS, _strEmpty);
                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
                        }

                        _paddingElement.css(paddingElementCSS);
                        _targetElement.css(textareaCSS);
                    }

                    //viewport size is padding container because it never has padding, margin and a border.
                    _viewportSize = getViewportSize();

                    //update Textarea
                    var textareaSize = _isTextarea ? textareaUpdate() : false;
                    var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);
                    var textareaDynOrigSize = _isTextarea && textareaSize ? {
                        w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
                        h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
                    } : {};
                    _textareaSizeCache = textareaSize;

                    //fix height auto / width auto in cooperation with current padding & boxSizing behavior:
                    if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
                        contentElementCSS[_strHeight] = _strAuto;
                    }
                    else if (heightAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strHeight] = _strHundredPercent;
                    }
                    if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
                        contentElementCSS[_strWidth] = _strAuto;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix
                    }
                    else if (widthAutoChanged || paddingAbsoluteChanged) {
                        contentElementCSS[_strWidth] = _strHundredPercent;
                        contentElementCSS[_strFloat] = _strEmpty;
                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix
                    }
                    if (widthAuto) {
                        //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width
                        contentGlueElementCSS[_strWidth] = _strAuto;

                        contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;
                        contentElementCSS[_strFloat] = isRTLRight;
                    }
                    else {
                        contentGlueElementCSS[_strWidth] = _strEmpty;
                    }
                    if (heightAuto) {
                        //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping
                        contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
                    }
                    else {
                        contentGlueElementCSS[_strHeight] = _strEmpty;
                    }
                    if (sizeAutoCapable)
                        _contentGlueElement.css(contentGlueElementCSS);
                    _contentElement.css(contentElementCSS);

                    //CHECKPOINT HERE ~
                    contentElementCSS = {};
                    contentGlueElementCSS = {};

                    //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true
                    if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
                        var strOverflow = 'overflow';
                        var strOverflowX = strOverflow + '-x';
                        var strOverflowY = strOverflow + '-y';
                        var strHidden = 'hidden';
                        var strVisible = 'visible';

                        //Reset the viewport (very important for natively overlaid scrollbars and zoom change
                        //don't change the overflow prop as it is very expensive and affects performance !A LOT!
                        if (!_nativeScrollbarStyling) {
                            var viewportElementResetCSS = {};
                            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;
                            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;
                            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);
                            _viewportElement.css(viewportElementResetCSS);
                        }

                        //measure several sizes:
                        var contentMeasureElement = getContentMeasureElement();
                        //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid
                        var contentSize = {
                            //use clientSize because natively overlaidScrollbars add borders
                            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
                            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
                        };
                        var scrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH]
                        };

                        //apply the correct viewport style and measure viewport size
                        if (!_nativeScrollbarStyling) {
                            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
                            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;
                            _viewportElement.css(viewportElementResetCSS);
                        }
                        _viewportSize = getViewportSize();

                        //measure and correct several sizes
                        var hostSize = getHostSize();
                        var hostAbsoluteRectSize = {
                            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
                            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
                        };
                        var contentGlueSize = {
                            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
                            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
                        };
                        contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
                        _contentGlueSizeCache = contentGlueSize;

                        //apply correct contentGlue size
                        if (sizeAutoCapable) {
                            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto
                            if (contentGlueSize.c || (heightAuto || widthAuto)) {
                                contentGlueElementCSS[_strWidth] = contentGlueSize.w;
                                contentGlueElementCSS[_strHeight] = contentGlueSize.h;

                                //textarea-sizes are already calculated correctly at this point
                                if (!_isTextarea) {
                                    contentSize = {
                                        //use clientSize because natively overlaidScrollbars add borders
                                        w: contentMeasureElement[LEXICON.cW],
                                        h: contentMeasureElement[LEXICON.cH]
                                    };
                                }
                            }
                            var textareaCoverCSS = {};
                            var setContentGlueElementCSSfunction = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var wh = scrollbarVars._w_h;
                                var strWH = scrollbarVars._width_height;
                                var autoSize = horizontal ? widthAuto : heightAuto;
                                var borderSize = horizontal ? _borderX : _borderY;
                                var paddingSize = horizontal ? _paddingX : _paddingY;
                                var marginSize = horizontal ? _marginX : _marginY;
                                var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);

                                //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks
                                if (!autoSize || (!autoSize && border.c))
                                    contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;

                                //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)
                                if (autoSize && (contentSize[wh] < viewportSize) && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                                    if (_isTextarea)
                                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                                    contentGlueElementCSS[strWH] -= 1;
                                }

                                //make sure content glue size is at least 1
                                if (contentSize[wh] > 0)
                                    contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
                            };
                            setContentGlueElementCSSfunction(true);
                            setContentGlueElementCSSfunction(false);

                            if (_isTextarea)
                                _textareaCoverElement.css(textareaCoverCSS);
                            _contentGlueElement.css(contentGlueElementCSS);
                        }
                        if (widthAuto)
                            contentElementCSS[_strWidth] = _strHundredPercent;
                        if (widthAuto && !_isBorderBox && !_mutationObserversConnected)
                            contentElementCSS[_strFloat] = 'none';

                        //apply and reset content style
                        _contentElement.css(contentElementCSS);
                        contentElementCSS = {};

                        //measure again, but this time all correct sizes:
                        var contentScrollSize = {
                            w: contentMeasureElement[LEXICON.sW],
                            h: contentMeasureElement[LEXICON.sH],
                        };
                        contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
                        _contentScrollSizeCache = contentScrollSize;

                        //refresh viewport size after correct measuring
                        _viewportSize = getViewportSize();

                        hostSize = getHostSize();
                        hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
                        _hostSizeCache = hostSize;

                        var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
                        var previousOverflowAmount = _overflowAmountCache;
                        var overflowBehaviorIsVS = {};
                        var overflowBehaviorIsVH = {};
                        var overflowBehaviorIsS = {};
                        var overflowAmount = {};
                        var hasOverflow = {};
                        var hideOverflow = {};
                        var canScroll = {};
                        var viewportRect = _paddingElementNative[LEXICON.bCR]();
                        var setOverflowVariables = function (horizontal) {
                            var scrollbarVars = getScrollbarVars(horizontal);
                            var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                            var xyI = scrollbarVarsInverted._x_y;
                            var xy = scrollbarVars._x_y;
                            var wh = scrollbarVars._w_h;
                            var widthHeight = scrollbarVars._width_height;
                            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';
                            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
                            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
                            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';
                            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';
                            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';
                            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
                            overflowAmount[xy] *= (hideOverflowForceTextarea || (checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1)) ? 0 : 1;
                            hasOverflow[xy] = overflowAmount[xy] > 0;

                            //hideOverflow:
                            //x || y : true === overflow is hidden by "overflow: scroll" OR "overflow: hidden"
                            //xs || ys : true === overflow is hidden by "overflow: scroll"
                            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? (hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI]) : hasOverflow[xy];
                            hideOverflow[xy + 's'] = hideOverflow[xy] ? (overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy]) : false;

                            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];
                        };
                        setOverflowVariables(true);
                        setOverflowVariables(false);

                        overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
                        _overflowAmountCache = overflowAmount;
                        hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
                        _hasOverflowCache = hasOverflow;
                        hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
                        _hideOverflowCache = hideOverflow;

                        //if native scrollbar is overlay at x OR y axis, prepare DOM
                        if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
                            var borderDesign = 'px solid transparent';
                            var contentArrangeElementCSS = {};
                            var arrangeContent = {};
                            var arrangeChanged = force;
                            var setContentElementCSS;

                            if (hasOverflow.x || hasOverflow.y) {
                                arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
                                arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
                                arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
                                _arrangeContentSizeCache = arrangeContent;
                            }

                            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
                                contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;
                                setContentElementCSS = function (horizontal) {
                                    var scrollbarVars = getScrollbarVars(horizontal);
                                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                    var xy = scrollbarVars._x_y;
                                    var strDirection = horizontal ? _strBottom : isRTLLeft;
                                    var invertedAutoSize = horizontal ? heightAuto : widthAuto;

                                    if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {
                                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? (ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy]) : _strEmpty;
                                        contentElementCSS[_strBorderMinus + strDirection] = ((horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding) ? (_overlayScrollbarDummySize[xy] + borderDesign) : _strEmpty;
                                    }
                                    else {
                                        arrangeContent[scrollbarVarsInverted._w_h] =
                                            contentElementCSS[_strMarginMinus + strDirection] =
                                            contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                                        arrangeChanged = true;
                                    }
                                };

                                if (_nativeScrollbarStyling) {
                                    addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding)
                                }
                                else {
                                    setContentElementCSS(true);
                                    setContentElementCSS(false);
                                }
                            }
                            if (ignoreOverlayScrollbarHiding) {
                                arrangeContent.w = arrangeContent.h = _strEmpty;
                                arrangeChanged = true;
                            }
                            if (arrangeChanged && !_nativeScrollbarStyling) {
                                contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
                                contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;

                                if (!_contentArrangeElement) {
                                    _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));
                                    _viewportElement.prepend(_contentArrangeElement);
                                }
                                _contentArrangeElement.css(contentArrangeElementCSS);
                            }
                            _contentElement.css(contentElementCSS);
                        }

                        var viewportElementCSS = {};
                        var paddingElementCSS = {};
                        var setViewportCSS;
                        if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
                            viewportElementCSS[isRTLRight] = _strEmpty;
                            setViewportCSS = function (horizontal) {
                                var scrollbarVars = getScrollbarVars(horizontal);
                                var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                                var xy = scrollbarVars._x_y;
                                var XY = scrollbarVars._X_Y;
                                var strDirection = horizontal ? _strBottom : isRTLLeft;

                                var reset = function () {
                                    viewportElementCSS[strDirection] = _strEmpty;
                                    _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
                                };
                                if (hasOverflow[xy] && hideOverflow[xy + 's']) {
                                    viewportElementCSS[strOverflow + XY] = _strScroll;
                                    if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                                        reset();
                                    }
                                    else {
                                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                                    }
                                } else {
                                    viewportElementCSS[strOverflow + XY] = _strEmpty;
                                    reset();
                                }
                            };
                            setViewportCSS(true);
                            setViewportCSS(false);

                            // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible), 
                            // make viewport element greater in size (Firefox hide Scrollbars fix)
                            // because firefox starts hiding scrollbars on too small elements
                            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284
                            if (!_nativeScrollbarStyling
                                && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y)
                                && ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))) {
                                viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
                                viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;

                                viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
                                viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
                            }
                            else {
                                viewportElementCSS[_strPaddingMinus + _strTop] =
                                    viewportElementCSS[_strMarginMinus + _strTop] =
                                    viewportElementCSS[_strPaddingMinus + isRTLRight] =
                                    viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
                            }
                            viewportElementCSS[_strPaddingMinus + isRTLLeft] =
                                viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;

                            //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible
                            if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {
                                //only hide if is Textarea
                                if (_isTextarea && hideOverflowForceTextarea) {
                                    paddingElementCSS[strOverflowX] =
                                        paddingElementCSS[strOverflowY] = strHidden;
                                }
                            }
                            else {
                                if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {
                                    //only un-hide if Textarea
                                    if (_isTextarea) {
                                        paddingElementCSS[strOverflowX] =
                                            paddingElementCSS[strOverflowY] = _strEmpty;
                                    }
                                    viewportElementCSS[strOverflowX] =
                                        viewportElementCSS[strOverflowY] = strVisible;
                                }
                            }

                            _paddingElement.css(paddingElementCSS);
                            _viewportElement.css(viewportElementCSS);
                            viewportElementCSS = {};

                            //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions
                            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
                                var elementStyle = _contentElementNative[LEXICON.s];
                                var dump;
                                elementStyle.webkitTransform = 'scale(1)';
                                elementStyle.display = 'run-in';
                                dump = _contentElementNative[LEXICON.oH];
                                elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify
                                elementStyle.webkitTransform = _strEmpty;
                            }
                            /*
                            //force hard redraw in webkit if native overlaid scrollbars shall appear
                            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {
                                _hostElement.hide();
                                var dump = _hostElementNative[LEXICON.oH];
                                _hostElement.show();
                            }
                            */
                        }

                        //change to direction RTL and width auto Bugfix in Webkit
                        //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left
                        contentElementCSS = {};
                        if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
                            if (_isRTL && widthAuto) {
                                var floatTmp = _contentElement.css(_strFloat);
                                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);
                                _contentElement.css(_strFloat, floatTmp);
                                var posLeftWithFloat = MATH.round(_contentElement.position().left);

                                if (posLeftWithoutFloat !== posLeftWithFloat)
                                    contentElementCSS[_strLeft] = posLeftWithoutFloat;
                            }
                            else {
                                contentElementCSS[_strLeft] = _strEmpty;
                            }
                        }
                        _contentElement.css(contentElementCSS);

                        //handle scroll position
                        if (_isTextarea && contentSizeChanged) {
                            var textareaInfo = getTextareaInfo();
                            if (textareaInfo) {
                                var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;
                                var cursorRow = textareaInfo._cursorRow;
                                var cursorCol = textareaInfo._cursorColumn;
                                var widestRow = textareaInfo._widestRow;
                                var lastRow = textareaInfo._rows;
                                var lastCol = textareaInfo._columns;
                                var cursorPos = textareaInfo._cursorPosition;
                                var cursorMax = textareaInfo._cursorMax;
                                var cursorIsLastPosition = (cursorPos >= cursorMax && _textareaHasFocus);
                                var textareaScrollAmount = {
                                    x: (!textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow)) ? _overflowAmountCache.x : -1,
                                    y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? (currScroll.y === previousOverflowAmount.y) : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
                                };
                                currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.
                                currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
                            }
                            _textareaInfoCache = textareaInfo;
                        }
                        if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)
                            currScroll.x += _contentBorderSize.w || 0;
                        if (widthAuto)
                            _hostElement[_strScrollLeft](0);
                        if (heightAuto)
                            _hostElement[_strScrollTop](0);
                        _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);

                        //scrollbars management:
                        var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';
                        var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';
                        var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';
                        var refreshScrollbarsVisibility = function (showX, showY) {
                            showY = showY === undefined ? showX : showY;
                            refreshScrollbarAppearance(true, showX, canScroll.x)
                            refreshScrollbarAppearance(false, showY, canScroll.y)
                        };

                        //manage class name which indicates scrollable overflow
                        addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
                        addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
                        addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);

                        //add or remove rtl class name for styling purposes except when its body, then the scrollbar stays
                        if (cssDirectionChanged && !_isBody) {
                            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
                        }

                        //manage the resize feature (CSS3 resize "polyfill" for this plugin)
                        if (_isBody)
                            addClass(_hostElement, _classNameHostResizeDisabled);
                        if (resizeChanged) {
                            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
                        }

                        //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)
                        if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
                            if (ignoreOverlayScrollbarHiding) {
                                if (ignoreOverlayScrollbarHidingChanged) {
                                    removeClass(_hostElement, _classNameHostScrolling);
                                    if (ignoreOverlayScrollbarHiding) {
                                        refreshScrollbarsVisibility(false);
                                    }
                                }
                            }
                            else if (scrollbarsVisibilityAuto) {
                                refreshScrollbarsVisibility(canScroll.x, canScroll.y);
                            }
                            else if (scrollbarsVisibilityVisible) {
                                refreshScrollbarsVisibility(true);
                            }
                            else if (scrollbarsVisibilityHidden) {
                                refreshScrollbarsVisibility(false);
                            }
                        }

                        //manage the scrollbars auto hide feature (auto hide them after specific actions)
                        if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
                            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
                            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
                        }

                        //manage scrollbars handle length & offset - don't remove!
                        if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
                            refreshScrollbarHandleLength(true);
                            refreshScrollbarHandleOffset(true);
                            refreshScrollbarHandleLength(false);
                            refreshScrollbarHandleOffset(false);
                        }

                        //manage interactivity
                        if (scrollbarsClickScrollingChanged)
                            refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
                        if (scrollbarsDragScrollingChanged)
                            refreshScrollbarsInteractive(false, scrollbarsDragScrolling);

                        //callbacks:
                        dispatchCallback('onDirectionChanged', {
                            isRTL: _isRTL,
                            dir: cssDirection
                        }, cssDirectionChanged);
                        dispatchCallback('onHostSizeChanged', {
                            width: _hostSizeCache.w,
                            height: _hostSizeCache.h
                        }, hostSizeChanged);
                        dispatchCallback('onContentSizeChanged', {
                            width: _contentScrollSizeCache.w,
                            height: _contentScrollSizeCache.h
                        }, contentSizeChanged);
                        dispatchCallback('onOverflowChanged', {
                            x: hasOverflow.x,
                            y: hasOverflow.y,
                            xScrollable: hideOverflow.xs,
                            yScrollable: hideOverflow.ys,
                            clipped: hideOverflow.x || hideOverflow.y
                        }, hasOverflow.c || hideOverflow.c);
                        dispatchCallback('onOverflowAmountChanged', {
                            x: overflowAmount.x,
                            y: overflowAmount.y
                        }, overflowAmount.c);
                    }

                    //fix body min size
                    if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
                        //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.
                        if (!_bodyMinSizeCache.f)
                            bodyMinSizeChanged();
                        if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)
                            _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
                        if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)
                            _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
                        _bodyMinSizeCache.c = false;
                    }

                    if (_initialized && changedOptions.updateOnLoad) {
                        updateElementsOnLoad();
                    }

                    //freezeResizeObserver(_sizeObserverElement, false);
                    //freezeResizeObserver(_sizeAutoObserverElement, false);

                    dispatchCallback('onUpdated', { forced: force });
                }

                /**
                 * Updates the found elements of which the load event shall be handled.
                 */
                function updateElementsOnLoad() {
                    if (!_isTextarea) {
                        eachUpdateOnLoad(function (i, updateOnLoadSelector) {
                            _contentElement.find(updateOnLoadSelector).each(function (i, el) {
                                // if element doesn't have a updateOnLoadCallback applied
                                if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                                    _updateOnLoadElms.push(el);
                                    FRAMEWORK(el)
                                        .off(_updateOnLoadEventName, updateOnLoadCallback)
                                        .on(_updateOnLoadEventName, updateOnLoadCallback);
                                }
                            });
                        });
                    }
                }

                //==== Options ====//

                /**
                 * Sets new options but doesn't call the update method.
                 * @param newOptions The object which contains the new options.
                 * @returns {*} A object which contains the changed options.
                 */
                function setOptions(newOptions) {
                    var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions)

                    _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
                    _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);

                    return validatedOpts._prepared;
                }


                //==== Structure ====//

                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                /**
                 * Builds or destroys the wrapper and helper DOM elements.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupStructureDOM(destroy) {
                    var strParent = 'parent';
                    var classNameResizeObserverHost = 'os-resize-observer-host';
                    var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
                    var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
                    var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
                    var adoptAttrsMap = {};
                    var applyAdoptedAttrs = function () {
                        var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
                        each(adoptAttrsMap, function (key, value) {
                            if (type(value) == TYPES.s) {
                                if (key == LEXICON.c)
                                    applyAdoptedAttrsElm.addClass(value);
                                else
                                    applyAdoptedAttrsElm.attr(key, value);
                            }
                        });
                    };
                    var hostElementClassNames = [
                        _classNameHostElement,
                        _classNameHostElementForeign,
                        _classNameHostTextareaElement,
                        _classNameHostResizeDisabled,
                        _classNameHostRTL,
                        _classNameHostScrollbarHorizontalHidden,
                        _classNameHostScrollbarVerticalHidden,
                        _classNameHostTransition,
                        _classNameHostScrolling,
                        _classNameHostOverflow,
                        _classNameHostOverflowX,
                        _classNameHostOverflowY,
                        _classNameThemeNone,
                        _classNameTextareaElement,
                        _classNameTextInherit,
                        _classNameCache].join(_strSpace);
                    var hostElementCSS = {};

                    //get host element as first element, because that's the most upper element and required for the other elements
                    _hostElement = _hostElement || (_isTextarea ? (_domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement))) : _targetElement);
                    _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
                    _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
                    _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
                    _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
                    _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined);

                    //add this class to workaround class changing issues with UI frameworks especially Vue
                    if (_domExists)
                        addClass(_hostElement, _classNameHostElementForeign);

                    //on destroy, remove all generated class names from the host element before collecting the adopted attributes 
                    //to prevent adopting generated class names
                    if (destroy)
                        removeClass(_hostElement, hostElementClassNames);

                    //collect all adopted attributes
                    adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;
                    if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
                        each(adoptAttrs, function (i, v) {
                            if (type(v) == TYPES.s) {
                                adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
                            }
                        });
                    }

                    if (!destroy) {
                        if (_isTextarea) {
                            if (!_currentPreparedOptions.sizeAutoCapable) {
                                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
                                hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
                            }

                            if (!_domExists)
                                _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _hostElement = _targetElement[strParent]().css(hostElementCSS);
                        }

                        if (!_domExists) {
                            //add the correct class to the target element
                            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);

                            //wrap the content into the generated elements to create the required DOM
                            _hostElement.wrapInner(_contentElement)
                                .wrapInner(_viewportElement)
                                .wrapInner(_paddingElement)
                                .prepend(_sizeObserverElement);

                            //jQuery clones elements in wrap functions, so we have to select them again
                            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
                            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
                            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);

                            if (_isTextarea) {
                                _contentElement.prepend(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_nativeScrollbarStyling)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
                        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)
                            addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
                        if (_isBody)
                            addClass(_htmlElement, _classNameHTMLElement);

                        _sizeObserverElementNative = _sizeObserverElement[0];
                        _hostElementNative = _hostElement[0];
                        _paddingElementNative = _paddingElement[0];
                        _viewportElementNative = _viewportElement[0];
                        _contentElementNative = _contentElement[0];

                        updateViewportAttrsFromTarget();
                    }
                    else {
                        if (_domExists && _initialized) {
                            //clear size observer
                            _sizeObserverElement.children().remove();

                            //remove the style property and classes from already generated elements
                            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {
                                if (elm) {
                                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                                }
                            });

                            //add classes to the host element which was removed previously to match the expected DOM
                            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
                        }
                        else {
                            //remove size observer
                            remove(_sizeObserverElement);

                            //unwrap the content to restore DOM
                            _contentElement.contents()
                                .unwrap()
                                .unwrap()
                                .unwrap();

                            if (_isTextarea) {
                                _targetElement.unwrap();
                                remove(_hostElement);
                                remove(_textareaCoverElement);
                                applyAdoptedAttrs();
                            }
                        }

                        if (_isTextarea)
                            _targetElement.removeAttr(LEXICON.s);

                        if (_isBody)
                            removeClass(_htmlElement, _classNameHTMLElement);
                    }
                }

                /**
                 * Adds or removes all wrapper elements interactivity events.
                 * @param destroy Indicates whether the Events shall be added or removed.
                 */
                function setupStructureEvents() {
                    var textareaKeyDownRestrictedKeyCodes = [
                        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,    //F1 to F12
                        33, 34,                                                   //page up, page down
                        37, 38, 39, 40,                                           //left, up, right, down arrows
                        16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
                    ];
                    var textareaKeyDownKeyCodesList = [];
                    var textareaUpdateIntervalID;
                    var scrollStopTimeoutId;
                    var scrollStopDelay = 175;
                    var strFocus = 'focus';

                    function updateTextarea(doClearInterval) {
                        textareaUpdate();
                        _base.update(_strAuto);
                        if (doClearInterval && _autoUpdateRecommended)
                            clearInterval(textareaUpdateIntervalID);
                    }
                    function textareaOnScroll(event) {
                        _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);
                        _targetElement[_strScrollTop](0);
                        COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                        return false;
                    }
                    function textareaOnDrop(event) {
                        setTimeout(function () {
                            if (!_destroyed)
                                updateTextarea();
                        }, 50);
                    }
                    function textareaOnFocus() {
                        _textareaHasFocus = true;
                        addClass(_hostElement, strFocus);
                    }
                    function textareaOnFocusout() {
                        _textareaHasFocus = false;
                        textareaKeyDownKeyCodesList = [];
                        removeClass(_hostElement, strFocus);
                        updateTextarea(true);
                    }
                    function textareaOnKeyDown(event) {
                        var keyCode = event.keyCode;

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
                                updateTextarea();
                                textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);
                            }
                            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)
                                textareaKeyDownKeyCodesList.push(keyCode);
                        }
                    }
                    function textareaOnKeyUp(event) {
                        var keyCode = event.keyCode;
                        var index = inArray(keyCode, textareaKeyDownKeyCodesList);

                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
                            if (index > -1)
                                textareaKeyDownKeyCodesList.splice(index, 1);
                            if (!textareaKeyDownKeyCodesList[LEXICON.l])
                                updateTextarea(true);
                        }
                    }
                    function contentOnTransitionEnd(event) {
                        if (_autoUpdateCache === true)
                            return;
                        event = event.originalEvent || event;
                        if (isSizeAffectingCSSProperty(event.propertyName))
                            _base.update(_strAuto);
                    }
                    function viewportOnScroll(event) {
                        if (!_sleeping) {
                            if (scrollStopTimeoutId !== undefined)
                                clearTimeout(scrollStopTimeoutId);
                            else {
                                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                    refreshScrollbarsAutoHide(true);

                                if (!nativeOverlayScrollbarsAreActive())
                                    addClass(_hostElement, _classNameHostScrolling);

                                dispatchCallback('onScrollStart', event);
                            }

                            //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset
                            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point
                            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove
                            if (!_scrollbarsHandlesDefineScrollPos) {
                                refreshScrollbarHandleOffset(true);
                                refreshScrollbarHandleOffset(false);
                            }
                            dispatchCallback('onScroll', event);

                            scrollStopTimeoutId = setTimeout(function () {
                                if (!_destroyed) {
                                    //OnScrollStop:
                                    clearTimeout(scrollStopTimeoutId);
                                    scrollStopTimeoutId = undefined;

                                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                        refreshScrollbarsAutoHide(false);

                                    if (!nativeOverlayScrollbarsAreActive())
                                        removeClass(_hostElement, _classNameHostScrolling);

                                    dispatchCallback('onScrollStop', event);
                                }
                            }, scrollStopDelay);
                        }
                    }


                    if (_isTextarea) {
                        if (_msieVersion > 9 || !_autoUpdateRecommended) {
                            addDestroyEventListener(_targetElement, 'input', updateTextarea);
                        }
                        else {
                            addDestroyEventListener(_targetElement,
                                [_strKeyDownEvent, _strKeyUpEvent],
                                [textareaOnKeyDown, textareaOnKeyUp]);
                        }

                        addDestroyEventListener(_targetElement,
                            [_strScroll, 'drop', strFocus, strFocus + 'out'],
                            [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);
                    }
                    else {
                        addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
                    }
                    addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
                }


                //==== Scrollbars ====//

                /**
                 * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarsDOM(destroy) {
                    var selectOrGenerateScrollbarDOM = function (isHorizontal) {
                        var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
                        var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
                        var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
                        var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);

                        if (!_domExists && !destroy) {
                            scrollbar.append(track);
                            track.append(handle);
                        }

                        return {
                            _scrollbar: scrollbar,
                            _track: track,
                            _handle: handle
                        };
                    };
                    function resetScrollbarDOM(isHorizontal) {
                        var scrollbarVars = getScrollbarVars(isHorizontal);
                        var scrollbar = scrollbarVars._scrollbar;
                        var track = scrollbarVars._track;
                        var handle = scrollbarVars._handle;

                        if (_domExists && _initialized) {
                            each([scrollbar, track, handle], function (i, elm) {
                                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                            });
                        }
                        else {
                            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
                        }
                    }
                    var horizontalElements;
                    var verticalElements;

                    if (!destroy) {
                        horizontalElements = selectOrGenerateScrollbarDOM(true);
                        verticalElements = selectOrGenerateScrollbarDOM();

                        _scrollbarHorizontalElement = horizontalElements._scrollbar;
                        _scrollbarHorizontalTrackElement = horizontalElements._track;
                        _scrollbarHorizontalHandleElement = horizontalElements._handle;
                        _scrollbarVerticalElement = verticalElements._scrollbar;
                        _scrollbarVerticalTrackElement = verticalElements._track;
                        _scrollbarVerticalHandleElement = verticalElements._handle;

                        if (!_domExists) {
                            _paddingElement.after(_scrollbarVerticalElement);
                            _paddingElement.after(_scrollbarHorizontalElement);
                        }
                    }
                    else {
                        resetScrollbarDOM(true);
                        resetScrollbarDOM();
                    }
                }

                /**
                 * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)
                 * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.
                 */
                function setupScrollbarEvents(isHorizontal) {
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var xy = scrollbarVars._x_y;
                    var XY = scrollbarVars._X_Y;
                    var scroll = _strScroll + scrollbarVars._Left_Top;
                    var strActive = 'active';
                    var strSnapHandle = 'snapHandle';
                    var strClickEvent = 'click';
                    var scrollDurationFactor = 1;
                    var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl
                    var trackTimeout;
                    var mouseDownScroll;
                    var mouseDownOffset;
                    var mouseDownInvertedScale;

                    function getPointerPosition(event) {
                        return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.
                    }
                    function getPreparedScrollbarsOption(name) {
                        return _currentPreparedOptions.scrollbars[name];
                    }
                    function increaseTrackScrollAmount() {
                        scrollDurationFactor = 0.5;
                    }
                    function decreaseTrackScrollAmount() {
                        scrollDurationFactor = 1;
                    }
                    function stopClickEventPropagation(event) {
                        COMPATIBILITY.stpP(event);
                    }
                    function documentKeyDown(event) {
                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                            increaseTrackScrollAmount();
                    }
                    function documentKeyUp(event) {
                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)
                            decreaseTrackScrollAmount();
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || (isTouchEvent && !getPreparedScrollbarsOption('touchSupport')) ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var trackLength = scrollbarVarsInfo._trackLength;
                            var handleLength = scrollbarVarsInfo._handleLength;
                            var scrollRange = scrollbarVarsInfo._maxScroll;
                            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
                            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
                            var scrollDelta = (scrollRange * scrollDeltaPercent);
                            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
                            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)
                                scrollDelta *= -1;

                            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));

                            if (_scrollbarsHandlesDefineScrollPos)
                                refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);

                            if (!_supportPassiveEvents)
                                COMPATIBILITY.prvD(event);
                        }
                        else
                            documentMouseTouchUp(event);
                    }
                    function documentMouseTouchUp(event) {
                        event = event || event.originalEvent;

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],
                            true);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });
                        });
                        
                            
                        if (_scrollbarsHandlesDefineScrollPos)
                            refreshScrollbarHandleOffset(isHorizontal, true);

                        _scrollbarsHandlesDefineScrollPos = false;
                        removeClass(_bodyElement, _classNameDragging);
                        removeClass(scrollbarVars._handle, strActive);
                        removeClass(scrollbarVars._track, strActive);
                        removeClass(scrollbarVars._scrollbar, strActive);

                        mouseDownScroll = undefined;
                        mouseDownOffset = undefined;
                        mouseDownInvertedScale = 1;

                        decreaseTrackScrollAmount();

                        if (trackTimeout !== undefined) {
                            _base.scrollStop();
                            clearTimeout(trackTimeout);
                            trackTimeout = undefined;
                        }

                        if (event) {
                            var rect = _hostElementNative[LEXICON.bCR]();
                            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;

                            //if mouse is outside host element
                            if (!mouseInsideHost)
                                hostOnMouseLeave();

                            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                                refreshScrollbarsAutoHide(false);
                        }
                    }
                    function onHandleMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event))
                            onHandleMouseTouchDownAction(event);
                    }
                    function onHandleMouseTouchDownAction(event) {
                        mouseDownScroll = _viewportElement[scroll]();
                        mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
                        if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)
                            mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;

                        mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                        mouseDownOffset = getPointerPosition(event);

                        _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                        addClass(_bodyElement, _classNameDragging);
                        addClass(scrollbarVars._handle, strActive);
                        addClass(scrollbarVars._scrollbar, strActive);

                        setupResponsiveEventListener(_documentElement,
                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],
                            [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);
                        COMPATIBILITY.rAF()(function() {
                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });
                        });
                        

                        if (_msieVersion || !_documentMixed)
                            COMPATIBILITY.prvD(event);
                        COMPATIBILITY.stpP(event);
                    }
                    function onTrackMouseTouchDown(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);
                            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);
                            var scrollBaseDuration = 270 * handleToViewportRatio;
                            var scrollFirstIterationDelay = 400 * handleToViewportRatio;
                            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];
                            var ctrlKey = event.ctrlKey;
                            var instantScroll = event.shiftKey;
                            var instantScrollTransition = instantScroll && ctrlKey;
                            var isFirstIteration = true;
                            var easing = 'linear';
                            var decreaseScroll;
                            var finishedCondition;
                            var scrollActionFinsished = function (transition) {
                                if (_scrollbarsHandlesDefineScrollPos)
                                    refreshScrollbarHandleOffset(isHorizontal, transition);
                            };
                            var scrollActionInstantFinished = function () {
                                scrollActionFinsished();
                                onHandleMouseTouchDownAction(event);
                            };
                            var scrollAction = function () {
                                if (!_destroyed) {
                                    var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                                    var handleOffset = scrollbarVarsInfo._handleOffset;
                                    var trackLength = scrollbarVarsInfo._trackLength;
                                    var handleLength = scrollbarVarsInfo._handleLength;
                                    var scrollRange = scrollbarVarsInfo._maxScroll;
                                    var currScroll = scrollbarVarsInfo._currentScroll;
                                    var scrollDuration = scrollBaseDuration * scrollDurationFactor;
                                    var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;
                                    var instantScrollPosition = scrollRange * ((mouseOffset - (handleLength / 2)) / (trackLength - handleLength)); // 100% * positionPercent
                                    var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);
                                    var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                                    var scrollObj = {};
                                    var animationObj = {
                                        easing: easing,
                                        step: function (now) {
                                            if (_scrollbarsHandlesDefineScrollPos) {
                                                _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340
                                                refreshScrollbarHandleOffset(isHorizontal, now);
                                            }
                                        }
                                    };
                                    instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                                    instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;

                                    //_base.scrollStop();

                                    if (instantScroll) {
                                        _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position
                                        if (instantScrollTransition) {
                                            //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position
                                            //and the animation stops at the correct point
                                            instantScrollPosition = _viewportElement[scroll]();
                                            //scroll back to the position before instant scrolling so animation can be performed
                                            _viewportElement[scroll](currScroll);

                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;
                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;

                                            scrollObj[xy] = instantScrollPosition;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: 130,
                                                complete: scrollActionInstantFinished
                                            }));
                                        }
                                        else
                                            scrollActionInstantFinished();
                                    }
                                    else {
                                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                                        finishedCondition = rtlIsNormal
                                            ? (decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset)
                                            : (decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset);

                                        if (finishedCondition) {
                                            clearTimeout(trackTimeout);
                                            _base.scrollStop();
                                            trackTimeout = undefined;
                                            scrollActionFinsished(true);
                                        }
                                        else {
                                            trackTimeout = setTimeout(scrollAction, timeoutDelay);

                                            scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;
                                            _base.scroll(scrollObj, extendDeep(animationObj, {
                                                duration: scrollDuration
                                            }));
                                        }
                                        isFirstIteration = false;
                                    }
                                }
                            };
                            if (ctrlKey)
                                increaseTrackScrollAmount();

                            mouseDownInvertedScale = getHostElementInvertedScale()[xy];
                            mouseDownOffset = COMPATIBILITY.page(event)[xy];

                            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
                            addClass(_bodyElement, _classNameDragging);
                            addClass(scrollbarVars._track, strActive);
                            addClass(scrollbarVars._scrollbar, strActive);

                            setupResponsiveEventListener(_documentElement,
                                [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],
                                [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);

                            scrollAction();
                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    }
                    function onTrackMouseTouchEnter(event) {
                        //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is "scroll" or "move".
                        _scrollbarsHandleHovered = true;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(true);
                    }
                    function onTrackMouseTouchLeave(event) {
                        _scrollbarsHandleHovered = false;
                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)
                            refreshScrollbarsAutoHide(false);
                    }
                    function onScrollbarMouseTouchDown(event) {
                        COMPATIBILITY.stpP(event);
                    }

                    addDestroyEventListener(scrollbarVars._handle,
                        _strMouseTouchDownEvent,
                        onHandleMouseTouchDown);
                    addDestroyEventListener(scrollbarVars._track,
                        [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],
                        [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);
                    addDestroyEventListener(scrollbarVars._scrollbar,
                        _strMouseTouchDownEvent,
                        onScrollbarMouseTouchDown);

                    if (_supportTransition) {
                        addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {
                            if (event.target !== scrollbarVars._scrollbar[0])
                                return;
                            refreshScrollbarHandleLength(isHorizontal);
                            refreshScrollbarHandleOffset(isHorizontal);
                        });
                    }
                }

                /**
                 * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.
                 * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.
                 * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.
                 * @param canScroll True if the scrollbar is scrollable, false otherwise.
                 */
                function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
                    var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
                    var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;

                    addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
                    addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
                }

                /**
                 * Autoshows / autohides both scrollbars with.
                 * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.
                 * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.
                 */
                function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
                    clearTimeout(_scrollbarsAutoHideTimeoutId);
                    if (shallBeVisible) {
                        //if(_hasOverflowCache.x && _hideOverflowCache.xs)
                        removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                        //if(_hasOverflowCache.y && _hideOverflowCache.ys)
                        removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                    }
                    else {
                        var anyActive;
                        var strActive = 'active';
                        var hide = function () {
                            if (!_scrollbarsHandleHovered && !_destroyed) {
                                anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))
                                    addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
                            }
                        };
                        if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)
                            _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);
                        else
                            hide();
                    }
                }

                /**
                 * Refreshes the handle length of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 */
                function refreshScrollbarHandleLength(isHorizontal) {
                    var handleCSS = {};
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var digit = 1000000;
                    //get and apply intended handle length
                    var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);
                    handleCSS[scrollbarVars._width_height] = (MATH.floor(handleRatio * 100 * digit) / digit) + '%'; //the last * digit / digit is for flooring to the 4th digit

                    if (!nativeOverlayScrollbarsAreActive())
                        scrollbarVars._handle.css(handleCSS);

                    //measure the handle length to respect min & max length
                    scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];
                    scrollbarVarsInfo._handleLengthRatio = handleRatio;
                }

                /**
                 * Refreshes the handle offset of the given scrollbar.
                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
                 * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)
                 */
                function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
                    var transition = type(scrollOrTransition) == TYPES.b;
                    var transitionDuration = 250;
                    var isRTLisHorizontal = _isRTL && isHorizontal;
                    var scrollbarVars = getScrollbarVars(isHorizontal);
                    var scrollbarVarsInfo = scrollbarVars._info;
                    var strTranslateBrace = 'translate(';
                    var strTransform = VENDORS._cssProperty('transform');
                    var strTransition = VENDORS._cssProperty('transition');
                    var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
                    var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition;

                    //measure the handle length to respect min & max length
                    var handleLength = scrollbarVarsInfo._handleLength;
                    var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];
                    var handleTrackDiff = trackLength - handleLength;
                    var handleCSS = {};
                    var transformOffset;
                    var translateValue;

                    //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'
                    // because its a bit behind during the small delay when content size updates
                    //(delay = mutationObserverContentLag, if its 0 then this var could be used)
                    var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative
                    var getScrollRatio = function (base) {
                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
                    };
                    var getHandleOffset = function (scrollRatio) {
                        var offset = handleTrackDiff * scrollRatio;
                        offset = isNaN(offset) ? 0 : offset;
                        offset = (isRTLisHorizontal && !_rtlScrollBehavior.i) ? (trackLength - handleLength - offset) : offset;
                        offset = MATH.max(0, offset);
                        return offset;
                    };
                    var scrollRatio = getScrollRatio(nativeScroll);
                    var unsnappedScrollRatio = getScrollRatio(currentScroll);
                    var handleOffset = getHandleOffset(unsnappedScrollRatio);
                    var snappedHandleOffset = getHandleOffset(scrollRatio);

                    scrollbarVarsInfo._maxScroll = maxScroll;
                    scrollbarVarsInfo._currentScroll = nativeScroll;
                    scrollbarVarsInfo._currentScrollRatio = scrollRatio;

                    if (_supportTransform) {
                        transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px
                        //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %
                        translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';

                        handleCSS[strTransform] = translateValue;

                        //apply or clear up transition
                        if (_supportTransition)
                            handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;
                    }
                    else
                        handleCSS[scrollbarVars._left_top] = handleOffset;


                    //only apply css if offset has changed and overflow exists.
                    if (!nativeOverlayScrollbarsAreActive()) {
                        scrollbarVars._handle.css(handleCSS);

                        //clear up transition
                        if (_supportTransform && _supportTransition && transition) {
                            scrollbarVars._handle.one(_strTransitionEndEvent, function () {
                                if (!_destroyed)
                                    scrollbarVars._handle.css(strTransition, _strEmpty);
                            });
                        }
                    }

                    scrollbarVarsInfo._handleOffset = handleOffset;
                    scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
                    scrollbarVarsInfo._trackLength = trackLength;
                }

                /**
                 * Refreshes the interactivity of the given scrollbar element.
                 * @param isTrack True if the track element is the target, false if the handle element is the target.
                 * @param value True for interactivity false for no interactivity.
                 */
                function refreshScrollbarsInteractive(isTrack, value) {
                    var action = value ? 'removeClass' : 'addClass';
                    var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
                    var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
                    var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;

                    element1[action](className);
                    element2[action](className);
                }

                /**
                 * Returns a object which is used for fast access for specific variables.
                 * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.
                 * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}
                 */
                function getScrollbarVars(isHorizontal) {
                    return {
                        _width_height: isHorizontal ? _strWidth : _strHeight,
                        _Width_Height: isHorizontal ? 'Width' : 'Height',
                        _left_top: isHorizontal ? _strLeft : _strTop,
                        _Left_Top: isHorizontal ? 'Left' : 'Top',
                        _x_y: isHorizontal ? _strX : _strY,
                        _X_Y: isHorizontal ? 'X' : 'Y',
                        _w_h: isHorizontal ? 'w' : 'h',
                        _l_t: isHorizontal ? 'l' : 't',
                        _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
                        _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
                        _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
                        _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
                    };
                }


                //==== Scrollbar Corner ====//

                /**
                 * Builds or destroys the scrollbar corner DOM element.
                 * @param destroy Indicates whether the DOM shall be build or destroyed.
                 */
                function setupScrollbarCornerDOM(destroy) {
                    _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);

                    if (!destroy) {
                        if (!_domExists) {
                            _hostElement.append(_scrollbarCornerElement);
                        }
                    }
                    else {
                        if (_domExists && _initialized) {
                            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
                        }
                        else {
                            remove(_scrollbarCornerElement);
                        }
                    }
                }

                /**
                 * Initializes all scrollbar corner interactivity events.
                 */
                function setupScrollbarCornerEvents() {
                    var insideIFrame = _windowElementNative.top !== _windowElementNative;
                    var mouseDownPosition = {};
                    var mouseDownSize = {};
                    var mouseDownInvertedScale = {};
                    var reconnectMutationObserver;

                    function documentDragMove(event) {
                        if (onMouseTouchDownContinue(event)) {
                            var pageOffset = getCoordinates(event);
                            var hostElementCSS = {};
                            if (_resizeHorizontal || _resizeBoth)
                                hostElementCSS[_strWidth] = (mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x);
                            if (_resizeVertical || _resizeBoth)
                                hostElementCSS[_strHeight] = (mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y);
                            _hostElement.css(hostElementCSS);
                            COMPATIBILITY.stpP(event);
                        }
                        else {
                            documentMouseTouchUp(event);
                        }
                    }
                    function documentMouseTouchUp(event) {
                        var eventIsTrusted = event !== undefined;

                        setupResponsiveEventListener(_documentElement,
                            [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                            [documentOnSelectStart, documentDragMove, documentMouseTouchUp],
                            true);

                        removeClass(_bodyElement, _classNameDragging);
                        if (_scrollbarCornerElement.releaseCapture)
                            _scrollbarCornerElement.releaseCapture();

                        if (eventIsTrusted) {
                            if (reconnectMutationObserver)
                                connectMutationObservers();
                            _base.update(_strAuto);
                        }
                        reconnectMutationObserver = false;
                    }
                    function onMouseTouchDownContinue(event) {
                        var originalEvent = event.originalEvent || event;
                        var isTouchEvent = originalEvent.touches !== undefined;
                        return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
                    }
                    function getCoordinates(event) {
                        return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);
                    }

                    addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {
                        if (onMouseTouchDownContinue(event) && !_resizeNone) {
                            if (_mutationObserversConnected) {
                                reconnectMutationObserver = true;
                                disconnectMutationObservers();
                            }

                            mouseDownPosition = getCoordinates(event);

                            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
                            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
                            mouseDownInvertedScale = getHostElementInvertedScale();

                            setupResponsiveEventListener(_documentElement,
                                [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],
                                [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);

                            addClass(_bodyElement, _classNameDragging);
                            if (_scrollbarCornerElement.setCapture)
                                _scrollbarCornerElement.setCapture();

                            COMPATIBILITY.prvD(event);
                            COMPATIBILITY.stpP(event);
                        }
                    });
                }


                //==== Utils ====//

                /**
                 * Calls the callback with the given name. The Context of this callback is always _base (this).
                 * @param name The name of the target which shall be called.
                 * @param args The args with which the callback shall be called.
                 * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a "true" value.
                 */
                function dispatchCallback(name, args, dependent) {
                    if (dependent === false)
                        return;
                    if (_initialized) {
                        var callback = _currentPreparedOptions.callbacks[name];
                        var extensionOnName = name;
                        var ext;

                        if (extensionOnName.substr(0, 2) === 'on')
                            extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);

                        if (type(callback) == TYPES.f)
                            callback.call(_base, args);

                        each(_extensions, function () {
                            ext = this;
                            if (type(ext.on) == TYPES.f)
                                ext.on(extensionOnName, args);
                        });
                    }
                    else if (!_destroyed)
                        _callbacksInitQeueue.push({ n: name, a: args });
                }

                /**
                 * Sets the "top, right, bottom, left" properties, with a given prefix, of the given css object.
                 * @param targetCSSObject The css object to which the values shall be applied.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param values A array of values which shall be applied to the "top, right, bottom, left" -properties. The array order is [top, right, bottom, left].
                 * If this argument is undefined the value '' (empty string) will be applied to all properties.
                 */
                function setTopRightBottomLeft(targetCSSObject, prefix, values) {
                    prefix = prefix || _strEmpty;
                    values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];

                    targetCSSObject[prefix + _strTop] = values[0];
                    targetCSSObject[prefix + _strRight] = values[1];
                    targetCSSObject[prefix + _strBottom] = values[2];
                    targetCSSObject[prefix + _strLeft] = values[3];
                }

                /**
                 * Gets the "top, right, bottom, left" CSS properties of the CSS property with the given prefix from the host element.
                 * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
                 * @param suffix The suffix of the "top, right, bottom, left" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)
                 * @param zeroX True if the x axis shall be 0.
                 * @param zeroY True if the y axis shall be 0.
                 * @returns {{}} The object which contains the numbers of the read CSS properties.
                 */
                function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
                    suffix = suffix || _strEmpty;
                    prefix = prefix || _strEmpty;
                    return {
                        t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
                        r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
                        b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
                        l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
                    };
                }

                /**
                 * Returns the computed CSS transition string from the given element.
                 * @param element The element from which the transition string shall be returned.
                 * @returns {string} The CSS transition string from the given element.
                 */
                function getCSSTransitionString(element) {
                    var transitionStr = VENDORS._cssProperty('transition');
                    var assembledValue = element.css(transitionStr);
                    if (assembledValue)
                        return assembledValue;
                    var regExpString = '\\s*(' + '([^,(]+(\\(.+?\\))?)+' + ')[\\s,]*';
                    var regExpMain = new RegExp(regExpString);
                    var regExpValidate = new RegExp('^(' + regExpString + ')+$');
                    var properties = 'property duration timing-function delay'.split(' ');
                    var result = [];
                    var strResult;
                    var valueArray;
                    var i = 0;
                    var j;
                    var splitCssStyleByComma = function (str) {
                        strResult = [];
                        if (!str.match(regExpValidate))
                            return str;
                        while (str.match(regExpMain)) {
                            strResult.push(RegExp.$1);
                            str = str.replace(regExpMain, _strEmpty);
                        }

                        return strResult;
                    };
                    for (; i < properties[LEXICON.l]; i++) {
                        valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));
                        for (j = 0; j < valueArray[LEXICON.l]; j++)
                            result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
                    }
                    return result.join(', ');
                }

                /**
                 * Generates a Regular Expression which matches with a string which starts with 'os-host'.
                 * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).
                 * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).
                 */
                function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
                    var i;
                    var split;
                    var appendix;
                    var appendClasses = function (classes, condition) {
                        appendix = '';
                        if (condition && typeof classes == TYPES.s) {
                            split = classes.split(_strSpace);
                            for (i = 0; i < split[LEXICON.l]; i++)
                                appendix += '|' + split[i] + '$';
                            // split[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') for escaping regex characters
                        }
                        return appendix;
                    };

                    return new RegExp(
                        '(^' + _classNameHostElement + '([-_].+|)$)' +
                        appendClasses(_classNameCache, withCurrClassNameOption) +
                        appendClasses(_oldClassName, withOldClassNameOption), 'g');
                }

                /**
                 * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)
                 * @returns {{x: number, y: number}} The scale of the host-element.
                 */
                function getHostElementInvertedScale() {
                    var rect = _paddingElementNative[LEXICON.bCR]();
                    return {
                        x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
                        y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
                    };
                }

                /**
                 * Checks whether the given object is a HTMLElement.
                 * @param o The object which shall be checked.
                 * @returns {boolean} True the given object is a HTMLElement, false otherwise.
                 */
                function isHTMLElement(o) {
                    var strOwnerDocument = 'ownerDocument';
                    var strHTMLElement = 'HTMLElement';
                    var wnd = o && o[strOwnerDocument] ? (o[strOwnerDocument].parentWindow || window) : window;
                    return (
                        typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2
                            o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s
                    );
                }

                /**
                 * Compares 2 arrays and returns the differences between them as a array.
                 * @param a1 The first array which shall be compared.
                 * @param a2 The second array which shall be compared.
                 * @returns {Array} The differences between the two arrays.
                 */
                function getArrayDifferences(a1, a2) {
                    var a = [];
                    var diff = [];
                    var i;
                    var k;
                    for (i = 0; i < a1.length; i++)
                        a[a1[i]] = true;
                    for (i = 0; i < a2.length; i++) {
                        if (a[a2[i]])
                            delete a[a2[i]];
                        else
                            a[a2[i]] = true;
                    }
                    for (k in a)
                        diff.push(k);
                    return diff;
                }

                /**
                 * Returns Zero or the number to which the value can be parsed.
                 * @param value The value which shall be parsed.
                 * @param toFloat Indicates whether the number shall be parsed to a float.
                 */
                function parseToZeroOrNumber(value, toFloat) {
                    var num = toFloat ? parseFloat(value) : parseInt(value, 10);
                    return isNaN(num) ? 0 : num;
                }

                /**
                 * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.
                 * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.
                 */
                function getTextareaInfo() {
                    //read needed values
                    var textareaCursorPosition = _targetElementNative.selectionStart;
                    if (textareaCursorPosition === undefined)
                        return;

                    var textareaValue = _targetElement.val();
                    var textareaLength = textareaValue[LEXICON.l];
                    var textareaRowSplit = textareaValue.split('\n');
                    var textareaLastRow = textareaRowSplit[LEXICON.l];
                    var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\n');
                    var widestRow = 0;
                    var textareaLastCol = 0;
                    var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
                    var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
                    var rowCols;
                    var i;

                    //get widest Row and the last column of the textarea
                    for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
                        rowCols = textareaRowSplit[i][LEXICON.l];
                        if (rowCols > textareaLastCol) {
                            widestRow = i + 1;
                            textareaLastCol = rowCols;
                        }
                    }

                    return {
                        _cursorRow: cursorRow, //cursorRow
                        _cursorColumn: cursorCol, //cursorCol
                        _rows: textareaLastRow, //rows
                        _columns: textareaLastCol, //cols
                        _widestRow: widestRow, //wRow
                        _cursorPosition: textareaCursorPosition, //pos
                        _cursorMax: textareaLength //max
                    };
                }

                /**
                 * Determines whether native overlay scrollbars are active.
                 * @returns {boolean} True if native overlay scrollbars are active, false otherwise.
                 */
                function nativeOverlayScrollbarsAreActive() {
                    return (_ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y));
                }

                /**
                 * Gets the element which is used to measure the content size.
                 * @returns {*} TextareaCover if target element is textarea else the ContentElement.
                 */
                function getContentMeasureElement() {
                    return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
                }

                /**
                 * Generates a string which represents a HTML div with the given classes or attributes.
                 * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as "className".)
                 * @param content The content of the div as string.
                 * @returns {string} The concated string which represents a HTML div and its content.
                 */
                function generateDiv(classesOrAttrs, content) {
                    return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ?
                        'class="' + classesOrAttrs + '"' :
                        (function () {
                            var key;
                            var attrs = _strEmpty;
                            if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
                                for (key in classesOrAttrs)
                                    attrs += (key === 'c' ? 'class' : key) + '="' + classesOrAttrs[key] + '" ';
                            }
                            return attrs;
                        })() :
                        _strEmpty) +
                        '>' +
                        (content || _strEmpty) +
                        '</div>';
                }

                /**
                 * Selects or generates a div with the given class attribute.
                 * @param className The class names (divided by spaces) of the div which shall be selected or generated.
                 * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)
                 * If its a boolean it decides whether only the children of the host element shall be selected.
                 * @returns {*} The generated or selected element.
                 */
                function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
                    var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
                    var selectParent = onlyChildren ? _hostElement : (selectParentOrOnlyChildren || _hostElement);

                    return (_domExists && !selectParent[LEXICON.l])
                        ? null
                        : _domExists
                            ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\s/g, _strDot)).eq(0)
                            : FRAMEWORK(generateDiv(className))
                }

                /**
                 * Gets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be got.
                 * @param path The property of which the value shall be got.
                 * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.
                 */
                function getObjectPropVal(obj, path) {
                    var splits = path.split(_strDot);
                    var i = 0;
                    var val;
                    for (; i < splits.length; i++) {
                        if (!obj[LEXICON.hOP](splits[i]))
                            return;
                        val = obj[splits[i]];
                        if (i < splits.length && type(val) == TYPES.o)
                            obj = val;
                    }
                    return val;
                }

                /**
                 * Sets the value of the given property from the given object.
                 * @param obj The object from which the property value shall be set.
                 * @param path The property of which the value shall be set.
                 * @param val The value of the property which shall be set.
                 */
                function setObjectPropVal(obj, path, val) {
                    var splits = path.split(_strDot);
                    var splitsLength = splits.length;
                    var i = 0;
                    var extendObj = {};
                    var extendObjRoot = extendObj;
                    for (; i < splitsLength; i++)
                        extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;
                    FRAMEWORK.extend(obj, extendObjRoot, true);
                }

                /**	
                 * Runs a action for each selector inside the updateOnLoad option.	
                 * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).	
                 */
                function eachUpdateOnLoad(action) {
                    var updateOnLoad = _currentPreparedOptions.updateOnLoad;
                    updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;

                    if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
                        each(updateOnLoad, action);
                    }
                }


                //==== Utils Cache ====//

                /**
                 * Compares two values or objects and returns true if they aren't equal.
                 * @param current The first value or object which shall be compared.
                 * @param cache The second value or object which shall be compared.
                 * @param force If true the returned value is always true.
                 * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.
                 */
                function checkCache(current, cache, force) {
                    if (force)
                        return force;
                    if (type(current) == TYPES.o && type(cache) == TYPES.o) {
                        for (var prop in current) {
                            if (prop !== 'c') {
                                if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                                    if (checkCache(current[prop], cache[prop]))
                                        return true;
                                }
                                else {
                                    return true;
                                }
                            }
                        }
                    }
                    else {
                        return current !== cache;
                    }
                    return false;
                }


                //==== Shortcuts ====//

                /**
                 * jQuery extend method shortcut with a appended "true" as first argument.
                 */
                function extendDeep() {
                    return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
                }

                /**
                 * jQuery addClass method shortcut.
                 */
                function addClass(el, classes) {
                    return _frameworkProto.addClass.call(el, classes);
                }

                /**
                 * jQuery removeClass method shortcut.
                 */
                function removeClass(el, classes) {
                    return _frameworkProto.removeClass.call(el, classes);
                }

                /**
                 * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.
                 */
                function addRemoveClass(el, classes, doAdd) {
                    return doAdd ? addClass(el, classes) : removeClass(el, classes);
                }

                /**
                 * jQuery remove method shortcut.
                 */
                function remove(el) {
                    return _frameworkProto.remove.call(el);
                }

                /**
                 * Finds the first child element with the given selector of the given element.
                 * @param el The root element from which the selector shall be valid.
                 * @param selector The selector of the searched element.
                 * @returns {*} The first element which is a child of the given element and matches the givens selector.
                 */
                function findFirst(el, selector) {
                    return _frameworkProto.find.call(el, selector).eq(0);
                }


                //==== API ====//

                /**
                 * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.
                 * This behavior can be reset by calling the update method.
                 */
                _base.sleep = function () {
                    _sleeping = true;
                };

                /**
                 * Updates the plugin and DOM to the current options.
                 * This method should only be called if a update is 100% required.
                 * @param force True if every property shall be updated and the cache shall be ignored.
                 * !INTERNAL USAGE! : force can be a string "auto", "sync" or "zoom" too
                 * if "auto" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.
                 * if "sync" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.
                 * if "zoom" then a update takes place where it's assumed that content and host size changed
                 * @returns {boolean|undefined} 
                 * If force is "sync" then a boolean is returned which indicates whether a update was needed due to pending changes.
                 * If force is "auto" then a boolean is returned whether a update was needed due to attribute or size changes.
                 * undefined otherwise.
                 */
                _base.update = function (force) {
                    if (_destroyed)
                        return;

                    var attrsChanged;
                    var contentSizeC;
                    var isString = type(force) == TYPES.s;
                    var doUpdateAuto;
                    var mutHost;
                    var mutContent;

                    if (isString) {
                        if (force === _strAuto) {
                            attrsChanged = meaningfulAttrsChanged();
                            contentSizeC = updateAutoContentSizeChanged();
                            doUpdateAuto = attrsChanged || contentSizeC;
                            if (doUpdateAuto) {
                                update({
                                    _contentSizeChanged: contentSizeC,
                                    _changedOptions: _initialized ? undefined : _currentPreparedOptions
                                });
                            }
                        }
                        else if (force === _strSync) {
                            if (_mutationObserversConnected) {
                                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
                                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
                            }
                            else {
                                mutHost = _base.update(_strAuto);
                            }
                        }
                        else if (force === 'zoom') {
                            update({
                                _hostSizeChanged: true,
                                _contentSizeChanged: true
                            });
                        }
                    }
                    else {
                        force = _sleeping || force;
                        _sleeping = false;
                        if (!_base.update(_strSync) || force)
                            update({ _force: force });
                    }

                    updateElementsOnLoad();

                    return doUpdateAuto || mutHost || mutContent;
                };

                /**
                 Gets or sets the current options. The update method will be called automatically if new options were set.
                 * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.
                 * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.
                 * @returns {*}
                 */
                _base.options = function (newOptions, value) {
                    var option = {};
                    var changedOps;

                    //return current options if newOptions are undefined or empty
                    if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
                        if (type(newOptions) == TYPES.s) {
                            if (arguments.length > 1) {
                                setObjectPropVal(option, newOptions, value);
                                changedOps = setOptions(option);
                            }
                            else
                                return getObjectPropVal(_currentOptions, newOptions);
                        }
                        else
                            return _currentOptions;
                    }
                    else {
                        changedOps = setOptions(newOptions);
                    }

                    if (!FRAMEWORK.isEmptyObject(changedOps)) {
                        update({ _changedOptions: changedOps });
                    }
                };

                /**
                 * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.
                 */
                _base.destroy = function () {
                    if (_destroyed)
                        return;

                    //remove this instance from auto update loop
                    autoUpdateLoop.remove(_base);

                    //disconnect all mutation observers
                    disconnectMutationObservers();

                    //remove all resize observers
                    setupResizeObserver(_sizeObserverElement);
                    setupResizeObserver(_sizeAutoObserverElement);

                    //remove all extensions
                    for (var extName in _extensions)
                        _base.removeExt(extName);

                    //remove all 'destroy' events
                    while (_destroyEvents[LEXICON.l] > 0)
                        _destroyEvents.pop()();

                    //remove all events from host element
                    setupHostMouseTouchEvents(true);

                    //remove all helper / detection elements
                    if (_contentGlueElement)
                        remove(_contentGlueElement);
                    if (_contentArrangeElement)
                        remove(_contentArrangeElement);
                    if (_sizeAutoObserverAdded)
                        remove(_sizeAutoObserverElement);

                    //remove all generated DOM
                    setupScrollbarsDOM(true);
                    setupScrollbarCornerDOM(true);
                    setupStructureDOM(true);

                    //remove all generated image load events
                    for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)
                        FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);
                    _updateOnLoadElms = undefined;

                    _destroyed = true;
                    _sleeping = true;

                    //remove this instance from the instances list
                    INSTANCES(pluginTargetElement, 0);
                    dispatchCallback('onDestroyed');

                    //remove all properties and methods
                    //for (var property in _base)
                    //    delete _base[property];
                    //_base = undefined;
                };

                /**
                 * Scrolls to a given position or element.
                 * @param coordinates
                 * 1. Can be "coordinates" which looks like:
                 *    { x : ?, y : ? } OR          Object with x and y properties
                 *    { left : ?, top : ? } OR     Object with left and top properties
                 *    { l : ?, t : ? } OR          Object with l and t properties
                 *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)
                 *    ?                            A single value which stays for both axis
                 *    A value can be a number, a string or a calculation.
                 *
                 *    Operators:
                 *    [NONE]  The current scroll will be overwritten by the value.
                 *    '+='    The value will be added to the current scroll offset
                 *    '-='    The value will be subtracted from the current scroll offset
                 *    '*='    The current scroll wil be multiplicated by the value.
                 *    '/='    The current scroll wil be divided by the value.
                 *
                 *    Units:
                 *    [NONE]  The value is the final scroll amount.                   final = (value * 1)
                 *    'px'    Same as none
                 *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)
                 *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)
                 *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)
                 *
                 *    example final values:
                 *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'
                 *
                 * 2. Can be a HTML or jQuery element:
                 *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.
                 *
                 * 3. Can be a object with a HTML or jQuery element with additional settings:
                 *    {
                 *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.
                 *      scroll : [string, array, object],               Default value is 'always'.
                 *      block : [string, array, object],                Default value is 'begin'.
                 *      margin : [number, boolean, array, object]       Default value is false.
                 *    }
                 *
                 *    Possible scroll settings are:
                 *    'always'      Scrolls always.
                 *    'ifneeded'    Scrolls only if the element isnt fully in view.
                 *    'never'       Scrolls never.
                 *
                 *    Possible block settings are:
                 *    'begin'   Both axis shall be docked to the "begin" edge. - The element will be docked to the top and left edge of the viewport.
                 *    'end'     Both axis shall be docked to the "end" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)
                 *    'center'  Both axis shall be docked to "center". - The element will be centered in the viewport.
                 *    'nearest' The element will be docked to the nearest edge(s).
                 *
                 *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.
                 *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.
                 *    [NUMBER]                                          The margin will be used for all edges.
                 *
                 * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.
                 * @param easing The animation easing.
                 * @param complete The animation complete callback.
                 * @returns {{
                 *   position: {x: number, y: number},
                 *   ratio: {x: number, y: number},
                 *   max: {x: number, y: number},
                 *   handleOffset: {x: number, y: number},
                 *   handleLength: {x: number, y: number},
                 *   handleLengthRatio: {x: number, y: number}, t
                 *   rackLength: {x: number, y: number},
                 *   isRTL: boolean,
                 *   isRTLNormalized: boolean
                 *  }}
                 */
                _base.scroll = function (coordinates, duration, easing, complete) {
                    if (arguments.length === 0 || coordinates === undefined) {
                        var infoX = _scrollHorizontalInfo;
                        var infoY = _scrollVerticalInfo;
                        var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
                        var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
                        var scrollX = infoX._currentScroll;
                        var scrollXRatio = infoX._currentScrollRatio;
                        var maxScrollX = infoX._maxScroll;
                        scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
                        scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
                        scrollX *= normalizeNegate ? -1 : 1;
                        maxScrollX *= normalizeNegate ? -1 : 1;

                        return {
                            position: {
                                x: scrollX,
                                y: infoY._currentScroll
                            },
                            ratio: {
                                x: scrollXRatio,
                                y: infoY._currentScrollRatio
                            },
                            max: {
                                x: maxScrollX,
                                y: infoY._maxScroll
                            },
                            handleOffset: {
                                x: infoX._handleOffset,
                                y: infoY._handleOffset
                            },
                            handleLength: {
                                x: infoX._handleLength,
                                y: infoY._handleLength
                            },
                            handleLengthRatio: {
                                x: infoX._handleLengthRatio,
                                y: infoY._handleLengthRatio
                            },
                            trackLength: {
                                x: infoX._trackLength,
                                y: infoY._trackLength
                            },
                            snappedHandleOffset: {
                                x: infoX._snappedHandleOffset,
                                y: infoY._snappedHandleOffset
                            },
                            isRTL: _isRTL,
                            isRTLNormalized: _normalizeRTLCache
                        };
                    }

                    _base.update(_strSync);

                    var normalizeRTL = _normalizeRTLCache;
                    var coordinatesXAxisProps = [_strX, _strLeft, 'l'];
                    var coordinatesYAxisProps = [_strY, _strTop, 't'];
                    var coordinatesOperators = ['+=', '-=', '*=', '/='];
                    var durationIsObject = type(duration) == TYPES.o;
                    var completeCallback = durationIsObject ? duration.complete : complete;
                    var i;
                    var finalScroll = {};
                    var specialEasing = {};
                    var doScrollLeft;
                    var doScrollTop;
                    var animationOptions;
                    var strEnd = 'end';
                    var strBegin = 'begin';
                    var strCenter = 'center';
                    var strNearest = 'nearest';
                    var strAlways = 'always';
                    var strNever = 'never';
                    var strIfNeeded = 'ifneeded';
                    var strLength = LEXICON.l;
                    var settingsAxis;
                    var settingsScroll;
                    var settingsBlock;
                    var settingsMargin;
                    var finalElement;
                    var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];
                    var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
                    var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
                    var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');
                    var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
                    var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
                    var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);
                    var updateScrollbarInfos = function () {
                        if (doScrollLeft)
                            refreshScrollbarHandleOffset(true);
                        if (doScrollTop)
                            refreshScrollbarHandleOffset(false);
                    };
                    var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {
                        updateScrollbarInfos();
                        completeCallback();
                    };
                    function checkSettingsStringValue(currValue, allowedValues) {
                        for (i = 0; i < allowedValues[strLength]; i++) {
                            if (currValue === allowedValues[i])
                                return true;
                        }
                        return false;
                    }
                    function getRawScroll(isX, coordinates) {
                        var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
                        coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;

                        if (COMPATIBILITY.isA(coordinates))
                            return isX ? coordinates[0] : coordinates[1];
                        else if (type(coordinates) == TYPES.o) {
                            //decides RTL normalization "hack" with .n
                            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL; 
                            for (i = 0; i < coordinateProps[strLength]; i++)
                                if (coordinateProps[i] in coordinates)
                                    return coordinates[coordinateProps[i]];
                        }
                    }
                    function getFinalScroll(isX, rawScroll) {
                        var isString = type(rawScroll) == TYPES.s;
                        var operator;
                        var amount;
                        var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
                        var currScroll = scrollInfo._currentScroll;
                        var maxScroll = scrollInfo._maxScroll;
                        var mult = ' * ';
                        var finalValue;
                        var isRTLisX = _isRTL && isX;
                        var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
                        var strReplace = 'replace';
                        var evalFunc = eval;
                        var possibleOperator;
                        if (isString) {
                            //check operator
                            if (rawScroll[strLength] > 2) {
                                possibleOperator = rawScroll.substr(0, 2);
                                if (inArray(possibleOperator, coordinatesOperators) > -1)
                                    operator = possibleOperator;
                            }

                            //calculate units and shortcuts
                            rawScroll = operator ? rawScroll.substr(2) : rawScroll;
                            rawScroll = rawScroll
                            [strReplace](/min/g, 0) //'min' = 0%
                            [strReplace](/</g, 0)   //'<'   = 0%
                            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)    //'max' = 100%
                            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)      //'>'   = 100%
                            [strReplace](/px/g, _strEmpty)
                            [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0))
                            [strReplace](/vw/g, mult + _viewportSize.w)
                            [strReplace](/vh/g, mult + _viewportSize.h);
                            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
                        }
                        else {
                            amount = rawScroll;
                        }

                        if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {
                            var normalizeIsRTLisX = normalizeRTL && isRTLisX;
                            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
                            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
                            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
                            operatorCurrScroll = invert ? (maxScroll - operatorCurrScroll) : operatorCurrScroll;
                            switch (operator) {
                                case '+=':
                                    finalValue = operatorCurrScroll + amount;
                                    break;
                                case '-=':
                                    finalValue = operatorCurrScroll - amount;
                                    break;
                                case '*=':
                                    finalValue = operatorCurrScroll * amount;
                                    break;
                                case '/=':
                                    finalValue = operatorCurrScroll / amount;
                                    break;
                                default:
                                    finalValue = amount;
                                    break;
                            }
                            finalValue = invert ? maxScroll - finalValue : finalValue;
                            finalValue *= negate ? -1 : 1;
                            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
                        }
                        return finalValue === currScroll ? undefined : finalValue;
                    }
                    function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
                        var resultDefault = [defaultValue, defaultValue];
                        var valueType = type(value);
                        var valueArrLength;
                        var valueArrItem;

                        //value can be [ string, or array of two strings ]
                        if (valueType == valueInternalType) {
                            value = [value, value];
                        }
                        else if (valueType == TYPES.a) {
                            valueArrLength = value[strLength];
                            if (valueArrLength > 2 || valueArrLength < 1)
                                value = resultDefault;
                            else {
                                if (valueArrLength === 1)
                                    value[1] = defaultValue;
                                for (i = 0; i < valueArrLength; i++) {
                                    valueArrItem = value[i];
                                    if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                                        value = resultDefault;
                                        break;
                                    }
                                }
                            }
                        }
                        else if (valueType == TYPES.o)
                            value = [value[_strX] || defaultValue, value[_strY] || defaultValue];
                        else
                            value = resultDefault;
                        return { x: value[0], y: value[1] };
                    }
                    function generateMargin(marginTopRightBottomLeftArray) {
                        var result = [];
                        var currValue;
                        var currValueType;
                        var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];
                        for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
                            if (i === valueDirections[strLength])
                                break;
                            currValue = marginTopRightBottomLeftArray[i];
                            currValueType = type(currValue);
                            if (currValueType == TYPES.b)
                                result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);
                            else
                                result.push(currValueType == TYPES.n ? currValue : 0);
                        }
                        return result;
                    }

                    if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
                        //get settings
                        var margin = coordinatesIsElementObj ? coordinates.margin : 0;
                        var axis = coordinatesIsElementObj ? coordinates.axis : 0;
                        var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
                        var block = coordinatesIsElementObj ? coordinates.block : 0;
                        var marginDefault = [0, 0, 0, 0];
                        var marginType = type(margin);
                        var marginLength;
                        finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);

                        if (finalElement[strLength] > 0) {
                            //margin can be [ boolean, number, array of 2, array of 4, object ]
                            if (marginType == TYPES.n || marginType == TYPES.b)
                                margin = generateMargin([margin, margin, margin, margin]);
                            else if (marginType == TYPES.a) {
                                marginLength = margin[strLength];
                                if (marginLength === 2)
                                    margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);
                                else if (marginLength >= 4)
                                    margin = generateMargin(margin);
                                else
                                    margin = marginDefault;
                            }
                            else if (marginType == TYPES.o)
                                margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);
                            else
                                margin = marginDefault;

                            //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;
                            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';
                            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
                            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
                            settingsMargin = margin;

                            var viewportScroll = {
                                l: _scrollHorizontalInfo._currentScroll,
                                t: _scrollVerticalInfo._currentScroll
                            };
                            // use padding element instead of viewport element because padding element has never padding, margin or position applied.
                            var viewportOffset = _paddingElement.offset();

                            //get coordinates
                            var elementOffset = finalElement.offset();
                            var doNotScroll = {
                                x: settingsScroll.x == strNever || settingsAxis == _strY,
                                y: settingsScroll.y == strNever || settingsAxis == _strX
                            };
                            elementOffset[_strTop] -= settingsMargin[0];
                            elementOffset[_strLeft] -= settingsMargin[3];
                            var elementScrollCoordinates = {
                                x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
                                y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
                            };
                            if (_isRTL) {
                                if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
                                if (_rtlScrollBehavior.n && normalizeRTL)
                                    elementScrollCoordinates.x *= -1;
                                if (_rtlScrollBehavior.i && normalizeRTL)
                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
                            }

                            //measuring is required
                            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
                                var measuringElm = finalElement[0];
                                var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                                    width: measuringElm[LEXICON.oW],
                                    height: measuringElm[LEXICON.oH]
                                };
                                var elementSize = {
                                    w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                                    h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
                                };
                                var finalizeBlock = function (isX) {
                                    var vars = getScrollbarVars(isX);
                                    var wh = vars._w_h;
                                    var lt = vars._left_top;
                                    var xy = vars._x_y;
                                    var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                                    var blockIsCenter = settingsBlock[xy] == strCenter;
                                    var blockIsNearest = settingsBlock[xy] == strNearest;
                                    var scrollNever = settingsScroll[xy] == strNever;
                                    var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                                    var vpSize = _viewportSize[wh];
                                    var vpOffset = viewportOffset[lt];
                                    var elSize = elementSize[wh];
                                    var elOffset = elementOffset[lt];
                                    var divide = blockIsCenter ? 2 : 1;
                                    var elementCenterOffset = elOffset + (elSize / 2);
                                    var viewportCenterOffset = vpOffset + (vpSize / 2);
                                    var isInView =
                                        elSize <= vpSize
                                        && elOffset >= vpOffset
                                        && elOffset + elSize <= vpOffset + vpSize;

                                    if (scrollNever)
                                        doNotScroll[xy] = true;
                                    else if (!doNotScroll[xy]) {
                                        if (blockIsNearest || scrollIfNeeded) {
                                            doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                                            blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                                        }
                                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? ((vpSize / divide) - (elSize / divide)) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                                    }
                                };
                                finalizeBlock(true);
                                finalizeBlock(false);
                            }

                            if (doNotScroll.y)
                                delete elementScrollCoordinates.y;
                            if (doNotScroll.x)
                                delete elementScrollCoordinates.x;

                            coordinates = elementScrollCoordinates;
                        }
                    }

                    finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
                    finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
                    doScrollLeft = finalScroll[_strScrollLeft] !== undefined;
                    doScrollTop = finalScroll[_strScrollTop] !== undefined;

                    if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
                        if (durationIsObject) {
                            duration.complete = proxyCompleteCallback;
                            _viewportElement.animate(finalScroll, duration);
                        }
                        else {
                            animationOptions = {
                                duration: duration,
                                complete: proxyCompleteCallback
                            };
                            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
                                specialEasing[_strScrollLeft] = easing[0] || easing.x;
                                specialEasing[_strScrollTop] = easing[1] || easing.y;
                                animationOptions.specialEasing = specialEasing;
                            }
                            else {
                                animationOptions.easing = easing;
                            }
                            _viewportElement.animate(finalScroll, animationOptions);
                        }
                    }
                    else {
                        if (doScrollLeft)
                            _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
                        if (doScrollTop)
                            _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
                        updateScrollbarInfos();
                    }
                };

                /**
                 * Stops all scroll animations.
                 * @returns {*} The current OverlayScrollbars instance (for chaining).
                 */
                _base.scrollStop = function (param1, param2, param3) {
                    _viewportElement.stop(param1, param2, param3);
                    return _base;
                };

                /**
                 * Returns all relevant elements.
                 * @param elementName The name of the element which shall be returned.
                 * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}
                 */
                _base.getElements = function (elementName) {
                    var obj = {
                        target: _targetElementNative,
                        host: _hostElementNative,
                        padding: _paddingElementNative,
                        viewport: _viewportElementNative,
                        content: _contentElementNative,
                        scrollbarHorizontal: {
                            scrollbar: _scrollbarHorizontalElement[0],
                            track: _scrollbarHorizontalTrackElement[0],
                            handle: _scrollbarHorizontalHandleElement[0]
                        },
                        scrollbarVertical: {
                            scrollbar: _scrollbarVerticalElement[0],
                            track: _scrollbarVerticalTrackElement[0],
                            handle: _scrollbarVerticalHandleElement[0]
                        },
                        scrollbarCorner: _scrollbarCornerElement[0]
                    };
                    return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
                };

                /**
                 * Returns a object which describes the current state of this instance.
                 * @param stateProperty A specific property from the state object which shall be returned.
                 * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}
                 */
                _base.getState = function (stateProperty) {
                    function prepare(obj) {
                        if (!FRAMEWORK.isPlainObject(obj))
                            return obj;
                        var extended = extendDeep({}, obj);
                        var changePropertyName = function (from, to) {
                            if (extended[LEXICON.hOP](from)) {
                                extended[to] = extended[from];
                                delete extended[from];
                            }
                        };
                        changePropertyName('w', _strWidth); //change w to width
                        changePropertyName('h', _strHeight); //change h to height
                        delete extended.c; //delete c (the 'changed' prop)
                        return extended;
                    };
                    var obj = {
                        destroyed: !!prepare(_destroyed),
                        sleeping: !!prepare(_sleeping),
                        autoUpdate: prepare(!_mutationObserversConnected),
                        widthAuto: prepare(_widthAutoCache),
                        heightAuto: prepare(_heightAutoCache),
                        padding: prepare(_cssPaddingCache),
                        overflowAmount: prepare(_overflowAmountCache),
                        hideOverflow: prepare(_hideOverflowCache),
                        hasOverflow: prepare(_hasOverflowCache),
                        contentScrollSize: prepare(_contentScrollSizeCache),
                        viewportSize: prepare(_viewportSize),
                        hostSize: prepare(_hostSizeCache),
                        documentMixed: prepare(_documentMixed)
                    };
                    return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
                };

                /**
                 * Gets all or specific extension instance.
                 * @param extName The name of the extension from which the instance shall be got.
                 * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.
                 */
                _base.ext = function (extName) {
                    var result;
                    var privateMethods = _extensionsPrivateMethods.split(' ');
                    var i = 0;
                    if (type(extName) == TYPES.s) {
                        if (_extensions[LEXICON.hOP](extName)) {
                            result = extendDeep({}, _extensions[extName]);
                            for (; i < privateMethods.length; i++)
                                delete result[privateMethods[i]];
                        }
                    }
                    else {
                        result = {};
                        for (i in _extensions)
                            result[i] = extendDeep({}, _base.ext(i));
                    }
                    return result;
                };

                /**
                 * Adds a extension to this instance.
                 * @param extName The name of the extension which shall be added.
                 * @param extensionOptions The extension options which shall be used.
                 * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.
                 */
                _base.addExt = function (extName, extensionOptions) {
                    var registeredExtensionObj = _plugin.extension(extName);
                    var instance;
                    var instanceAdded;
                    var instanceContract;
                    var contractResult;
                    var contractFulfilled = true;
                    if (registeredExtensionObj) {
                        if (!_extensions[LEXICON.hOP](extName)) {
                            instance = registeredExtensionObj.extensionFactory.call(_base,
                                extendDeep({}, registeredExtensionObj.defaultOptions),
                                FRAMEWORK,
                                COMPATIBILITY);

                            if (instance) {
                                instanceContract = instance.contract;
                                if (type(instanceContract) == TYPES.f) {
                                    contractResult = instanceContract(window);
                                    contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
                                }
                                if (contractFulfilled) {
                                    _extensions[extName] = instance;
                                    instanceAdded = instance.added;
                                    if (type(instanceAdded) == TYPES.f)
                                        instanceAdded(extensionOptions);

                                    return _base.ext(extName);
                                }
                            }
                        }
                        else
                            return _base.ext(extName);
                    }
                    else
                        console.warn("A extension with the name \"" + extName + "\" isn't registered.");
                };

                /**
                 * Removes a extension from this instance.
                 * @param extName The name of the extension which shall be removed.
                 * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.
                 */
                _base.removeExt = function (extName) {
                    var instance = _extensions[extName];
                    var instanceRemoved;
                    if (instance) {
                        delete _extensions[extName];

                        instanceRemoved = instance.removed;
                        if (type(instanceRemoved) == TYPES.f)
                            instanceRemoved();

                        return true;
                    }
                    return false;
                };

                /**
                 * Constructs the plugin.
                 * @param targetElement The element to which the plugin shall be applied.
                 * @param options The initial options of the plugin.
                 * @param extensions The extension(s) which shall be added right after the initialization.
                 * @returns {boolean} True if the plugin was successfully initialized, false otherwise.
                 */
                function construct(targetElement, options, extensions) {
                    _defaultOptions = globals.defaultOptions;
                    _nativeScrollbarStyling = globals.nativeScrollbarStyling;
                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
                    _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
                    _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
                    _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);

                    //parse & set options but don't update
                    setOptions(extendDeep({}, _defaultOptions, options));

                    _cssCalc = globals.cssCalc;
                    _msieVersion = globals.msie;
                    _autoUpdateRecommended = globals.autoUpdateRecommended;
                    _supportTransition = globals.supportTransition;
                    _supportTransform = globals.supportTransform;
                    _supportPassiveEvents = globals.supportPassiveEvents;
                    _supportResizeObserver = globals.supportResizeObserver;
                    _supportMutationObserver = globals.supportMutationObserver;
                    _restrictedMeasuring = globals.restrictedMeasuring;
                    _documentElement = FRAMEWORK(targetElement.ownerDocument);
                    _documentElementNative = _documentElement[0];
                    _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
                    _windowElementNative = _windowElement[0];
                    _htmlElement = findFirst(_documentElement, 'html');
                    _bodyElement = findFirst(_htmlElement, 'body');
                    _targetElement = FRAMEWORK(targetElement);
                    _targetElementNative = _targetElement[0];
                    _isTextarea = _targetElement.is('textarea');
                    _isBody = _targetElement.is('body');
                    _documentMixed = _documentElementNative !== document;

                    /* On a div Element The if checks only whether:
                     * - the targetElement has the class "os-host"
                     * - the targetElement has a a child with the class "os-padding"
                     * 
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-host" element is the targetElement)
                     *
                     *  <div class="os-host">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding">
                     *          <div class="os-viewport">
                     *              <div class="os-content"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     *
                     * =====================================================================================
                     * 
                     * On a Textarea Element The if checks only whether:
                     * - the targetElement has the class "os-textarea" 
                     * - the targetElement is inside a element with the class "os-content" 
                     * 
                     * If that's the case, its assumed the DOM has already the following structure:
                     * (The ".os-textarea" (textarea) element is the targetElement)
                     *
                     *  <div class="os-host-textarea">
                     *      <div class="os-resize-observer-host"></div>
                     *      <div class="os-padding os-text-inherit">
                     *          <div class="os-viewport os-text-inherit">
                     *              <div class="os-content os-text-inherit">
                     *                  <div class="os-textarea-cover"></div>
                     *                  <textarea class="os-textarea os-text-inherit"></textarea>
                     *              </div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-horizontal ">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar os-scrollbar-vertical">
                     *          <div class="os-scrollbar-track">
                     *              <div class="os-scrollbar-handle"></div>
                     *          </div>
                     *      </div>
                     *      <div class="os-scrollbar-corner"></div>
                     *  </div>
                     */
                    _domExists = _isTextarea
                        ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)
                        : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];

                    var initBodyScroll;
                    var bodyMouseTouchDownListener;

                    //check if the plugin hasn't to be initialized
                    if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
                        dispatchCallback('onInitializationWithdrawn');
                        if (_domExists) {
                            setupStructureDOM(true);
                            setupScrollbarsDOM(true);
                            setupScrollbarCornerDOM(true);
                        }

                        _destroyed = true;
                        _sleeping = true;

                        return _base;
                    }

                    if (_isBody) {
                        initBodyScroll = {};
                        initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
                        initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());

                        bodyMouseTouchDownListener = function () {
                            _viewportElement.removeAttr(LEXICON.ti);
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
                        }
                    }

                    //build OverlayScrollbars DOM
                    setupStructureDOM();
                    setupScrollbarsDOM();
                    setupScrollbarCornerDOM();

                    //create OverlayScrollbars events
                    setupStructureEvents();
                    setupScrollbarEvents(true);
                    setupScrollbarEvents(false);
                    setupScrollbarCornerEvents();

                    //create mutation observers
                    createMutationObservers();

                    //build resize observer for the host element
                    setupResizeObserver(_sizeObserverElement, hostOnResized);

                    if (_isBody) {
                        //apply the body scroll to handle it right in the update method
                        _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);

                        //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling
                        if (document.activeElement == targetElement && _viewportElementNative.focus) {
                            //set a tabindex to make the viewportElement focusable
                            _viewportElement.attr(LEXICON.ti, '-1');
                            _viewportElementNative.focus();

                            /* the tabindex has to be removed due to;
                             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too
                             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                             */
                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
                        }
                    }

                    //update for the first time & initialize cache
                    _base.update(_strAuto);

                    //the plugin is initialized now!
                    _initialized = true;
                    dispatchCallback('onInitialized');

                    //call all callbacks which would fire before the initialized was complete
                    each(_callbacksInitQeueue, function (index, value) { dispatchCallback(value.n, value.a); });
                    _callbacksInitQeueue = [];

                    //add extensions
                    if (type(extensions) == TYPES.s)
                        extensions = [extensions];
                    if (COMPATIBILITY.isA(extensions))
                        each(extensions, function (index, value) { _base.addExt(value); });
                    else if (FRAMEWORK.isPlainObject(extensions))
                        each(extensions, function (key, value) { _base.addExt(key, value); });

                    //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)
                    setTimeout(function () {
                        if (_supportTransition && !_destroyed)
                            addClass(_hostElement, _classNameHostTransition);
                    }, 333);

                    return _base;
                }

                if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
                    INSTANCES(pluginTargetElement, _base);
                }

                return _base;
            }

            /**
             * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.
             * @param pluginTargetElements The elements to which the Plugin shall be initialized.
             * @param options The custom options with which the plugin shall be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*}
             */
            _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {
                if (arguments[LEXICON.l] === 0)
                    return this;

                var arr = [];
                var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
                var inst;
                var result;

                //pluginTargetElements is null or undefined
                if (!pluginTargetElements)
                    return optsIsPlainObj || !options ? result : arr;

                /*
                   pluginTargetElements will be converted to:
                   1. A jQueryElement Array
                   2. A HTMLElement Array
                   3. A Array with a single HTML Element
                   so pluginTargetElements is always a array.
                */
                pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
                initOverlayScrollbarsStatics();

                if (pluginTargetElements[LEXICON.l] > 0) {
                    if (optsIsPlainObj) {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = v;
                            if (inst !== undefined)
                                arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
                        });
                    }
                    else {
                        FRAMEWORK.each(pluginTargetElements, function (i, v) {
                            inst = INSTANCES(v);
                            if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst)))
                                arr.push(inst);
                            else if (options === undefined)
                                arr.push(inst);
                        });
                    }
                    result = arr[LEXICON.l] === 1 ? arr[0] : arr;
                }
                return result;
            };

            /**
             * Returns a object which contains global information about the plugin and each instance of it.
             * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.
             */
            _plugin.globals = function () {
                initOverlayScrollbarsStatics();
                var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
                delete globals['msie'];
                return globals;
            };

            /**
             * Gets or Sets the default options for each new plugin initialization.
             * @param newDefaultOptions The object with which the default options shall be extended.
             */
            _plugin.defaultOptions = function (newDefaultOptions) {
                initOverlayScrollbarsStatics();
                var currDefaultOptions = _pluginsGlobals.defaultOptions;
                if (newDefaultOptions === undefined)
                    return FRAMEWORK.extend(true, {}, currDefaultOptions);

                //set the new default options
                _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
            };

            /**
             * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.
             * @param osInstance The potential OverlayScrollbars instance which shall be checked.
             * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.
             */
            _plugin.valid = function (osInstance) {
                return osInstance instanceof _plugin && !osInstance.getState().destroyed;
            };

            /**
             * Registers, Unregisters or returns a extension.
             * Register: Pass the name and the extension. (defaultOptions is optional)
             * Unregister: Pass the name and anything except a function as extension parameter.
             * Get extension: Pass the name of the extension which shall be got.
             * Get all extensions: Pass no arguments.
             * @param extensionName The name of the extension which shall be registered, unregistered or returned.
             * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.
             * @param defaultOptions The default options which shall be used for the registered extension.
             */
            _plugin.extension = function (extensionName, extension, defaultOptions) {
                var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
                var argLen = arguments[LEXICON.l];
                var i = 0;
                if (argLen < 1 || !extNameTypeString) {
                    //return a copy of all extension objects
                    return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);
                }
                else if (extNameTypeString) {
                    if (COMPATIBILITY.type(extension) == TYPES.f) {
                        //register extension
                        _pluginsExtensions.push({
                            name: extensionName,
                            extensionFactory: extension,
                            defaultOptions: defaultOptions
                        });
                    }
                    else {
                        for (; i < _pluginsExtensions[LEXICON.l]; i++) {
                            if (_pluginsExtensions[i].name === extensionName) {
                                if (argLen > 1)
                                    _pluginsExtensions.splice(i, 1); //remove extension
                                else
                                    return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name
                            }
                        }
                    }
                }
            };

            return _plugin;
        })();

        if (JQUERY && JQUERY.fn) {
            /**
             * The jQuery initialization interface.
             * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.
             * @param extensions The extension(s) which shall be added right after initialization.
             * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.
             */
            JQUERY.fn.overlayScrollbars = function (options, extensions) {
                var _elements = this;
                if (JQUERY.isPlainObject(options)) {
                    JQUERY.each(_elements, function () { PLUGIN(this, options, extensions); });
                    return _elements;
                }
                else
                    return PLUGIN(_elements, options);
            };
        }
        return PLUGIN;
    }
));

/***/ }),

/***/ "./node_modules/rc-drawer/es/DrawerChild.js":
/*!**************************************************!*\
  !*** ./node_modules/rc-drawer/es/DrawerChild.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var rc_util_es_getScrollBarSize__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rc-util/es/getScrollBarSize */ "./node_modules/rc-util/es/getScrollBarSize.js");
/* harmony import */ var rc_util_es_KeyCode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rc-util/es/KeyCode */ "./node_modules/rc-util/es/KeyCode.js");
/* harmony import */ var rc_util_es_omit__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rc-util/es/omit */ "./node_modules/rc-util/es/omit.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils */ "./node_modules/rc-drawer/es/utils.js");









var _excluded = ["className", "children", "style", "width", "height", "defaultOpen", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration", "getContainer", "handler", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "onClose", "onHandleClick", "keyboard", "getOpenCount", "scrollLocker", "contentWrapperStyle"];






var currentDrawer = {};

var DrawerChild = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_7__["default"])(DrawerChild, _React$Component);

  var _super = Object(_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_8__["default"])(DrawerChild);

  function DrawerChild(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, DrawerChild);

    _this = _super.call(this, props);
    _this.levelDom = void 0;
    _this.dom = void 0;
    _this.contentWrapper = void 0;
    _this.contentDom = void 0;
    _this.maskDom = void 0;
    _this.handlerDom = void 0;
    _this.drawerId = void 0;
    _this.timeout = void 0;
    _this.passive = void 0;
    _this.startPos = void 0;

    _this.domFocus = function () {
      if (_this.dom) {
        _this.dom.focus();
      }
    };

    _this.removeStartHandler = function (e) {
      if (e.touches.length > 1) {
        return;
      }

      _this.startPos = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      };
    };

    _this.removeMoveHandler = function (e) {
      if (e.changedTouches.length > 1) {
        return;
      }

      var currentTarget = e.currentTarget;
      var differX = e.changedTouches[0].clientX - _this.startPos.x;
      var differY = e.changedTouches[0].clientY - _this.startPos.y;

      if ((currentTarget === _this.maskDom || currentTarget === _this.handlerDom || currentTarget === _this.contentDom && Object(_utils__WEBPACK_IMPORTED_MODULE_14__["getTouchParentScroll"])(currentTarget, e.target, differX, differY)) && e.cancelable) {
        e.preventDefault();
      }
    };

    _this.transitionEnd = function (e) {
      var dom = e.target;
      Object(_utils__WEBPACK_IMPORTED_MODULE_14__["removeEventListener"])(dom, _utils__WEBPACK_IMPORTED_MODULE_14__["transitionEnd"], _this.transitionEnd);
      dom.style.transition = '';
    };

    _this.onKeyDown = function (e) {
      if (e.keyCode === rc_util_es_KeyCode__WEBPACK_IMPORTED_MODULE_12__["default"].ESC) {
        var onClose = _this.props.onClose;
        e.stopPropagation();

        if (onClose) {
          onClose(e);
        }
      }
    };

    _this.onWrapperTransitionEnd = function (e) {
      var _this$props = _this.props,
          open = _this$props.open,
          afterVisibleChange = _this$props.afterVisibleChange;

      if (e.target === _this.contentWrapper && e.propertyName.match(/transform$/)) {
        _this.dom.style.transition = '';

        if (!open && _this.getCurrentDrawerSome()) {
          document.body.style.overflowX = '';

          if (_this.maskDom) {
            _this.maskDom.style.left = '';
            _this.maskDom.style.width = '';
          }
        }

        if (afterVisibleChange) {
          afterVisibleChange(!!open);
        }
      }
    };

    _this.openLevelTransition = function () {
      var _this$props2 = _this.props,
          open = _this$props2.open,
          width = _this$props2.width,
          height = _this$props2.height;

      var _this$getHorizontalBo = _this.getHorizontalBoolAndPlacementName(),
          isHorizontal = _this$getHorizontalBo.isHorizontal,
          placementName = _this$getHorizontalBo.placementName;

      var contentValue = _this.contentDom ? _this.contentDom.getBoundingClientRect()[isHorizontal ? 'width' : 'height'] : 0;
      var value = (isHorizontal ? width : height) || contentValue;

      _this.setLevelAndScrolling(open, placementName, value);
    };

    _this.setLevelTransform = function (open, placementName, value, right) {
      var _this$props3 = _this.props,
          placement = _this$props3.placement,
          levelMove = _this$props3.levelMove,
          duration = _this$props3.duration,
          ease = _this$props3.ease,
          showMask = _this$props3.showMask; // router 

      _this.levelDom.forEach(function (dom) {
        dom.style.transition = "transform ".concat(duration, " ").concat(ease);
        Object(_utils__WEBPACK_IMPORTED_MODULE_14__["addEventListener"])(dom, _utils__WEBPACK_IMPORTED_MODULE_14__["transitionEnd"], _this.transitionEnd);
        var levelValue = open ? value : 0;

        if (levelMove) {
          var $levelMove = Object(_utils__WEBPACK_IMPORTED_MODULE_14__["transformArguments"])(levelMove, {
            target: dom,
            open: open
          });
          levelValue = open ? $levelMove[0] : $levelMove[1] || 0;
        }

        var $value = typeof levelValue === 'number' ? "".concat(levelValue, "px") : levelValue;
        var placementPos = placement === 'left' || placement === 'top' ? $value : "-".concat($value);
        placementPos = showMask && placement === 'right' && right ? "calc(".concat(placementPos, " + ").concat(right, "px)") : placementPos;
        dom.style.transform = levelValue ? "".concat(placementName, "(").concat(placementPos, ")") : '';
      });
    };

    _this.setLevelAndScrolling = function (open, placementName, value) {
      var onChange = _this.props.onChange;

      if (!_utils__WEBPACK_IMPORTED_MODULE_14__["windowIsUndefined"]) {
        var right = document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth ? Object(rc_util_es_getScrollBarSize__WEBPACK_IMPORTED_MODULE_11__["default"])(true) : 0;

        _this.setLevelTransform(open, placementName, value, right);

        _this.toggleScrollingToDrawerAndBody(right);
      }

      if (onChange) {
        onChange(open);
      }
    };

    _this.toggleScrollingToDrawerAndBody = function (right) {
      var _this$props4 = _this.props,
          getContainer = _this$props4.getContainer,
          showMask = _this$props4.showMask,
          open = _this$props4.open;
      var container = getContainer && getContainer(); //  body 

      if (container && container.parentNode === document.body && showMask) {
        var eventArray = ['touchstart'];
        var domArray = [document.body, _this.maskDom, _this.handlerDom, _this.contentDom];

        if (open && document.body.style.overflow !== 'hidden') {
          if (right) {
            _this.addScrollingEffect(right);
          }

          document.body.style.touchAction = 'none'; // 

          domArray.forEach(function (item, i) {
            if (!item) {
              return;
            }

            Object(_utils__WEBPACK_IMPORTED_MODULE_14__["addEventListener"])(item, eventArray[i] || 'touchmove', i ? _this.removeMoveHandler : _this.removeStartHandler, _this.passive);
          });
        } else if (_this.getCurrentDrawerSome()) {
          document.body.style.touchAction = '';

          if (right) {
            _this.remScrollingEffect(right);
          } // 


          domArray.forEach(function (item, i) {
            if (!item) {
              return;
            }

            Object(_utils__WEBPACK_IMPORTED_MODULE_14__["removeEventListener"])(item, eventArray[i] || 'touchmove', i ? _this.removeMoveHandler : _this.removeStartHandler, _this.passive);
          });
        }
      }
    };

    _this.addScrollingEffect = function (right) {
      var _this$props5 = _this.props,
          placement = _this$props5.placement,
          duration = _this$props5.duration,
          ease = _this$props5.ease;
      var widthTransition = "width ".concat(duration, " ").concat(ease);
      var transformTransition = "transform ".concat(duration, " ").concat(ease);
      _this.dom.style.transition = 'none';

      switch (placement) {
        case 'right':
          _this.dom.style.transform = "translateX(-".concat(right, "px)");
          break;

        case 'top':
        case 'bottom':
          _this.dom.style.width = "calc(100% - ".concat(right, "px)");
          _this.dom.style.transform = 'translateZ(0)';
          break;

        default:
          break;
      }

      clearTimeout(_this.timeout);
      _this.timeout = setTimeout(function () {
        if (_this.dom) {
          _this.dom.style.transition = "".concat(transformTransition, ",").concat(widthTransition);
          _this.dom.style.width = '';
          _this.dom.style.transform = '';
        }
      });
    };

    _this.remScrollingEffect = function (right) {
      var _this$props6 = _this.props,
          placement = _this$props6.placement,
          duration = _this$props6.duration,
          ease = _this$props6.ease;

      if (_utils__WEBPACK_IMPORTED_MODULE_14__["transitionStr"]) {
        document.body.style.overflowX = 'hidden';
      }

      _this.dom.style.transition = 'none';
      var heightTransition;
      var widthTransition = "width ".concat(duration, " ").concat(ease);
      var transformTransition = "transform ".concat(duration, " ").concat(ease);

      switch (placement) {
        case 'left':
          {
            _this.dom.style.width = '100%';
            widthTransition = "width 0s ".concat(ease, " ").concat(duration);
            break;
          }

        case 'right':
          {
            _this.dom.style.transform = "translateX(".concat(right, "px)");
            _this.dom.style.width = '100%';
            widthTransition = "width 0s ".concat(ease, " ").concat(duration);

            if (_this.maskDom) {
              _this.maskDom.style.left = "-".concat(right, "px");
              _this.maskDom.style.width = "calc(100% + ".concat(right, "px)");
            }

            break;
          }

        case 'top':
        case 'bottom':
          {
            _this.dom.style.width = "calc(100% + ".concat(right, "px)");
            _this.dom.style.height = '100%';
            _this.dom.style.transform = 'translateZ(0)';
            heightTransition = "height 0s ".concat(ease, " ").concat(duration);
            break;
          }

        default:
          break;
      }

      clearTimeout(_this.timeout);
      _this.timeout = setTimeout(function () {
        if (_this.dom) {
          _this.dom.style.transition = "".concat(transformTransition, ",").concat(heightTransition ? "".concat(heightTransition, ",") : '').concat(widthTransition);
          _this.dom.style.transform = '';
          _this.dom.style.width = '';
          _this.dom.style.height = '';
        }
      });
    };

    _this.getCurrentDrawerSome = function () {
      return !Object.keys(currentDrawer).some(function (key) {
        return currentDrawer[key];
      });
    };

    _this.getLevelDom = function (_ref) {
      var level = _ref.level,
          getContainer = _ref.getContainer;

      if (_utils__WEBPACK_IMPORTED_MODULE_14__["windowIsUndefined"]) {
        return;
      }

      var container = getContainer && getContainer();
      var parent = container ? container.parentNode : null;
      _this.levelDom = [];

      if (level === 'all') {
        var children = parent ? Array.prototype.slice.call(parent.children) : [];
        children.forEach(function (child) {
          if (child.nodeName !== 'SCRIPT' && child.nodeName !== 'STYLE' && child.nodeName !== 'LINK' && child !== container) {
            _this.levelDom.push(child);
          }
        });
      } else if (level) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_14__["dataToArray"])(level).forEach(function (key) {
          document.querySelectorAll(key).forEach(function (item) {
            _this.levelDom.push(item);
          });
        });
      }
    };

    _this.getHorizontalBoolAndPlacementName = function () {
      var placement = _this.props.placement;
      var isHorizontal = placement === 'left' || placement === 'right';
      var placementName = "translate".concat(isHorizontal ? 'X' : 'Y');
      return {
        isHorizontal: isHorizontal,
        placementName: placementName
      };
    };

    _this.state = {
      _self: Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_6__["default"])(_this)
    };
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(DrawerChild, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      if (!_utils__WEBPACK_IMPORTED_MODULE_14__["windowIsUndefined"]) {
        var passiveSupported = false;

        try {
          window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
            get: function get() {
              passiveSupported = true;
              return null;
            }
          }));
        } catch (err) {}

        this.passive = passiveSupported ? {
          passive: false
        } : false;
      }

      var _this$props7 = this.props,
          open = _this$props7.open,
          getContainer = _this$props7.getContainer,
          showMask = _this$props7.showMask,
          autoFocus = _this$props7.autoFocus;
      var container = getContainer && getContainer();
      this.drawerId = "drawer_id_".concat(Number((Date.now() + Math.random()).toString().replace('.', Math.round(Math.random() * 9).toString())).toString(16));
      this.getLevelDom(this.props);

      if (open) {
        if (container && container.parentNode === document.body) {
          currentDrawer[this.drawerId] = open;
        } //  level;


        this.openLevelTransition();
        this.forceUpdate(function () {
          if (autoFocus) {
            _this2.domFocus();
          }
        });

        if (showMask) {
          var _this$props$scrollLoc;

          (_this$props$scrollLoc = this.props.scrollLocker) === null || _this$props$scrollLoc === void 0 ? void 0 : _this$props$scrollLoc.lock();
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props8 = this.props,
          open = _this$props8.open,
          getContainer = _this$props8.getContainer,
          scrollLocker = _this$props8.scrollLocker,
          showMask = _this$props8.showMask,
          autoFocus = _this$props8.autoFocus;
      var container = getContainer && getContainer();

      if (open !== prevProps.open) {
        if (container && container.parentNode === document.body) {
          currentDrawer[this.drawerId] = !!open;
        }

        this.openLevelTransition();

        if (open) {
          if (autoFocus) {
            this.domFocus();
          }

          if (showMask) {
            scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.lock();
          }
        } else {
          scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.unLock();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props9 = this.props,
          open = _this$props9.open,
          scrollLocker = _this$props9.scrollLocker;
      delete currentDrawer[this.drawerId];

      if (open) {
        this.setLevelTransform(false);
        document.body.style.touchAction = '';
      }

      scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.unLock();
    }
  }, {
    key: "render",
    value: // tslint:disable-next-line:member-ordering
    function render() {
      var _classnames,
          _this3 = this;

      var _this$props10 = this.props,
          className = _this$props10.className,
          children = _this$props10.children,
          style = _this$props10.style,
          width = _this$props10.width,
          height = _this$props10.height,
          defaultOpen = _this$props10.defaultOpen,
          $open = _this$props10.open,
          prefixCls = _this$props10.prefixCls,
          placement = _this$props10.placement,
          level = _this$props10.level,
          levelMove = _this$props10.levelMove,
          ease = _this$props10.ease,
          duration = _this$props10.duration,
          getContainer = _this$props10.getContainer,
          handler = _this$props10.handler,
          onChange = _this$props10.onChange,
          afterVisibleChange = _this$props10.afterVisibleChange,
          showMask = _this$props10.showMask,
          maskClosable = _this$props10.maskClosable,
          maskStyle = _this$props10.maskStyle,
          onClose = _this$props10.onClose,
          onHandleClick = _this$props10.onHandleClick,
          keyboard = _this$props10.keyboard,
          getOpenCount = _this$props10.getOpenCount,
          scrollLocker = _this$props10.scrollLocker,
          contentWrapperStyle = _this$props10.contentWrapperStyle,
          props = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__["default"])(_this$props10, _excluded); // 


      var open = this.dom ? $open : false;
      var wrapperClassName = classnames__WEBPACK_IMPORTED_MODULE_10___default()(prefixCls, (_classnames = {}, Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(_classnames, "".concat(prefixCls, "-").concat(placement), true), Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(_classnames, "".concat(prefixCls, "-open"), open), Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(_classnames, className || '', !!className), Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(_classnames, 'no-mask', !showMask), _classnames));

      var _this$getHorizontalBo2 = this.getHorizontalBoolAndPlacementName(),
          placementName = _this$getHorizontalBo2.placementName; // 
      // const defaultValue = !this.contentDom || !level ? '100%' : `${value}px`;


      var placementPos = placement === 'left' || placement === 'top' ? '-100%' : '100%';
      var transform = open ? '' : "".concat(placementName, "(").concat(placementPos, ")");
      var handlerChildren = handler && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_9__["cloneElement"](handler, {
        onClick: function onClick(e) {
          if (handler.props.onClick) {
            handler.props.onClick();
          }

          if (onHandleClick) {
            onHandleClick(e);
          }
        },
        ref: function ref(c) {
          _this3.handlerDom = c;
        }
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_9__["createElement"]("div", Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, Object(rc_util_es_omit__WEBPACK_IMPORTED_MODULE_13__["default"])(props, ['switchScrollingEffect']), {
        tabIndex: -1,
        className: wrapperClassName,
        style: style,
        ref: function ref(c) {
          _this3.dom = c;
        },
        onKeyDown: open && keyboard ? this.onKeyDown : undefined,
        onTransitionEnd: this.onWrapperTransitionEnd
      }), showMask && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_9__["createElement"]("div", {
        className: "".concat(prefixCls, "-mask"),
        onClick: maskClosable ? onClose : undefined,
        style: maskStyle,
        ref: function ref(c) {
          _this3.maskDom = c;
        }
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_9__["createElement"]("div", {
        className: "".concat(prefixCls, "-content-wrapper"),
        style: Object(_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_1__["default"])({
          transform: transform,
          msTransform: transform,
          width: Object(_utils__WEBPACK_IMPORTED_MODULE_14__["isNumeric"])(width) ? "".concat(width, "px") : width,
          height: Object(_utils__WEBPACK_IMPORTED_MODULE_14__["isNumeric"])(height) ? "".concat(height, "px") : height
        }, contentWrapperStyle),
        ref: function ref(c) {
          _this3.contentWrapper = c;
        }
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_9__["createElement"]("div", {
        className: "".concat(prefixCls, "-content"),
        ref: function ref(c) {
          _this3.contentDom = c;
        },
        onTouchStart: open && showMask ? this.removeStartHandler : undefined // 
        ,
        onTouchMove: open && showMask ? this.removeMoveHandler : undefined // 

      }, children), handlerChildren));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, _ref2) {
      var prevProps = _ref2.prevProps,
          _self = _ref2._self;
      var nextState = {
        prevProps: props
      };

      if (prevProps !== undefined) {
        var placement = props.placement,
            level = props.level;

        if (placement !== prevProps.placement) {
          // test  bug,  dom
          _self.contentDom = null;
        }

        if (level !== prevProps.level) {
          _self.getLevelDom(props);
        }
      }

      return nextState;
    }
  }]);

  return DrawerChild;
}(react__WEBPACK_IMPORTED_MODULE_9__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (DrawerChild);

/***/ }),

/***/ "./node_modules/rc-drawer/es/DrawerWrapper.js":
/*!****************************************************!*\
  !*** ./node_modules/rc-drawer/es/DrawerWrapper.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
/* harmony import */ var rc_util_es_PortalWrapper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rc-util/es/PortalWrapper */ "./node_modules/rc-util/es/PortalWrapper.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _DrawerChild__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DrawerChild */ "./node_modules/rc-drawer/es/DrawerChild.js");






var _excluded = ["defaultOpen", "getContainer", "wrapperClassName", "forceRender", "handler"],
    _excluded2 = ["visible", "afterClose"];




var DrawerWrapper = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(DrawerWrapper, _React$Component);

  var _super = Object(_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_5__["default"])(DrawerWrapper);

  function DrawerWrapper(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, DrawerWrapper);

    _this = _super.call(this, props);
    _this.dom = void 0;

    _this.onHandleClick = function (e) {
      var _this$props = _this.props,
          onHandleClick = _this$props.onHandleClick,
          $open = _this$props.open;

      if (onHandleClick) {
        onHandleClick(e);
      }

      if (typeof $open === 'undefined') {
        var open = _this.state.open;

        _this.setState({
          open: !open
        });
      }
    };

    _this.onClose = function (e) {
      var _this$props2 = _this.props,
          onClose = _this$props2.onClose,
          open = _this$props2.open;

      if (onClose) {
        onClose(e);
      }

      if (typeof open === 'undefined') {
        _this.setState({
          open: false
        });
      }
    };

    var _open = typeof props.open !== 'undefined' ? props.open : !!props.defaultOpen;

    _this.state = {
      open: _open
    };

    if ('onMaskClick' in props) {
      console.warn('`onMaskClick` are removed, please use `onClose` instead.');
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(DrawerWrapper, [{
    key: "render",
    value: // tslint:disable-next-line:member-ordering
    function render() {
      var _this2 = this;

      var _this$props3 = this.props,
          defaultOpen = _this$props3.defaultOpen,
          getContainer = _this$props3.getContainer,
          wrapperClassName = _this$props3.wrapperClassName,
          forceRender = _this$props3.forceRender,
          handler = _this$props3.handler,
          props = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_this$props3, _excluded);

      var open = this.state.open; //  dom 

      if (!getContainer) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7__["createElement"]("div", {
          className: wrapperClassName,
          ref: function ref(c) {
            _this2.dom = c;
          }
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7__["createElement"](_DrawerChild__WEBPACK_IMPORTED_MODULE_8__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
          open: open,
          handler: handler,
          getContainer: function getContainer() {
            return _this2.dom;
          },
          onClose: this.onClose,
          onHandleClick: this.onHandleClick
        })));
      } //  handler 


      var $forceRender = !!handler || forceRender;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7__["createElement"](rc_util_es_PortalWrapper__WEBPACK_IMPORTED_MODULE_6__["default"], {
        visible: open,
        forceRender: $forceRender,
        getContainer: getContainer,
        wrapperClassName: wrapperClassName
      }, function (_ref) {
        var visible = _ref.visible,
            afterClose = _ref.afterClose,
            rest = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, _excluded2);

        return (
          /*#__PURE__*/
          // react 15componentWillUnmount  Portal  afterClose, visible.
          react__WEBPACK_IMPORTED_MODULE_7__["createElement"](_DrawerChild__WEBPACK_IMPORTED_MODULE_8__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, rest, {
            open: visible !== undefined ? visible : open,
            afterVisibleChange: afterClose !== undefined ? afterClose : props.afterVisibleChange,
            handler: handler,
            onClose: _this2.onClose,
            onHandleClick: _this2.onHandleClick
          }))
        );
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, _ref2) {
      var prevProps = _ref2.prevProps;
      var newState = {
        prevProps: props
      };

      if (typeof prevProps !== 'undefined' && props.open !== prevProps.open) {
        newState.open = props.open;
      }

      return newState;
    }
  }]);

  return DrawerWrapper;
}(react__WEBPACK_IMPORTED_MODULE_7__["Component"]);

DrawerWrapper.defaultProps = {
  prefixCls: 'drawer',
  placement: 'left',
  getContainer: 'body',
  defaultOpen: false,
  level: 'all',
  duration: '.3s',
  ease: 'cubic-bezier(0.78, 0.14, 0.15, 0.86)',
  onChange: function onChange() {},
  afterVisibleChange: function afterVisibleChange() {},
  handler: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7__["createElement"]("div", {
    className: "drawer-handle"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_7__["createElement"]("i", {
    className: "drawer-handle-icon"
  })),
  showMask: true,
  maskClosable: true,
  maskStyle: {},
  wrapperClassName: '',
  className: '',
  keyboard: true,
  forceRender: false,
  autoFocus: true
};
/* harmony default export */ __webpack_exports__["default"] = (DrawerWrapper);

/***/ }),

/***/ "./node_modules/rc-drawer/es/index.js":
/*!********************************************!*\
  !*** ./node_modules/rc-drawer/es/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawerWrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DrawerWrapper */ "./node_modules/rc-drawer/es/DrawerWrapper.js");
// export this package's api

/* harmony default export */ __webpack_exports__["default"] = (_DrawerWrapper__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./node_modules/rc-drawer/es/utils.js":
/*!********************************************!*\
  !*** ./node_modules/rc-drawer/es/utils.js ***!
  \********************************************/
/*! exports provided: dataToArray, transitionStr, transitionEnd, addEventListener, removeEventListener, transformArguments, isNumeric, windowIsUndefined, getTouchParentScroll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataToArray", function() { return dataToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transitionStr", function() { return transitionStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transitionEnd", function() { return transitionEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEventListener", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeEventListener", function() { return removeEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformArguments", function() { return transformArguments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumeric", function() { return isNumeric; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windowIsUndefined", function() { return windowIsUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTouchParentScroll", function() { return getTouchParentScroll; });
function dataToArray(vars) {
  if (Array.isArray(vars)) {
    return vars;
  }

  return [vars];
}
var transitionEndObject = {
  transition: 'transitionend',
  WebkitTransition: 'webkitTransitionEnd',
  MozTransition: 'transitionend',
  OTransition: 'oTransitionEnd otransitionend'
};
var transitionStr = Object.keys(transitionEndObject).filter(function (key) {
  if (typeof document === 'undefined') {
    return false;
  }

  var html = document.getElementsByTagName('html')[0];
  return key in (html ? html.style : {});
})[0];
var transitionEnd = transitionEndObject[transitionStr];
function addEventListener(target, eventType, callback, options) {
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, options);
  } else if (target.attachEvent) {
    // tslint:disable-line
    target.attachEvent("on".concat(eventType), callback); // tslint:disable-line
  }
}
function removeEventListener(target, eventType, callback, options) {
  if (target.removeEventListener) {
    target.removeEventListener(eventType, callback, options);
  } else if (target.attachEvent) {
    // tslint:disable-line
    target.detachEvent("on".concat(eventType), callback); // tslint:disable-line
  }
}
function transformArguments(arg, cb) {
  var result = typeof arg === 'function' ? arg(cb) : arg;

  if (Array.isArray(result)) {
    if (result.length === 2) {
      return result;
    }

    return [result[0], result[1]];
  }

  return [result];
}
var isNumeric = function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};
var windowIsUndefined = !(typeof window !== 'undefined' && window.document && window.document.createElement);
var getTouchParentScroll = function getTouchParentScroll(root, currentTarget, differX, differY) {
  if (!currentTarget || currentTarget === document || currentTarget instanceof Document) {
    return false;
  } // root  drawer-content  overflow,  root  parent 


  if (currentTarget === root.parentNode) {
    return true;
  }

  var isY = Math.max(Math.abs(differX), Math.abs(differY)) === Math.abs(differY);
  var isX = Math.max(Math.abs(differX), Math.abs(differY)) === Math.abs(differX);
  var scrollY = currentTarget.scrollHeight - currentTarget.clientHeight;
  var scrollX = currentTarget.scrollWidth - currentTarget.clientWidth;
  var style = document.defaultView.getComputedStyle(currentTarget);
  var overflowY = style.overflowY === 'auto' || style.overflowY === 'scroll';
  var overflowX = style.overflowX === 'auto' || style.overflowX === 'scroll';
  var y = scrollY && overflowY;
  var x = scrollX && overflowX;

  if (isY && (!y || y && (currentTarget.scrollTop >= scrollY && differY < 0 || currentTarget.scrollTop <= 0 && differY > 0)) || isX && (!x || x && (currentTarget.scrollLeft >= scrollX && differX < 0 || currentTarget.scrollLeft <= 0 && differX > 0))) {
    return getTouchParentScroll(root, currentTarget.parentNode, differX, differY);
  }

  return false;
};

/***/ }),

/***/ "./node_modules/rc-util/es/Dom/canUseDom.js":
/*!**************************************************!*\
  !*** ./node_modules/rc-util/es/Dom/canUseDom.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return canUseDom; });
function canUseDom() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}

/***/ }),

/***/ "./node_modules/rc-util/es/Dom/scrollLocker.js":
/*!*****************************************************!*\
  !*** ./node_modules/rc-util/es/Dom/scrollLocker.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScrollLocker; });
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _getScrollBarSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getScrollBarSize */ "./node_modules/rc-util/es/getScrollBarSize.js");
/* harmony import */ var _setStyle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../setStyle */ "./node_modules/rc-util/es/setStyle.js");




var locks = [];
var scrollingEffectClassName = 'ant-scrolling-effect';
var scrollingEffectClassNameReg = new RegExp("".concat(scrollingEffectClassName), 'g');
var uuid = 0; // https://github.com/ant-design/ant-design/issues/19340
// https://github.com/ant-design/ant-design/issues/19332

var cacheStyle = new Map();

var ScrollLocker = function ScrollLocker(_options) {
  var _this = this;

  Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, ScrollLocker);

  this.lockTarget = void 0;
  this.options = void 0;

  this.getContainer = function () {
    var _this$options;

    return (_this$options = _this.options) === null || _this$options === void 0 ? void 0 : _this$options.container;
  };

  this.reLock = function (options) {
    var findLock = locks.find(function (_ref) {
      var target = _ref.target;
      return target === _this.lockTarget;
    });

    if (findLock) {
      _this.unLock();
    }

    _this.options = options;

    if (findLock) {
      findLock.options = options;

      _this.lock();
    }
  };

  this.lock = function () {
    var _this$options3;

    // If lockTarget exist return
    if (locks.some(function (_ref2) {
      var target = _ref2.target;
      return target === _this.lockTarget;
    })) {
      return;
    } // If same container effect, return


    if (locks.some(function (_ref3) {
      var _this$options2;

      var options = _ref3.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_this$options2 = _this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.container);
    })) {
      locks = [].concat(Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(locks), [{
        target: _this.lockTarget,
        options: _this.options
      }]);
      return;
    }

    var scrollBarSize = 0;
    var container = ((_this$options3 = _this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.container) || document.body;

    if (container === document.body && window.innerWidth - document.documentElement.clientWidth > 0 || container.scrollHeight > container.clientHeight) {
      scrollBarSize = Object(_getScrollBarSize__WEBPACK_IMPORTED_MODULE_2__["default"])();
    }

    var containerClassName = container.className;

    if (locks.filter(function (_ref4) {
      var _this$options4;

      var options = _ref4.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_this$options4 = _this.options) === null || _this$options4 === void 0 ? void 0 : _this$options4.container);
    }).length === 0) {
      cacheStyle.set(container, Object(_setStyle__WEBPACK_IMPORTED_MODULE_3__["default"])({
        width: scrollBarSize !== 0 ? "calc(100% - ".concat(scrollBarSize, "px)") : undefined,
        overflow: 'hidden',
        overflowX: 'hidden',
        overflowY: 'hidden'
      }, {
        element: container
      }));
    } // https://github.com/ant-design/ant-design/issues/19729


    if (!scrollingEffectClassNameReg.test(containerClassName)) {
      var addClassName = "".concat(containerClassName, " ").concat(scrollingEffectClassName);
      container.className = addClassName.trim();
    }

    locks = [].concat(Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(locks), [{
      target: _this.lockTarget,
      options: _this.options
    }]);
  };

  this.unLock = function () {
    var _this$options5;

    var findLock = locks.find(function (_ref5) {
      var target = _ref5.target;
      return target === _this.lockTarget;
    });
    locks = locks.filter(function (_ref6) {
      var target = _ref6.target;
      return target !== _this.lockTarget;
    });

    if (!findLock || locks.some(function (_ref7) {
      var _findLock$options;

      var options = _ref7.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_findLock$options = findLock.options) === null || _findLock$options === void 0 ? void 0 : _findLock$options.container);
    })) {
      return;
    } // Remove Effect


    var container = ((_this$options5 = _this.options) === null || _this$options5 === void 0 ? void 0 : _this$options5.container) || document.body;
    var containerClassName = container.className;
    if (!scrollingEffectClassNameReg.test(containerClassName)) return;
    Object(_setStyle__WEBPACK_IMPORTED_MODULE_3__["default"])(cacheStyle.get(container), {
      element: container
    });
    cacheStyle.delete(container);
    container.className = container.className.replace(scrollingEffectClassNameReg, '').trim();
  };

  // eslint-disable-next-line no-plusplus
  this.lockTarget = uuid++;
  this.options = _options;
};



/***/ }),

/***/ "./node_modules/rc-util/es/KeyCode.js":
/*!********************************************!*\
  !*** ./node_modules/rc-util/es/KeyCode.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,

  /**
   * BACKSPACE
   */
  BACKSPACE: 8,

  /**
   * TAB
   */
  TAB: 9,

  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,

  /**
   * ENTER
   */
  ENTER: 13,

  /**
   * SHIFT
   */
  SHIFT: 16,

  /**
   * CTRL
   */
  CTRL: 17,

  /**
   * ALT
   */
  ALT: 18,

  /**
   * PAUSE
   */
  PAUSE: 19,

  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,

  /**
   * ESC
   */
  ESC: 27,

  /**
   * SPACE
   */
  SPACE: 32,

  /**
   * PAGE_UP
   */
  PAGE_UP: 33,

  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,

  /**
   * END
   */
  END: 35,

  /**
   * HOME
   */
  HOME: 36,

  /**
   * LEFT
   */
  LEFT: 37,

  /**
   * UP
   */
  UP: 38,

  /**
   * RIGHT
   */
  RIGHT: 39,

  /**
   * DOWN
   */
  DOWN: 40,

  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,

  /**
   * INSERT
   */
  INSERT: 45,

  /**
   * DELETE
   */
  DELETE: 46,

  /**
   * ZERO
   */
  ZERO: 48,

  /**
   * ONE
   */
  ONE: 49,

  /**
   * TWO
   */
  TWO: 50,

  /**
   * THREE
   */
  THREE: 51,

  /**
   * FOUR
   */
  FOUR: 52,

  /**
   * FIVE
   */
  FIVE: 53,

  /**
   * SIX
   */
  SIX: 54,

  /**
   * SEVEN
   */
  SEVEN: 55,

  /**
   * EIGHT
   */
  EIGHT: 56,

  /**
   * NINE
   */
  NINE: 57,

  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,

  /**
   * A
   */
  A: 65,

  /**
   * B
   */
  B: 66,

  /**
   * C
   */
  C: 67,

  /**
   * D
   */
  D: 68,

  /**
   * E
   */
  E: 69,

  /**
   * F
   */
  F: 70,

  /**
   * G
   */
  G: 71,

  /**
   * H
   */
  H: 72,

  /**
   * I
   */
  I: 73,

  /**
   * J
   */
  J: 74,

  /**
   * K
   */
  K: 75,

  /**
   * L
   */
  L: 76,

  /**
   * M
   */
  M: 77,

  /**
   * N
   */
  N: 78,

  /**
   * O
   */
  O: 79,

  /**
   * P
   */
  P: 80,

  /**
   * Q
   */
  Q: 81,

  /**
   * R
   */
  R: 82,

  /**
   * S
   */
  S: 83,

  /**
   * T
   */
  T: 84,

  /**
   * U
   */
  U: 85,

  /**
   * V
   */
  V: 86,

  /**
   * W
   */
  W: 87,

  /**
   * X
   */
  X: 88,

  /**
   * Y
   */
  Y: 89,

  /**
   * Z
   */
  Z: 90,

  /**
   * META
   */
  META: 91,

  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,

  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,

  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,

  /**
   * NUM_ONE
   */
  NUM_ONE: 97,

  /**
   * NUM_TWO
   */
  NUM_TWO: 98,

  /**
   * NUM_THREE
   */
  NUM_THREE: 99,

  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,

  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,

  /**
   * NUM_SIX
   */
  NUM_SIX: 102,

  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,

  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,

  /**
   * NUM_NINE
   */
  NUM_NINE: 105,

  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,

  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,

  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,

  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,

  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,

  /**
   * F1
   */
  F1: 112,

  /**
   * F2
   */
  F2: 113,

  /**
   * F3
   */
  F3: 114,

  /**
   * F4
   */
  F4: 115,

  /**
   * F5
   */
  F5: 116,

  /**
   * F6
   */
  F6: 117,

  /**
   * F7
   */
  F7: 118,

  /**
   * F8
   */
  F8: 119,

  /**
   * F9
   */
  F9: 120,

  /**
   * F10
   */
  F10: 121,

  /**
   * F11
   */
  F11: 122,

  /**
   * F12
   */
  F12: 123,

  /**
   * NUMLOCK
   */
  NUMLOCK: 144,

  /**
   * SEMICOLON
   */
  SEMICOLON: 186,

  /**
   * DASH
   */
  DASH: 189,

  /**
   * EQUALS
   */
  EQUALS: 187,

  /**
   * COMMA
   */
  COMMA: 188,

  /**
   * PERIOD
   */
  PERIOD: 190,

  /**
   * SLASH
   */
  SLASH: 191,

  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,

  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,

  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,

  /**
   * BACKSLASH
   */
  BACKSLASH: 220,

  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,

  /**
   * WIN_KEY
   */
  WIN_KEY: 224,

  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,

  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================

  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;

    if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    } // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.


    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;

      default:
        return true;
    }
  },

  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }

    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }

    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    } // Safari sends zero key code for non-latin characters.


    if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }

    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;

      default:
        return false;
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (KeyCode);

/***/ }),

/***/ "./node_modules/rc-util/es/Portal.js":
/*!*******************************************!*\
  !*** ./node_modules/rc-util/es/Portal.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Dom_canUseDom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dom/canUseDom */ "./node_modules/rc-util/es/Dom/canUseDom.js");



var Portal = /*#__PURE__*/Object(react__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(function (props, ref) {
  var didUpdate = props.didUpdate,
      getContainer = props.getContainer,
      children = props.children;
  var containerRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(); // Ref return nothing, only for wrapper check exist

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"])(ref, function () {
    return {};
  }); // Create container in client side with sync to avoid useEffect not get ref

  var initRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(false);

  if (!initRef.current && Object(_Dom_canUseDom__WEBPACK_IMPORTED_MODULE_2__["default"])()) {
    containerRef.current = getContainer();
    initRef.current = true;
  } // [Legacy] Used by `rc-trigger`


  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    return function () {
      var _containerRef$current, _containerRef$current2;

      // [Legacy] This should not be handle by Portal but parent PortalWrapper instead.
      // Since some component use `Portal` directly, we have to keep the logic here.
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /*#__PURE__*/react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.createPortal(children, containerRef.current) : null;
});
/* harmony default export */ __webpack_exports__["default"] = (Portal);

/***/ }),

/***/ "./node_modules/rc-util/es/PortalWrapper.js":
/*!**************************************************!*\
  !*** ./node_modules/rc-util/es/PortalWrapper.js ***!
  \**************************************************/
/*! exports provided: getOpenCount, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOpenCount", function() { return getOpenCount; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js");
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _raf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./raf */ "./node_modules/rc-util/es/raf.js");
/* harmony import */ var _Portal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Portal */ "./node_modules/rc-util/es/Portal.js");
/* harmony import */ var _Dom_canUseDom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Dom/canUseDom */ "./node_modules/rc-util/es/Dom/canUseDom.js");
/* harmony import */ var _switchScrollingEffect__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./switchScrollingEffect */ "./node_modules/rc-util/es/switchScrollingEffect.js");
/* harmony import */ var _setStyle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./setStyle */ "./node_modules/rc-util/es/setStyle.js");
/* harmony import */ var _Dom_scrollLocker__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Dom/scrollLocker */ "./node_modules/rc-util/es/Dom/scrollLocker.js");






/* eslint-disable no-underscore-dangle,react/require-default-props */







var openCount = 0;
var supportDom = Object(_Dom_canUseDom__WEBPACK_IMPORTED_MODULE_8__["default"])();
/** @private Test usage only */

function getOpenCount() {
  return  false ? undefined : 0;
} // https://github.com/ant-design/ant-design/issues/19340
// https://github.com/ant-design/ant-design/issues/19332

var cacheOverflow = {};

var getParent = function getParent(getContainer) {
  if (!supportDom) {
    return null;
  }

  if (getContainer) {
    if (typeof getContainer === 'string') {
      return document.querySelectorAll(getContainer)[0];
    }

    if (typeof getContainer === 'function') {
      return getContainer();
    }

    if (Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_4__["default"])(getContainer) === 'object' && getContainer instanceof window.HTMLElement) {
      return getContainer;
    }
  }

  return document.body;
};

var PortalWrapper = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(PortalWrapper, _React$Component);

  var _super = Object(_babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_3__["default"])(PortalWrapper);

  function PortalWrapper(props) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, PortalWrapper);

    _this = _super.call(this, props);
    _this.container = void 0;
    _this.componentRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__["createRef"]();
    _this.rafId = void 0;
    _this.scrollLocker = void 0;
    _this.renderComponent = void 0;

    _this.updateScrollLocker = function (prevProps) {
      var _ref = prevProps || {},
          prevVisible = _ref.visible;

      var _this$props = _this.props,
          getContainer = _this$props.getContainer,
          visible = _this$props.visible;

      if (visible && visible !== prevVisible && supportDom && getParent(getContainer) !== _this.scrollLocker.getContainer()) {
        _this.scrollLocker.reLock({
          container: getParent(getContainer)
        });
      }
    };

    _this.updateOpenCount = function (prevProps) {
      var _ref2 = prevProps || {},
          prevVisible = _ref2.visible,
          prevGetContainer = _ref2.getContainer;

      var _this$props2 = _this.props,
          visible = _this$props2.visible,
          getContainer = _this$props2.getContainer; // Update count

      if (visible !== prevVisible && supportDom && getParent(getContainer) === document.body) {
        if (visible && !prevVisible) {
          openCount += 1;
        } else if (prevProps) {
          openCount -= 1;
        }
      } // Clean up container if needed


      var getContainerIsFunc = typeof getContainer === 'function' && typeof prevGetContainer === 'function';

      if (getContainerIsFunc ? getContainer.toString() !== prevGetContainer.toString() : getContainer !== prevGetContainer) {
        _this.removeCurrentContainer();
      }
    };

    _this.attachToParent = function () {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (force || _this.container && !_this.container.parentNode) {
        var parent = getParent(_this.props.getContainer);

        if (parent) {
          parent.appendChild(_this.container);
          return true;
        }

        return false;
      }

      return true;
    };

    _this.getContainer = function () {
      if (!supportDom) {
        return null;
      }

      if (!_this.container) {
        _this.container = document.createElement('div');

        _this.attachToParent(true);
      }

      _this.setWrapperClassName();

      return _this.container;
    };

    _this.setWrapperClassName = function () {
      var wrapperClassName = _this.props.wrapperClassName;

      if (_this.container && wrapperClassName && wrapperClassName !== _this.container.className) {
        _this.container.className = wrapperClassName;
      }
    };

    _this.removeCurrentContainer = function () {
      var _this$container, _this$container$paren;

      // Portal will remove from `parentNode`.
      // Let's handle this again to avoid refactor issue.
      (_this$container = _this.container) === null || _this$container === void 0 ? void 0 : (_this$container$paren = _this$container.parentNode) === null || _this$container$paren === void 0 ? void 0 : _this$container$paren.removeChild(_this.container);
    };

    _this.switchScrollingEffect = function () {
      if (openCount === 1 && !Object.keys(cacheOverflow).length) {
        Object(_switchScrollingEffect__WEBPACK_IMPORTED_MODULE_9__["default"])(); // Must be set after switchScrollingEffect

        cacheOverflow = Object(_setStyle__WEBPACK_IMPORTED_MODULE_10__["default"])({
          overflow: 'hidden',
          overflowX: 'hidden',
          overflowY: 'hidden'
        });
      } else if (!openCount) {
        Object(_setStyle__WEBPACK_IMPORTED_MODULE_10__["default"])(cacheOverflow);
        cacheOverflow = {};
        Object(_switchScrollingEffect__WEBPACK_IMPORTED_MODULE_9__["default"])(true);
      }
    };

    _this.scrollLocker = new _Dom_scrollLocker__WEBPACK_IMPORTED_MODULE_11__["default"]({
      container: getParent(props.getContainer)
    });
    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(PortalWrapper, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.updateOpenCount();

      if (!this.attachToParent()) {
        this.rafId = Object(_raf__WEBPACK_IMPORTED_MODULE_6__["default"])(function () {
          _this2.forceUpdate();
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.updateOpenCount(prevProps);
      this.updateScrollLocker(prevProps);
      this.setWrapperClassName();
      this.attachToParent();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props3 = this.props,
          visible = _this$props3.visible,
          getContainer = _this$props3.getContainer;

      if (supportDom && getParent(getContainer) === document.body) {
        //  render  func 
        openCount = visible && openCount ? openCount - 1 : openCount;
      }

      this.removeCurrentContainer();
      _raf__WEBPACK_IMPORTED_MODULE_6__["default"].cancel(this.rafId);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props,
          children = _this$props4.children,
          forceRender = _this$props4.forceRender,
          visible = _this$props4.visible;
      var portal = null;
      var childProps = {
        getOpenCount: function getOpenCount() {
          return openCount;
        },
        getContainer: this.getContainer,
        switchScrollingEffect: this.switchScrollingEffect,
        scrollLocker: this.scrollLocker
      };

      if (forceRender || visible || this.componentRef.current) {
        portal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5__["createElement"](_Portal__WEBPACK_IMPORTED_MODULE_7__["default"], {
          getContainer: this.getContainer,
          ref: this.componentRef
        }, children(childProps));
      }

      return portal;
    }
  }]);

  return PortalWrapper;
}(react__WEBPACK_IMPORTED_MODULE_5__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (PortalWrapper);

/***/ }),

/***/ "./node_modules/rc-util/es/getScrollBarSize.js":
/*!*****************************************************!*\
  !*** ./node_modules/rc-util/es/getScrollBarSize.js ***!
  \*****************************************************/
/*! exports provided: default, getTargetScrollBarSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getScrollBarSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTargetScrollBarSize", function() { return getTargetScrollBarSize; });
/* eslint-disable no-param-reassign */
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === 'undefined') {
    return 0;
  }

  if (fresh || cached === undefined) {
    var inner = document.createElement('div');
    inner.style.width = '100%';
    inner.style.height = '200px';
    var outer = document.createElement('div');
    var outerStyle = outer.style;
    outerStyle.position = 'absolute';
    outerStyle.top = '0';
    outerStyle.left = '0';
    outerStyle.pointerEvents = 'none';
    outerStyle.visibility = 'hidden';
    outerStyle.width = '200px';
    outerStyle.height = '150px';
    outerStyle.overflow = 'hidden';
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var widthScroll = inner.offsetWidth;

    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }

    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }

  return cached;
}

function ensureSize(str) {
  var match = str.match(/^(.*)px$/);
  var value = Number(match === null || match === void 0 ? void 0 : match[1]);
  return Number.isNaN(value) ? getScrollBarSize() : value;
}

function getTargetScrollBarSize(target) {
  if (typeof document === 'undefined' || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }

  var _getComputedStyle = getComputedStyle(target, '::-webkit-scrollbar'),
      width = _getComputedStyle.width,
      height = _getComputedStyle.height;

  return {
    width: ensureSize(width),
    height: ensureSize(height)
  };
}

/***/ }),

/***/ "./node_modules/rc-util/es/omit.js":
/*!*****************************************!*\
  !*** ./node_modules/rc-util/es/omit.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return omit; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js");

function omit(obj, fields) {
  var clone = Object(_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__["default"])({}, obj);

  if (Array.isArray(fields)) {
    fields.forEach(function (key) {
      delete clone[key];
    });
  }

  return clone;
}

/***/ }),

/***/ "./node_modules/rc-util/es/raf.js":
/*!****************************************!*\
  !*** ./node_modules/rc-util/es/raf.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return wrapperRaf; });
var raf = function raf(callback) {
  return +setTimeout(callback, 16);
};

var caf = function caf(num) {
  return clearTimeout(num);
};

if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
  raf = function raf(callback) {
    return window.requestAnimationFrame(callback);
  };

  caf = function caf(handle) {
    return window.cancelAnimationFrame(handle);
  };
}

var rafUUID = 0;
var rafIds = new Map();

function cleanup(id) {
  rafIds.delete(id);
}

function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;

  function callRef(leftTimes) {
    if (leftTimes === 0) {
      // Clean up
      cleanup(id); // Trigger

      callback();
    } else {
      // Next raf
      var realId = raf(function () {
        callRef(leftTimes - 1);
      }); // Bind real raf id

      rafIds.set(id, realId);
    }
  }

  callRef(times);
  return id;
}

wrapperRaf.cancel = function (id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};

/***/ }),

/***/ "./node_modules/rc-util/es/setStyle.js":
/*!*********************************************!*\
  !*** ./node_modules/rc-util/es/setStyle.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Easy to set element style, return previous style
 * IE browser compatible(IE browser doesn't merge overflow style, need to set it separately)
 * https://github.com/ant-design/ant-design/issues/19393
 *
 */
function setStyle(style) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!style) {
    return {};
  }

  var _options$element = options.element,
      element = _options$element === void 0 ? document.body : _options$element;
  var oldStyle = {};
  var styleKeys = Object.keys(style); // IE browser compatible

  styleKeys.forEach(function (key) {
    oldStyle[key] = element.style[key];
  });
  styleKeys.forEach(function (key) {
    element.style[key] = style[key];
  });
  return oldStyle;
}

/* harmony default export */ __webpack_exports__["default"] = (setStyle);

/***/ }),

/***/ "./node_modules/rc-util/es/switchScrollingEffect.js":
/*!**********************************************************!*\
  !*** ./node_modules/rc-util/es/switchScrollingEffect.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getScrollBarSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollBarSize */ "./node_modules/rc-util/es/getScrollBarSize.js");
/* harmony import */ var _setStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setStyle */ "./node_modules/rc-util/es/setStyle.js");



function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}

var cacheStyle = {};
/* harmony default export */ __webpack_exports__["default"] = (function (close) {
  if (!isBodyOverflowing() && !close) {
    return;
  } // https://github.com/ant-design/ant-design/issues/19729


  var scrollingEffectClassName = 'ant-scrolling-effect';
  var scrollingEffectClassNameReg = new RegExp("".concat(scrollingEffectClassName), 'g');
  var bodyClassName = document.body.className;

  if (close) {
    if (!scrollingEffectClassNameReg.test(bodyClassName)) return;
    Object(_setStyle__WEBPACK_IMPORTED_MODULE_1__["default"])(cacheStyle);
    cacheStyle = {};
    document.body.className = bodyClassName.replace(scrollingEffectClassNameReg, '').trim();
    return;
  }

  var scrollBarSize = Object(_getScrollBarSize__WEBPACK_IMPORTED_MODULE_0__["default"])();

  if (scrollBarSize) {
    cacheStyle = Object(_setStyle__WEBPACK_IMPORTED_MODULE_1__["default"])({
      position: 'relative',
      width: "calc(100% - ".concat(scrollBarSize, "px)")
    });

    if (!scrollingEffectClassNameReg.test(bodyClassName)) {
      var addClassName = "".concat(bodyClassName, " ").concat(scrollingEffectClassName);
      document.body.className = addClassName.trim();
    }
  }
});

/***/ }),

/***/ "./node_modules/re-resizable/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/re-resizable/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var resizer_1 = __webpack_require__(/*! ./resizer */ "./node_modules/re-resizable/lib/resizer.js");
var fast_memoize_1 = __importDefault(__webpack_require__(/*! fast-memoize */ "./node_modules/fast-memoize/src/index.js"));
var DEFAULT_SIZE = {
    width: 'auto',
    height: 'auto',
};
var clamp = fast_memoize_1.default(function (n, min, max) { return Math.max(Math.min(n, max), min); });
var snap = fast_memoize_1.default(function (n, size) { return Math.round(n / size) * size; });
var hasDirection = fast_memoize_1.default(function (dir, target) { return new RegExp(dir, 'i').test(target); });
var findClosestSnap = fast_memoize_1.default(function (n, snapArray, snapGap) {
    if (snapGap === void 0) { snapGap = 0; }
    var closestGapIndex = snapArray.reduce(function (prev, curr, index) { return (Math.abs(curr - n) < Math.abs(snapArray[prev] - n) ? index : prev); }, 0);
    var gap = Math.abs(snapArray[closestGapIndex] - n);
    return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n;
});
var endsWith = fast_memoize_1.default(function (str, searchStr) {
    return str.substr(str.length - searchStr.length, searchStr.length) === searchStr;
});
var getStringSize = fast_memoize_1.default(function (n) {
    n = n.toString();
    if (n === 'auto') {
        return n;
    }
    if (endsWith(n, 'px')) {
        return n;
    }
    if (endsWith(n, '%')) {
        return n;
    }
    if (endsWith(n, 'vh')) {
        return n;
    }
    if (endsWith(n, 'vw')) {
        return n;
    }
    if (endsWith(n, 'vmax')) {
        return n;
    }
    if (endsWith(n, 'vmin')) {
        return n;
    }
    return n + "px";
});
var calculateNewMax = fast_memoize_1.default(function (parentSize, maxWidth, maxHeight, minWidth, minHeight) {
    if (maxWidth && typeof maxWidth === 'string' && endsWith(maxWidth, '%')) {
        var ratio = Number(maxWidth.replace('%', '')) / 100;
        maxWidth = parentSize.width * ratio;
    }
    if (maxHeight && typeof maxHeight === 'string' && endsWith(maxHeight, '%')) {
        var ratio = Number(maxHeight.replace('%', '')) / 100;
        maxHeight = parentSize.height * ratio;
    }
    if (minWidth && typeof minWidth === 'string' && endsWith(minWidth, '%')) {
        var ratio = Number(minWidth.replace('%', '')) / 100;
        minWidth = parentSize.width * ratio;
    }
    if (minHeight && typeof minHeight === 'string' && endsWith(minHeight, '%')) {
        var ratio = Number(minHeight.replace('%', '')) / 100;
        minHeight = parentSize.height * ratio;
    }
    return {
        maxWidth: typeof maxWidth === 'undefined' ? undefined : Number(maxWidth),
        maxHeight: typeof maxHeight === 'undefined' ? undefined : Number(maxHeight),
        minWidth: typeof minWidth === 'undefined' ? undefined : Number(minWidth),
        minHeight: typeof minHeight === 'undefined' ? undefined : Number(minHeight),
    };
});
var definedProps = [
    'style',
    'className',
    'grid',
    'snap',
    'bounds',
    'size',
    'defaultSize',
    'minWidth',
    'minHeight',
    'maxWidth',
    'maxHeight',
    'lockAspectRatio',
    'lockAspectRatioExtraWidth',
    'lockAspectRatioExtraHeight',
    'enable',
    'handleStyles',
    'handleClasses',
    'handleWrapperStyle',
    'handleWrapperClass',
    'children',
    'onResizeStart',
    'onResize',
    'onResizeStop',
    'handleComponent',
    'scale',
    'resizeRatio',
    'snapGap',
];
// HACK: This class is used to calculate % size.
var baseClassName = '__resizable_base__';
var Resizable = /** @class */ (function (_super) {
    __extends(Resizable, _super);
    function Resizable(props) {
        var _this = _super.call(this, props) || this;
        _this.ratio = 1;
        _this.resizable = null;
        _this.extendsProps = {};
        // For parent boundary
        _this.parentLeft = 0;
        _this.parentTop = 0;
        // For boundary
        _this.resizableLeft = 0;
        _this.resizableTop = 0;
        // For target boundary
        _this.targetLeft = 0;
        _this.targetTop = 0;
        _this.state = {
            isResizing: false,
            resizeCursor: 'auto',
            width: typeof (_this.propsSize && _this.propsSize.width) === 'undefined'
                ? 'auto'
                : _this.propsSize && _this.propsSize.width,
            height: typeof (_this.propsSize && _this.propsSize.height) === 'undefined'
                ? 'auto'
                : _this.propsSize && _this.propsSize.height,
            direction: 'right',
            original: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            },
        };
        _this.updateExtendsProps(props);
        _this.onResizeStart = _this.onResizeStart.bind(_this);
        _this.onMouseMove = _this.onMouseMove.bind(_this);
        _this.onMouseUp = _this.onMouseUp.bind(_this);
        if (typeof window !== 'undefined') {
            window.addEventListener('mouseup', _this.onMouseUp);
            window.addEventListener('mousemove', _this.onMouseMove);
            window.addEventListener('mouseleave', _this.onMouseUp);
            window.addEventListener('touchmove', _this.onMouseMove);
            window.addEventListener('touchend', _this.onMouseUp);
        }
        return _this;
    }
    Object.defineProperty(Resizable.prototype, "parentNode", {
        get: function () {
            if (!this.resizable) {
                return null;
            }
            return this.resizable.parentNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "propsSize", {
        get: function () {
            return this.props.size || this.props.defaultSize || DEFAULT_SIZE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "base", {
        get: function () {
            var parent = this.parentNode;
            if (!parent) {
                return undefined;
            }
            var children = [].slice.call(parent.children);
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var n = children_1[_i];
                if (n instanceof HTMLElement) {
                    if (n.classList.contains(baseClassName)) {
                        return n;
                    }
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "size", {
        get: function () {
            var width = 0;
            var height = 0;
            if (typeof window !== 'undefined' && this.resizable) {
                var orgWidth = this.resizable.offsetWidth;
                var orgHeight = this.resizable.offsetHeight;
                // HACK: Set position `relative` to get parent size.
                //       This is because when re-resizable set `absolute`, I can not get base width correctly.
                var orgPosition = this.resizable.style.position;
                if (orgPosition !== 'relative') {
                    this.resizable.style.position = 'relative';
                }
                // INFO: Use original width or height if set auto.
                width = this.resizable.style.width !== 'auto' ? this.resizable.offsetWidth : orgWidth;
                height = this.resizable.style.height !== 'auto' ? this.resizable.offsetHeight : orgHeight;
                // Restore original position
                this.resizable.style.position = orgPosition;
            }
            return { width: width, height: height };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Resizable.prototype, "sizeStyle", {
        get: function () {
            var _this = this;
            var size = this.props.size;
            var getSize = function (key) {
                if (typeof _this.state[key] === 'undefined' || _this.state[key] === 'auto') {
                    return 'auto';
                }
                if (_this.propsSize && _this.propsSize[key] && endsWith(_this.propsSize[key].toString(), '%')) {
                    if (endsWith(_this.state[key].toString(), '%')) {
                        return _this.state[key].toString();
                    }
                    var parentSize = _this.getParentSize();
                    var value = Number(_this.state[key].toString().replace('px', ''));
                    var percent = (value / parentSize[key]) * 100;
                    return percent + "%";
                }
                return getStringSize(_this.state[key]);
            };
            var width = size && typeof size.width !== 'undefined' && !this.state.isResizing
                ? getStringSize(size.width)
                : getSize('width');
            var height = size && typeof size.height !== 'undefined' && !this.state.isResizing
                ? getStringSize(size.height)
                : getSize('height');
            return { width: width, height: height };
        },
        enumerable: true,
        configurable: true
    });
    Resizable.prototype.updateExtendsProps = function (props) {
        this.extendsProps = Object.keys(props).reduce(function (acc, key) {
            if (definedProps.indexOf(key) !== -1) {
                return acc;
            }
            acc[key] = props[key];
            return acc;
        }, {});
    };
    Resizable.prototype.getParentSize = function () {
        if (!this.base || !this.parentNode) {
            return { width: window.innerWidth, height: window.innerHeight };
        }
        // INFO: To calculate parent width with flex layout
        var wrapChanged = false;
        var wrap = this.parentNode.style.flexWrap;
        var minWidth = this.base.style.minWidth;
        if (wrap !== 'wrap') {
            wrapChanged = true;
            this.parentNode.style.flexWrap = 'wrap';
            // HACK: Use relative to get parent padding size
        }
        this.base.style.position = 'relative';
        this.base.style.minWidth = '100%';
        var size = {
            width: this.base.offsetWidth,
            height: this.base.offsetHeight,
        };
        this.base.style.position = 'absolute';
        if (wrapChanged) {
            this.parentNode.style.flexWrap = wrap;
        }
        this.base.style.minWidth = minWidth;
        return size;
    };
    Resizable.prototype.componentDidMount = function () {
        this.setState({
            width: this.state.width || this.size.width,
            height: this.state.height || this.size.height,
        });
        var parent = this.parentNode;
        if (!(parent instanceof HTMLElement)) {
            return;
        }
        if (this.base) {
            return;
        }
        var element = document.createElement('div');
        element.style.width = '100%';
        element.style.height = '100%';
        element.style.position = 'absolute';
        element.style.transform = 'scale(0, 0)';
        element.style.left = '0';
        element.style.flex = '0';
        if (element.classList) {
            element.classList.add(baseClassName);
        }
        else {
            element.className += baseClassName;
        }
        parent.appendChild(element);
    };
    Resizable.prototype.componentWillReceiveProps = function (next) {
        this.updateExtendsProps(next);
    };
    Resizable.prototype.componentWillUnmount = function () {
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', this.onMouseUp);
            window.removeEventListener('mousemove', this.onMouseMove);
            window.removeEventListener('mouseleave', this.onMouseUp);
            window.removeEventListener('touchmove', this.onMouseMove);
            window.removeEventListener('touchend', this.onMouseUp);
            var parent_1 = this.parentNode;
            if (!this.base || !parent_1) {
                return;
            }
            if (!(parent_1 instanceof HTMLElement) || !(this.base instanceof Node)) {
                return;
            }
            parent_1.removeChild(this.base);
        }
    };
    Resizable.prototype.createSizeForCssProperty = function (newSize, kind) {
        var propsSize = this.propsSize && this.propsSize[kind];
        return this.state[kind] === 'auto' &&
            this.state.original[kind] === newSize &&
            (typeof propsSize === 'undefined' || propsSize === 'auto')
            ? 'auto'
            : newSize;
    };
    Resizable.prototype.calculateNewMaxFromBoundary = function (maxWidth, maxHeight) {
        if (this.props.bounds === 'parent') {
            var parent_2 = this.parentNode;
            if (parent_2 instanceof HTMLElement) {
                var boundWidth = parent_2.offsetWidth + (this.parentLeft - this.resizableLeft);
                var boundHeight = parent_2.offsetHeight + (this.parentTop - this.resizableTop);
                maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
                maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
            }
        }
        else if (this.props.bounds === 'window') {
            if (typeof window !== 'undefined') {
                var boundWidth = window.innerWidth - this.resizableLeft;
                var boundHeight = window.innerHeight - this.resizableTop;
                maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
                maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
            }
        }
        else if (this.props.bounds instanceof HTMLElement) {
            var boundWidth = this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
            var boundHeight = this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
            maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
            maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
        }
        return { maxWidth: maxWidth, maxHeight: maxHeight };
    };
    Resizable.prototype.calculateNewSizeFromDirection = function (clientX, clientY) {
        var scale = this.props.scale || 1;
        var resizeRatio = this.props.resizeRatio || 1;
        var _a = this.state, direction = _a.direction, original = _a.original;
        var _b = this.props, lockAspectRatio = _b.lockAspectRatio, lockAspectRatioExtraHeight = _b.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _b.lockAspectRatioExtraWidth;
        var newWidth = original.width;
        var newHeight = original.height;
        var extraHeight = lockAspectRatioExtraHeight || 0;
        var extraWidth = lockAspectRatioExtraWidth || 0;
        if (hasDirection('right', direction)) {
            newWidth = original.width + ((clientX - original.x) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
            }
        }
        if (hasDirection('left', direction)) {
            newWidth = original.width - ((clientX - original.x) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
            }
        }
        if (hasDirection('bottom', direction)) {
            newHeight = original.height + ((clientY - original.y) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
            }
        }
        if (hasDirection('top', direction)) {
            newHeight = original.height - ((clientY - original.y) * resizeRatio) / scale;
            if (lockAspectRatio) {
                newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
            }
        }
        return { newWidth: newWidth, newHeight: newHeight };
    };
    Resizable.prototype.calculateNewSizeFromAspectRatio = function (newWidth, newHeight, max, min) {
        var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;
        var computedMinWidth = typeof min.width === 'undefined' ? 10 : min.width;
        var computedMaxWidth = typeof max.width === 'undefined' || max.width < 0 ? newWidth : max.width;
        var computedMinHeight = typeof min.height === 'undefined' ? 10 : min.height;
        var computedMaxHeight = typeof max.height === 'undefined' || max.height < 0 ? newHeight : max.height;
        var extraHeight = lockAspectRatioExtraHeight || 0;
        var extraWidth = lockAspectRatioExtraWidth || 0;
        if (lockAspectRatio) {
            var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
            var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
            var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
            var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
            var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
            var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
            var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
            var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
            newWidth = clamp(newWidth, lockedMinWidth, lockedMaxWidth);
            newHeight = clamp(newHeight, lockedMinHeight, lockedMaxHeight);
        }
        else {
            newWidth = clamp(newWidth, computedMinWidth, computedMaxWidth);
            newHeight = clamp(newHeight, computedMinHeight, computedMaxHeight);
        }
        return { newWidth: newWidth, newHeight: newHeight };
    };
    Resizable.prototype.setBoundingClientRect = function () {
        // For parent boundary
        if (this.props.bounds === 'parent') {
            var parent_3 = this.parentNode;
            if (parent_3 instanceof HTMLElement) {
                var parentRect = parent_3.getBoundingClientRect();
                this.parentLeft = parentRect.left;
                this.parentTop = parentRect.top;
            }
        }
        // For target(html element) boundary
        if (this.props.bounds instanceof HTMLElement) {
            var targetRect = this.props.bounds.getBoundingClientRect();
            this.targetLeft = targetRect.left;
            this.targetTop = targetRect.top;
        }
        // For boundary
        if (this.resizable) {
            var _a = this.resizable.getBoundingClientRect(), left = _a.left, top_1 = _a.top;
            this.resizableLeft = left;
            this.resizableTop = top_1;
        }
    };
    Resizable.prototype.onResizeStart = function (event, direction) {
        var clientX = 0;
        var clientY = 0;
        if (event.nativeEvent instanceof MouseEvent) {
            clientX = event.nativeEvent.clientX;
            clientY = event.nativeEvent.clientY;
            // When user click with right button the resize is stuck in resizing mode
            // until users clicks again, dont continue if right click is used.
            // HACK: MouseEvent does not have `which` from flow-bin v0.68.
            if (event.nativeEvent.which === 3) {
                return;
            }
        }
        else if (event.nativeEvent instanceof TouchEvent) {
            clientX = event.nativeEvent.touches[0].clientX;
            clientY = event.nativeEvent.touches[0].clientY;
        }
        if (this.props.onResizeStart) {
            if (this.resizable) {
                this.props.onResizeStart(event, direction, this.resizable);
            }
        }
        // Fix #168
        if (this.props.size) {
            if (typeof this.props.size.height !== 'undefined' && this.props.size.height !== this.state.height) {
                this.setState({ height: this.props.size.height });
            }
            if (typeof this.props.size.width !== 'undefined' && this.props.size.width !== this.state.width) {
                this.setState({ width: this.props.size.width });
            }
        }
        // For lockAspectRatio case
        this.ratio =
            typeof this.props.lockAspectRatio === 'number' ? this.props.lockAspectRatio : this.size.width / this.size.height;
        // For boundary
        this.setBoundingClientRect();
        this.setState({
            original: {
                x: clientX,
                y: clientY,
                width: this.size.width,
                height: this.size.height,
            },
            isResizing: true,
            resizeCursor: window.getComputedStyle(event.target).cursor || 'auto',
            direction: direction,
        });
    };
    Resizable.prototype.onMouseMove = function (event) {
        if (!this.state.isResizing || !this.resizable) {
            return;
        }
        var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;
        var clientX = event instanceof MouseEvent ? event.clientX : event.touches[0].clientX;
        var clientY = event instanceof MouseEvent ? event.clientY : event.touches[0].clientY;
        var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;
        var parentSize = this.getParentSize();
        var max = calculateNewMax(parentSize, maxWidth, maxHeight, minWidth, minHeight);
        maxWidth = max.maxWidth;
        maxHeight = max.maxHeight;
        minWidth = max.minWidth;
        minHeight = max.minHeight;
        // Calculate new size
        var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
        // Calculate max size from boundary settings
        var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
        // Calculate new size from aspect ratio
        var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
        newWidth = newSize.newWidth;
        newHeight = newSize.newHeight;
        if (this.props.grid) {
            var newGridWidth = snap(newWidth, this.props.grid[0]);
            var newGridHeight = snap(newHeight, this.props.grid[1]);
            var gap = this.props.snapGap || 0;
            newWidth = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
            newHeight = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
        }
        if (this.props.snap && this.props.snap.x) {
            newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);
        }
        if (this.props.snap && this.props.snap.y) {
            newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);
        }
        var delta = {
            width: newWidth - original.width,
            height: newHeight - original.height,
        };
        if (width && typeof width === 'string') {
            if (endsWith(width, '%')) {
                var percent = (newWidth / parentSize.width) * 100;
                newWidth = percent + "%";
            }
            else if (endsWith(width, 'vw')) {
                var vw = (newWidth / window.innerWidth) * 100;
                newWidth = vw + "vw";
            }
            else if (endsWith(width, 'vh')) {
                var vh = (newWidth / window.innerHeight) * 100;
                newWidth = vh + "vh";
            }
        }
        if (height && typeof height === 'string') {
            if (endsWith(height, '%')) {
                var percent = (newHeight / parentSize.height) * 100;
                newHeight = percent + "%";
            }
            else if (endsWith(height, 'vw')) {
                var vw = (newHeight / window.innerWidth) * 100;
                newHeight = vw + "vw";
            }
            else if (endsWith(height, 'vh')) {
                var vh = (newHeight / window.innerHeight) * 100;
                newHeight = vh + "vh";
            }
        }
        this.setState({
            width: this.createSizeForCssProperty(newWidth, 'width'),
            height: this.createSizeForCssProperty(newHeight, 'height'),
        });
        if (this.props.onResize) {
            this.props.onResize(event, direction, this.resizable, delta);
        }
    };
    Resizable.prototype.onMouseUp = function (event) {
        var _a = this.state, isResizing = _a.isResizing, direction = _a.direction, original = _a.original;
        if (!isResizing || !this.resizable) {
            return;
        }
        var delta = {
            width: this.size.width - original.width,
            height: this.size.height - original.height,
        };
        if (this.props.onResizeStop) {
            this.props.onResizeStop(event, direction, this.resizable, delta);
        }
        if (this.props.size) {
            this.setState(this.props.size);
        }
        this.setState({ isResizing: false, resizeCursor: 'auto' });
    };
    Resizable.prototype.updateSize = function (size) {
        this.setState({ width: size.width, height: size.height });
    };
    Resizable.prototype.renderResizer = function () {
        var _this = this;
        var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;
        if (!enable) {
            return null;
        }
        var resizers = Object.keys(enable).map(function (dir) {
            if (enable[dir] !== false) {
                return (React.createElement(resizer_1.Resizer, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null));
            }
            return null;
        });
        // #93 Wrap the resize box in span (will not break 100% width/height)
        return (React.createElement("span", { className: handleWrapperClass, style: handleWrapperStyle }, resizers));
    };
    Resizable.prototype.render = function () {
        var _this = this;
        return (React.createElement("div", __assign({ ref: function (c) {
                if (c) {
                    _this.resizable = c;
                }
            }, style: __assign({ position: 'relative', userSelect: this.state.isResizing ? 'none' : 'auto' }, this.props.style, this.sizeStyle, { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: 'border-box' }), className: this.props.className }, this.extendsProps),
            this.state.isResizing && (React.createElement("div", { style: {
                    height: '100%',
                    width: '100%',
                    backgroundColor: 'rgba(0,0,0,0)',
                    cursor: "" + (this.state.resizeCursor || 'auto'),
                    opacity: 0,
                    position: 'fixed',
                    zIndex: 9999,
                    top: '0',
                    left: '0',
                    bottom: '0',
                    right: '0',
                } })),
            this.props.children,
            this.renderResizer()));
    };
    Resizable.defaultProps = {
        onResizeStart: function () { },
        onResize: function () { },
        onResizeStop: function () { },
        enable: {
            top: true,
            right: true,
            bottom: true,
            left: true,
            topRight: true,
            bottomRight: true,
            bottomLeft: true,
            topLeft: true,
        },
        style: {},
        grid: [1, 1],
        lockAspectRatio: false,
        lockAspectRatioExtraWidth: 0,
        lockAspectRatioExtraHeight: 0,
        scale: 1,
        resizeRatio: 1,
        snapGap: 0,
    };
    return Resizable;
}(React.Component));
exports.Resizable = Resizable;


/***/ }),

/***/ "./node_modules/re-resizable/lib/resizer.js":
/*!**************************************************!*\
  !*** ./node_modules/re-resizable/lib/resizer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var styles = {
    top: {
        width: '100%',
        height: '10px',
        top: '-5px',
        left: '0px',
        cursor: 'row-resize',
    },
    right: {
        width: '10px',
        height: '100%',
        top: '0px',
        right: '-5px',
        cursor: 'col-resize',
    },
    bottom: {
        width: '100%',
        height: '10px',
        bottom: '-5px',
        left: '0px',
        cursor: 'row-resize',
    },
    left: {
        width: '10px',
        height: '100%',
        top: '0px',
        left: '-5px',
        cursor: 'col-resize',
    },
    topRight: {
        width: '20px',
        height: '20px',
        position: 'absolute',
        right: '-10px',
        top: '-10px',
        cursor: 'ne-resize',
    },
    bottomRight: {
        width: '20px',
        height: '20px',
        position: 'absolute',
        right: '-10px',
        bottom: '-10px',
        cursor: 'se-resize',
    },
    bottomLeft: {
        width: '20px',
        height: '20px',
        position: 'absolute',
        left: '-10px',
        bottom: '-10px',
        cursor: 'sw-resize',
    },
    topLeft: {
        width: '20px',
        height: '20px',
        position: 'absolute',
        left: '-10px',
        top: '-10px',
        cursor: 'nw-resize',
    },
};
function Resizer(props) {
    return (React.createElement("div", { className: props.className || '', style: __assign({ position: 'absolute', userSelect: 'none' }, styles[props.direction], (props.replaceStyles || {})), onMouseDown: function (e) {
            props.onResizeStart(e, props.direction);
        }, onTouchStart: function (e) {
            props.onResizeStart(e, props.direction);
        } }, props.children));
}
exports.Resizer = Resizer;


/***/ }),

/***/ "./node_modules/react-device-detect/main.js":
/*!**************************************************!*\
  !*** ./node_modules/react-device-detect/main.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var React__default = _interopDefault(React);

var UAParser = __webpack_require__(/*! ua-parser-js/dist/ua-parser.min */ "./node_modules/ua-parser-js/dist/ua-parser.min.js");

var UA = new UAParser();
var browser = UA.getBrowser();
var cpu = UA.getCPU();
var device = UA.getDevice();
var engine = UA.getEngine();
var os = UA.getOS();
var ua = UA.getUA();

var setDefaults = function setDefaults(p) {
  var d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'none';
  return p ? p : d;
};
var getNavigatorInstance = function getNavigatorInstance() {
  if (typeof window !== 'undefined') {
    if (window.navigator || navigator) {
      return window.navigator || navigator;
    }
  }

  return false;
};
var isIOS13Check = function isIOS13Check(type) {
  var nav = getNavigatorInstance();
  return nav && nav.platform && (nav.platform.indexOf(type) !== -1 || nav.platform === 'MacIntel' && nav.maxTouchPoints > 1 && !window.MSStream);
};

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var DEVICE_TYPES = {
  MOBILE: 'mobile',
  TABLET: 'tablet',
  SMART_TV: 'smarttv',
  CONSOLE: 'console',
  WEARABLE: 'wearable',
  BROWSER: undefined
};
var BROWSER_TYPES = {
  CHROME: 'Chrome',
  FIREFOX: "Firefox",
  OPERA: "Opera",
  YANDEX: "Yandex",
  SAFARI: "Safari",
  INTERNET_EXPLORER: "Internet Explorer",
  EDGE: "Edge",
  CHROMIUM: "Chromium",
  IE: 'IE',
  MOBILE_SAFARI: "Mobile Safari",
  EDGE_CHROMIUM: "Edge Chromium",
  MIUI: "MIUI Browser"
};
var OS_TYPES = {
  IOS: 'iOS',
  ANDROID: "Android",
  WINDOWS_PHONE: "Windows Phone",
  WINDOWS: 'Windows',
  MAC_OS: 'Mac OS'
};
var initialData = {
  isMobile: false,
  isTablet: false,
  isBrowser: false,
  isSmartTV: false,
  isConsole: false,
  isWearable: false
};
var checkType = function checkType(type) {
  switch (type) {
    case DEVICE_TYPES.MOBILE:
      return {
        isMobile: true
      };

    case DEVICE_TYPES.TABLET:
      return {
        isTablet: true
      };

    case DEVICE_TYPES.SMART_TV:
      return {
        isSmartTV: true
      };

    case DEVICE_TYPES.CONSOLE:
      return {
        isConsole: true
      };

    case DEVICE_TYPES.WEARABLE:
      return {
        isWearable: true
      };

    case DEVICE_TYPES.BROWSER:
      return {
        isBrowser: true
      };

    default:
      return initialData;
  }
};
var broPayload = function broPayload(isBrowser, browser, engine, os, ua) {
  return {
    isBrowser: isBrowser,
    browserMajorVersion: setDefaults(browser.major),
    browserFullVersion: setDefaults(browser.version),
    browserName: setDefaults(browser.name),
    engineName: setDefaults(engine.name),
    engineVersion: setDefaults(engine.version),
    osName: setDefaults(os.name),
    osVersion: setDefaults(os.version),
    userAgent: setDefaults(ua)
  };
};
var mobilePayload = function mobilePayload(type, device, os, ua) {
  return _objectSpread2({}, type, {
    vendor: setDefaults(device.vendor),
    model: setDefaults(device.model),
    os: setDefaults(os.name),
    osVersion: setDefaults(os.version),
    ua: setDefaults(ua)
  });
};
var stvPayload = function stvPayload(isSmartTV, engine, os, ua) {
  return {
    isSmartTV: isSmartTV,
    engineName: setDefaults(engine.name),
    engineVersion: setDefaults(engine.version),
    osName: setDefaults(os.name),
    osVersion: setDefaults(os.version),
    userAgent: setDefaults(ua)
  };
};
var consolePayload = function consolePayload(isConsole, engine, os, ua) {
  return {
    isConsole: isConsole,
    engineName: setDefaults(engine.name),
    engineVersion: setDefaults(engine.version),
    osName: setDefaults(os.name),
    osVersion: setDefaults(os.version),
    userAgent: setDefaults(ua)
  };
};
var wearPayload = function wearPayload(isWearable, engine, os, ua) {
  return {
    isWearable: isWearable,
    engineName: setDefaults(engine.name),
    engineVersion: setDefaults(engine.version),
    osName: setDefaults(os.name),
    osVersion: setDefaults(os.version),
    userAgent: setDefaults(ua)
  };
};

var type = checkType(device.type);

function deviceDetect() {
  var isBrowser = type.isBrowser,
      isMobile = type.isMobile,
      isTablet = type.isTablet,
      isSmartTV = type.isSmartTV,
      isConsole = type.isConsole,
      isWearable = type.isWearable;

  if (isBrowser) {
    return broPayload(isBrowser, browser, engine, os, ua);
  }

  if (isSmartTV) {
    return stvPayload(isSmartTV, engine, os, ua);
  }

  if (isConsole) {
    return consolePayload(isConsole, engine, os, ua);
  }

  if (isMobile) {
    return mobilePayload(type, device, os, ua);
  }

  if (isTablet) {
    return mobilePayload(type, device, os, ua);
  }

  if (isWearable) {
    return wearPayload(isWearable, engine, os, ua);
  }
}

var isMobileType = function isMobileType() {
  return device.type === DEVICE_TYPES.MOBILE;
};

var isTabletType = function isTabletType() {
  return device.type === DEVICE_TYPES.TABLET;
};

var isMobileAndTabletType = function isMobileAndTabletType() {
  switch (device.type) {
    case DEVICE_TYPES.MOBILE:
    case DEVICE_TYPES.TABLET:
      return true;

    default:
      return false;
  }
};

var isEdgeChromiumType = function isEdgeChromiumType() {
  return typeof ua === 'string' && ua.indexOf('Edg/') !== -1;
};

var isSmartTVType = function isSmartTVType() {
  return device.type === DEVICE_TYPES.SMART_TV;
};

var isBrowserType = function isBrowserType() {
  return device.type === DEVICE_TYPES.BROWSER;
};

var isWearableType = function isWearableType() {
  return device.type === DEVICE_TYPES.WEARABLE;
};

var isConsoleType = function isConsoleType() {
  return device.type === DEVICE_TYPES.CONSOLE;
};

var isAndroidType = function isAndroidType() {
  return os.name === OS_TYPES.ANDROID;
};

var isWindowsType = function isWindowsType() {
  return os.name === OS_TYPES.WINDOWS;
};

var isMacOsType = function isMacOsType() {
  return os.name === OS_TYPES.MAC_OS;
};

var isWinPhoneType = function isWinPhoneType() {
  return os.name === OS_TYPES.WINDOWS_PHONE;
};

var isIOSType = function isIOSType() {
  return os.name === OS_TYPES.IOS;
};

var isChromeType = function isChromeType() {
  return browser.name === BROWSER_TYPES.CHROME;
};

var isFirefoxType = function isFirefoxType() {
  return browser.name === BROWSER_TYPES.FIREFOX;
};

var isChromiumType = function isChromiumType() {
  return browser.name === BROWSER_TYPES.CHROMIUM;
};

var isEdgeType = function isEdgeType() {
  return browser.name === BROWSER_TYPES.EDGE;
};

var isYandexType = function isYandexType() {
  return browser.name === BROWSER_TYPES.YANDEX;
};

var isSafariType = function isSafariType() {
  return browser.name === BROWSER_TYPES.SAFARI || browser.name === BROWSER_TYPES.MOBILE_SAFARI;
};

var isMobileSafariType = function isMobileSafariType() {
  return browser.name === BROWSER_TYPES.MOBILE_SAFARI;
};

var isOperaType = function isOperaType() {
  return browser.name === BROWSER_TYPES.OPERA;
};

var isIEType = function isIEType() {
  return browser.name === BROWSER_TYPES.INTERNET_EXPLORER || browser.name === BROWSER_TYPES.IE;
};

var isMIUIType = function isMIUIType() {
  return browser.name === BROWSER_TYPES.MIUI;
};

var isElectronType = function isElectronType() {
  var nav = getNavigatorInstance();
  var ua = nav && nav.userAgent.toLowerCase();
  return typeof ua === 'string' ? /electron/.test(ua) : false;
};

var getIOS13 = function getIOS13() {
  var nav = getNavigatorInstance();
  return nav && (/iPad|iPhone|iPod/.test(nav.platform) || nav.platform === 'MacIntel' && nav.maxTouchPoints > 1) && !window.MSStream;
};

var getIPad13 = function getIPad13() {
  return isIOS13Check('iPad');
};

var getIphone13 = function getIphone13() {
  return isIOS13Check('iPhone');
};

var getIPod13 = function getIPod13() {
  return isIOS13Check('iPod');
};

var getBrowserFullVersion = function getBrowserFullVersion() {
  return setDefaults(browser.version);
};

var getBrowserVersion = function getBrowserVersion() {
  return setDefaults(browser.major);
};

var getOsVersion = function getOsVersion() {
  return setDefaults(os.version);
};

var getOsName = function getOsName() {
  return setDefaults(os.name);
};

var getBrowserName = function getBrowserName() {
  return setDefaults(browser.name);
};

var getMobileVendor = function getMobileVendor() {
  return setDefaults(device.vendor);
};

var getMobileModel = function getMobileModel() {
  return setDefaults(device.model);
};

var getEngineName = function getEngineName() {
  return setDefaults(engine.name);
};

var getEngineVersion = function getEngineVersion() {
  return setDefaults(engine.version);
};

var getUseragent = function getUseragent() {
  return setDefaults(ua);
};

var getDeviceType = function getDeviceType() {
  return setDefaults(device.type, 'browser');
};

var isSmartTV = isSmartTVType();
var isConsole = isConsoleType();
var isWearable = isWearableType();
var isMobileSafari = isMobileSafariType() || getIPad13();
var isChromium = isChromiumType();
var isMobile = isMobileAndTabletType() || getIPad13();
var isMobileOnly = isMobileType();
var isTablet = isTabletType() || getIPad13();
var isBrowser = isBrowserType();
var isAndroid = isAndroidType();
var isWinPhone = isWinPhoneType();
var isIOS = isIOSType() || getIPad13();
var isChrome = isChromeType();
var isFirefox = isFirefoxType();
var isSafari = isSafariType();
var isOpera = isOperaType();
var isIE = isIEType();
var osVersion = getOsVersion();
var osName = getOsName();
var fullBrowserVersion = getBrowserFullVersion();
var browserVersion = getBrowserVersion();
var browserName = getBrowserName();
var mobileVendor = getMobileVendor();
var mobileModel = getMobileModel();
var engineName = getEngineName();
var engineVersion = getEngineVersion();
var getUA = getUseragent();
var isEdge = isEdgeType() || isEdgeChromiumType();
var isYandex = isYandexType();
var deviceType = getDeviceType();
var isIOS13 = getIOS13();
var isIPad13 = getIPad13();
var isIPhone13 = getIphone13();
var isIPod13 = getIPod13();
var isElectron = isElectronType();
var isEdgeChromium = isEdgeChromiumType();
var isLegacyEdge = isEdgeType() && !isEdgeChromiumType();
var isWindows = isWindowsType();
var isMacOs = isMacOsType();
var isMIUI = isMIUIType();

var AndroidView = function AndroidView(_ref) {
  var renderWithFragment = _ref.renderWithFragment,
      children = _ref.children,
      viewClassName = _ref.viewClassName,
      style = _ref.style;
  return isAndroid ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var BrowserView = function BrowserView(_ref2) {
  var renderWithFragment = _ref2.renderWithFragment,
      children = _ref2.children,
      viewClassName = _ref2.viewClassName,
      style = _ref2.style;
  return isBrowser ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var IEView = function IEView(_ref3) {
  var renderWithFragment = _ref3.renderWithFragment,
      children = _ref3.children,
      viewClassName = _ref3.viewClassName,
      style = _ref3.style;
  return isIE ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var IOSView = function IOSView(_ref4) {
  var renderWithFragment = _ref4.renderWithFragment,
      children = _ref4.children,
      viewClassName = _ref4.viewClassName,
      style = _ref4.style;
  return isIOS ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var MobileView = function MobileView(_ref5) {
  var renderWithFragment = _ref5.renderWithFragment,
      children = _ref5.children,
      viewClassName = _ref5.viewClassName,
      style = _ref5.style;
  return isMobile ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var TabletView = function TabletView(_ref6) {
  var renderWithFragment = _ref6.renderWithFragment,
      children = _ref6.children,
      viewClassName = _ref6.viewClassName,
      style = _ref6.style;
  return isTablet ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var WinPhoneView = function WinPhoneView(_ref7) {
  var renderWithFragment = _ref7.renderWithFragment,
      children = _ref7.children,
      viewClassName = _ref7.viewClassName,
      style = _ref7.style;
  return isWinPhone ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var MobileOnlyView = function MobileOnlyView(_ref8) {
  var renderWithFragment = _ref8.renderWithFragment,
      children = _ref8.children,
      viewClassName = _ref8.viewClassName,
      style = _ref8.style;
  return isMobileOnly ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var SmartTVView = function SmartTVView(_ref9) {
  var renderWithFragment = _ref9.renderWithFragment,
      children = _ref9.children,
      viewClassName = _ref9.viewClassName,
      style = _ref9.style;
  return isSmartTV ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var ConsoleView = function ConsoleView(_ref10) {
  var renderWithFragment = _ref10.renderWithFragment,
      children = _ref10.children,
      viewClassName = _ref10.viewClassName,
      style = _ref10.style;
  return isConsole ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var WearableView = function WearableView(_ref11) {
  var renderWithFragment = _ref11.renderWithFragment,
      children = _ref11.children,
      viewClassName = _ref11.viewClassName,
      style = _ref11.style;
  return isWearable ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};
var CustomView = function CustomView(_ref12) {
  var renderWithFragment = _ref12.renderWithFragment,
      children = _ref12.children,
      viewClassName = _ref12.viewClassName,
      style = _ref12.style,
      condition = _ref12.condition;
  return condition ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", {
    className: viewClassName,
    style: style
  }, children) : null;
};

function withOrientationChange(WrappedComponent) {
  return (
    /*#__PURE__*/
    function (_React$Component) {
      _inherits(_class, _React$Component);

      function _class(props) {
        var _this;

        _classCallCheck(this, _class);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));
        _this.isEventListenerAdded = false;
        _this.handleOrientationChange = _this.handleOrientationChange.bind(_assertThisInitialized(_this));
        _this.onOrientationChange = _this.onOrientationChange.bind(_assertThisInitialized(_this));
        _this.onPageLoad = _this.onPageLoad.bind(_assertThisInitialized(_this));
        _this.state = {
          isLandscape: false,
          isPortrait: false
        };
        return _this;
      }

      _createClass(_class, [{
        key: "handleOrientationChange",
        value: function handleOrientationChange() {
          if (!this.isEventListenerAdded) {
            this.isEventListenerAdded = true;
          }

          var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
          this.setState({
            isPortrait: orientation === 0,
            isLandscape: orientation === 90
          });
        }
      }, {
        key: "onOrientationChange",
        value: function onOrientationChange() {
          this.handleOrientationChange();
        }
      }, {
        key: "onPageLoad",
        value: function onPageLoad() {
          this.handleOrientationChange();
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefined && isMobile) {
            if (!this.isEventListenerAdded) {
              this.handleOrientationChange();
              window.addEventListener("load", this.onPageLoad, false);
            } else {
              window.removeEventListener("load", this.onPageLoad, false);
            }

            window.addEventListener("resize", this.onOrientationChange, false);
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          window.removeEventListener("resize", this.onOrientationChange, false);
        }
      }, {
        key: "render",
        value: function render() {
          return React__default.createElement(WrappedComponent, _extends({}, this.props, {
            isLandscape: this.state.isLandscape,
            isPortrait: this.state.isPortrait
          }));
        }
      }]);

      return _class;
    }(React__default.Component)
  );
}

exports.AndroidView = AndroidView;
exports.BrowserView = BrowserView;
exports.ConsoleView = ConsoleView;
exports.CustomView = CustomView;
exports.IEView = IEView;
exports.IOSView = IOSView;
exports.MobileOnlyView = MobileOnlyView;
exports.MobileView = MobileView;
exports.SmartTVView = SmartTVView;
exports.TabletView = TabletView;
exports.WearableView = WearableView;
exports.WinPhoneView = WinPhoneView;
exports.browserName = browserName;
exports.browserVersion = browserVersion;
exports.deviceDetect = deviceDetect;
exports.deviceType = deviceType;
exports.engineName = engineName;
exports.engineVersion = engineVersion;
exports.fullBrowserVersion = fullBrowserVersion;
exports.getUA = getUA;
exports.isAndroid = isAndroid;
exports.isBrowser = isBrowser;
exports.isChrome = isChrome;
exports.isChromium = isChromium;
exports.isConsole = isConsole;
exports.isEdge = isEdge;
exports.isEdgeChromium = isEdgeChromium;
exports.isElectron = isElectron;
exports.isFirefox = isFirefox;
exports.isIE = isIE;
exports.isIOS = isIOS;
exports.isIOS13 = isIOS13;
exports.isIPad13 = isIPad13;
exports.isIPhone13 = isIPhone13;
exports.isIPod13 = isIPod13;
exports.isLegacyEdge = isLegacyEdge;
exports.isMIUI = isMIUI;
exports.isMacOs = isMacOs;
exports.isMobile = isMobile;
exports.isMobileOnly = isMobileOnly;
exports.isMobileSafari = isMobileSafari;
exports.isOpera = isOpera;
exports.isSafari = isSafari;
exports.isSmartTV = isSmartTV;
exports.isTablet = isTablet;
exports.isWearable = isWearable;
exports.isWinPhone = isWinPhone;
exports.isWindows = isWindows;
exports.isYandex = isYandex;
exports.mobileModel = mobileModel;
exports.mobileVendor = mobileVendor;
exports.osName = osName;
exports.osVersion = osVersion;
exports.withOrientationChange = withOrientationChange;


/***/ }),

/***/ "./node_modules/react-draggable/dist/react-draggable.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-draggable/dist/react-draggable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"), __webpack_require__(/*! react */ "./node_modules/react/index.js")) :
	undefined;
}(this, (function (ReactDOM,React) { 'use strict';

	ReactDOM = ReactDOM && ReactDOM.hasOwnProperty('default') ? ReactDOM['default'] : ReactDOM;
	React = React && React.hasOwnProperty('default') ? React['default'] : React;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	var emptyFunction_1 = emptyFunction;

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	{
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	var invariant_1 = invariant;

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction_1;

	{
	  var printWarning = function printWarning(format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  warning = function warning(condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }

	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }

	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	var warning_1 = warning;

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	var ReactPropTypesSecret_1 = ReactPropTypesSecret;

	{
	  var invariant$1 = invariant_1;
	  var warning$1 = warning_1;
	  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
	  var loggedTypeFailures = {};
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant$1(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
	        } catch (ex) {
	          error = ex;
	        }
	        warning$1(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          warning$1(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}

	var checkPropTypes_1 = checkPropTypes;

	var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret_1) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant_1(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if ( true && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning_1(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction_1.thatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      warning_1(false, 'Invalid argument supplied to oneOf, expected an instance of array.');
	      return emptyFunction_1.thatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      warning_1(false, 'Invalid argument supplied to oneOfType, expected an instance of array.');
	      return emptyFunction_1.thatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        warning_1(
	          false,
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received %s at index %s.',
	          getPostfixForTypeWarning(checker),
	          i
	        );
	        return emptyFunction_1.thatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = objectAssign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes_1;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	var propTypes = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	{
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;

	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
	}
	});

	var classnames = createCommonjsModule(function (module) {
	/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if ( true && module.exports) {
			module.exports = classNames;
		} else if (false) {} else {
			window.classNames = classNames;
		}
	}());
	});

	// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
	function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/ {
	  for (var i = 0, length = array.length; i < length; i++) {
	    if (callback.apply(callback, [array[i], i, array])) return array[i];
	  }
	}

	function isFunction(func /*: any*/) /*: boolean*/ {
	  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
	}

	function isNum(num /*: any*/) /*: boolean*/ {
	  return typeof num === 'number' && !isNaN(num);
	}

	function int(a /*: string*/) /*: number*/ {
	  return parseInt(a, 10);
	}

	function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
	  if (props[propName]) {
	    return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
	  }
	}

	var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
	function getPrefix() /*: string*/ {
	  var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';

	  // Checking specifically for 'window.document' is for pseudo-browser server-side
	  // environments that define 'window' as the global context.
	  // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
	  if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';

	  var style = window.document.documentElement.style;

	  if (prop in style) return '';

	  for (var i = 0; i < prefixes.length; i++) {
	    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
	  }

	  return '';
	}

	function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/ {
	  return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
	}

	function kebabToTitleCase(str /*: string*/) /*: string*/ {
	  var out = '';
	  var shouldCapitalize = true;
	  for (var i = 0; i < str.length; i++) {
	    if (shouldCapitalize) {
	      out += str[i].toUpperCase();
	      shouldCapitalize = false;
	    } else if (str[i] === '-') {
	      shouldCapitalize = true;
	    } else {
	      out += str[i];
	    }
	  }
	  return out;
	}

	// Default export is the prefix itself, like 'Moz', 'Webkit', etc
	// Note that you may have to re-test for certain things; for instance, Chrome 50
	// can handle unprefixed `transform`, but not unprefixed `user-select`
	var browserPrefix = getPrefix();

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

	/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/


	var matchesSelectorFunc = '';
	function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/ {
	  if (!matchesSelectorFunc) {
	    matchesSelectorFunc = findInArray(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
	      // $FlowIgnore: Doesn't think elements are indexable
	      return isFunction(el[method]);
	    });
	  }

	  // Might not be found entirely (not an Element?) - in that case, bail
	  // $FlowIgnore: Doesn't think elements are indexable
	  if (!isFunction(el[matchesSelectorFunc])) return false;

	  // $FlowIgnore: Doesn't think elements are indexable
	  return el[matchesSelectorFunc](selector);
	}

	// Works up the tree to the draggable itself attempting to match selector.
	function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/ {
	  var node = el;
	  do {
	    if (matchesSelector(node, selector)) return true;
	    if (node === baseNode) return false;
	    node = node.parentNode;
	  } while (node);

	  return false;
	}

	function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.attachEvent) {
	    el.attachEvent('on' + event, handler);
	  } else if (el.addEventListener) {
	    el.addEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = handler;
	  }
	}

	function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/ {
	  if (!el) {
	    return;
	  }
	  if (el.detachEvent) {
	    el.detachEvent('on' + event, handler);
	  } else if (el.removeEventListener) {
	    el.removeEventListener(event, handler, true);
	  } else {
	    // $FlowIgnore: Doesn't think elements are indexable
	    el['on' + event] = null;
	  }
	}

	function outerHeight(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetTop which is including margin. See getBoundPosition
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height += int(computedStyle.borderTopWidth);
	  height += int(computedStyle.borderBottomWidth);
	  return height;
	}

	function outerWidth(node /*: HTMLElement*/) /*: number*/ {
	  // This is deliberately excluding margin for our calculations, since we are using
	  // offsetLeft which is including margin. See getBoundPosition
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width += int(computedStyle.borderLeftWidth);
	  width += int(computedStyle.borderRightWidth);
	  return width;
	}
	function innerHeight(node /*: HTMLElement*/) /*: number*/ {
	  var height = node.clientHeight;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  height -= int(computedStyle.paddingTop);
	  height -= int(computedStyle.paddingBottom);
	  return height;
	}

	function innerWidth(node /*: HTMLElement*/) /*: number*/ {
	  var width = node.clientWidth;
	  var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	  width -= int(computedStyle.paddingLeft);
	  width -= int(computedStyle.paddingRight);
	  return width;
	}

	// Get from offsetParent
	function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/ {
	  var isBody = offsetParent === offsetParent.ownerDocument.body;
	  var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();

	  var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
	  var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;

	  return { x: x, y: y };
	}

	function createCSSTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: Object*/ {
	  var translation = getTranslation(controlPos, positionOffset, 'px');
	  return defineProperty({}, browserPrefixToKey('transform', browserPrefix), translation);
	}

	function createSVGTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: string*/ {
	  var translation = getTranslation(controlPos, positionOffset, '');
	  return translation;
	}
	function getTranslation(_ref2, positionOffset /*: PositionOffsetControlPosition*/, unitSuffix /*: string*/) /*: string*/ {
	  var x = _ref2.x,
	      y = _ref2.y;

	  var translation = 'translate(' + x + unitSuffix + ',' + y + unitSuffix + ')';
	  if (positionOffset) {
	    var defaultX = '' + (typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix);
	    var defaultY = '' + (typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix);
	    translation = 'translate(' + defaultX + ', ' + defaultY + ')' + translation;
	  }
	  return translation;
	}

	function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/ {
	  return e.targetTouches && findInArray(e.targetTouches, function (t) {
	    return identifier === t.identifier;
	  }) || e.changedTouches && findInArray(e.changedTouches, function (t) {
	    return identifier === t.identifier;
	  });
	}

	function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/ {
	  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
	  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
	}

	// User-select Hacks:
	//
	// Useful for preventing blue highlights all over everything when dragging.

	// Note we're passing `document` b/c we could be iframed
	function addUserSelectStyles(doc /*: ?Document*/) {
	  if (!doc) return;
	  var styleEl = doc.getElementById('react-draggable-style-el');
	  if (!styleEl) {
	    styleEl = doc.createElement('style');
	    styleEl.type = 'text/css';
	    styleEl.id = 'react-draggable-style-el';
	    styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {background: transparent;}\n';
	    styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {background: transparent;}\n';
	    doc.getElementsByTagName('head')[0].appendChild(styleEl);
	  }
	  if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');
	}

	function removeUserSelectStyles(doc /*: ?Document*/) {
	  try {
	    if (doc && doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');
	    // $FlowIgnore: IE
	    if (doc.selection) {
	      // $FlowIgnore: IE
	      doc.selection.empty();
	    } else {
	      window.getSelection().removeAllRanges(); // remove selection caused by scroll
	    }
	  } catch (e) {
	    // probably IE
	  }
	}

	function styleHacks() /*: Object*/ {
	  var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  // Workaround IE pointer events; see #51
	  // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
	  return _extends({
	    touchAction: 'none'
	  }, childStyle);
	}

	function addClassName(el /*: HTMLElement*/, className /*: string*/) {
	  if (el.classList) {
	    el.classList.add(className);
	  } else {
	    if (!el.className.match(new RegExp('(?:^|\\s)' + className + '(?!\\S)'))) {
	      el.className += ' ' + className;
	    }
	  }
	}

	function removeClassName(el /*: HTMLElement*/, className /*: string*/) {
	  if (el.classList) {
	    el.classList.remove(className);
	  } else {
	    el.className = el.className.replace(new RegExp('(?:^|\\s)' + className + '(?!\\S)', 'g'), '');
	  }
	}

	/*:: import type Draggable from '../Draggable';*/
	/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/
	/*:: import type DraggableCore from '../DraggableCore';*/


	function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/ {
	  // If no bounds, short-circuit and move on
	  if (!draggable.props.bounds) return [x, y];

	  // Clone new bounds
	  var bounds = draggable.props.bounds;

	  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
	  var node = findDOMNode(draggable);

	  if (typeof bounds === 'string') {
	    var ownerDocument = node.ownerDocument;

	    var ownerWindow = ownerDocument.defaultView;
	    var boundNode = void 0;
	    if (bounds === 'parent') {
	      boundNode = node.parentNode;
	    } else {
	      boundNode = ownerDocument.querySelector(bounds);
	    }
	    if (!(boundNode instanceof ownerWindow.HTMLElement)) {
	      throw new Error('Bounds selector "' + bounds + '" could not find an element.');
	    }
	    var nodeStyle = ownerWindow.getComputedStyle(node);
	    var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
	    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
	    bounds = {
	      left: -node.offsetLeft + int(boundNodeStyle.paddingLeft) + int(nodeStyle.marginLeft),
	      top: -node.offsetTop + int(boundNodeStyle.paddingTop) + int(nodeStyle.marginTop),
	      right: innerWidth(boundNode) - outerWidth(node) - node.offsetLeft + int(boundNodeStyle.paddingRight) - int(nodeStyle.marginRight),
	      bottom: innerHeight(boundNode) - outerHeight(node) - node.offsetTop + int(boundNodeStyle.paddingBottom) - int(nodeStyle.marginBottom)
	    };
	  }

	  // Keep x and y below right and bottom limits...
	  if (isNum(bounds.right)) x = Math.min(x, bounds.right);
	  if (isNum(bounds.bottom)) y = Math.min(y, bounds.bottom);

	  // But above left and top limits.
	  if (isNum(bounds.left)) x = Math.max(x, bounds.left);
	  if (isNum(bounds.top)) y = Math.max(y, bounds.top);

	  return [x, y];
	}

	function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/ {
	  var x = Math.round(pendingX / grid[0]) * grid[0];
	  var y = Math.round(pendingY / grid[1]) * grid[1];
	  return [x, y];
	}

	function canDragX(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'x';
	}

	function canDragY(draggable /*: Draggable*/) /*: boolean*/ {
	  return draggable.props.axis === 'both' || draggable.props.axis === 'y';
	}

	// Get {x, y} positions from event.
	function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/ {
	  var touchObj = typeof touchIdentifier === 'number' ? getTouch(e, touchIdentifier) : null;
	  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
	  var node = findDOMNode(draggableCore);
	  // User can provide an offsetParent if desired.
	  var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
	  return offsetXYFromParent(touchObj || e, offsetParent);
	}

	// Create an data object exposed by <DraggableCore>'s events
	function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/ {
	  var state = draggable.state;
	  var isStart = !isNum(state.lastX);
	  var node = findDOMNode(draggable);

	  if (isStart) {
	    // If this is our first move, use the x and y as last coords.
	    return {
	      node: node,
	      deltaX: 0, deltaY: 0,
	      lastX: x, lastY: y,
	      x: x, y: y
	    };
	  } else {
	    // Otherwise calculate proper values.
	    return {
	      node: node,
	      deltaX: x - state.lastX, deltaY: y - state.lastY,
	      lastX: state.lastX, lastY: state.lastY,
	      x: x, y: y
	    };
	  }
	}

	// Create an data exposed by <Draggable>'s events
	function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/ {
	  var scale = draggable.props.scale;
	  return {
	    node: coreData.node,
	    x: draggable.state.x + coreData.deltaX / scale,
	    y: draggable.state.y + coreData.deltaY / scale,
	    deltaX: coreData.deltaX / scale,
	    deltaY: coreData.deltaY / scale,
	    lastX: draggable.state.x,
	    lastY: draggable.state.y
	  };
	}

	// A lot faster than stringify/parse
	function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/ {
	  return {
	    left: bounds.left,
	    top: bounds.top,
	    right: bounds.right,
	    bottom: bounds.bottom
	  };
	}

	function findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/ {
	  var node = ReactDOM.findDOMNode(draggable);
	  if (!node) {
	    throw new Error('<DraggableCore>: Unmounted during event!');
	  }
	  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME
	  return node;
	}

	/*eslint no-console:0*/
	function log() {
	}

	/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/


	// Simple abstraction for dragging events names.
	/*:: import type {Element as ReactElement} from 'react';*/
	var eventsFor = {
	  touch: {
	    start: 'touchstart',
	    move: 'touchmove',
	    stop: 'touchend'
	  },
	  mouse: {
	    start: 'mousedown',
	    move: 'mousemove',
	    stop: 'mouseup'
	  }
	};

	// Default to mouse events.
	var dragEventFor = eventsFor.mouse;

	/*:: type DraggableCoreState = {
	  dragging: boolean,
	  lastX: number,
	  lastY: number,
	  touchIdentifier: ?number
	};*/
	/*:: export type DraggableBounds = {
	  left: number,
	  right: number,
	  top: number,
	  bottom: number,
	};*/
	/*:: export type DraggableData = {
	  node: HTMLElement,
	  x: number, y: number,
	  deltaX: number, deltaY: number,
	  lastX: number, lastY: number,
	};*/
	/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void;*/
	/*:: export type ControlPosition = {x: number, y: number};*/
	/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/


	//
	// Define <DraggableCore>.
	//
	// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
	// work well with libraries that require more control over the element.
	//

	/*:: export type DraggableCoreProps = {
	  allowAnyClick: boolean,
	  cancel: string,
	  children: ReactElement<any>,
	  disabled: boolean,
	  enableUserSelectHack: boolean,
	  offsetParent: HTMLElement,
	  grid: [number, number],
	  handle: string,
	  onStart: DraggableEventHandler,
	  onDrag: DraggableEventHandler,
	  onStop: DraggableEventHandler,
	  onMouseDown: (e: MouseEvent) => void,
	};*/

	var DraggableCore = function (_React$Component) {
	  inherits(DraggableCore, _React$Component);

	  function DraggableCore() {
	    var _ref;

	    var _temp, _this, _ret;

	    classCallCheck(this, DraggableCore);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      dragging: false,
	      // Used while dragging to determine deltas.
	      lastX: NaN, lastY: NaN,
	      touchIdentifier: null
	    }, _this.handleDragStart = function (e) {
	      // Make it possible to attach event handlers on top of this one.
	      _this.props.onMouseDown(e);

	      // Only accept left-clicks.
	      if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;

	      // Get nodes. Be sure to grab relative document (could be iframed)
	      var thisNode = ReactDOM.findDOMNode(_this);
	      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
	        throw new Error('<DraggableCore> not mounted on DragStart!');
	      }
	      var ownerDocument = thisNode.ownerDocument;

	      // Short circuit if handle or cancel prop was provided and selector doesn't match.

	      if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !matchesSelectorAndParentsTo(e.target, _this.props.handle, thisNode) || _this.props.cancel && matchesSelectorAndParentsTo(e.target, _this.props.cancel, thisNode)) {
	        return;
	      }

	      // Set touch identifier in component state if this is a touch event. This allows us to
	      // distinguish between individual touches on multitouch screens by identifying which
	      // touchpoint was set to this element.
	      var touchIdentifier = getTouchIdentifier(e);
	      _this.setState({ touchIdentifier: touchIdentifier });

	      // Get the current drag point from the event. This is used as the offset.
	      var position = getControlPosition(e, touchIdentifier, _this);
	      if (position == null) return; // not possible but satisfies flow
	      var x = position.x,
	          y = position.y;

	      // Create an event object with all the data parents need to make a decision here.

	      var coreEvent = createCoreData(_this, x, y);

	      // Call event handler. If it returns explicit false, cancel.
	      log('calling', _this.props.onStart);
	      var shouldUpdate = _this.props.onStart(e, coreEvent);
	      if (shouldUpdate === false) return;

	      // Add a style to the body to disable user-select. This prevents text from
	      // being selected all over the page.
	      if (_this.props.enableUserSelectHack) addUserSelectStyles(ownerDocument);

	      // Initiate dragging. Set the current x and y as offsets
	      // so we know how much we've moved during the drag. This allows us
	      // to drag elements around even if they have been moved, without issue.
	      _this.setState({
	        dragging: true,

	        lastX: x,
	        lastY: y
	      });

	      // Add events to the document directly so we catch when the user's mouse/touch moves outside of
	      // this element. We use different events depending on whether or not we have detected that this
	      // is a touch-capable device.
	      addEvent(ownerDocument, dragEventFor.move, _this.handleDrag);
	      addEvent(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	    }, _this.handleDrag = function (e) {

	      // Prevent scrolling on mobile devices, like ipad/iphone.
	      if (e.type === 'touchmove') e.preventDefault();

	      // Get the current drag point from the event. This is used as the offset.
	      var position = getControlPosition(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;

	      // Snap to grid if prop has been provided

	      if (Array.isArray(_this.props.grid)) {
	        var _deltaX = x - _this.state.lastX,
	            _deltaY = y - _this.state.lastY;

	        var _snapToGrid = snapToGrid(_this.props.grid, _deltaX, _deltaY);

	        var _snapToGrid2 = slicedToArray(_snapToGrid, 2);

	        _deltaX = _snapToGrid2[0];
	        _deltaY = _snapToGrid2[1];

	        if (!_deltaX && !_deltaY) return; // skip useless drag
	        x = _this.state.lastX + _deltaX, y = _this.state.lastY + _deltaY;
	      }

	      var coreEvent = createCoreData(_this, x, y);

	      // Call event handler. If it returns explicit false, trigger end.
	      var shouldUpdate = _this.props.onDrag(e, coreEvent);
	      if (shouldUpdate === false) {
	        try {
	          // $FlowIgnore
	          _this.handleDragStop(new MouseEvent('mouseup'));
	        } catch (err) {
	          // Old browsers
	          var event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);
	          // I see why this insanity was deprecated
	          // $FlowIgnore
	          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	          _this.handleDragStop(event);
	        }
	        return;
	      }

	      _this.setState({
	        lastX: x,
	        lastY: y
	      });
	    }, _this.handleDragStop = function (e) {
	      if (!_this.state.dragging) return;

	      var position = getControlPosition(e, _this.state.touchIdentifier, _this);
	      if (position == null) return;
	      var x = position.x,
	          y = position.y;

	      var coreEvent = createCoreData(_this, x, y);

	      var thisNode = ReactDOM.findDOMNode(_this);
	      if (thisNode) {
	        // Remove user-select hack
	        if (_this.props.enableUserSelectHack) removeUserSelectStyles(thisNode.ownerDocument);
	      }

	      // Reset the el.
	      _this.setState({
	        dragging: false,
	        lastX: NaN,
	        lastY: NaN
	      });

	      // Call event handler
	      _this.props.onStop(e, coreEvent);

	      if (thisNode) {
	        removeEvent(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
	        removeEvent(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
	      }
	    }, _this.onMouseDown = function (e) {
	      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse

	      return _this.handleDragStart(e);
	    }, _this.onMouseUp = function (e) {
	      dragEventFor = eventsFor.mouse;

	      return _this.handleDragStop(e);
	    }, _this.onTouchStart = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;

	      return _this.handleDragStart(e);
	    }, _this.onTouchEnd = function (e) {
	      // We're on a touch device now, so change the event handlers
	      dragEventFor = eventsFor.touch;

	      return _this.handleDragStop(e);
	    }, _temp), possibleConstructorReturn(_this, _ret);
	  }

	  createClass(DraggableCore, [{
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      // Remove any leftover event handlers. Remove both touch and mouse handlers in case
	      // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
	      var thisNode = ReactDOM.findDOMNode(this);
	      if (thisNode) {
	        var ownerDocument = thisNode.ownerDocument;

	        removeEvent(ownerDocument, eventsFor.mouse.move, this.handleDrag);
	        removeEvent(ownerDocument, eventsFor.touch.move, this.handleDrag);
	        removeEvent(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
	        removeEvent(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
	        if (this.props.enableUserSelectHack) removeUserSelectStyles(ownerDocument);
	      }
	    }

	    // Same as onMouseDown (start drag), but now consider this a touch device.

	  }, {
	    key: 'render',
	    value: function render() {
	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return React.cloneElement(React.Children.only(this.props.children), {
	        style: styleHacks(this.props.children.props.style),

	        // Note: mouseMove handler is attached to document so it will still function
	        // when the user drags quickly and leaves the bounds of the element.
	        onMouseDown: this.onMouseDown,
	        onTouchStart: this.onTouchStart,
	        onMouseUp: this.onMouseUp,
	        onTouchEnd: this.onTouchEnd
	      });
	    }
	  }]);
	  return DraggableCore;
	}(React.Component);

	DraggableCore.displayName = 'DraggableCore';
	DraggableCore.propTypes = {
	  /**
	   * `allowAnyClick` allows dragging using any mouse button.
	   * By default, we only accept the left button.
	   *
	   * Defaults to `false`.
	   */
	  allowAnyClick: propTypes.bool,

	  /**
	   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
	   * with the exception of `onMouseDown`, will not fire.
	   */
	  disabled: propTypes.bool,

	  /**
	   * By default, we add 'user-select:none' attributes to the document body
	   * to prevent ugly text selection during drag. If this is causing problems
	   * for your app, set this to `false`.
	   */
	  enableUserSelectHack: propTypes.bool,

	  /**
	   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
	   * instead of using the parent node.
	   */
	  offsetParent: function offsetParent(props /*: DraggableCoreProps*/, propName /*: $Keys<DraggableCoreProps>*/) {
	    if (props[propName] && props[propName].nodeType !== 1) {
	      throw new Error('Draggable\'s offsetParent must be a DOM Node.');
	    }
	  },

	  /**
	   * `grid` specifies the x and y that dragging should snap to.
	   */
	  grid: propTypes.arrayOf(propTypes.number),

	  /**
	   * `scale` specifies the scale of the area you are dragging inside of. It allows
	   * the drag deltas to scale correctly with how far zoomed in/out you are.
	   */
	  scale: propTypes.number,

	  /**
	   * `handle` specifies a selector to be used as the handle that initiates drag.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable handle=".handle">
	   *              <div>
	   *                  <div className="handle">Click me to drag</div>
	   *                  <div>This is some other content</div>
	   *              </div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  handle: propTypes.string,

	  /**
	   * `cancel` specifies a selector to be used to prevent drag initialization.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *           return(
	   *               <Draggable cancel=".cancel">
	   *                   <div>
	   *                     <div className="cancel">You can't drag from here</div>
	   *                     <div>Dragging here works fine</div>
	   *                   </div>
	   *               </Draggable>
	   *           );
	   *       }
	   *   });
	   * ```
	   */
	  cancel: propTypes.string,

	  /**
	   * Called when dragging starts.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onStart: propTypes.func,

	  /**
	   * Called while dragging.
	   * If this function returns the boolean false, dragging will be canceled.
	   */
	  onDrag: propTypes.func,

	  /**
	   * Called when dragging stops.
	   * If this function returns the boolean false, the drag will remain active.
	   */
	  onStop: propTypes.func,

	  /**
	   * A workaround option which can be passed if onMouseDown needs to be accessed,
	   * since it'll always be blocked (as there is internal use of onMouseDown)
	   */
	  onMouseDown: propTypes.func,

	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: dontSetMe,
	  style: dontSetMe,
	  transform: dontSetMe
	};
	DraggableCore.defaultProps = {
	  allowAnyClick: false, // by default only accept left click
	  cancel: null,
	  disabled: false,
	  enableUserSelectHack: true,
	  offsetParent: null,
	  handle: null,
	  grid: null,
	  transform: null,
	  onStart: function onStart() {},
	  onDrag: function onDrag() {},
	  onStop: function onStop() {},
	  onMouseDown: function onMouseDown() {}
	};

	/*:: import type {DraggableEventHandler} from './utils/types';*/
	/*:: import type {Element as ReactElement} from 'react';*/
	/*:: type DraggableState = {
	  dragging: boolean,
	  dragged: boolean,
	  x: number, y: number,
	  slackX: number, slackY: number,
	  isElementSVG: boolean
	};*/


	//
	// Define <Draggable>
	//

	/*:: export type DraggableProps = {
	  ...$Exact<DraggableCoreProps>,
	  axis: 'both' | 'x' | 'y' | 'none',
	  bounds: DraggableBounds | string | false,
	  defaultClassName: string,
	  defaultClassNameDragging: string,
	  defaultClassNameDragged: string,
	  defaultPosition: ControlPosition,
	  positionOffset: PositionOffsetControlPosition,
	  position: ControlPosition,
	  scale: number
	};*/

	var Draggable = function (_React$Component) {
	  inherits(Draggable, _React$Component);

	  function Draggable(props /*: DraggableProps*/) {
	    classCallCheck(this, Draggable);

	    var _this = possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));

	    _this.onDragStart = function (e, coreData) {

	      // Short-circuit if user's callback killed it.
	      var shouldStart = _this.props.onStart(e, createDraggableData(_this, coreData));
	      // Kills start event on core as well, so move handlers are never bound.
	      if (shouldStart === false) return false;

	      _this.setState({ dragging: true, dragged: true });
	    };

	    _this.onDrag = function (e, coreData) {
	      if (!_this.state.dragging) return false;

	      var uiData = createDraggableData(_this, coreData);

	      var newState /*: $Shape<DraggableState>*/ = {
	        x: uiData.x,
	        y: uiData.y
	      };

	      // Keep within bounds.
	      if (_this.props.bounds) {
	        // Save original x and y.
	        var _x = newState.x,
	            _y = newState.y;

	        // Add slack to the values used to calculate bound position. This will ensure that if
	        // we start removing slack, the element won't react to it right away until it's been
	        // completely removed.

	        newState.x += _this.state.slackX;
	        newState.y += _this.state.slackY;

	        // Get bound position. This will ceil/floor the x and y within the boundaries.

	        var _getBoundPosition = getBoundPosition(_this, newState.x, newState.y),
	            _getBoundPosition2 = slicedToArray(_getBoundPosition, 2),
	            newStateX = _getBoundPosition2[0],
	            newStateY = _getBoundPosition2[1];

	        newState.x = newStateX;
	        newState.y = newStateY;

	        // Recalculate slack by noting how much was shaved by the boundPosition handler.
	        newState.slackX = _this.state.slackX + (_x - newState.x);
	        newState.slackY = _this.state.slackY + (_y - newState.y);

	        // Update the event we fire to reflect what really happened after bounds took effect.
	        uiData.x = newState.x;
	        uiData.y = newState.y;
	        uiData.deltaX = newState.x - _this.state.x;
	        uiData.deltaY = newState.y - _this.state.y;
	      }

	      // Short-circuit if user's callback killed it.
	      var shouldUpdate = _this.props.onDrag(e, uiData);
	      if (shouldUpdate === false) return false;

	      _this.setState(newState);
	    };

	    _this.onDragStop = function (e, coreData) {
	      if (!_this.state.dragging) return false;

	      // Short-circuit if user's callback killed it.
	      var shouldStop = _this.props.onStop(e, createDraggableData(_this, coreData));
	      if (shouldStop === false) return false;

	      var newState /*: $Shape<DraggableState>*/ = {
	        dragging: false,
	        slackX: 0,
	        slackY: 0
	      };

	      // If this is a controlled component, the result of this operation will be to
	      // revert back to the old position. We expect a handler on `onDragStop`, at the least.
	      var controlled = Boolean(_this.props.position);
	      if (controlled) {
	        var _this$props$position = _this.props.position,
	            _x2 = _this$props$position.x,
	            _y2 = _this$props$position.y;

	        newState.x = _x2;
	        newState.y = _y2;
	      }

	      _this.setState(newState);
	    };

	    _this.state = {
	      // Whether or not we are currently dragging.
	      dragging: false,

	      // Whether or not we have been dragged before.
	      dragged: false,

	      // Current transform x and y.
	      x: props.position ? props.position.x : props.defaultPosition.x,
	      y: props.position ? props.position.y : props.defaultPosition.y,

	      // Used for compensating for out-of-bounds drags
	      slackX: 0, slackY: 0,

	      // Can only determine if SVG after mounting
	      isElementSVG: false
	    };
	    return _this;
	  }

	  createClass(Draggable, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
	        // eslint-disable-next-line
	        console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      // Check to see if the element passed is an instanceof SVGElement
	      if (typeof window.SVGElement !== 'undefined' && ReactDOM.findDOMNode(this) instanceof window.SVGElement) {
	        this.setState({ isElementSVG: true });
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps /*: Object*/) {
	      // Set x/y if position has changed
	      if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
	        this.setState({ x: nextProps.position.x, y: nextProps.position.y });
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.setState({ dragging: false }); // prevents invariant if unmounted while dragging
	    }
	  }, {
	    key: 'render',
	    value: function render() /*: ReactElement<any>*/ {
	      var _classNames;

	      var style = {},
	          svgTransform = null;

	      // If this is controlled, we don't want to move it - unless it's dragging.
	      var controlled = Boolean(this.props.position);
	      var draggable = !controlled || this.state.dragging;

	      var position = this.props.position || this.props.defaultPosition;
	      var transformOpts = {
	        // Set left if horizontal drag is enabled
	        x: canDragX(this) && draggable ? this.state.x : position.x,

	        // Set top if vertical drag is enabled
	        y: canDragY(this) && draggable ? this.state.y : position.y
	      };

	      // If this element was SVG, we use the `transform` attribute.
	      if (this.state.isElementSVG) {
	        svgTransform = createSVGTransform(transformOpts, this.props.positionOffset);
	      } else {
	        // Add a CSS transform to move the element around. This allows us to move the element around
	        // without worrying about whether or not it is relatively or absolutely positioned.
	        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
	        // has a clean slate.
	        style = createCSSTransform(transformOpts, this.props.positionOffset);
	      }

	      var _props = this.props,
	          defaultClassName = _props.defaultClassName,
	          defaultClassNameDragging = _props.defaultClassNameDragging,
	          defaultClassNameDragged = _props.defaultClassNameDragged;


	      var children = React.Children.only(this.props.children);

	      // Mark with class while dragging
	      var className = classnames(children.props.className || '', defaultClassName, (_classNames = {}, defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));

	      // Reuse the child provided
	      // This makes it flexible to use whatever element is wanted (div, ul, etc)
	      return React.createElement(
	        DraggableCore,
	        _extends({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }),
	        React.cloneElement(children, {
	          className: className,
	          style: _extends({}, children.props.style, style),
	          transform: svgTransform
	        })
	      );
	    }
	  }]);
	  return Draggable;
	}(React.Component);

	Draggable.displayName = 'Draggable';
	Draggable.propTypes = _extends({}, DraggableCore.propTypes, {

	  /**
	   * `axis` determines which axis the draggable can move.
	   *
	   *  Note that all callbacks will still return data as normal. This only
	   *  controls flushing to the DOM.
	   *
	   * 'both' allows movement horizontally and vertically.
	   * 'x' limits movement to horizontal axis.
	   * 'y' limits movement to vertical axis.
	   * 'none' limits all movement.
	   *
	   * Defaults to 'both'.
	   */
	  axis: propTypes.oneOf(['both', 'x', 'y', 'none']),

	  /**
	   * `bounds` determines the range of movement available to the element.
	   * Available values are:
	   *
	   * 'parent' restricts movement within the Draggable's parent node.
	   *
	   * Alternatively, pass an object with the following properties, all of which are optional:
	   *
	   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
	   *
	   * All values are in px.
	   *
	   * Example:
	   *
	   * ```jsx
	   *   let App = React.createClass({
	   *       render: function () {
	   *         return (
	   *            <Draggable bounds={{right: 300, bottom: 300}}>
	   *              <div>Content</div>
	   *           </Draggable>
	   *         );
	   *       }
	   *   });
	   * ```
	   */
	  bounds: propTypes.oneOfType([propTypes.shape({
	    left: propTypes.number,
	    right: propTypes.number,
	    top: propTypes.number,
	    bottom: propTypes.number
	  }), propTypes.string, propTypes.oneOf([false])]),

	  defaultClassName: propTypes.string,
	  defaultClassNameDragging: propTypes.string,
	  defaultClassNameDragged: propTypes.string,

	  /**
	   * `defaultPosition` specifies the x and y that the dragged item should start at
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  defaultPosition: propTypes.shape({
	    x: propTypes.number,
	    y: propTypes.number
	  }),
	  positionOffset: propTypes.shape({
	    x: propTypes.oneOfType([propTypes.number, propTypes.string]),
	    y: propTypes.oneOfType([propTypes.number, propTypes.string])
	  }),

	  /**
	   * `position`, if present, defines the current position of the element.
	   *
	   *  This is similar to how form elements in React work - if no `position` is supplied, the component
	   *  is uncontrolled.
	   *
	   * Example:
	   *
	   * ```jsx
	   *      let App = React.createClass({
	   *          render: function () {
	   *              return (
	   *                  <Draggable position={{x: 25, y: 25}}>
	   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	   *                  </Draggable>
	   *              );
	   *          }
	   *      });
	   * ```
	   */
	  position: propTypes.shape({
	    x: propTypes.number,
	    y: propTypes.number
	  }),

	  /**
	   * These properties should be defined on the child, not here.
	   */
	  className: dontSetMe,
	  style: dontSetMe,
	  transform: dontSetMe
	});
	Draggable.defaultProps = _extends({}, DraggableCore.defaultProps, {
	  axis: 'both',
	  bounds: false,
	  defaultClassName: 'react-draggable',
	  defaultClassNameDragging: 'react-draggable-dragging',
	  defaultClassNameDragged: 'react-draggable-dragged',
	  defaultPosition: { x: 0, y: 0 },
	  position: null,
	  scale: 1
	});

	// Previous versions of this lib exported <Draggable> as the root export. As to not break
	// them, or TypeScript, we export *both* as the root and as 'default'.
	// See https://github.com/mzabriskie/react-draggable/pull/254
	// and https://github.com/mzabriskie/react-draggable/issues/266
	Draggable.default = Draggable;
	Draggable.DraggableCore = DraggableCore;

	return Draggable;

})));
//# sourceMappingURL=react-draggable.js.map


/***/ }),

/***/ "./node_modules/react-spring/renderprops.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/react-spring/renderprops.cjs.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _objectWithoutPropertiesLoose = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"));
var _inheritsLoose = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/inheritsLoose.js"));
var _assertThisInitialized = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));
var _extends = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var React__default = _interopDefault(React);
var ReactDOM = _interopDefault(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));

var bugfixes = undefined;
var applyAnimatedValues = undefined;
var colorNames = [];
var requestFrame = function requestFrame(cb) {
  return typeof window !== 'undefined' && window.requestAnimationFrame(cb);
};
var cancelFrame = function cancelFrame(cb) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame(cb);
};
var interpolation = undefined;
var now = function now() {
  return Date.now();
};
var defaultElement = undefined;
var createAnimatedStyle = undefined;
var injectApplyAnimatedValues = function injectApplyAnimatedValues(fn, transform) {
  return applyAnimatedValues = {
    fn: fn,
    transform: transform
  };
};
var injectColorNames = function injectColorNames(names) {
  return colorNames = names;
};
var injectBugfixes = function injectBugfixes(fn) {
  return bugfixes = fn;
};
var injectInterpolation = function injectInterpolation(cls) {
  return interpolation = cls;
};
var injectFrame = function injectFrame(raf, caf) {
  var _ref;

  return _ref = [raf, caf], requestFrame = _ref[0], cancelFrame = _ref[1], _ref;
};
var injectNow = function injectNow(nowFn) {
  return now = nowFn;
};
var injectDefaultElement = function injectDefaultElement(el) {
  return defaultElement = el;
};
var injectCreateAnimatedStyle = function injectCreateAnimatedStyle(factory) {
  return createAnimatedStyle = factory;
};

var Globals = /*#__PURE__*/Object.freeze({
  get bugfixes () { return bugfixes; },
  get applyAnimatedValues () { return applyAnimatedValues; },
  get colorNames () { return colorNames; },
  get requestFrame () { return requestFrame; },
  get cancelFrame () { return cancelFrame; },
  get interpolation () { return interpolation; },
  get now () { return now; },
  get defaultElement () { return defaultElement; },
  get createAnimatedStyle () { return createAnimatedStyle; },
  injectApplyAnimatedValues: injectApplyAnimatedValues,
  injectColorNames: injectColorNames,
  injectBugfixes: injectBugfixes,
  injectInterpolation: injectInterpolation,
  injectFrame: injectFrame,
  injectNow: injectNow,
  injectDefaultElement: injectDefaultElement,
  injectCreateAnimatedStyle: injectCreateAnimatedStyle
});

var Animated =
/*#__PURE__*/
function () {
  function Animated() {}

  var _proto = Animated.prototype;

  _proto.attach = function attach() {};

  _proto.detach = function detach() {};

  _proto.getValue = function getValue() {};

  _proto.getAnimatedValue = function getAnimatedValue() {
    return this.getValue();
  };

  _proto.addChild = function addChild(child) {};

  _proto.removeChild = function removeChild(child) {};

  _proto.getChildren = function getChildren() {
    return [];
  };

  return Animated;
}();

var getValues = function getValues(object) {
  return Object.keys(object).map(function (k) {
    return object[k];
  });
};

var AnimatedWithChildren =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedWithChildren, _Animated);

  function AnimatedWithChildren() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Animated.call.apply(_Animated, [this].concat(args)) || this;
    _this.children = [];

    _this.getChildren = function () {
      return _this.children;
    };

    _this.getPayload = function (index) {
      if (index === void 0) {
        index = undefined;
      }

      return index !== void 0 && _this.payload ? _this.payload[index] : _this.payload || _assertThisInitialized(_this);
    };

    return _this;
  }

  var _proto = AnimatedWithChildren.prototype;

  _proto.addChild = function addChild(child) {
    if (this.children.length === 0) this.attach();
    this.children.push(child);
  };

  _proto.removeChild = function removeChild(child) {
    var index = this.children.indexOf(child);
    this.children.splice(index, 1);
    if (this.children.length === 0) this.detach();
  };

  return AnimatedWithChildren;
}(Animated);
var AnimatedArrayWithChildren =
/*#__PURE__*/
function (_AnimatedWithChildren) {
  _inheritsLoose(AnimatedArrayWithChildren, _AnimatedWithChildren);

  function AnimatedArrayWithChildren() {
    var _this2;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = _AnimatedWithChildren.call.apply(_AnimatedWithChildren, [this].concat(args)) || this;
    _this2.payload = [];

    _this2.getAnimatedValue = function () {
      return _this2.getValue();
    };

    _this2.attach = function () {
      return _this2.payload.forEach(function (p) {
        return p instanceof Animated && p.addChild(_assertThisInitialized(_this2));
      });
    };

    _this2.detach = function () {
      return _this2.payload.forEach(function (p) {
        return p instanceof Animated && p.removeChild(_assertThisInitialized(_this2));
      });
    };

    return _this2;
  }

  return AnimatedArrayWithChildren;
}(AnimatedWithChildren);
var AnimatedObjectWithChildren =
/*#__PURE__*/
function (_AnimatedWithChildren2) {
  _inheritsLoose(AnimatedObjectWithChildren, _AnimatedWithChildren2);

  function AnimatedObjectWithChildren() {
    var _this3;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    _this3 = _AnimatedWithChildren2.call.apply(_AnimatedWithChildren2, [this].concat(args)) || this;
    _this3.payload = {};

    _this3.getAnimatedValue = function () {
      return _this3.getValue(true);
    };

    _this3.attach = function () {
      return getValues(_this3.payload).forEach(function (s) {
        return s instanceof Animated && s.addChild(_assertThisInitialized(_this3));
      });
    };

    _this3.detach = function () {
      return getValues(_this3.payload).forEach(function (s) {
        return s instanceof Animated && s.removeChild(_assertThisInitialized(_this3));
      });
    };

    return _this3;
  }

  var _proto2 = AnimatedObjectWithChildren.prototype;

  _proto2.getValue = function getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }

    var payload = {};

    for (var key in this.payload) {
      var value = this.payload[key];
      if (animated && !(value instanceof Animated)) continue;
      payload[key] = value instanceof Animated ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;
    }

    return payload;
  };

  return AnimatedObjectWithChildren;
}(AnimatedWithChildren);

var AnimatedStyle =
/*#__PURE__*/
function (_AnimatedObjectWithCh) {
  _inheritsLoose(AnimatedStyle, _AnimatedObjectWithCh);

  function AnimatedStyle(style) {
    var _this;

    _this = _AnimatedObjectWithCh.call(this) || this;
    style = style || {};
    if (style.transform && !(style.transform instanceof Animated)) style = applyAnimatedValues.transform(style);
    _this.payload = style;
    return _this;
  }

  return AnimatedStyle;
}(AnimatedObjectWithChildren);

// http://www.w3.org/TR/css3-color/#svg-color
var colors = {
  transparent: 0x00000000,
  aliceblue: 0xf0f8ffff,
  antiquewhite: 0xfaebd7ff,
  aqua: 0x00ffffff,
  aquamarine: 0x7fffd4ff,
  azure: 0xf0ffffff,
  beige: 0xf5f5dcff,
  bisque: 0xffe4c4ff,
  black: 0x000000ff,
  blanchedalmond: 0xffebcdff,
  blue: 0x0000ffff,
  blueviolet: 0x8a2be2ff,
  brown: 0xa52a2aff,
  burlywood: 0xdeb887ff,
  burntsienna: 0xea7e5dff,
  cadetblue: 0x5f9ea0ff,
  chartreuse: 0x7fff00ff,
  chocolate: 0xd2691eff,
  coral: 0xff7f50ff,
  cornflowerblue: 0x6495edff,
  cornsilk: 0xfff8dcff,
  crimson: 0xdc143cff,
  cyan: 0x00ffffff,
  darkblue: 0x00008bff,
  darkcyan: 0x008b8bff,
  darkgoldenrod: 0xb8860bff,
  darkgray: 0xa9a9a9ff,
  darkgreen: 0x006400ff,
  darkgrey: 0xa9a9a9ff,
  darkkhaki: 0xbdb76bff,
  darkmagenta: 0x8b008bff,
  darkolivegreen: 0x556b2fff,
  darkorange: 0xff8c00ff,
  darkorchid: 0x9932ccff,
  darkred: 0x8b0000ff,
  darksalmon: 0xe9967aff,
  darkseagreen: 0x8fbc8fff,
  darkslateblue: 0x483d8bff,
  darkslategray: 0x2f4f4fff,
  darkslategrey: 0x2f4f4fff,
  darkturquoise: 0x00ced1ff,
  darkviolet: 0x9400d3ff,
  deeppink: 0xff1493ff,
  deepskyblue: 0x00bfffff,
  dimgray: 0x696969ff,
  dimgrey: 0x696969ff,
  dodgerblue: 0x1e90ffff,
  firebrick: 0xb22222ff,
  floralwhite: 0xfffaf0ff,
  forestgreen: 0x228b22ff,
  fuchsia: 0xff00ffff,
  gainsboro: 0xdcdcdcff,
  ghostwhite: 0xf8f8ffff,
  gold: 0xffd700ff,
  goldenrod: 0xdaa520ff,
  gray: 0x808080ff,
  green: 0x008000ff,
  greenyellow: 0xadff2fff,
  grey: 0x808080ff,
  honeydew: 0xf0fff0ff,
  hotpink: 0xff69b4ff,
  indianred: 0xcd5c5cff,
  indigo: 0x4b0082ff,
  ivory: 0xfffff0ff,
  khaki: 0xf0e68cff,
  lavender: 0xe6e6faff,
  lavenderblush: 0xfff0f5ff,
  lawngreen: 0x7cfc00ff,
  lemonchiffon: 0xfffacdff,
  lightblue: 0xadd8e6ff,
  lightcoral: 0xf08080ff,
  lightcyan: 0xe0ffffff,
  lightgoldenrodyellow: 0xfafad2ff,
  lightgray: 0xd3d3d3ff,
  lightgreen: 0x90ee90ff,
  lightgrey: 0xd3d3d3ff,
  lightpink: 0xffb6c1ff,
  lightsalmon: 0xffa07aff,
  lightseagreen: 0x20b2aaff,
  lightskyblue: 0x87cefaff,
  lightslategray: 0x778899ff,
  lightslategrey: 0x778899ff,
  lightsteelblue: 0xb0c4deff,
  lightyellow: 0xffffe0ff,
  lime: 0x00ff00ff,
  limegreen: 0x32cd32ff,
  linen: 0xfaf0e6ff,
  magenta: 0xff00ffff,
  maroon: 0x800000ff,
  mediumaquamarine: 0x66cdaaff,
  mediumblue: 0x0000cdff,
  mediumorchid: 0xba55d3ff,
  mediumpurple: 0x9370dbff,
  mediumseagreen: 0x3cb371ff,
  mediumslateblue: 0x7b68eeff,
  mediumspringgreen: 0x00fa9aff,
  mediumturquoise: 0x48d1ccff,
  mediumvioletred: 0xc71585ff,
  midnightblue: 0x191970ff,
  mintcream: 0xf5fffaff,
  mistyrose: 0xffe4e1ff,
  moccasin: 0xffe4b5ff,
  navajowhite: 0xffdeadff,
  navy: 0x000080ff,
  oldlace: 0xfdf5e6ff,
  olive: 0x808000ff,
  olivedrab: 0x6b8e23ff,
  orange: 0xffa500ff,
  orangered: 0xff4500ff,
  orchid: 0xda70d6ff,
  palegoldenrod: 0xeee8aaff,
  palegreen: 0x98fb98ff,
  paleturquoise: 0xafeeeeff,
  palevioletred: 0xdb7093ff,
  papayawhip: 0xffefd5ff,
  peachpuff: 0xffdab9ff,
  peru: 0xcd853fff,
  pink: 0xffc0cbff,
  plum: 0xdda0ddff,
  powderblue: 0xb0e0e6ff,
  purple: 0x800080ff,
  rebeccapurple: 0x663399ff,
  red: 0xff0000ff,
  rosybrown: 0xbc8f8fff,
  royalblue: 0x4169e1ff,
  saddlebrown: 0x8b4513ff,
  salmon: 0xfa8072ff,
  sandybrown: 0xf4a460ff,
  seagreen: 0x2e8b57ff,
  seashell: 0xfff5eeff,
  sienna: 0xa0522dff,
  silver: 0xc0c0c0ff,
  skyblue: 0x87ceebff,
  slateblue: 0x6a5acdff,
  slategray: 0x708090ff,
  slategrey: 0x708090ff,
  snow: 0xfffafaff,
  springgreen: 0x00ff7fff,
  steelblue: 0x4682b4ff,
  tan: 0xd2b48cff,
  teal: 0x008080ff,
  thistle: 0xd8bfd8ff,
  tomato: 0xff6347ff,
  turquoise: 0x40e0d0ff,
  violet: 0xee82eeff,
  wheat: 0xf5deb3ff,
  white: 0xffffffff,
  whitesmoke: 0xf5f5f5ff,
  yellow: 0xffff00ff,
  yellowgreen: 0x9acd32ff
};

var Interpolation =
/*#__PURE__*/
function () {
  function Interpolation() {}

  // Default config = config, args
  // Short config   = range, output, extrapolate
  Interpolation.create = function create(config, output, extra) {
    if (typeof config === 'function') return config;else if (interpolation && config.output && typeof config.output[0] === 'string') return interpolation(config);else if (Array.isArray(config)) return Interpolation.create({
      range: config,
      output: output,
      extrapolate: extra || 'extend'
    });
    var outputRange = config.output;
    var inputRange = config.range || [0, 1];

    var easing = config.easing || function (t) {
      return t;
    };

    var extrapolateLeft = 'extend';
    var map = config.map;
    if (config.extrapolateLeft !== undefined) extrapolateLeft = config.extrapolateLeft;else if (config.extrapolate !== undefined) extrapolateLeft = config.extrapolate;
    var extrapolateRight = 'extend';
    if (config.extrapolateRight !== undefined) extrapolateRight = config.extrapolateRight;else if (config.extrapolate !== undefined) extrapolateRight = config.extrapolate;
    return function (input) {
      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, map);
    };
  };

  return Interpolation;
}();

function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  var result = map ? map(input) : input; // Extrapolate

  if (result < inputMin) {
    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;
  }

  if (outputMin === outputMax) return outputMin;
  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax; // Input Range

  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin); // Easing

  result = easing(result); // Output Range

  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;
  return result;
}

function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) break;
  }

  return i - 1;
}

// const INTEGER = '[-+]?\\d+';
var NUMBER = '[-+]?\\d*\\.?\\d+';
var PERCENTAGE = NUMBER + '%';

function call() {
  return '\\(\\s*(' + Array.prototype.slice.call(arguments).join(')\\s*,\\s*(') + ')\\s*\\)';
}

var rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;

/*
https://github.com/react-community/normalize-css-color

BSD 3-Clause License

Copyright (c) 2016, React Community
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function normalizeColor(color) {
  var match;

  if (typeof color === 'number') {
    return color >>> 0 === color && color >= 0 && color <= 0xffffffff ? color : null;
  } // Ordered based on occurrences on Facebook codebase


  if (match = hex6.exec(color)) return parseInt(match[1] + 'ff', 16) >>> 0;
  if (colors.hasOwnProperty(color)) return colors[color];

  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    0x000000ff) >>> // a
    0;
  }

  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }

  if (match = hex3.exec(color)) {
    return parseInt(match[1] + match[1] + // r
    match[2] + match[2] + // g
    match[3] + match[3] + // b
    'ff', // a
    16) >>> 0;
  } // https://drafts.csswg.org/css-color-4/#hex-notation


  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;

  if (match = hex4.exec(color)) {
    return parseInt(match[1] + match[1] + // r
    match[2] + match[2] + // g
    match[3] + match[3] + // b
    match[4] + match[4], // a
    16) >>> 0;
  }

  if (match = hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]), // h
    parsePercentage(match[2]), // s
    parsePercentage(match[3]) // l
    ) | 0x000000ff) >>> // a
    0;
  }

  if (match = hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]), // h
    parsePercentage(match[2]), // s
    parsePercentage(match[3]) // l
    ) | parse1(match[4])) >>> // a
    0;
  }

  return null;
}

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

function hslToRgb(h, s, l) {
  var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  var p = 2 * l - q;
  var r = hue2rgb(p, q, h + 1 / 3);
  var g = hue2rgb(p, q, h);
  var b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}

function parse255(str) {
  var int = parseInt(str, 10);
  if (int < 0) return 0;
  if (int > 255) return 255;
  return int;
}

function parse360(str) {
  var int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}

function parse1(str) {
  var num = parseFloat(str);
  if (num < 0) return 0;
  if (num > 1) return 255;
  return Math.round(num * 255);
}

function parsePercentage(str) {
  // parseFloat conveniently ignores the final %
  var int = parseFloat(str);
  if (int < 0) return 0;
  if (int > 100) return 1;
  return int / 100;
}

function colorToRgba(input) {
  var int32Color = normalizeColor(input);
  if (int32Color === null) return input;
  int32Color = int32Color || 0;
  var r = (int32Color & 0xff000000) >>> 24;
  var g = (int32Color & 0x00ff0000) >>> 16;
  var b = (int32Color & 0x0000ff00) >>> 8;
  var a = (int32Color & 0x000000ff) / 255;
  return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
} // Problem: https://github.com/animatedjs/animated/pull/102
// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662


var stringShapeRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g; // Covers rgb, rgba, hsl, hsla
// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e

var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi; // Covers color names (transparent, blue, etc.)

var colorNamesRegex = new RegExp("(" + Object.keys(colors).join('|') + ")", 'g');
/**
 * Supports string shapes by extracting numbers so new values can be computed,
 * and recombines those values into new strings of the same shape.  Supports
 * things like:
 *
 *   rgba(123, 42, 99, 0.36)           // colors
 *   -45deg                            // values with units
 *   0 2px 2px 0px rgba(0, 0, 0, 0.12) // box shadows
 */

function createInterpolation(config) {
  // Replace colors with rgba
  var outputRange = config.output.map(function (rangeValue) {
    return rangeValue.replace(colorRegex, colorToRgba);
  }).map(function (rangeValue) {
    return rangeValue.replace(colorNamesRegex, colorToRgba);
  }); // ->
  // [
  //   [0, 50],
  //   [100, 150],
  //   [200, 250],
  //   [0, 0.5],
  // ]

  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
    return [];
  });
  outputRange.forEach(function (value) {
    value.match(stringShapeRegex).forEach(function (number, i) {
      return outputRanges[i].push(+number);
    });
  });
  var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
    return Interpolation.create(_extends({}, config, {
      output: outputRanges[i]
    }));
  });
  return function (input) {
    var i = 0;
    return outputRange[0] // 'rgba(0, 100, 200, 0)'
    // ->
    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
    .replace(stringShapeRegex, function () {
      return interpolations[i++](input);
    }) // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
    // round the opacity (4th column).
    .replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, function (_, p1, p2, p3, p4) {
      return "rgba(" + Math.round(p1) + ", " + Math.round(p2) + ", " + Math.round(p3) + ", " + p4 + ")";
    });
  };
}

var AnimatedInterpolation =
/*#__PURE__*/
function (_AnimatedArrayWithChi) {
  _inheritsLoose(AnimatedInterpolation, _AnimatedArrayWithChi);

  function AnimatedInterpolation(parents, _config, _arg) {
    var _this;

    _this = _AnimatedArrayWithChi.call(this) || this;

    _this.getValue = function () {
      var _this2;

      return (_this2 = _this).calc.apply(_this2, _this.payload.map(function (value) {
        return value.getValue();
      }));
    };

    _this.updateConfig = function (config, arg) {
      return _this.calc = Interpolation.create(config, arg);
    };

    _this.interpolate = function (config, arg) {
      return new AnimatedInterpolation(_assertThisInitialized(_this), config, arg);
    };

    _this.payload = // AnimatedArrays should unfold, except AnimatedInterpolation which is taken as is
    parents instanceof AnimatedArrayWithChildren && !parents.updateConfig ? parents.payload : Array.isArray(parents) ? parents : [parents];
    _this.calc = Interpolation.create(_config, _arg);
    return _this;
  }

  return AnimatedInterpolation;
}(AnimatedArrayWithChildren);
var interpolate$1 = function interpolate(parents, config, arg) {
  return parents && new AnimatedInterpolation(parents, config, arg);
};

/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an Animated.Value is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */

function findAnimatedStyles(node, styles) {
  if (typeof node.update === 'function') styles.add(node);else node.getChildren().forEach(function (child) {
    return findAnimatedStyles(child, styles);
  });
}
/**
 * Standard value for driving animations.  One `Animated.Value` can drive
 * multiple properties in a synchronized fashion, but can only be driven by one
 * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
 * or calling `setValue`) will stop any previous ones.
 */


var AnimatedValue =
/*#__PURE__*/
function (_AnimatedWithChildren) {
  _inheritsLoose(AnimatedValue, _AnimatedWithChildren);

  function AnimatedValue(_value) {
    var _this;

    _this = _AnimatedWithChildren.call(this) || this;

    _this.setValue = function (value, flush) {
      if (flush === void 0) {
        flush = true;
      }

      _this.value = value;
      if (flush) _this.flush();
    };

    _this.getValue = function () {
      return _this.value;
    };

    _this.updateStyles = function () {
      return findAnimatedStyles(_assertThisInitialized(_this), _this.animatedStyles);
    };

    _this.updateValue = function (value) {
      return _this.flush(_this.value = value);
    };

    _this.interpolate = function (config, arg) {
      return new AnimatedInterpolation(_assertThisInitialized(_this), config, arg);
    };

    _this.value = _value;
    _this.animatedStyles = new Set();
    _this.done = false;
    _this.startPosition = _value;
    _this.lastPosition = _value;
    _this.lastVelocity = undefined;
    _this.lastTime = undefined;
    _this.controller = undefined;
    return _this;
  }

  var _proto = AnimatedValue.prototype;

  _proto.flush = function flush() {
    if (this.animatedStyles.size === 0) this.updateStyles();
    this.animatedStyles.forEach(function (animatedStyle) {
      return animatedStyle.update();
    });
  };

  _proto.prepare = function prepare(controller) {
    // Values stay loyal to their original controller, this is also a way to
    // detect trailing values originating from a foreign controller
    if (this.controller === undefined) this.controller = controller;

    if (this.controller === controller) {
      this.startPosition = this.value;
      this.lastPosition = this.value;
      this.lastVelocity = controller.isActive ? this.lastVelocity : undefined;
      this.lastTime = controller.isActive ? this.lastTime : undefined;
      this.done = false;
      this.animatedStyles.clear();
    }
  };

  return AnimatedValue;
}(AnimatedWithChildren);

var AnimatedArray =
/*#__PURE__*/
function (_AnimatedArrayWithChi) {
  _inheritsLoose(AnimatedArray, _AnimatedArrayWithChi);

  function AnimatedArray(array) {
    var _this;

    _this = _AnimatedArrayWithChi.call(this) || this;

    _this.setValue = function (value, flush) {
      if (flush === void 0) {
        flush = true;
      }

      if (Array.isArray(value)) {
        if (value.length === _this.payload.length) value.forEach(function (v, i) {
          return _this.payload[i].setValue(v, flush);
        });
      } else _this.payload.forEach(function (v, i) {
        return _this.payload[i].setValue(value, flush);
      });
    };

    _this.getValue = function () {
      return _this.payload.map(function (v) {
        return v.getValue();
      });
    };

    _this.interpolate = function (config, arg) {
      return new AnimatedInterpolation(_assertThisInitialized(_this), config, arg);
    };

    _this.payload = array.map(function (n) {
      return new AnimatedValue(n);
    });
    return _this;
  }

  return AnimatedArray;
}(AnimatedArrayWithChildren);

function withDefault(value, defaultValue) {
  return value === undefined || value === null ? defaultValue : value;
}
function toArray(a) {
  return a !== void 0 ? Array.isArray(a) ? a : [a] : [];
}
function shallowEqual(a, b) {
  if (typeof a !== typeof b) return false;
  if (typeof a === 'string' || typeof a === 'number') return a === b;
  var i;

  for (i in a) {
    if (!(i in b)) return false;
  }

  for (i in b) {
    if (a[i] !== b[i]) return false;
  }

  return i === void 0 ? a === b : true;
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return typeof obj === 'function' ? obj.apply(void 0, args) : obj;
}
function getValues$1(object) {
  return Object.keys(object).map(function (k) {
    return object[k];
  });
}
function getForwardProps(props) {
  var to = props.to,
      from = props.from,
      config = props.config,
      native = props.native,
      onStart = props.onStart,
      onRest = props.onRest,
      onFrame = props.onFrame,
      children = props.children,
      reset = props.reset,
      reverse = props.reverse,
      force = props.force,
      immediate = props.immediate,
      impl = props.impl,
      inject = props.inject,
      delay = props.delay,
      attach = props.attach,
      destroyed = props.destroyed,
      interpolateTo = props.interpolateTo,
      autoStart = props.autoStart,
      ref = props.ref,
      forward = _objectWithoutPropertiesLoose(props, ["to", "from", "config", "native", "onStart", "onRest", "onFrame", "children", "reset", "reverse", "force", "immediate", "impl", "inject", "delay", "attach", "destroyed", "interpolateTo", "autoStart", "ref"]);

  return forward;
}
function interpolateTo(props) {
  var forward = getForwardProps(props);
  var rest = Object.keys(props).reduce(function (a, k) {
    var _extends2;

    return forward[k] !== void 0 ? a : _extends({}, a, (_extends2 = {}, _extends2[k] = props[k], _extends2));
  }, {});
  return _extends({
    to: forward
  }, rest);
}
function convertToAnimatedValue(acc, _ref) {
  var _extends3;

  var name = _ref[0],
      value = _ref[1];
  return _extends({}, acc, (_extends3 = {}, _extends3[name] = new (Array.isArray(value) ? AnimatedArray : AnimatedValue)(value), _extends3));
}
function convertValues(props) {
  var from = props.from,
      to = props.to,
      native = props.native;
  var allProps = Object.entries(_extends({}, from, to));
  return native ? allProps.reduce(convertToAnimatedValue, {}) : _extends({}, from, to);
}
function handleRef(ref, forward) {
  if (forward) {
    // If it's a function, assume it's a ref callback
    if (typeof forward === 'function') forward(ref);else if (typeof forward === 'object') {
      // If it's an object and has a 'current' property, assume it's a ref object
      forward.current = ref;
    }
  }

  return ref;
}

var check = function check(value) {
  return value === 'auto';
};

var overwrite = function overwrite(width, height) {
  return function (acc, _ref) {
    var _extends2;

    var name = _ref[0],
        value = _ref[1];
    return _extends({}, acc, (_extends2 = {}, _extends2[name] = value === 'auto' ? ~name.indexOf('height') ? height : width : value, _extends2));
  };
};

function fixAuto(props, callback) {
  var from = props.from,
      to = props.to,
      children = props.children; // Dry-route props back if nothing's using 'auto' in there
  // TODO: deal with "null"

  if (!(getValues$1(to).some(check) || getValues$1(from).some(check))) return; // Fetch render v-dom

  var element = children(convertValues(props)); // A spring can return undefined/null, check against that (#153)

  if (!element) return; // Or it could be an array (#346) ...

  if (Array.isArray(element)) element = {
    type: 'div',
    props: {
      children: element
    } // Extract styles

  };
  var elementStyles = element.props.style; // Return v.dom with injected ref

  return React__default.createElement(element.type, _extends({
    key: element.key ? element.key : undefined
  }, element.props, {
    style: _extends({}, elementStyles, {
      position: 'absolute',
      visibility: 'hidden'
    }),
    ref: function ref(_ref2) {
      if (_ref2) {
        // Once it's rendered out, fetch bounds (minus padding/margin/borders)
        var node = ReactDOM.findDOMNode(_ref2);
        var width, height;
        var cs = getComputedStyle(node);

        if (cs.boxSizing === 'border-box') {
          width = node.offsetWidth;
          height = node.offsetHeight;
        } else {
          var paddingX = parseFloat(cs.paddingLeft || 0) + parseFloat(cs.paddingRight || 0);
          var paddingY = parseFloat(cs.paddingTop || 0) + parseFloat(cs.paddingBottom || 0);
          var borderX = parseFloat(cs.borderLeftWidth || 0) + parseFloat(cs.borderRightWidth || 0);
          var borderY = parseFloat(cs.borderTopWidth || 0) + parseFloat(cs.borderBottomWidth || 0);
          width = node.offsetWidth - paddingX - borderX;
          height = node.offsetHeight - paddingY - borderY;
        }

        var convert = overwrite(width, height);
        callback(_extends({}, props, {
          from: Object.entries(from).reduce(convert, from),
          to: Object.entries(to).reduce(convert, to)
        }));
      }
    }
  }));
}

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

var prefixKey = function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
};

var prefixes = ['Webkit', 'Ms', 'Moz', 'O'];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce(function (acc, prop) {
  prefixes.forEach(function (prefix) {
    return acc[prefixKey(prefix, prop)] = acc[prop];
  });
  return acc;
}, isUnitlessNumber);

function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === 'boolean' || value === '') return '';
  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers

  return ('' + value).trim();
}

var attributeCache = {};
injectCreateAnimatedStyle(function (style) {
  return new AnimatedStyle(style);
});
injectDefaultElement('div');
injectInterpolation(createInterpolation);
injectColorNames(colors);
injectBugfixes(fixAuto);
injectApplyAnimatedValues(function (instance, props) {
  if (instance.nodeType && instance.setAttribute !== undefined) {
    var style = props.style,
        children = props.children,
        scrollTop = props.scrollTop,
        scrollLeft = props.scrollLeft,
        attributes = _objectWithoutPropertiesLoose(props, ["style", "children", "scrollTop", "scrollLeft"]);

    if (scrollTop !== void 0) instance.scrollTop = scrollTop;
    if (scrollLeft !== void 0) instance.scrollLeft = scrollLeft; // Set textContent, if children is an animatable value

    if (children !== void 0) instance.textContent = children; // Set styles ...

    for (var styleName in style) {
      if (!style.hasOwnProperty(styleName)) continue;
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
      if (styleName === 'float') styleName = 'cssFloat';
      if (isCustomProperty) instance.style.setProperty(styleName, styleValue);else instance.style[styleName] = styleValue;
    } // Set attributes ...


    for (var name in attributes) {
      // Attributes are written in dash case
      var dashCase = attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, function (n) {
        return '-' + n.toLowerCase();
      }));
      if (typeof instance.getAttribute(dashCase) !== 'undefined') instance.setAttribute(dashCase, attributes[name]);
    }
  } else return false;
}, function (style) {
  return style;
});

var active = false;
var controllers = new Set();

var frameLoop = function frameLoop() {
  var time = now();

  for (var _iterator = controllers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var controller = _ref;
    var isDone = true;
    var noChange = true;

    for (var configIdx = 0; configIdx < controller.configs.length; configIdx++) {
      var config = controller.configs[configIdx];
      var endOfAnimation = void 0,
          lastTime = void 0;

      for (var valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {
        var animation = config.animatedValues[valIdx]; // If an animation is done, skip, until all of them conclude

        if (animation.done) continue;
        var from = config.fromValues[valIdx];
        var to = config.toValues[valIdx];
        var position = animation.lastPosition;
        var isAnimated = to instanceof Animated;

        var _velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;

        if (isAnimated) to = to.getValue(); // Conclude animation if it's either immediate, or from-values match end-state

        if (config.immediate || !isAnimated && !config.decay && from === to) {
          animation.updateValue(to);
          animation.done = true;
          continue;
        } // Doing delay here instead of setTimeout is one async worry less


        if (config.delay && time - controller.startTime < config.delay) {
          isDone = false;
          continue;
        } // Flag change


        noChange = false; // Break animation when string values are involved

        if (typeof from === 'string' || typeof to === 'string') {
          animation.updateValue(to);
          animation.done = true;
          continue;
        }

        if (config.duration !== void 0) {
          /** Duration easing */
          position = from + config.easing((time - controller.startTime - config.delay) / config.duration) * (to - from);
          endOfAnimation = time >= controller.startTime + config.delay + config.duration;
        } else if (config.decay) {
          /** Decay easing */
          position = from + _velocity / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (time - controller.startTime)));
          endOfAnimation = Math.abs(animation.lastPosition - position) < 0.1;
          if (endOfAnimation) to = position;
        } else {
          /** Spring easing */
          lastTime = animation.lastTime !== void 0 ? animation.lastTime : time;
          _velocity = animation.lastVelocity !== void 0 ? animation.lastVelocity : config.initialVelocity; // If we lost a lot of frames just jump to the end.

          if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/

          var numSteps = Math.floor(time - lastTime);

          for (var i = 0; i < numSteps; ++i) {
            var force = -config.tension * (position - to);
            var damping = -config.friction * _velocity;
            var acceleration = (force + damping) / config.mass;
            _velocity = _velocity + acceleration * 1 / 1000;
            position = position + _velocity * 1 / 1000;
          } // Conditions for stopping the spring animation


          var isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;
          var isVelocity = Math.abs(_velocity) <= config.precision;
          var isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;
          endOfAnimation = isOvershooting || isVelocity && isDisplacement;
          animation.lastVelocity = _velocity;
          animation.lastTime = time;
        } // Trails aren't done until their parents conclude


        if (isAnimated && !config.toValues[valIdx].done) endOfAnimation = false;

        if (endOfAnimation) {
          // Ensure that we end up with a round value
          if (animation.value !== to) position = to;
          animation.done = true;
        } else isDone = false;

        animation.updateValue(position);
        animation.lastPosition = position;
      } // Keep track of updated values only when necessary


      if (controller.props.onFrame || !controller.props.native) controller.animatedProps[config.name] = config.interpolation.getValue();
    } // Update callbacks in the end of the frame


    if (controller.props.onFrame || !controller.props.native) {
      if (!controller.props.native && controller.onUpdate) controller.onUpdate();
      if (controller.props.onFrame) controller.props.onFrame(controller.animatedProps);
    } // Either call onEnd or next frame


    if (isDone) {
      controllers.delete(controller);
      controller.debouncedOnEnd({
        finished: true,
        noChange: noChange
      });
    }
  } // Loop over as long as there are controllers ...


  if (controllers.size) requestFrame(frameLoop);else active = false;
};

var addController = function addController(controller) {
  if (!controllers.has(controller)) {
    controllers.add(controller);
    if (!active) requestFrame(frameLoop);
    active = true;
  }
};

var removeController = function removeController(controller) {
  if (controllers.has(controller)) {
    controllers.delete(controller);
  }
};

var Controller =
/*#__PURE__*/
function () {
  function Controller(props, config) {
    var _this = this;

    if (config === void 0) {
      config = {
        native: true,
        interpolateTo: true,
        autoStart: true
      };
    }

    this.getValues = function () {
      return _this.props.native ? _this.interpolations : _this.animatedProps;
    };

    this.dependents = new Set();
    this.isActive = false;
    this.hasChanged = false;
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.animatedProps = {};
    this.configs = [];
    this.frame = undefined;
    this.startTime = undefined;
    this.lastTime = undefined;
    this.update(_extends({}, props, config));
  }

  var _proto = Controller.prototype;

  _proto.update = function update(props) {
    var _this2 = this;

    this.props = _extends({}, this.props, props);

    var _ref = this.props.interpolateTo ? interpolateTo(this.props) : this.props,
        _ref$from = _ref.from,
        from = _ref$from === void 0 ? {} : _ref$from,
        _ref$to = _ref.to,
        to = _ref$to === void 0 ? {} : _ref$to,
        _ref$config = _ref.config,
        config = _ref$config === void 0 ? {} : _ref$config,
        _ref$delay = _ref.delay,
        delay = _ref$delay === void 0 ? 0 : _ref$delay,
        reverse = _ref.reverse,
        attach = _ref.attach,
        reset = _ref.reset,
        immediate = _ref.immediate,
        autoStart = _ref.autoStart,
        ref = _ref.ref; // Reverse values when requested


    if (reverse) {
      var _ref2 = [to, from];
      from = _ref2[0];
      to = _ref2[1];
    }

    this.hasChanged = false; // Attachment handling, trailed springs can "attach" themselves to a previous spring

    var target = attach && attach(this); // Reset merged props when necessary

    var extra = reset ? {} : this.merged; // This will collect all props that were ever set

    this.merged = _extends({}, from, extra, to); // Reduces input { name: value } pairs into animated values

    this.animations = Object.entries(this.merged).reduce(function (acc, _ref3, i) {
      var name = _ref3[0],
          value = _ref3[1];
      // Issue cached entries, except on reset
      var entry = !reset && acc[name] || {}; // Figure out what the value is supposed to be

      var isNumber = typeof value === 'number';
      var isString = typeof value === 'string' && !value.startsWith('#') && !/\d/.test(value) && !colorNames[value];
      var isArray = !isNumber && !isString && Array.isArray(value);
      var fromValue = from[name] !== undefined ? from[name] : value;
      var toValue = isNumber || isArray ? value : isString ? value : 1;
      var toConfig = callProp(config, name);
      if (target) toValue = target.animations[name].parent; // Detect changes, animated values will be checked in the raf-loop

      if (toConfig.decay !== void 0 || !shallowEqual(entry.changes, value)) {
        var _extends2;

        _this2.hasChanged = true;
        var parent, interpolation$$1;
        if (isNumber || isString) parent = interpolation$$1 = entry.parent || new AnimatedValue(fromValue);else if (isArray) parent = interpolation$$1 = entry.parent || new AnimatedArray(fromValue);else {
          var prev = entry.interpolation && entry.interpolation.calc(entry.parent.value);

          if (entry.parent) {
            parent = entry.parent;
            parent.setValue(0, false);
          } else parent = new AnimatedValue(0);

          var range = {
            output: [prev !== void 0 ? prev : fromValue, value]
          };

          if (entry.interpolation) {
            interpolation$$1 = entry.interpolation;
            entry.interpolation.updateConfig(range);
          } else interpolation$$1 = parent.interpolate(range);
        } // Set immediate values

        if (callProp(immediate, name)) parent.setValue(value, false); // Reset animated values

        var animatedValues = toArray(parent.getPayload());
        animatedValues.forEach(function (value) {
          return value.prepare(_this2);
        });
        return _extends({}, acc, (_extends2 = {}, _extends2[name] = _extends({}, entry, {
          name: name,
          parent: parent,
          interpolation: interpolation$$1,
          animatedValues: animatedValues,
          changes: value,
          fromValues: toArray(parent.getValue()),
          toValues: toArray(target ? toValue.getPayload() : toValue),
          immediate: callProp(immediate, name),
          delay: withDefault(toConfig.delay, delay || 0),
          initialVelocity: withDefault(toConfig.velocity, 0),
          clamp: withDefault(toConfig.clamp, false),
          precision: withDefault(toConfig.precision, 0.01),
          tension: withDefault(toConfig.tension, 170),
          friction: withDefault(toConfig.friction, 26),
          mass: withDefault(toConfig.mass, 1),
          duration: toConfig.duration,
          easing: withDefault(toConfig.easing, function (t) {
            return t;
          }),
          decay: toConfig.decay
        }), _extends2));
      } else return acc;
    }, this.animations);

    if (this.hasChanged) {
      this.configs = getValues$1(this.animations);
      this.animatedProps = {};
      this.interpolations = {};

      for (var key in this.animations) {
        this.interpolations[key] = this.animations[key].interpolation;
        this.animatedProps[key] = this.animations[key].interpolation.getValue();
      }
    } // TODO: clean up ref in controller


    for (var _len = arguments.length, start = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      start[_key - 1] = arguments[_key];
    }

    if (!ref && (autoStart || start.length)) this.start.apply(this, start);
    var onEnd = start[0],
        onUpdate = start[1];
    this.onEnd = typeof onEnd === 'function' && onEnd;
    this.onUpdate = onUpdate;
    return this.getValues();
  };

  _proto.start = function start(onEnd, onUpdate) {
    var _this3 = this;

    this.startTime = now();
    if (this.isActive) this.stop();
    this.isActive = true;
    this.onEnd = typeof onEnd === 'function' && onEnd;
    this.onUpdate = onUpdate;
    if (this.props.onStart) this.props.onStart();
    addController(this);
    return new Promise(function (res) {
      return _this3.resolve = res;
    });
  };

  _proto.stop = function stop(finished) {
    if (finished === void 0) {
      finished = false;
    }

    // Reset collected changes since the animation has been stopped cold turkey
    if (finished) getValues$1(this.animations).forEach(function (a) {
      return a.changes = undefined;
    });
    this.debouncedOnEnd({
      finished: finished
    });
  };

  _proto.destroy = function destroy() {
    removeController(this);
    this.props = {};
    this.merged = {};
    this.animations = {};
    this.interpolations = {};
    this.animatedProps = {};
    this.configs = [];
  };

  _proto.debouncedOnEnd = function debouncedOnEnd(result) {
    removeController(this);
    this.isActive = false;
    var onEnd = this.onEnd;
    this.onEnd = null;
    if (onEnd) onEnd(result);
    if (this.resolve) this.resolve();
    this.resolve = null;
  };

  return Controller;
}();

var AnimatedProps =
/*#__PURE__*/
function (_AnimatedObjectWithCh) {
  _inheritsLoose(AnimatedProps, _AnimatedObjectWithCh);

  function AnimatedProps(props, callback) {
    var _this;

    _this = _AnimatedObjectWithCh.call(this) || this;
    if (props.style) props = _extends({}, props, {
      style: createAnimatedStyle(props.style)
    });
    _this.payload = props;
    _this.update = callback;

    _this.attach();

    return _this;
  }

  return AnimatedProps;
}(AnimatedObjectWithChildren);

function createAnimatedComponent(Component) {
  var AnimatedComponent =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(AnimatedComponent, _React$Component);

    function AnimatedComponent(props) {
      var _this;

      _this = _React$Component.call(this) || this;

      _this.callback = function () {
        if (_this.node) {
          var didUpdate = applyAnimatedValues.fn(_this.node, _this.propsAnimated.getAnimatedValue(), _assertThisInitialized(_this));
          if (didUpdate === false) _this.forceUpdate();
        }
      };

      _this.attachProps(props);

      return _this;
    }

    var _proto = AnimatedComponent.prototype;

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.propsAnimated && this.propsAnimated.detach();
    };

    _proto.setNativeProps = function setNativeProps(props) {
      var didUpdate = applyAnimatedValues.fn(this.node, props, this);
      if (didUpdate === false) this.forceUpdate();
    } // The system is best designed when setNativeProps is implemented. It is
    // able to avoid re-rendering and directly set the attributes that
    // changed. However, setNativeProps can only be implemented on leaf
    // native components. If you want to animate a composite component, you
    // need to re-render it. In this case, we have a fallback that uses
    // forceUpdate.
    ;

    _proto.attachProps = function attachProps(_ref) {
      var forwardRef = _ref.forwardRef,
          nextProps = _objectWithoutPropertiesLoose(_ref, ["forwardRef"]);

      var oldPropsAnimated = this.propsAnimated;
      this.propsAnimated = new AnimatedProps(nextProps, this.callback); // When you call detach, it removes the element from the parent list
      // of children. If it goes to 0, then the parent also detaches itself
      // and so on.
      // An optimization is to attach the new elements and THEN detach the old
      // ones instead of detaching and THEN attaching.
      // This way the intermediate state isn't to go to 0 and trigger
      // this expensive recursive detaching to then re-attach everything on
      // the very next operation.

      oldPropsAnimated && oldPropsAnimated.detach();
    };

    _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {
      var style = props.style,
          nextProps = _objectWithoutPropertiesLoose(props, ["style"]);

      var _this$props = this.props,
          currentStyle = _this$props.style,
          currentProps = _objectWithoutPropertiesLoose(_this$props, ["style"]);

      if (!shallowEqual(currentProps, nextProps) || !shallowEqual(currentStyle, style)) {
        this.attachProps(props);
        return true;
      }

      return false;
    };

    _proto.render = function render() {
      var _this2 = this;

      var _this$propsAnimated$g = this.propsAnimated.getValue(),
          scrollTop = _this$propsAnimated$g.scrollTop,
          scrollLeft = _this$propsAnimated$g.scrollLeft,
          animatedProps = _objectWithoutPropertiesLoose(_this$propsAnimated$g, ["scrollTop", "scrollLeft"]);

      return React__default.createElement(Component, _extends({}, animatedProps, {
        ref: function ref(node) {
          return _this2.node = handleRef(node, _this2.props.forwardRef);
        }
      }));
    };

    return AnimatedComponent;
  }(React__default.Component);

  return React__default.forwardRef(function (props, ref) {
    return React__default.createElement(AnimatedComponent, _extends({}, props, {
      forwardRef: ref
    }));
  });
}

var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};

var Spring =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Spring, _React$Component);

  function Spring() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      lastProps: {
        from: {},
        to: {}
      },
      propsChanged: false,
      internal: false
    };
    _this.controller = new Controller(null, null);
    _this.didUpdate = false;
    _this.didInject = false;
    _this.finished = true;

    _this.start = function () {
      _this.finished = false;
      var wasMounted = _this.mounted;

      _this.controller.start(function (props) {
        return _this.finish(_extends({}, props, {
          wasMounted: wasMounted
        }));
      }, _this.update);
    };

    _this.stop = function () {
      return _this.controller.stop(true);
    };

    _this.update = function () {
      return _this.mounted && _this.setState({
        internal: true
      });
    };

    _this.finish = function (_ref) {
      var finished = _ref.finished,
          noChange = _ref.noChange,
          wasMounted = _ref.wasMounted;
      _this.finished = true;

      if (_this.mounted && finished) {
        // Only call onRest if either we *were* mounted, or when there were changes
        if (_this.props.onRest && (wasMounted || !noChange)) _this.props.onRest(_this.controller.merged); // Restore end-state

        if (_this.mounted && _this.didInject) {
          _this.afterInject = convertValues(_this.props);

          _this.setState({
            internal: true
          });
        } // If we have an inject or values to apply after the animation we ping here


        if (_this.mounted && (_this.didInject || _this.props.after)) _this.setState({
          internal: true
        });
        _this.didInject = false;
      }
    };

    return _this;
  }

  var _proto = Spring.prototype;

  _proto.componentDidMount = function componentDidMount() {
    // componentDidUpdate isn't called on mount, we call it here to start animating
    this.componentDidUpdate();
    this.mounted = true;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    // Stop all ongoing animtions
    this.mounted = false;
    this.stop();
  };

  Spring.getDerivedStateFromProps = function getDerivedStateFromProps(props, _ref2) {
    var internal = _ref2.internal,
        lastProps = _ref2.lastProps;
    // The following is a test against props that could alter the animation
    var from = props.from,
        to = props.to,
        reset = props.reset,
        force = props.force;
    var propsChanged = !shallowEqual(to, lastProps.to) || !shallowEqual(from, lastProps.from) || reset && !internal || force && !internal;
    return {
      propsChanged: propsChanged,
      lastProps: props,
      internal: false
    };
  };

  _proto.render = function render() {
    var _this2 = this;

    var children = this.props.children;
    var propsChanged = this.state.propsChanged; // Inject phase -----------------------------------------------------------
    // Handle injected frames, for instance targets/web/fix-auto
    // An inject will return an intermediary React node which measures itself out
    // .. and returns a callback when the values sought after are ready, usually "auto".

    if (this.props.inject && propsChanged && !this.injectProps) {
      var frame = this.props.inject(this.props, function (injectProps) {
        // The inject frame has rendered, now let's update animations...
        _this2.injectProps = injectProps;

        _this2.setState({
          internal: true
        });
      }); // Render out injected frame

      if (frame) return frame;
    } // Update phase -----------------------------------------------------------


    if (this.injectProps || propsChanged) {
      // We can potentially cause setState, but we're inside render, the flag prevents that
      this.didInject = false; // Update animations, this turns from/to props into AnimatedValues
      // An update can occur on injected props, or when own-props have changed.

      if (this.injectProps) {
        this.controller.update(this.injectProps); // didInject is needed, because there will be a 3rd stage, where the original values
        // .. will be restored after the animation is finished. When someone animates towards
        // .. "auto", the end-result should be "auto", not "1999px", which would block nested
        // .. height/width changes.

        this.didInject = true;
      } else if (propsChanged) this.controller.update(this.props); // Flag an update that occured, componentDidUpdate will start the animation later on


      this.didUpdate = true;
      this.afterInject = undefined;
      this.injectProps = undefined;
    } // Render phase -----------------------------------------------------------
    // Render out raw values or AnimatedValues depending on "native"


    var values = _extends({}, this.controller.getValues(), this.afterInject);

    if (this.finished) values = _extends({}, values, this.props.after);
    return Object.keys(values).length ? children(values) : null;
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    // The animation has to start *after* render, since at that point the scene
    // .. graph should be established, so we do it here. Unfortunatelly, non-native
    // .. animations as well as "auto"-injects call forceUpdate, so it's causing a loop.
    // .. didUpdate prevents that as it gets set only on prop changes.
    if (this.didUpdate) this.start();
    this.didUpdate = false;
  };

  return Spring;
}(React__default.Component);

Spring.defaultProps = {
  from: {},
  to: {},
  config: config.default,
  native: false,
  immediate: false,
  reset: false,
  force: false,
  inject: bugfixes
};

var Trail =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(Trail, _React$PureComponent);

  function Trail() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.first = true;
    _this.instances = new Set();

    _this.hook = function (instance, index, length, reverse) {
      // Add instance to set
      _this.instances.add(instance); // Return undefined on the first index and from then on the previous instance


      if (reverse ? index === length - 1 : index === 0) return undefined;else return Array.from(_this.instances)[reverse ? index + 1 : index - 1];
    };

    return _this;
  }

  var _proto = Trail.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        items = _this$props.items,
        _children = _this$props.children,
        _this$props$from = _this$props.from,
        from = _this$props$from === void 0 ? {} : _this$props$from,
        initial = _this$props.initial,
        reverse = _this$props.reverse,
        keys = _this$props.keys,
        delay = _this$props.delay,
        onRest = _this$props.onRest,
        props = _objectWithoutPropertiesLoose(_this$props, ["items", "children", "from", "initial", "reverse", "keys", "delay", "onRest"]);

    var array = toArray(items);
    return toArray(array).map(function (item, i) {
      return React__default.createElement(Spring, _extends({
        onRest: i === 0 ? onRest : null,
        key: typeof keys === 'function' ? keys(item) : toArray(keys)[i],
        from: _this2.first && initial !== void 0 ? initial || {} : from
      }, props, {
        delay: i === 0 && delay || undefined,
        attach: function attach(instance) {
          return _this2.hook(instance, i, array.length, reverse);
        },
        children: function children(props) {
          var child = _children(item, i);

          return child ? child(props) : null;
        }
      }));
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    this.first = false;
    if (prevProps.items !== this.props.items) this.instances.clear();
  };

  return Trail;
}(React__default.PureComponent);

Trail.defaultProps = {
  keys: function keys(item) {
    return item;
  }
};

var DEFAULT = '__default';

var KeyframesImpl =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(KeyframesImpl, _React$PureComponent);

  function KeyframesImpl() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.guid = 0;
    _this.state = {
      props: {},
      resolve: function resolve() {
        return null;
      },
      last: true,
      index: 0
    };

    _this.next = function (props, last, index) {
      if (last === void 0) {
        last = true;
      }

      if (index === void 0) {
        index = 0;
      }

      _this.running = true;
      return new Promise(function (resolve) {
        _this.mounted && _this.setState(function (state) {
          return {
            props: props,
            resolve: resolve,
            last: last,
            index: index
          };
        }, function () {
          return _this.running = false;
        });
      });
    };

    return _this;
  }

  var _proto = KeyframesImpl.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.componentDidUpdate({});
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  _proto.componentDidUpdate = function componentDidUpdate(previous) {
    var _this2 = this;

    var _this$props = this.props,
        states = _this$props.states,
        f = _this$props.filter,
        state = _this$props.state;

    if (previous.state !== this.props.state || this.props.reset && !this.running || !shallowEqual(states[state], previous.states[previous.state])) {
      if (states && state && states[state]) {
        (function () {
          var localId = ++_this2.guid;
          var slots = states[state];

          if (slots) {
            if (Array.isArray(slots)) {
              var q = Promise.resolve();

              var _loop = function _loop(i) {
                var index = i;
                var slot = slots[index];
                var last = index === slots.length - 1;
                q = q.then(function () {
                  return localId === _this2.guid && _this2.next(f(slot), last, index);
                });
              };

              for (var i = 0; i < slots.length; i++) {
                _loop(i);
              }
            } else if (typeof slots === 'function') {
              var index = 0;
              slots( // next
              function (props, last) {
                if (last === void 0) {
                  last = false;
                }

                return localId === _this2.guid && _this2.next(f(props), last, index++);
              }, // cancel
              function () {
                return requestFrame(function () {
                  return _this2.instance && _this2.instance.stop();
                });
              }, // ownprops
              _this2.props);
            } else {
              _this2.next(f(states[state]));
            }
          }
        })();
      }
    }
  };

  _proto.render = function render() {
    var _this3 = this;

    var _this$state = this.state,
        props = _this$state.props,
        resolve = _this$state.resolve,
        last = _this$state.last,
        index = _this$state.index;
    if (!props || Object.keys(props).length === 0) return null;

    var _this$props2 = this.props,
        state = _this$props2.state,
        filter = _this$props2.filter,
        states = _this$props2.states,
        config = _this$props2.config,
        Component = _this$props2.primitive,
        _onRest = _this$props2.onRest,
        forwardRef = _this$props2.forwardRef,
        rest = _objectWithoutPropertiesLoose(_this$props2, ["state", "filter", "states", "config", "primitive", "onRest", "forwardRef"]); // Arrayed configs need an index to process


    if (Array.isArray(config)) config = config[index];
    return React__default.createElement(Component, _extends({
      ref: function ref(_ref) {
        return _this3.instance = handleRef(_ref, forwardRef);
      },
      config: config
    }, rest, props, {
      onRest: function onRest(args) {
        resolve(args);
        if (_onRest && last) _onRest(args);
      }
    }));
  };

  return KeyframesImpl;
}(React__default.PureComponent);

KeyframesImpl.defaultProps = {
  state: DEFAULT
};
var Keyframes = React__default.forwardRef(function (props, ref) {
  return React__default.createElement(KeyframesImpl, _extends({}, props, {
    forwardRef: ref
  }));
});

Keyframes.create = function (primitive) {
  return function (states, filter) {
    var _states;

    if (filter === void 0) {
      filter = function filter(states) {
        return states;
      };
    }

    if (typeof states === 'function' || Array.isArray(states)) states = (_states = {}, _states[DEFAULT] = states, _states);
    return function (props) {
      return React__default.createElement(KeyframesImpl, _extends({
        primitive: primitive,
        states: states,
        filter: filter
      }, props));
    };
  };
};

Keyframes.Spring = function (states) {
  return Keyframes.create(Spring)(states, interpolateTo);
};

Keyframes.Trail = function (states) {
  return Keyframes.create(Trail)(states, interpolateTo);
};

var guid = 0;

var get = function get(props) {
  var items = props.items,
      keys = props.keys,
      rest = _objectWithoutPropertiesLoose(props, ["items", "keys"]);

  items = toArray(items !== void 0 ? items : null);
  keys = typeof keys === 'function' ? items.map(keys) : toArray(keys); // Make sure numeric keys are interpreted as Strings (5 !== "5")

  return _extends({
    items: items,
    keys: keys.map(function (key) {
      return String(key);
    })
  }, rest);
};

var Transition =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(Transition, _React$PureComponent);

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  function Transition(prevProps) {
    var _this;

    _this = _React$PureComponent.call(this, prevProps) || this;

    _this.destroyItem = function (item, key, state) {
      return function (values) {
        var _this$props = _this.props,
            onRest = _this$props.onRest,
            onDestroyed = _this$props.onDestroyed;

        if (_this.mounted) {
          onDestroyed && onDestroyed(item);

          _this.setState(function (_ref) {
            var deleted = _ref.deleted;
            return {
              deleted: deleted.filter(function (t) {
                return t.key !== key;
              })
            };
          });

          onRest && onRest(item, state, values);
        }
      };
    };

    _this.state = {
      first: true,
      transitions: [],
      current: {},
      deleted: [],
      prevProps: prevProps
    };
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(props, _ref2) {
    var first = _ref2.first,
        prevProps = _ref2.prevProps,
        state = _objectWithoutPropertiesLoose(_ref2, ["first", "prevProps"]);

    var _get = get(props),
        items = _get.items,
        keys = _get.keys,
        initial = _get.initial,
        from = _get.from,
        enter = _get.enter,
        leave = _get.leave,
        update = _get.update,
        _get$trail = _get.trail,
        trail = _get$trail === void 0 ? 0 : _get$trail,
        unique = _get.unique,
        config = _get.config;

    var _get2 = get(prevProps),
        _keys = _get2.keys,
        _items = _get2.items;

    var current = _extends({}, state.current);

    var deleted = [].concat(state.deleted); // Compare next keys with current keys

    var currentKeys = Object.keys(current);
    var currentSet = new Set(currentKeys);
    var nextSet = new Set(keys);
    var added = keys.filter(function (item) {
      return !currentSet.has(item);
    });
    var removed = state.transitions.filter(function (item) {
      return !item.destroyed && !nextSet.has(item.originalKey);
    }).map(function (i) {
      return i.originalKey;
    });
    var updated = keys.filter(function (item) {
      return currentSet.has(item);
    });
    var delay = 0;
    added.forEach(function (key) {
      // In unique mode, remove fading out transitions if their key comes in again
      if (unique && deleted.find(function (d) {
        return d.originalKey === key;
      })) deleted = deleted.filter(function (t) {
        return t.originalKey !== key;
      });
      var keyIndex = keys.indexOf(key);
      var item = items[keyIndex];
      var state = 'enter';
      current[key] = {
        state: state,
        originalKey: key,
        key: unique ? String(key) : guid++,
        item: item,
        trail: delay = delay + trail,
        config: callProp(config, item, state),
        from: callProp(first ? initial !== void 0 ? initial || {} : from : from, item),
        to: callProp(enter, item)
      };
    });
    removed.forEach(function (key) {
      var keyIndex = _keys.indexOf(key);

      var item = _items[keyIndex];
      var state = 'leave';
      deleted.push(_extends({}, current[key], {
        state: state,
        destroyed: true,
        left: _keys[Math.max(0, keyIndex - 1)],
        right: _keys[Math.min(_keys.length, keyIndex + 1)],
        trail: delay = delay + trail,
        config: callProp(config, item, state),
        to: callProp(leave, item)
      }));
      delete current[key];
    });
    updated.forEach(function (key) {
      var keyIndex = keys.indexOf(key);
      var item = items[keyIndex];
      var state = 'update';
      current[key] = _extends({}, current[key], {
        item: item,
        state: state,
        trail: delay = delay + trail,
        config: callProp(config, item, state),
        to: callProp(update, item)
      });
    }); // This tries to restore order for deleted items by finding their last known siblings

    var out = keys.map(function (key) {
      return current[key];
    });
    deleted.forEach(function (_ref3) {
      var left = _ref3.left,
          right = _ref3.right,
          transition = _objectWithoutPropertiesLoose(_ref3, ["left", "right"]);

      var pos; // Was it the element on the left, if yes, move there ...

      if ((pos = out.findIndex(function (t) {
        return t.originalKey === left;
      })) !== -1) pos += 1; // Or how about the element on the right ...

      if (pos === -1) pos = out.findIndex(function (t) {
        return t.originalKey === right;
      }); // Maybe we'll find it in the list of deleted items

      if (pos === -1) pos = deleted.findIndex(function (t) {
        return t.originalKey === left;
      }); // Checking right side as well

      if (pos === -1) pos = deleted.findIndex(function (t) {
        return t.originalKey === right;
      }); // And if nothing else helps, move it to the start \_()_/

      pos = Math.max(0, pos);
      out = [].concat(out.slice(0, pos), [transition], out.slice(pos));
    });
    return {
      first: first && added.length === 0,
      transitions: out,
      current: current,
      deleted: deleted,
      prevProps: props
    };
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        initial = _this$props2.initial,
        _this$props2$from = _this$props2.from,
        _this$props2$enter = _this$props2.enter,
        _this$props2$leave = _this$props2.leave,
        _this$props2$update = _this$props2.update,
        onDestroyed = _this$props2.onDestroyed,
        keys = _this$props2.keys,
        items = _this$props2.items,
        onFrame = _this$props2.onFrame,
        onRest = _this$props2.onRest,
        onStart = _this$props2.onStart,
        trail = _this$props2.trail,
        config = _this$props2.config,
        _children = _this$props2.children,
        unique = _this$props2.unique,
        reset = _this$props2.reset,
        extra = _objectWithoutPropertiesLoose(_this$props2, ["initial", "from", "enter", "leave", "update", "onDestroyed", "keys", "items", "onFrame", "onRest", "onStart", "trail", "config", "children", "unique", "reset"]);

    return this.state.transitions.map(function (_ref4, i) {
      var _ref5;

      var state = _ref4.state,
          key = _ref4.key,
          item = _ref4.item,
          from = _ref4.from,
          to = _ref4.to,
          trail = _ref4.trail,
          config = _ref4.config,
          destroyed = _ref4.destroyed;
      return React__default.createElement(Keyframes, _extends({
        reset: reset && state === 'enter',
        primitive: Spring,
        state: state,
        filter: interpolateTo,
        states: (_ref5 = {}, _ref5[state] = to, _ref5),
        key: key,
        onRest: destroyed ? _this2.destroyItem(item, key, state) : onRest && function (values) {
          return onRest(item, state, values);
        },
        onStart: onStart && function () {
          return onStart(item, state);
        },
        onFrame: onFrame && function (values) {
          return onFrame(item, state, values);
        },
        delay: trail,
        config: config
      }, extra, {
        from: from,
        children: function children(props) {
          var child = _children(item, state, i);

          return child ? child(props) : null;
        }
      }));
    });
  };

  return Transition;
}(React__default.PureComponent);

Transition.defaultProps = {
  keys: function keys(item) {
    return item;
  },
  unique: false,
  reset: false
};

var domElements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
var extendedAnimated = domElements.reduce(function (acc, element) {
  acc[element] = createAnimatedComponent(element);
  return acc;
}, createAnimatedComponent);

exports.Spring = Spring;
exports.Keyframes = Keyframes;
exports.Transition = Transition;
exports.Trail = Trail;
exports.Controller = Controller;
exports.config = config;
exports.animated = extendedAnimated;
exports.interpolate = interpolate$1;
exports.Globals = Globals;


/***/ }),

/***/ "./node_modules/ua-parser-js/dist/ua-parser.min.js":
/*!*********************************************************!*\
  !*** ./node_modules/ua-parser-js/dist/ua-parser.min.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * UAParser.js v0.7.24
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright  2012-2021 Faisal Salman <f@faisalman.com>
 * Licensed under MIT License
 */
(function(window,undefined){"use strict";var LIBVERSION="0.7.24",EMPTY="",UNKNOWN="?",FUNC_TYPE="function",UNDEF_TYPE="undefined",OBJ_TYPE="object",STR_TYPE="string",MAJOR="major",MODEL="model",NAME="name",TYPE="type",VENDOR="vendor",VERSION="version",ARCHITECTURE="architecture",CONSOLE="console",MOBILE="mobile",TABLET="tablet",SMARTTV="smarttv",WEARABLE="wearable",EMBEDDED="embedded";var util={extend:function(regexes,extensions){var mergedRegexes={};for(var i in regexes){if(extensions[i]&&extensions[i].length%2===0){mergedRegexes[i]=extensions[i].concat(regexes[i])}else{mergedRegexes[i]=regexes[i]}}return mergedRegexes},has:function(str1,str2){if(typeof str1==="string"){return str2.toLowerCase().indexOf(str1.toLowerCase())!==-1}else{return false}},lowerize:function(str){return str.toLowerCase()},major:function(version){return typeof version===STR_TYPE?version.replace(/[^\d\.]/g,"").split(".")[0]:undefined},trim:function(str){return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}};var mapper={rgx:function(ua,arrays){var i=0,j,k,p,q,matches,match;while(i<arrays.length&&!matches){var regex=arrays[i],props=arrays[i+1];j=k=0;while(j<regex.length&&!matches){matches=regex[j++].exec(ua);if(!!matches){for(p=0;p<props.length;p++){match=matches[++k];q=props[p];if(typeof q===OBJ_TYPE&&q.length>0){if(q.length==2){if(typeof q[1]==FUNC_TYPE){this[q[0]]=q[1].call(this,match)}else{this[q[0]]=q[1]}}else if(q.length==3){if(typeof q[1]===FUNC_TYPE&&!(q[1].exec&&q[1].test)){this[q[0]]=match?q[1].call(this,match,q[2]):undefined}else{this[q[0]]=match?match.replace(q[1],q[2]):undefined}}else if(q.length==4){this[q[0]]=match?q[3].call(this,match.replace(q[1],q[2])):undefined}}else{this[q]=match?match:undefined}}}}i+=2}},str:function(str,map){for(var i in map){if(typeof map[i]===OBJ_TYPE&&map[i].length>0){for(var j=0;j<map[i].length;j++){if(util.has(map[i][j],str)){return i===UNKNOWN?undefined:i}}}else if(util.has(map[i],str)){return i===UNKNOWN?undefined:i}}return str}};var maps={browser:{oldsafari:{version:{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}}},device:{amazon:{model:{"Fire Phone":["SD","KF"]}},sprint:{model:{"Evo Shift 4G":"7373KT"},vendor:{HTC:"APA",Sprint:"Sprint"}}},os:{windows:{version:{ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2000:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"}}}};var regexes={browser:[[/(opera\smini)\/([\w\.-]+)/i,/(opera\s[mobiletab]{3,6}).+version\/([\w\.-]+)/i,/(opera).+version\/([\w\.]+)/i,/(opera)[\/\s]+([\w\.]+)/i],[NAME,VERSION],[/(opios)[\/\s]+([\w\.]+)/i],[[NAME,"Opera Mini"],VERSION],[/\s(opr)\/([\w\.]+)/i],[[NAME,"Opera"],VERSION],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,/(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i,/(bidubrowser|baidubrowser)[\/\s]?([\w\.]+)/i,/(?:ms|\()(ie)\s([\w\.]+)/i,/(rekonq)\/([\w\.]*)/i,/(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i],[NAME,VERSION],[/(konqueror)\/([\w\.]+)/i],[[NAME,"Konqueror"],VERSION],[/(trident).+rv[:\s]([\w\.]{1,9}).+like\sgecko/i],[[NAME,"IE"],VERSION],[/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i],[[NAME,"Edge"],VERSION],[/(yabrowser)\/([\w\.]+)/i],[[NAME,"Yandex"],VERSION],[/(Avast)\/([\w\.]+)/i],[[NAME,"Avast Secure Browser"],VERSION],[/(AVG)\/([\w\.]+)/i],[[NAME,"AVG Secure Browser"],VERSION],[/(puffin)\/([\w\.]+)/i],[[NAME,"Puffin"],VERSION],[/(focus)\/([\w\.]+)/i],[[NAME,"Firefox Focus"],VERSION],[/(opt)\/([\w\.]+)/i],[[NAME,"Opera Touch"],VERSION],[/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],[[NAME,"UCBrowser"],VERSION],[/(comodo_dragon)\/([\w\.]+)/i],[[NAME,/_/g," "],VERSION],[/(windowswechat qbcore)\/([\w\.]+)/i],[[NAME,"WeChat(Win) Desktop"],VERSION],[/(micromessenger)\/([\w\.]+)/i],[[NAME,"WeChat"],VERSION],[/(brave)\/([\w\.]+)/i],[[NAME,"Brave"],VERSION],[/(whale)\/([\w\.]+)/i],[[NAME,"Whale"],VERSION],[/(qqbrowserlite)\/([\w\.]+)/i],[NAME,VERSION],[/(QQ)\/([\d\.]+)/i],[NAME,VERSION],[/m?(qqbrowser)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(baiduboxapp)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(2345Explorer)[\/\s]?([\w\.]+)/i],[NAME,VERSION],[/(MetaSr)[\/\s]?([\w\.]+)/i],[NAME],[/(LBBROWSER)/i],[NAME],[/xiaomi\/miuibrowser\/([\w\.]+)/i],[VERSION,[NAME,"MIUI Browser"]],[/;fbav\/([\w\.]+);/i],[VERSION,[NAME,"Facebook"]],[/FBAN\/FBIOS|FB_IAB\/FB4A/i],[[NAME,"Facebook"]],[/safari\s(line)\/([\w\.]+)/i,/android.+(line)\/([\w\.]+)\/iab/i],[NAME,VERSION],[/headlesschrome(?:\/([\w\.]+)|\s)/i],[VERSION,[NAME,"Chrome Headless"]],[/\swv\).+(chrome)\/([\w\.]+)/i],[[NAME,/(.+)/,"$1 WebView"],VERSION],[/((?:oculus|samsung)browser)\/([\w\.]+)/i],[[NAME,/(.+(?:g|us))(.+)/,"$1 $2"],VERSION],[/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],[VERSION,[NAME,"Android Browser"]],[/(coc_coc_browser)\/([\w\.]+)/i],[[NAME,"Coc Coc"],VERSION],[/(sailfishbrowser)\/([\w\.]+)/i],[[NAME,"Sailfish Browser"],VERSION],[/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],[NAME,VERSION],[/(dolfin)\/([\w\.]+)/i],[[NAME,"Dolphin"],VERSION],[/(qihu|qhbrowser|qihoobrowser|360browser)/i],[[NAME,"360 Browser"]],[/((?:android.+)crmo|crios)\/([\w\.]+)/i],[[NAME,"Chrome"],VERSION],[/(coast)\/([\w\.]+)/i],[[NAME,"Opera Coast"],VERSION],[/fxios\/([\w\.-]+)/i],[VERSION,[NAME,"Firefox"]],[/version\/([\w\.]+)\s.*mobile\/\w+\s(safari)/i],[VERSION,[NAME,"Mobile Safari"]],[/version\/([\w\.]+)\s.*(mobile\s?safari|safari)/i],[VERSION,NAME],[/webkit.+?(gsa)\/([\w\.]+)\s.*(mobile\s?safari|safari)(\/[\w\.]+)/i],[[NAME,"GSA"],VERSION],[/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[NAME,[VERSION,mapper.str,maps.browser.oldsafari.version]],[/(webkit|khtml)\/([\w\.]+)/i],[NAME,VERSION],[/(navigator|netscape)\/([\w\.-]+)/i],[[NAME,"Netscape"],VERSION],[/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,/(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,/(firefox)\/([\w\.]+)\s[\w\s\-]+\/[\w\.]+$/i,/(mozilla)\/([\w\.]+)\s.+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,/(links)\s\(([\w\.]+)/i,/(gobrowser)\/?([\w\.]*)/i,/(ice\s?browser)\/v?([\w\._]+)/i,/(mosaic)[\/\s]([\w\.]+)/i],[NAME,VERSION]],cpu:[[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],[[ARCHITECTURE,"amd64"]],[/(ia32(?=;))/i],[[ARCHITECTURE,util.lowerize]],[/((?:i[346]|x)86)[;\)]/i],[[ARCHITECTURE,"ia32"]],[/windows\s(ce|mobile);\sppc;/i],[[ARCHITECTURE,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],[[ARCHITECTURE,/ower/,"",util.lowerize]],[/(sun4\w)[;\)]/i],[[ARCHITECTURE,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],[[ARCHITECTURE,util.lowerize]]],device:[[/\((ipad|playbook);[\w\s\),;-]+(rim|apple)/i],[MODEL,VENDOR,[TYPE,TABLET]],[/applecoremedia\/[\w\.]+ \((ipad)/],[MODEL,[VENDOR,"Apple"],[TYPE,TABLET]],[/(apple\s{0,1}tv)/i],[[MODEL,"Apple TV"],[VENDOR,"Apple"],[TYPE,SMARTTV]],[/(archos)\s(gamepad2?)/i,/(hp).+(touchpad)/i,/(hp).+(tablet)/i,/(kindle)\/([\w\.]+)/i,/\s(nook)[\w\s]+build\/(\w+)/i,/(dell)\s(strea[kpr\s\d]*[\dko])/i],[VENDOR,MODEL,[TYPE,TABLET]],[/(kf[A-z]+)(\sbuild\/|\)).+silk\//i],[MODEL,[VENDOR,"Amazon"],[TYPE,TABLET]],[/(sd|kf)[0349hijorstuw]+(\sbuild\/|\)).+silk\//i],[[MODEL,mapper.str,maps.device.amazon.model],[VENDOR,"Amazon"],[TYPE,MOBILE]],[/android.+aft([\w])(\sbuild\/|\))/i],[MODEL,[VENDOR,"Amazon"],[TYPE,SMARTTV]],[/\((ip[honed|\s\w*]+);.+(apple)/i],[MODEL,VENDOR,[TYPE,MOBILE]],[/\((ip[honed|\s\w*]+);/i],[MODEL,[VENDOR,"Apple"],[TYPE,MOBILE]],[/(blackberry)[\s-]?(\w+)/i,/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,/(hp)\s([\w\s]+\w)/i,/(asus)-?(\w+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/\(bb10;\s(\w+)/i],[MODEL,[VENDOR,"BlackBerry"],[TYPE,MOBILE]],[/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone|p00c)/i],[MODEL,[VENDOR,"Asus"],[TYPE,TABLET]],[/(sony)\s(tablet\s[ps])\sbuild\//i,/(sony)?(?:sgp.+)\sbuild\//i],[[VENDOR,"Sony"],[MODEL,"Xperia Tablet"],[TYPE,TABLET]],[/android.+\s([c-g]\d{4}|so[-l]\w+)(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i],[MODEL,[VENDOR,"Sony"],[TYPE,MOBILE]],[/\s(ouya)\s/i,/(nintendo)\s([wids3u]+)/i],[VENDOR,MODEL,[TYPE,CONSOLE]],[/android.+;\s(shield)\sbuild/i],[MODEL,[VENDOR,"Nvidia"],[TYPE,CONSOLE]],[/(playstation\s[34portablevi]+)/i],[MODEL,[VENDOR,"Sony"],[TYPE,CONSOLE]],[/(sprint\s(\w+))/i],[[VENDOR,mapper.str,maps.device.sprint.vendor],[MODEL,mapper.str,maps.device.sprint.model],[TYPE,MOBILE]],[/(htc)[;_\s-]{1,2}([\w\s]+(?=\)|\sbuild)|\w+)/i,/(zte)-(\w*)/i,/(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i],[VENDOR,[MODEL,/_/g," "],[TYPE,MOBILE]],[/(nexus\s9)/i],[MODEL,[VENDOR,"HTC"],[TYPE,TABLET]],[/d\/huawei([\w\s-]+)[;\)]/i,/android.+\s(nexus\s6p|vog-[at]?l\d\d|ane-[at]?l[x\d]\d|eml-a?l\d\da?|lya-[at]?l\d[\dc]|clt-a?l\d\di?)/i],[MODEL,[VENDOR,"Huawei"],[TYPE,MOBILE]],[/android.+(bah2?-a?[lw]\d{2})/i],[MODEL,[VENDOR,"Huawei"],[TYPE,TABLET]],[/(microsoft);\s(lumia[\s\w]+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/[\s\(;](xbox(?:\sone)?)[\s\);]/i],[MODEL,[VENDOR,"Microsoft"],[TYPE,CONSOLE]],[/(kin\.[onetw]{3})/i],[[MODEL,/\./g," "],[VENDOR,"Microsoft"],[TYPE,MOBILE]],[/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,/mot[\s-]?(\w*)/i,/(XT\d{3,4}) build\//i,/(nexus\s6)/i],[MODEL,[VENDOR,"Motorola"],[TYPE,MOBILE]],[/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],[MODEL,[VENDOR,"Motorola"],[TYPE,TABLET]],[/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],[[VENDOR,util.trim],[MODEL,util.trim],[TYPE,SMARTTV]],[/hbbtv.+maple;(\d+)/i],[[MODEL,/^/,"SmartTV"],[VENDOR,"Samsung"],[TYPE,SMARTTV]],[/\(dtv[\);].+(aquos)/i],[MODEL,[VENDOR,"Sharp"],[TYPE,SMARTTV]],[/android.+((sch-i[89]0\d|shw-m380s|SM-P605|SM-P610|SM-P587|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,/((SM-T\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,TABLET]],[/smart-tv.+(samsung)/i],[VENDOR,[TYPE,SMARTTV],MODEL],[/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,/(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,/sec-((sgh\w+))/i],[[VENDOR,"Samsung"],MODEL,[TYPE,MOBILE]],[/sie-(\w*)/i],[MODEL,[VENDOR,"Siemens"],[TYPE,MOBILE]],[/(maemo|nokia).*(n900|lumia\s\d+)/i,/(nokia)[\s_-]?([\w-]*)/i],[[VENDOR,"Nokia"],MODEL,[TYPE,MOBILE]],[/android[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i],[MODEL,[VENDOR,"Acer"],[TYPE,TABLET]],[/android.+([vl]k\-?\d{3})\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,TABLET]],[/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],[[VENDOR,"LG"],MODEL,[TYPE,TABLET]],[/linux;\snetcast.+smarttv/i,/lg\snetcast\.tv-201\d/i],[[VENDOR,"LG"],MODEL,[TYPE,SMARTTV]],[/(nexus\s[45])/i,/lg[e;\s\/-]+(\w*)/i,/android.+lg(\-?[\d\w]+)\s+build/i],[MODEL,[VENDOR,"LG"],[TYPE,MOBILE]],[/(lenovo)\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+))/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+(ideatab[a-z0-9\-\s]+)/i],[MODEL,[VENDOR,"Lenovo"],[TYPE,TABLET]],[/(lenovo)[_\s-]?([\w-]+)/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/linux;.+((jolla));/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/((pebble))app\/[\d\.]+\s/i],[VENDOR,MODEL,[TYPE,WEARABLE]],[/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],[VENDOR,MODEL,[TYPE,MOBILE]],[/crkey/i],[[MODEL,"Chromecast"],[VENDOR,"Google"],[TYPE,SMARTTV]],[/android.+;\s(glass)\s\d/i],[MODEL,[VENDOR,"Google"],[TYPE,WEARABLE]],[/android.+;\s(pixel c)[\s)]/i],[MODEL,[VENDOR,"Google"],[TYPE,TABLET]],[/android.+;\s(pixel( [2-9]a?)?( xl)?)[\s)]/i],[MODEL,[VENDOR,"Google"],[TYPE,MOBILE]],[/android.+;\s(\w+)\s+build\/hm\1/i,/android.+(hm[\s\-_]?note?[\s_]?(?:\d\w)?)\sbuild/i,/android.+(redmi[\s\-_]?(?:note|k)?(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i,/android.+(mi[\s\-_]?(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]?(?:plus)?)\sbuild/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,MOBILE]],[/android.+(mi[\s\-_]?(?:pad)(?:[\s_]?[\w\s]+))(?:\sbuild|\))/i],[[MODEL,/_/g," "],[VENDOR,"Xiaomi"],[TYPE,TABLET]],[/android.+;\s(m[1-5]\snote)\sbuild/i],[MODEL,[VENDOR,"Meizu"],[TYPE,MOBILE]],[/(mz)-([\w-]{2,})/i],[[VENDOR,"Meizu"],MODEL,[TYPE,MOBILE]],[/android.+a000(1)\s+build/i,/android.+oneplus\s(a\d{4})[\s)]/i],[MODEL,[VENDOR,"OnePlus"],[TYPE,MOBILE]],[/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],[MODEL,[VENDOR,"RCA"],[TYPE,TABLET]],[/android.+[;\/\s](Venue[\d\s]{2,7})\s+build/i],[MODEL,[VENDOR,"Dell"],[TYPE,TABLET]],[/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],[MODEL,[VENDOR,"Verizon"],[TYPE,TABLET]],[/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(\S(?:.*\S)?)\s+build/i],[[VENDOR,"Barnes & Noble"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],[MODEL,[VENDOR,"NuVision"],[TYPE,TABLET]],[/android.+;\s(k88)\sbuild/i],[MODEL,[VENDOR,"ZTE"],[TYPE,TABLET]],[/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],[MODEL,[VENDOR,"Swiss"],[TYPE,MOBILE]],[/android.+[;\/]\s*(zur\d{3})\s+build/i],[MODEL,[VENDOR,"Swiss"],[TYPE,TABLET]],[/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],[MODEL,[VENDOR,"Zeki"],[TYPE,TABLET]],[/(android).+[;\/]\s+([YR]\d{2})\s+build/i,/android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i],[[VENDOR,"Dragon Touch"],MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i],[MODEL,[VENDOR,"Insignia"],[TYPE,TABLET]],[/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i],[MODEL,[VENDOR,"NextBook"],[TYPE,TABLET]],[/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],[[VENDOR,"Voice"],MODEL,[TYPE,MOBILE]],[/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i],[[VENDOR,"LvTel"],MODEL,[TYPE,MOBILE]],[/android.+;\s(PH-1)\s/i],[MODEL,[VENDOR,"Essential"],[TYPE,MOBILE]],[/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],[MODEL,[VENDOR,"Envizen"],[TYPE,TABLET]],[/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*(Trio[\s\w\-\.]+)\s+build/i],[MODEL,[VENDOR,"MachSpeed"],[TYPE,TABLET]],[/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android.+[;\/]\s*TU_(1491)\s+build/i],[MODEL,[VENDOR,"Rotor"],[TYPE,TABLET]],[/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i],[VENDOR,MODEL,[TYPE,TABLET]],[/android .+?; ([^;]+?)(?: build|\) applewebkit).+? mobile safari/i],[MODEL,[TYPE,MOBILE]],[/android .+?;\s([^;]+?)(?: build|\) applewebkit).+?(?! mobile) safari/i],[MODEL,[TYPE,TABLET]],[/\s(tablet|tab)[;\/]/i,/\s(mobile)(?:[;\/]|\ssafari)/i],[[TYPE,util.lowerize],VENDOR,MODEL],[/[\s\/\(](smart-?tv)[;\)]/i],[[TYPE,SMARTTV]],[/(android[\w\.\s\-]{0,9});.+build/i],[MODEL,[VENDOR,"Generic"]],[/(phone)/i],[[TYPE,MOBILE]]],engine:[[/windows.+\sedge\/([\w\.]+)/i],[VERSION,[NAME,"EdgeHTML"]],[/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],[VERSION,[NAME,"Blink"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,/(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,/(icab)[\/\s]([23]\.[\d\.]+)/i],[NAME,VERSION],[/rv\:([\w\.]{1,9}).+(gecko)/i],[VERSION,NAME]],os:[[/(xbox);\s+xbox\s([^\);]+)/i,/microsoft\s(windows)\s(vista|xp)/i],[NAME,VERSION],[/(windows)\snt\s6\.2;\s(arm)/i,/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],[NAME,[VERSION,mapper.str,maps.os.windows.version]],[/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],[[NAME,"Windows"],[VERSION,mapper.str,maps.os.windows.version]],[/\((bb)(10);/i],[[NAME,"BlackBerry"],VERSION],[/(blackberry)\w*\/?([\w\.]*)/i,/(tizen|kaios)[\/\s]([\w\.]+)/i,/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i],[NAME,VERSION],[/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i],[[NAME,"Symbian"],VERSION],[/\((series40);/i],[NAME],[/mozilla.+\(mobile;.+gecko.+firefox/i],[[NAME,"Firefox OS"],VERSION],[/crkey\/([\d\.]+)/i],[VERSION,[NAME,"Chromecast"]],[/(nintendo|playstation)\s([wids34portablevu]+)/i,/(mint)[\/\s\(]?(\w*)/i,/(mageia|vectorlinux)[;\s]/i,/(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,/(hurd|linux)\s?([\w\.]*)/i,/(gnu)\s?([\w\.]*)/i],[NAME,VERSION],[/(cros)\s[\w]+\s([\w\.]+\w)/i],[[NAME,"Chromium OS"],VERSION],[/(sunos)\s?([\w\.\d]*)/i],[[NAME,"Solaris"],VERSION],[/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i],[NAME,VERSION],[/(haiku)\s(\w+)/i],[NAME,VERSION],[/cfnetwork\/.+darwin/i,/ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],[[VERSION,/_/g,"."],[NAME,"iOS"]],[/(mac\sos\sx)\s?([\w\s\.]*)/i,/(macintosh|mac(?=_powerpc)\s)/i],[[NAME,"Mac OS"],[VERSION,/_/g,"."]],[/((?:open)?solaris)[\/\s-]?([\w\.]*)/i,/(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,/(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,/(unix)\s?([\w\.]*)/i],[NAME,VERSION]]};var UAParser=function(uastring,extensions){if(typeof uastring==="object"){extensions=uastring;uastring=undefined}if(!(this instanceof UAParser)){return new UAParser(uastring,extensions).getResult()}var ua=uastring||(window&&window.navigator&&window.navigator.userAgent?window.navigator.userAgent:EMPTY);var rgxmap=extensions?util.extend(regexes,extensions):regexes;this.getBrowser=function(){var browser={name:undefined,version:undefined};mapper.rgx.call(browser,ua,rgxmap.browser);browser.major=util.major(browser.version);return browser};this.getCPU=function(){var cpu={architecture:undefined};mapper.rgx.call(cpu,ua,rgxmap.cpu);return cpu};this.getDevice=function(){var device={vendor:undefined,model:undefined,type:undefined};mapper.rgx.call(device,ua,rgxmap.device);return device};this.getEngine=function(){var engine={name:undefined,version:undefined};mapper.rgx.call(engine,ua,rgxmap.engine);return engine};this.getOS=function(){var os={name:undefined,version:undefined};mapper.rgx.call(os,ua,rgxmap.os);return os};this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}};this.getUA=function(){return ua};this.setUA=function(uastring){ua=uastring;return this};return this};UAParser.VERSION=LIBVERSION;UAParser.BROWSER={NAME:NAME,MAJOR:MAJOR,VERSION:VERSION};UAParser.CPU={ARCHITECTURE:ARCHITECTURE};UAParser.DEVICE={MODEL:MODEL,VENDOR:VENDOR,TYPE:TYPE,CONSOLE:CONSOLE,MOBILE:MOBILE,SMARTTV:SMARTTV,TABLET:TABLET,WEARABLE:WEARABLE,EMBEDDED:EMBEDDED};UAParser.ENGINE={NAME:NAME,VERSION:VERSION};UAParser.OS={NAME:NAME,VERSION:VERSION};if(typeof exports!==UNDEF_TYPE){if(typeof module!==UNDEF_TYPE&&module.exports){exports=module.exports=UAParser}exports.UAParser=UAParser}else{if(true){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return UAParser}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else {}}var $=window&&(window.jQuery||window.Zepto);if($&&!$.ua){var parser=new UAParser;$.ua=parser.getResult();$.ua.get=function(){return parser.getUA()};$.ua.set=function(uastring){parser.setUA(uastring);var result=parser.getResult();for(var prop in result){$.ua[prop]=result[prop]}}}})(typeof window==="object"?window:this);

/***/ }),

/***/ "./src/assets/icons/CloseIcon.tsx":
/*!****************************************!*\
  !*** ./src/assets/icons/CloseIcon.tsx ***!
  \****************************************/
/*! exports provided: CloseIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CloseIcon", function() { return CloseIcon; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);


var _jsxFileName = "C:\\Users\\2012b\\WebstormProjects\\ecommerce-MERN\\client\\src\\assets\\icons\\CloseIcon.tsx",
    _this = undefined;


var CloseIcon = function CloseIcon() {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "10.003",
    height: "10",
    viewBox: "0 0 10.003 10",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("path", {
      "data-name": "_ionicons_svg_ios-close (5)",
      d: "M166.686,165.55l3.573-3.573a.837.837,0,0,0-1.184-1.184l-3.573,3.573-3.573-3.573a.837.837,0,1,0-1.184,1.184l3.573,3.573-3.573,3.573a.837.837,0,0,0,1.184,1.184l3.573-3.573,3.573,3.573a.837.837,0,0,0,1.184-1.184Z",
      transform: "translate(-160.5 -160.55)",
      fill: "currentColor"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 4,
    columnNumber: 5
  }, _this);
};
_c = CloseIcon;

var _c;

$RefreshReg$(_c, "CloseIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./src/assets/icons/LongArrowLeft.tsx":
/*!********************************************!*\
  !*** ./src/assets/icons/LongArrowLeft.tsx ***!
  \********************************************/
/*! exports provided: LongArrowLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LongArrowLeft", function() { return LongArrowLeft; });
/* harmony import */ var C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/extends */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);




var _jsxFileName = "C:\\Users\\2012b\\WebstormProjects\\ecommerce-MERN\\client\\src\\assets\\icons\\LongArrowLeft.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


var LongArrowLeft = function LongArrowLeft(_ref) {
  var props = Object(C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__["default"])({}, _ref);

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("svg", _objectSpread(_objectSpread({
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "8.003",
    viewBox: "0 0 12 8.003"
  }, props), {}, {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("path", {
      "data-name": "_ionicons_svg_ios-arrow-round-back (2)",
      d: "M116.447,160.177a.545.545,0,0,1,0,.767l-2.53,2.538h9.641a.542.542,0,0,1,0,1.084h-9.641l2.534,2.538a.549.549,0,0,1,0,.767.54.54,0,0,1-.763,0l-3.435-3.46a.608.608,0,0,1-.113-.171.517.517,0,0,1-.042-.208.543.543,0,0,1,.154-.379l3.435-3.46A.531.531,0,0,1,116.447,160.177Z",
      transform: "translate(-112.1 -160.023)",
      fill: "currentColor"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 7
    }, _this)
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 4,
    columnNumber: 5
  }, _this);
};
_c = LongArrowLeft;

var _c;

$RefreshReg$(_c, "LongArrowLeft");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/Layout/drawer/drawer.tsx":
/*!*************************************************!*\
  !*** ./src/components/Layout/drawer/drawer.tsx ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var rc_drawer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rc-drawer */ "./node_modules/rc-drawer/es/index.js");




var _jsxFileName = "C:\\Users\\2012b\\WebstormProjects\\ecommerce-MERN\\client\\src\\components\\Layout\\drawer\\drawer.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var Drawer = function Drawer(_ref) {
  var className = _ref.className,
      children = _ref.children,
      closeButton = _ref.closeButton,
      closeButtonStyle = _ref.closeButtonStyle,
      drawerHandler = _ref.drawerHandler,
      toggleHandler = _ref.toggleHandler,
      open = _ref.open,
      width = _ref.width,
      placement = _ref.placement,
      props = Object(C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref, ["className", "children", "closeButton", "closeButtonStyle", "drawerHandler", "toggleHandler", "open", "width", "placement"]);

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(react__WEBPACK_IMPORTED_MODULE_3__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(rc_drawer__WEBPACK_IMPORTED_MODULE_4__["default"], _objectSpread(_objectSpread({
      open: open,
      onClose: toggleHandler,
      className: "drawer ".concat(className ? className : '').trim(),
      width: width,
      placement: placement,
      handler: false,
      level: null,
      duration: ".4s"
    }, props), {}, {
      children: [closeButton && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
        className: "drawer__close",
        onClick: toggleHandler,
        style: closeButtonStyle,
        children: closeButton
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 11
      }, _this), children]
    }), void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
      className: "drawer__handler",
      style: {
        display: 'inline-block'
      },
      onClick: toggleHandler,
      children: drawerHandler
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 53,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 29,
    columnNumber: 5
  }, _this);
};

_c = Drawer;
Drawer.defaultProps = {
  width: '300px',
  placement: 'left'
};
/* harmony default export */ __webpack_exports__["default"] = (Drawer);

var _c;

$RefreshReg$(_c, "Drawer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/Layout/header/MobileHeader.tsx":
/*!*******************************************************!*\
  !*** ./src/components/Layout/header/MobileHeader.tsx ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _redq_reuse_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @redq/reuse-modal */ "./node_modules/@redq/reuse-modal/es/index.js");
/* harmony import */ var _MobileSidebar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MobileSidebar */ "./src/components/Layout/header/MobileSidebar.tsx");
/* harmony import */ var _header_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./header.style */ "./src/components/Layout/header/header.style.tsx");
/* harmony import */ var _search_search__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./search/search */ "./src/components/Layout/header/search/search.tsx");
/* harmony import */ var _assets_images_logo_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../assets/images/logo.svg */ "./src/assets/images/logo.svg");
/* harmony import */ var _assets_images_logo_svg__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_assets_images_logo_svg__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _assets_icons_SearchIcon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../assets/icons/SearchIcon */ "./src/assets/icons/SearchIcon.tsx");
/* harmony import */ var _assets_icons_LongArrowLeft__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../assets/icons/LongArrowLeft */ "./src/assets/icons/LongArrowLeft.tsx");
/* harmony import */ var _logo_logo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../logo/logo */ "./src/components/Layout/logo/logo.tsx");
/* harmony import */ var _menu_currency_switcher_CurrencySwitcher__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./menu/currency-switcher/CurrencySwitcher */ "./src/components/Layout/header/menu/currency-switcher/CurrencySwitcher.tsx");


var _jsxFileName = "C:\\Users\\2012b\\WebstormProjects\\ecommerce-MERN\\client\\src\\components\\Layout\\header\\MobileHeader.tsx",
    _this = undefined;


// @ts-ignore










var SearchModal = function SearchModal() {
  var onSubmit = function onSubmit() {
    Object(_redq_reuse_modal__WEBPACK_IMPORTED_MODULE_2__["closeModal"])();
  };

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_4__["SearchModalWrapper"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_4__["SearchModalClose"], {
      type: "submit",
      onClick: function onClick() {
        return Object(_redq_reuse_modal__WEBPACK_IMPORTED_MODULE_2__["closeModal"])();
      },
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_assets_icons_LongArrowLeft__WEBPACK_IMPORTED_MODULE_8__["LongArrowLeft"], {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 17
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 13
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_search_search__WEBPACK_IMPORTED_MODULE_5__["default"], {
      className: "header-modal-search",
      showButtonText: false,
      onSubmit: onSubmit
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 13
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 32,
    columnNumber: 9
  }, _this);
};

_c = SearchModal;

var MobileHeader = function MobileHeader(_ref) {
  var className = _ref.className;

  var handleSearchModal = function handleSearchModal() {
    Object(_redq_reuse_modal__WEBPACK_IMPORTED_MODULE_2__["openModal"])({
      show: true,
      config: {
        enableResizing: false,
        disableDragging: true,
        className: 'search-modal-mobile',
        width: '100%',
        height: '100%'
      },
      closeOnClickOutside: false,
      component: SearchModal,
      closeComponent: function closeComponent() {
        return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 59,
          columnNumber: 35
        }, _this);
      }
    });
  };

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_4__["MobileHeaderWrapper"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_4__["MobileHeaderInnerWrapper"], {
      className: className,
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_4__["DrawerWrapper"], {
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_MobileSidebar__WEBPACK_IMPORTED_MODULE_3__["default"], {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 69,
          columnNumber: 21
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 68,
        columnNumber: 17
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_4__["LogoWrapper"], {
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_logo_logo__WEBPACK_IMPORTED_MODULE_9__["default"], {
          imageUrl: _assets_images_logo_svg__WEBPACK_IMPORTED_MODULE_6___default.a,
          alt: "Wisecart - Logo"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 72,
          columnNumber: 21
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 71,
        columnNumber: 17
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_menu_currency_switcher_CurrencySwitcher__WEBPACK_IMPORTED_MODULE_10__["default"], {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 74,
        columnNumber: 17
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_4__["SearchWrapper"], {
        onClick: handleSearchModal,
        className: "searchIconWrapper",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_assets_icons_SearchIcon__WEBPACK_IMPORTED_MODULE_7__["SearchIcon"], {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 80,
          columnNumber: 21
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 76,
        columnNumber: 17
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 67,
      columnNumber: 13
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 65,
    columnNumber: 9
  }, _this);
};

_c2 = MobileHeader;
/* harmony default export */ __webpack_exports__["default"] = (MobileHeader);

var _c, _c2;

$RefreshReg$(_c, "SearchModal");
$RefreshReg$(_c2, "MobileHeader");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/Layout/header/MobileSidebar.tsx":
/*!********************************************************!*\
  !*** ./src/components/Layout/header/MobileSidebar.tsx ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawer_drawer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawer/drawer */ "./src/components/Layout/drawer/drawer.tsx");
/* harmony import */ var _Others_button_button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Others/button/button */ "./src/components/Others/button/button.tsx");
/* harmony import */ var _nav_link_nav_link__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../nav-link/nav-link */ "./src/components/Layout/nav-link/nav-link.tsx");
/* harmony import */ var _assets_icons_CloseIcon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../assets/icons/CloseIcon */ "./src/assets/icons/CloseIcon.tsx");
/* harmony import */ var _header_style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./header.style */ "./src/components/Layout/header/header.style.tsx");
/* harmony import */ var _assets_images_user_jpg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../assets/images/user.jpg */ "./src/assets/images/user.jpg");
/* harmony import */ var _assets_images_user_jpg__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_assets_images_user_jpg__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _site_navigation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./site-navigation */ "./src/components/Layout/header/site-navigation.ts");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-redux */ "./node_modules/react-redux/es/index.js");
/* harmony import */ var _redux_actions_globalActions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/redux/actions/globalActions */ "./src/redux/actions/globalActions.ts");
/* harmony import */ var _components_Scrollbar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/Scrollbar */ "./src/components/Scrollbar.tsx");


var _jsxFileName = "C:\\Users\\2012b\\WebstormProjects\\ecommerce-MERN\\client\\src\\components\\Layout\\header\\MobileSidebar.tsx",
    _this = undefined,
    _s = $RefreshSig$();

 // @ts-ignore












var MobileSidebar = function MobileSidebar() {
  _s();

  var dispatch = Object(react_redux__WEBPACK_IMPORTED_MODULE_9__["useDispatch"])(); //getting user

  var _useSelector = Object(react_redux__WEBPACK_IMPORTED_MODULE_9__["useSelector"])(function (state) {
    return state.globalReducer;
  }),
      isAuthenticated = _useSelector.isAuthenticated,
      user = _useSelector.user; //toggle state


  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])(false),
      toggle = _useState[0],
      setToggle = _useState[1]; //hardcoded authentication
  // Toggle drawer


  var toggleHandler = react__WEBPACK_IMPORTED_MODULE_1___default.a.useCallback(function () {
    setToggle(!toggle);
  }, [toggle]);

  var handleLogout = function handleLogout() {
    dispatch(Object(_redux_actions_globalActions__WEBPACK_IMPORTED_MODULE_10__["logout"])());
  };

  var signInOutForm = function signInOutForm() {};

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_drawer_drawer__WEBPACK_IMPORTED_MODULE_2__["default"], {
    width: "316px",
    drawerHandler: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["HamburgerIcon"], {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 56,
        columnNumber: 15
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 57,
        columnNumber: 15
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 58,
        columnNumber: 15
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 59,
        columnNumber: 15
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 55,
      columnNumber: 13
    }, _this),
    open: toggle,
    toggleHandler: toggleHandler,
    closeButton: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["DrawerClose"], {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_assets_icons_CloseIcon__WEBPACK_IMPORTED_MODULE_5__["CloseIcon"], {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 66,
        columnNumber: 15
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 65,
      columnNumber: 13
    }, _this),
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_Scrollbar__WEBPACK_IMPORTED_MODULE_11__["Scrollbar"], {
      style: {
        height: "100vh"
      },
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["DrawerContentWrapper"], {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["DrawerProfile"], {
          children: isAuthenticated && user ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["LoginView"], {
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["UserAvatar"], {
              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("img", {
                src: _assets_images_user_jpg__WEBPACK_IMPORTED_MODULE_7___default.a,
                alt: "user_avatar"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 76,
                columnNumber: 23
              }, _this)
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 75,
              columnNumber: 21
            }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["UserDetails"], {
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
                children: user.firstName + ' ' + user.lastName
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 79,
                columnNumber: 23
              }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
                children: user.email
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 80,
                columnNumber: 23
              }, _this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 78,
              columnNumber: 21
            }, _this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 74,
            columnNumber: 19
          }, _this) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["LogoutView"], {
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_Others_button_button__WEBPACK_IMPORTED_MODULE_3__["Button"], {
              variant: "primary",
              onClick: signInOutForm,
              children: "Login/Register"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 85,
              columnNumber: 21
            }, _this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 84,
            columnNumber: 19
          }, _this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 72,
          columnNumber: 13
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["DrawerMenu"], {
          children: _site_navigation__WEBPACK_IMPORTED_MODULE_8__["MOBILE_DRAWER_MENU"].map(function (item) {
            return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["DrawerMenuItem"], {
              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_nav_link_nav_link__WEBPACK_IMPORTED_MODULE_4__["default"], {
                onClick: toggleHandler,
                href: item.href,
                label: item.defaultMessage,
                className: "drawer_menu_item"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 96,
                columnNumber: 21
              }, _this)
            }, item.id, false, {
              fileName: _jsxFileName,
              lineNumber: 94,
              columnNumber: 19
            }, _this);
          })
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 92,
          columnNumber: 13
        }, _this), isAuthenticated && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["UserOptionMenu"], {
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["DrawerMenuItem"], {
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_nav_link_nav_link__WEBPACK_IMPORTED_MODULE_4__["default"], {
              href: _site_navigation__WEBPACK_IMPORTED_MODULE_8__["PROFILE_PAGE"],
              label: "Your Account Settings",
              className: "drawer_menu_item"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 109,
              columnNumber: 21
            }, _this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 108,
            columnNumber: 19
          }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_header_style__WEBPACK_IMPORTED_MODULE_6__["DrawerMenuItem"], {
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
              onClick: handleLogout,
              className: "drawer_menu_item",
              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
                className: "logoutBtn",
                children: "Logout"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 117,
                columnNumber: 19
              }, _this)
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 116,
              columnNumber: 21
            }, _this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 115,
            columnNumber: 19
          }, _this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 107,
          columnNumber: 17
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 71,
        columnNumber: 11
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 9
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 52,
    columnNumber: 7
  }, _this);
};

_s(MobileSidebar, "Kcm3tKnA7gE5mi3oFpx4LGUuYSw=", false, function () {
  return [react_redux__WEBPACK_IMPORTED_MODULE_9__["useDispatch"], react_redux__WEBPACK_IMPORTED_MODULE_9__["useSelector"]];
});

_c = MobileSidebar;
/* harmony default export */ __webpack_exports__["default"] = (MobileSidebar);

var _c;

$RefreshReg$(_c, "MobileSidebar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/Scrollbar.tsx":
/*!**************************************!*\
  !*** ./src/components/Scrollbar.tsx ***!
  \**************************************/
/*! exports provided: Scrollbar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scrollbar", function() { return Scrollbar; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var overlayscrollbars_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! overlayscrollbars-react */ "./node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var overlayscrollbars_css_OverlayScrollbars_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! overlayscrollbars/css/OverlayScrollbars.css */ "./node_modules/overlayscrollbars/css/OverlayScrollbars.css");
/* harmony import */ var overlayscrollbars_css_OverlayScrollbars_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(overlayscrollbars_css_OverlayScrollbars_css__WEBPACK_IMPORTED_MODULE_5__);




var _jsxFileName = "C:\\Users\\2012b\\WebstormProjects\\ecommerce-MERN\\client\\src\\components\\Scrollbar.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var Scrollbar = function Scrollbar(_ref) {
  var children = _ref.children,
      className = _ref.className,
      options = _ref.options,
      style = _ref.style,
      props = Object(C_Users_2012b_WebstormProjects_ecommerce_MERN_client_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__["default"])(_ref, ["children", "className", "options", "style"]);

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(overlayscrollbars_react__WEBPACK_IMPORTED_MODULE_3__["OverlayScrollbarsComponent"], _objectSpread(_objectSpread({
    options: _objectSpread({
      className: "".concat(className, " os-theme-thin"),
      scrollbars: {
        autoHide: 'leave'
      }
    }, options),
    style: style
  }, props), {}, {
    children: children
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 20,
    columnNumber: 9
  }, _this);
};
_c = Scrollbar;

var _c;

$RefreshReg$(_c, "Scrollbar");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ "./node_modules/next/dist/compiled/webpack/harmony-module.js")(module)))

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZVN1cGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlZHEvcmV1c2UtbW9kYWwvZXMvY2xvc2VTdmcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVkcS9yZXVzZS1tb2RhbC9lcy9ob29rcy91c2VDbGlja091dHNpZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVkcS9yZXVzZS1tb2RhbC9lcy9ob29rcy91c2VDb21wb25lbnRTaXplLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlZHEvcmV1c2UtbW9kYWwvZXMvaG9va3MvdXNlUG9ydGFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlZHEvcmV1c2UtbW9kYWwvZXMvaG9va3MvdXNlUmVhY3RTcHJpbmcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVkcS9yZXVzZS1tb2RhbC9lcy9ob29rcy91c2VSbmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVkcS9yZXVzZS1tb2RhbC9lcy9ob29rcy91c2VXaW5kb3dTaXplLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlZHEvcmV1c2UtbW9kYWwvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVkcS9yZXVzZS1tb2RhbC9ub2RlX21vZHVsZXMvcmVhY3Qtcm5kL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zhc3QtbWVtb2l6ZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vdmVybGF5c2Nyb2xsYmFycy9jc3MvT3ZlcmxheVNjcm9sbGJhcnMuY3NzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL292ZXJsYXlzY3JvbGxiYXJzLXJlYWN0L2Rpc3Qvb3ZlcmxheXNjcm9sbGJhcnMtcmVhY3QuZXNtLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3ZlcmxheXNjcm9sbGJhcnMvY3NzL092ZXJsYXlTY3JvbGxiYXJzLmNzcz9lNGNmIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3ZlcmxheXNjcm9sbGJhcnMvanMvT3ZlcmxheVNjcm9sbGJhcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yYy1kcmF3ZXIvZXMvRHJhd2VyQ2hpbGQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yYy1kcmF3ZXIvZXMvRHJhd2VyV3JhcHBlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLWRyYXdlci9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLWRyYXdlci9lcy91dGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLXV0aWwvZXMvRG9tL2NhblVzZURvbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLXV0aWwvZXMvRG9tL3Njcm9sbExvY2tlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLXV0aWwvZXMvS2V5Q29kZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JjLXV0aWwvZXMvUG9ydGFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmMtdXRpbC9lcy9Qb3J0YWxXcmFwcGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmMtdXRpbC9lcy9nZXRTY3JvbGxCYXJTaXplLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmMtdXRpbC9lcy9vbWl0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmMtdXRpbC9lcy9yYWYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yYy11dGlsL2VzL3NldFN0eWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmMtdXRpbC9lcy9zd2l0Y2hTY3JvbGxpbmdFZmZlY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZS1yZXNpemFibGUvbGliL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmUtcmVzaXphYmxlL2xpYi9yZXNpemVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGV2aWNlLWRldGVjdC9tYWluLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2Rpc3QvcmVhY3QtZHJhZ2dhYmxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3ByaW5nL3JlbmRlcnByb3BzLmNqcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VhLXBhcnNlci1qcy9kaXN0L3VhLXBhcnNlci5taW4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hc3NldHMvaWNvbnMvQ2xvc2VJY29uLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9Mb25nQXJyb3dMZWZ0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGF5b3V0L2RyYXdlci9kcmF3ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9MYXlvdXQvaGVhZGVyL01vYmlsZUhlYWRlci50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0xheW91dC9oZWFkZXIvTW9iaWxlU2lkZWJhci50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1Njcm9sbGJhci50c3giXSwibmFtZXMiOlsiQ2xvc2VJY29uIiwiTG9uZ0Fycm93TGVmdCIsInByb3BzIiwiRHJhd2VyIiwiY2xhc3NOYW1lIiwiY2hpbGRyZW4iLCJjbG9zZUJ1dHRvbiIsImNsb3NlQnV0dG9uU3R5bGUiLCJkcmF3ZXJIYW5kbGVyIiwidG9nZ2xlSGFuZGxlciIsIm9wZW4iLCJ3aWR0aCIsInBsYWNlbWVudCIsInRyaW0iLCJkaXNwbGF5IiwiZGVmYXVsdFByb3BzIiwiU2VhcmNoTW9kYWwiLCJvblN1Ym1pdCIsImNsb3NlTW9kYWwiLCJNb2JpbGVIZWFkZXIiLCJoYW5kbGVTZWFyY2hNb2RhbCIsIm9wZW5Nb2RhbCIsInNob3ciLCJjb25maWciLCJlbmFibGVSZXNpemluZyIsImRpc2FibGVEcmFnZ2luZyIsImhlaWdodCIsImNsb3NlT25DbGlja091dHNpZGUiLCJjb21wb25lbnQiLCJjbG9zZUNvbXBvbmVudCIsIkxvZ29JbWFnZSIsIk1vYmlsZVNpZGViYXIiLCJkaXNwYXRjaCIsInVzZURpc3BhdGNoIiwidXNlU2VsZWN0b3IiLCJzdGF0ZSIsImdsb2JhbFJlZHVjZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJ1c2VyIiwidXNlU3RhdGUiLCJ0b2dnbGUiLCJzZXRUb2dnbGUiLCJSZWFjdCIsInVzZUNhbGxiYWNrIiwiaGFuZGxlTG9nb3V0IiwibG9nb3V0Iiwic2lnbkluT3V0Rm9ybSIsIlVzZXJJbWFnZSIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiZW1haWwiLCJNT0JJTEVfRFJBV0VSX01FTlUiLCJtYXAiLCJpdGVtIiwiaHJlZiIsImRlZmF1bHRNZXNzYWdlIiwiaWQiLCJQUk9GSUxFX1BBR0UiLCJTY3JvbGxiYXIiLCJvcHRpb25zIiwic3R5bGUiLCJzY3JvbGxi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YUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEseUJBQXlCLE1BQU0sS0FBSyx3QkFBd0IsTUFBTSxNQUFNLFVBQVUsTUFBTSxNQUFNLFlBQVksYUFBYSxhQUFhLGFBQWEsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksV0FBVyxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxXQUFXLE1BQU0sTUFBTSxVQUFVLFVBQVUsVUFBVSxXQUFXLFlBQVksTUFBTSxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxVQUFVLE1BQU0sWUFBWSxTQUFTLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxZQUFZLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxZQUFZLE1BQU0sUUFBUSxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsS0FBSyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxVQUFVLE1BQU0sTUFBTSxZQUFZLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsV0FBVyxLQUFLLEtBQUssWUFBWSxXQUFXLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsTUFBTSxNQUFNLFVBQVUsVUFBVSxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxNQUFNLE1BQU0sVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxXQUFXLFVBQVUsVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksWUFBWSxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxVQUFVLFVBQVUsTUFBTSxLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVUsVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksV0FBVyxVQUFVLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxNQUFNLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLEtBQUssd0JBQXdCLHVCQUF1QixNQUFNLE1BQU0sWUFBWSxXQUFXLFlBQVksV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssYUFBYSxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssTUFBTSxVQUFVLFVBQVUsS0FBSyxNQUFNLFlBQVksYUFBYSxNQUFNLEtBQUssY0FBYyxjQUFjLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxLQUFLLEtBQUssTUFBTSxNQUFNLE1BQU0sWUFBWSxRQUFRLFlBQVksTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLE1BQU0sWUFBWSxPQUFPLFVBQVUsVUFBVSxNQUFNLE1BQU0sVUFBVSxVQUFVLEtBQUssTUFBTSxVQUFVLFVBQVUsS0FBSyxNQUFNLFVBQVUsVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLE1BQU0sVUFBVSxZQUFZLGFBQWEsYUFBYSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sVUFBVSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sUUFBUSxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sUUFBUSxVQUFVLFlBQVksV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLE1BQU0sUUFBUSxVQUFVLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxNQUFNLFVB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Qiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQix5QkFBeUI7QUFDeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FB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OztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1DQUFtQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7O0FBRW5JO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEY7O0FBRTlGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RkFBOEY7QUFDOUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTEFBZ0w7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1ELGdCQUFnQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQsMkRBQTJEOztBQUUzRDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILGlCQUFpQjtBQUM3SSx5QkFBeUI7OztBQUd6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILGlCQUFpQjtBQUM5SSx5QkFBeUI7OztBQUd6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0o7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IOztBQUVuSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtOQUErTjtBQUMvTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBIQUEwSDtBQUMxSCxpSEFBaUg7QUFDakg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0VBQStFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDLG9GQUFvRjtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOENBQThDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUFRO0FBQ1o7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzlJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OUc7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQyx5RUFBeUUsNEVBQTRFLEVBQUU7QUFDdko7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlG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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsOEJBQThCO0FBQzlCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVUsS0FBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QkFBdUIsbUNBQW1DOztBQUUxRDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0NBQXNDOztBQUV0QztBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QixJQUFJLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxPQUFPLG9CQUFvQjs7QUFFM0I7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztB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Q0FDRjtBQUFNLHlCQUFTLEVBQUMsV0FBaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFSRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBcENOO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFsQkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURKO0FBOEVELENBbkdEOztHQUFNYixhO1VBQ1dFLHVELEVBRWdCQyx1RDs7O0tBSDNCSCxhO0FBcUdTQSw0RUFBZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSUE7QUFDQTtBQUNBO0FBU08sSUFBTTJCLFNBQW1DLEdBQUcsU0FBdENBLFNBQXNDLE9BTU87QUFBQSxNQUxGckQsUUFLRSxRQUxGQSxRQUtFO0FBQUEsTUFKRkQsU0FJRSxRQUpGQSxTQUlFO0FBQUEsTUFIRnVELE9BR0UsUUFIRkEsT0FHRTtBQUFBLE1BRkZDLEtBRUUsUUFGRkEsS0FFRTtBQUFBLE1BREMxRCxLQUNEOztBQUN0RCxzQkFDSSxxRUFBQyxrRkFBRDtBQUNJLFdBQU87QUFDSEUsZUFBUyxZQUFLQSxTQUFMLG1CQUROO0FBRUh5RCxnQkFBVSxFQUFFO0FBQ1JDLGdCQUFRLEVBQUU7QUFERjtBQUZULE9BS0FILE9BTEEsQ0FEWDtBQVFJLFNBQUssRUFBRUM7QUFSWCxLQVNRMUQsS0FUUjtBQUFBLGNBV0tHO0FBWEw7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURKO0FBZUgsQ0F0Qk07S0FBTXFELFMiLCJmaWxlIjoic3RhdGljL2NodW5rcy8wLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iLCJpbXBvcnQgZ2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vZ2V0UHJvdG90eXBlT2YuanNcIjtcbmltcG9ydCBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgZnJvbSBcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzXCI7XG5pbXBvcnQgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tIFwiLi9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufSIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tIFwiLi9kZWZpbmVQcm9wZXJ0eS5qc1wiO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiaW1wb3J0IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIi4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufSIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHNMb29zZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IHZhciBDbG9zZUljb24gPSBmdW5jdGlvbiBDbG9zZUljb24oKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFwic3ZnXCIsXG4gICAge1xuICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIHdpZHRoOiBcIjMyXCIsXG4gICAgICBoZWlnaHQ6IFwiMzJcIixcbiAgICAgIHZpZXdCb3g6IFwiMCAwIDMyIDMyXCJcbiAgICB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgIGlkOiBcIl9pb25pY29uc19zdmdfaW9zLWNsb3NlXzVfXCIsXG4gICAgICBcImRhdGEtbmFtZVwiOiBcIl9pb25pY29uc19zdmdfaW9zLWNsb3NlICg1KVwiLFxuICAgICAgZDogXCJNMTc5LjQxOCwxNzUuODRsMTAuOTI1LTEwLjkyNWEyLjU2LDIuNTYsMCwwLDAtMy42Mi0zLjYyTDE3NS44LDE3Mi4yMmwtMTAuOTI1LTEwLjkyNWEyLjU2LDIuNTYsMCwxLDAtMy42MiwzLjYybDEwLjkyNSwxMC45MjUtMTAuOTI1LDEwLjkyNWEyLjU2LDIuNTYsMCwwLDAsMy42MiwzLjYyTDE3NS44LDE3OS40NmwxMC45MjUsMTAuOTI1YTIuNTYsMi41NiwwLDAsMCwzLjYyLTMuNjJaXCIsXG4gICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC0xNjAuNSAtMTYwLjU1KVwiLFxuICAgICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIlxuICAgIH0pXG4gICk7XG59OyIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VDbGlja091dHNpZGUoX3JlZikge1xuICB2YXIgbW9kYWxSZWYgPSBfcmVmLm1vZGFsUmVmLFxuICAgICAgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoLFxuICAgICAgY2xvc2VPbkNsaWNrT3V0c2lkZSA9IF9yZWYuY2xvc2VPbkNsaWNrT3V0c2lkZTtcblxuICB2YXIgaGFuZGxlQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgdmFyIGFyZWEgPSBSZWFjdERPTS5maW5kRE9NTm9kZShtb2RhbFJlZi5jdXJyZW50KTtcbiAgICBpZiAoYXJlYSAmJiAhYXJlYS5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICBpZiAoY2xvc2VPbkNsaWNrT3V0c2lkZSkgZGlzcGF0Y2goe30pO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgfTtcbiAgfSwgW10pO1xufSIsImltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxudmFyIGdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgaGVpZ2h0OiBlbC5vZmZzZXRIZWlnaHRcbiAgfTtcbn07XG5cbnZhciB1c2VDb21wb25lbnRTaXplID0gZnVuY3Rpb24gdXNlQ29tcG9uZW50U2l6ZShyZWYpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKGdldFNpemUocmVmID8gcmVmLmN1cnJlbnQgOiB7fSkpLFxuICAgICAgQ29tcG9uZW50U2l6ZSA9IF91c2VTdGF0ZVswXSxcbiAgICAgIHNldENvbXBvbmVudFNpemUgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIGhhbmRsZVJlc2l6ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgIHNldENvbXBvbmVudFNpemUoZ2V0U2l6ZShyZWYuY3VycmVudCkpO1xuICAgIH1cbiAgfSwgW3JlZl0pO1xuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhbmRsZVJlc2l6ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc2l6ZSgpO1xuICAgICAgfSk7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZi5jdXJyZW50KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdChyZWYuY3VycmVudCk7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbcmVmLmN1cnJlbnRdKTtcblxuICByZXR1cm4gQ29tcG9uZW50U2l6ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNvbXBvbmVudFNpemU7IiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVBvcnRhbCgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUobnVsbCksXG4gICAgICBjb250YWluZXIgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRDb250YWluZXIgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIGlkID0gcHJvcHMuaWQ7XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXByb2Nlc3MuYnJvd3NlcikgcmV0dXJuIG51bGw7XG4gICAgdmFyIGRpdklkID0gd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkIHx8ICdfX25leHQnKTsgLy9pZCA9ICdfX25leHQnIGZvciBuZXh0IGpzXG4gICAgaWYgKCFkaXZJZCkgZGl2SWQgPSBkb2N1bWVudC5ib2R5O1xuICAgIGlmICghZGl2SWQpIHJldHVybiBudWxsO1xuICAgIHZhciBjb250YWluZXIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2SWQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBzZXRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZGl2SWQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuICAgIHJldHVybiBjb250YWluZXIgPyBSZWFjdERPTS5jcmVhdGVQb3J0YWwocHJvcHMuY2hpbGRyZW4sIGNvbnRhaW5lcikgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgRnJhZ21lbnQsXG4gICAgICBudWxsLFxuICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9O1xufSIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTcHJpbmcgfSBmcm9tICdyZWFjdC1zcHJpbmcvcmVuZGVycHJvcHMuY2pzLmpzJztcbmltcG9ydCB1c2VDbGlja091dHNpZGUgZnJvbSAnLi91c2VDbGlja091dHNpZGUnO1xuaW1wb3J0IHVzZVdpbmRvd1NpemUgZnJvbSAnLi91c2VXaW5kb3dTaXplJztcbmltcG9ydCB1c2VDb21wb25lbnRTaXplIGZyb20gJy4vdXNlQ29tcG9uZW50U2l6ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVJlYWN0U3ByaW5nKCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZGlzcGF0Y2ggPSBwcm9wcy5kaXNwYXRjaCxcbiAgICAgIGNsb3NlT25DbGlja091dHNpZGUgPSBwcm9wcy5jbG9zZU9uQ2xpY2tPdXRzaWRlO1xuXG5cbiAgdmFyIHNpemUgPSBwcm9jZXNzLmJyb3dzZXIgJiYgdXNlV2luZG93U2l6ZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBSU3ByaW5nKHByb3BzKSB7XG4gICAgdmFyIG1vZGFsUmVmID0gdXNlUmVmKCk7XG5cbiAgICB2YXIgY29tcFNpemUgPSB1c2VDb21wb25lbnRTaXplKG1vZGFsUmVmKTtcblxuICAgIHVzZUNsaWNrT3V0c2lkZSh7IG1vZGFsUmVmOiBtb2RhbFJlZiwgZGlzcGF0Y2g6IGRpc3BhdGNoLCBjbG9zZU9uQ2xpY2tPdXRzaWRlOiBjbG9zZU9uQ2xpY2tPdXRzaWRlIH0pO1xuICAgIHZhciBjb25maWdzID0gcHJvcHMuY29uZmlncyxcbiAgICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZTtcblxuXG4gICAgdmFyIGRlZmF1bHRGcm9tID0ge1xuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMC4zKSdcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0VG8gPSB7XG4gICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKSdcbiAgICB9O1xuICAgIHZhciBzcHJpbmdDb25maWcgPSBfZXh0ZW5kcyh7fSwgY29uZmlncywge1xuICAgICAgY2xhc3NOYW1lOiAncmV1c2VNb2RhbEhvbGRlciAnICsgY29uZmlncy5jbGFzc05hbWUsXG4gICAgICBtYXhIZWlnaHQ6IHNpemUuaGVpZ2h0IC0gNjAsXG4gICAgICBtYXhXaWR0aDogc2l6ZS53aWR0aCAtIDQwLFxuICAgICAgd2lkdGg6IGNvbmZpZ3Mud2lkdGggPyBjb25maWdzLndpZHRoIDogY29uZmlncy5kZWZhdWx0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBjb25maWdzLmhlaWdodCA/IGNvbmZpZ3MuaGVpZ2h0IDogY29uZmlncy5kZWZhdWx0LmhlaWdodCxcbiAgICAgIHg6IGNvbmZpZ3MuZGVmYXVsdC54ID8gY29uZmlncy5kZWZhdWx0LnggOiBjb25maWdzLnggPyBjb25maWdzLnggOiAoY29uZmlncy53aWR0aCA/IGNvbmZpZ3Mud2lkdGggOiBjb25maWdzLmRlZmF1bHQud2lkdGgpIDw9IHNpemUud2lkdGggPyAoc2l6ZS53aWR0aCAtIChjb25maWdzLndpZHRoID8gY29uZmlncy53aWR0aCA6IGNvbmZpZ3MuZGVmYXVsdC53aWR0aCkpIC8gMiA6IGNvbXBTaXplLndpZHRoIDw9IHNpemUud2lkdGggPyAoc2l6ZS53aWR0aCAtIGNvbXBTaXplLndpZHRoKSAvIDIgOiAyMCxcbiAgICAgIHk6IGNvbmZpZ3MuZGVmYXVsdC55ID8gY29uZmlncy5kZWZhdWx0LnkgOiBjb25maWdzLnkgPyBjb25maWdzLnkgOiAoY29uZmlncy5oZWlnaHQgPyBjb25maWdzLmhlaWdodCA6IGNvbmZpZ3MuZGVmYXVsdC5oZWlnaHQpIDw9IHNpemUuaGVpZ2h0ID8gKHNpemUuaGVpZ2h0IC0gKGNvbmZpZ3MuaGVpZ2h0ID8gY29uZmlncy5oZWlnaHQgOiBjb25maWdzLmRlZmF1bHQuaGVpZ2h0KSkgLyAyIDogY29tcFNpemUuaGVpZ2h0IDw9IHNpemUuaGVpZ2h0ID8gKHNpemUuaGVpZ2h0IC0gY29tcFNpemUuaGVpZ2h0KSAvIDIgOiAzMCxcbiAgICAgIGFuaW1hdGlvbkZyb206IGNvbmZpZ3MuYW5pbWF0aW9uRnJvbSA/IGNvbmZpZ3MuYW5pbWF0aW9uRnJvbSA6IGRlZmF1bHRGcm9tLFxuICAgICAgYW5pbWF0aW9uVG86IGNvbmZpZ3MuYW5pbWF0aW9uVG8gPyBjb25maWdzLmFuaW1hdGlvblRvIDogZGVmYXVsdFRvLFxuICAgICAgdHJhbnNpdGlvbjogY29uZmlncy50cmFuc2l0aW9uID8gY29uZmlncy50cmFuc2l0aW9uIDoge1xuICAgICAgICBtYXNzOiAxLFxuICAgICAgICB0ZW5zaW9uOiAxMzAsXG4gICAgICAgIGZyaWN0aW9uOiAyNlxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHNwcmluZ1N0eWxlID0ge1xuICAgICAgbWF4V2lkdGg6IHNwcmluZ0NvbmZpZy5tYXhXaWR0aCxcbiAgICAgIG1heEhlaWdodDogc3ByaW5nQ29uZmlnLm1heEhlaWdodCxcbiAgICAgIHdpZHRoOiBzcHJpbmdDb25maWcud2lkdGgsXG4gICAgICBoZWlnaHQ6IHNwcmluZ0NvbmZpZy5oZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGxlZnQ6IHNwcmluZ0NvbmZpZy54LFxuICAgICAgdG9wOiBzcHJpbmdDb25maWcueVxuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFNwcmluZyxcbiAgICAgIHtcbiAgICAgICAgZnJvbTogX2V4dGVuZHMoe30sIHNwcmluZ0NvbmZpZy5hbmltYXRpb25Gcm9tKSxcbiAgICAgICAgdG86IF9leHRlbmRzKHt9LCBzcHJpbmdDb25maWcuYW5pbWF0aW9uVG8pLFxuICAgICAgICBjb25maWc6IHNwcmluZ0NvbmZpZy50cmFuc2l0aW9uXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKHNwcmluZ1Byb3BzKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdkaXYnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlZjogbW9kYWxSZWYsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHNwcmluZ0NvbmZpZy5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIHNwcmluZ1N0eWxlLCBzdHlsZSwgc3ByaW5nUHJvcHMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2lubmVyUm5kQ29tcG9uZW50JyB9LFxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcbn0iLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm5kIH0gZnJvbSAncmVhY3Qtcm5kJztcbmltcG9ydCB1c2VDbGlja091dHNpZGUgZnJvbSAnLi91c2VDbGlja091dHNpZGUnO1xuaW1wb3J0IHVzZVdpbmRvd1NpemUgZnJvbSAnLi91c2VXaW5kb3dTaXplJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlUm5kKCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZGlzcGF0Y2ggPSBwcm9wcy5kaXNwYXRjaCxcbiAgICAgIGNsb3NlT25DbGlja091dHNpZGUgPSBwcm9wcy5jbG9zZU9uQ2xpY2tPdXRzaWRlO1xuXG5cbiAgdmFyIHNpemUgPSBwcm9jZXNzLmJyb3dzZXIgJiYgdXNlV2luZG93U2l6ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gUk5EKHByb3BzKSB7XG4gICAgdmFyIG1vZGFsUmVmID0gdXNlUmVmKCk7XG4gICAgdXNlQ2xpY2tPdXRzaWRlKHsgbW9kYWxSZWY6IG1vZGFsUmVmLCBkaXNwYXRjaDogZGlzcGF0Y2gsIGNsb3NlT25DbGlja091dHNpZGU6IGNsb3NlT25DbGlja091dHNpZGUgfSk7XG4gICAgdmFyIGNvbmZpZyA9IHByb3BzLmNvbmZpZztcblxuICAgIHZhciBybmRDb25maWcgPSBfZXh0ZW5kcyh7fSwgY29uZmlnLCB7XG4gICAgICBjbGFzc05hbWU6ICdyZXVzZU1vZGFsSG9sZGVyICcgKyBjb25maWcuY2xhc3NOYW1lLFxuICAgICAgbWF4V2lkdGg6IHNpemUud2lkdGggLSA0MCxcbiAgICAgIG1heEhlaWdodDogc2l6ZS5oZWlnaHQgLSA2MCxcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5kZWZhdWx0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZy5kZWZhdWx0LmhlaWdodCxcbiAgICAgICAgeDogY29uZmlnLmRlZmF1bHQueCA/IGNvbmZpZy5kZWZhdWx0LnggOiBjb25maWcuZGVmYXVsdC53aWR0aCA8PSBzaXplLndpZHRoID8gKHNpemUud2lkdGggLSBjb25maWcuZGVmYXVsdC53aWR0aCkgLyAyIDogMjAsXG4gICAgICAgIHk6IGNvbmZpZy5kZWZhdWx0LnkgPyBjb25maWcuZGVmYXVsdC55IDogY29uZmlnLmRlZmF1bHQuaGVpZ2h0IDw9IHNpemUuaGVpZ2h0ID8gKHNpemUuaGVpZ2h0IC0gY29uZmlnLmRlZmF1bHQuaGVpZ2h0KSAvIDIgOiAzMFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSbmQsXG4gICAgICBfZXh0ZW5kcyh7fSwgcm5kQ29uZmlnLCB7IHJlZjogbW9kYWxSZWYgfSksXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzc05hbWU6ICdpbm5lclJuZENvbXBvbmVudCcgfSxcbiAgICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICAgIClcbiAgICApO1xuICB9O1xufSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc01vYmlsZSB9IGZyb20gJ3JlYWN0LWRldmljZS1kZXRlY3QnO1xudmFyIGV2ZW50cyA9IG5ldyBTZXQoKTtcbnZhciBvblJlc2l6ZSA9IGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICByZXR1cm4gZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0pO1xufTtcblxudmFyIHVzZVdpbmRvd1NpemUgPSBmdW5jdGlvbiB1c2VXaW5kb3dTaXplKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBfb3B0aW9ucyR0aHJvdHRsZU1zID0gb3B0aW9ucy50aHJvdHRsZU1zLFxuICAgICAgdGhyb3R0bGVNcyA9IF9vcHRpb25zJHRocm90dGxlTXMgPT09IHVuZGVmaW5lZCA/IDEwMCA6IF9vcHRpb25zJHRocm90dGxlTXM7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgfSksXG4gICAgICBzaXplID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0U2l6ZSA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgaGFuZGxlID0gdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgIHNldFNpemUoe1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9KTtcbiAgfSwgdGhyb3R0bGVNcyk7XG5cbiAgaWYgKCFpc01vYmlsZSkge1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZXZlbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzLmFkZChoYW5kbGUpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudHMuZGVsZXRlKGhhbmRsZSk7XG5cbiAgICAgICAgaWYgKGV2ZW50cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmdW5jKSB7XG4gIHZhciB0aHJlc2hob2xkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyNTA7XG4gIHZhciBzY29wZSA9IGFyZ3VtZW50c1syXTtcblxuICB2YXIgbGFzdCA9IHZvaWQgMCxcbiAgICAgIGRlZmVyVGltZXIgPSB2b2lkIDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBzY29wZSB8fCB0aGlzO1xuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKGxhc3QgJiYgbm93IDwgbGFzdCArIHRocmVzaGhvbGQpIHtcbiAgICAgIC8vIGhvbGQgb24gdG8gaXRcbiAgICAgIGNsZWFyVGltZW91dChkZWZlclRpbWVyKTtcbiAgICAgIGRlZmVyVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGFzdCA9IG5vdztcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH0sIHRocmVzaGhvbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gbm93O1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCB1c2VXaW5kb3dTaXplOyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VSZWR1Y2VyLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHVzZVBvcnRhbCBmcm9tICcuL2hvb2tzL3VzZVBvcnRhbCc7XG5pbXBvcnQgdXNlUm5kIGZyb20gJy4vaG9va3MvdXNlUm5kJztcbmltcG9ydCB1c2VSZWFjdFNwcmluZyBmcm9tICcuL2hvb2tzL3VzZVJlYWN0U3ByaW5nJztcbmltcG9ydCB7IENsb3NlSWNvbiB9IGZyb20gJy4vY2xvc2VTdmcnO1xuXG52YXIgb3Blbk1vZGFsID0gdm9pZCAwLFxuICAgIGNsb3NlTW9kYWwgPSB2b2lkIDA7XG5cbnZhciBpbml0aWFsRGF0YSA9IHtcbiAgc2hvdzogZmFsc2UsXG4gIHNwcmluZ1N0YXRlOiBmYWxzZSxcbiAgY29tcG9uZW50OiBudWxsLFxuICBjbG9zZU9uQ2xpY2tPdXRzaWRlOiB0cnVlLFxuICBjbG9zZUNvbXBvbmVudDogbnVsbCxcbiAgY29tcG9uZW50UHJvcHM6IHt9LFxuICBvdmVybGF5Q2xhc3NOYW1lOiAnJyxcbiAgd2l0aFJuZDogZmFsc2UsXG4gIHNwcmluZ1N0eWxlOiAnJyxcbiAgY29uZmlnOiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgd2lkdGg6IDUwMCxcbiAgICAgIGhlaWdodDogMzAwXG4gICAgfSxcbiAgICBjbGFzc05hbWU6ICcnLFxuICAgIG1pbldpZHRoOiAzMDAsXG4gICAgbWluSGVpZ2h0OiAnYXV0bycsXG4gICAgbG9ja0FzcGVjdFJhdGlvOiB0cnVlLFxuICAgIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSxcbiAgICBib3VuZHM6ICcucmV1c2VNb2RhbFBhcmVudFdyYXBwZXInLFxuICAgIGVuYWJsZVJlc2l6aW5nOiB7XG4gICAgICBib3R0b206IGZhbHNlLFxuICAgICAgYm90dG9tTGVmdDogZmFsc2UsXG4gICAgICBib3R0b21SaWdodDogZmFsc2UsXG4gICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgIHRvcDogZmFsc2UsXG4gICAgICB0b3BMZWZ0OiBmYWxzZSxcbiAgICAgIHRvcFJpZ2h0OiBmYWxzZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FuVXNlRE9NKCkge1xuICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbn1cblxudmFyIE1vZGFsUmVkdWNlciA9IGZ1bmN0aW9uIE1vZGFsUmVkdWNlcihzdGF0ZSkge1xuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgc2hvdzogYWN0aW9uLnNob3cgIT09IHVuZGVmaW5lZCA/IGFjdGlvbi5zaG93IDogIXN0YXRlLnNob3csXG4gICAgc3ByaW5nU3RhdGU6IGFjdGlvbi5zcHJpbmdTdGF0ZSAhPT0gdW5kZWZpbmVkID8gYWN0aW9uLnNwcmluZ1N0YXRlIDogIXN0YXRlLnNwcmluZ1N0YXRlLFxuICAgIHdpdGhSbmQ6IGFjdGlvbi53aXRoUm5kICE9PSB1bmRlZmluZWQgPyBhY3Rpb24ud2l0aFJuZCA6IHN0YXRlLndpdGhSbmQsXG4gICAgc3ByaW5nU3R5bGU6IGFjdGlvbi5zcHJpbmdTdHlsZSAhPT0gdW5kZWZpbmVkID8gYWN0aW9uLnNwcmluZ1N0eWxlIDogc3RhdGUuc3ByaW5nU3R5bGUsXG4gICAgb3ZlcmxheUNsYXNzTmFtZTogYWN0aW9uLm92ZXJsYXlDbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IGFjdGlvbi5vdmVybGF5Q2xhc3NOYW1lIDogc3RhdGUub3ZlcmxheUNsYXNzTmFtZSxcbiAgICBjb21wb25lbnQ6IGFjdGlvbi5jb21wb25lbnQgIT09IHVuZGVmaW5lZCA/IGFjdGlvbi5jb21wb25lbnQgOiBudWxsLFxuICAgIGNvbXBvbmVudFByb3BzOiBhY3Rpb24uY29tcG9uZW50UHJvcHMgIT09IHVuZGVmaW5lZCA/IGFjdGlvbi5jb21wb25lbnRQcm9wcyA6IHt9LFxuICAgIGNsb3NlQ29tcG9uZW50OiBhY3Rpb24uY2xvc2VDb21wb25lbnQgIT09IHVuZGVmaW5lZCA/IGFjdGlvbi5jbG9zZUNvbXBvbmVudCA6IG51bGwsXG4gICAgY2xvc2VPbkNsaWNrT3V0c2lkZTogYWN0aW9uLmNsb3NlT25DbGlja091dHNpZGUgIT09IHVuZGVmaW5lZCA/IGFjdGlvbi5jbG9zZU9uQ2xpY2tPdXRzaWRlIDogc3RhdGUuY2xvc2VPbkNsaWNrT3V0c2lkZSxcbiAgICBjb25maWc6IGFjdGlvbi5jb25maWcgIT09IHVuZGVmaW5lZCA/IF9leHRlbmRzKHt9LCBzdGF0ZS5jb25maWcsIGFjdGlvbi5jb25maWcpIDogc3RhdGUuY29uZmlnXG4gIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIE1vZGFsKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcblxuICB2YXIgUG9ydGFsID0gdXNlUG9ydGFsKCk7XG5cbiAgdmFyIF91c2VSZWR1Y2VyID0gdXNlUmVkdWNlcihNb2RhbFJlZHVjZXIsIGluaXRpYWxEYXRhKSxcbiAgICAgIHN0YXRlID0gX3VzZVJlZHVjZXJbMF0sXG4gICAgICBkaXNwYXRjaCA9IF91c2VSZWR1Y2VyWzFdO1xuXG4gIG9wZW5Nb2RhbCA9IGRpc3BhdGNoO1xuICBjbG9zZU1vZGFsID0gZGlzcGF0Y2g7XG5cbiAgdmFyIHNob3cgPSBzdGF0ZS5zaG93LFxuICAgICAgY29tcG9uZW50ID0gc3RhdGUuY29tcG9uZW50LFxuICAgICAgY2xvc2VDb21wb25lbnQgPSBzdGF0ZS5jbG9zZUNvbXBvbmVudCxcbiAgICAgIG92ZXJsYXlDbGFzc05hbWUgPSBzdGF0ZS5vdmVybGF5Q2xhc3NOYW1lLFxuICAgICAgd2l0aFJuZCA9IHN0YXRlLndpdGhSbmQsXG4gICAgICBzcHJpbmdTdHlsZSA9IHN0YXRlLnNwcmluZ1N0eWxlLFxuICAgICAgc3ByaW5nU3RhdGUgPSBzdGF0ZS5zcHJpbmdTdGF0ZTtcblxuICB2YXIgUm5kID0gdXNlUm5kKHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgY2xvc2VPbkNsaWNrT3V0c2lkZTogc3RhdGUuY2xvc2VPbkNsaWNrT3V0c2lkZVxuICB9KTtcblxuICB2YXIgUmVhY3RTcHJpbmcgPSB1c2VSZWFjdFNwcmluZyh7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIGNsb3NlT25DbGlja091dHNpZGU6IHN0YXRlLmNsb3NlT25DbGlja091dHNpZGVcbiAgfSk7XG4gIHZhciBNb2RhbENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgdmFyIGRlZmF1bHRDbG9zZUNvbXBvbmVudCA9IGZ1bmN0aW9uIGRlZmF1bHRDbG9zZUNvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdidXR0b24nLFxuICAgICAgeyBjbGFzc05hbWU6ICdyZXVzZU1vZGFsQ2xvc2VCdG4nLCBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh7fSk7XG4gICAgICAgIH0gfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvc2VJY29uLCBudWxsKVxuICAgICk7XG4gIH07XG4gIHZhciBDbG9zZSA9IGNsb3NlQ29tcG9uZW50ID8gY2xvc2VDb21wb25lbnQgOiBkZWZhdWx0Q2xvc2VDb21wb25lbnQ7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgRnJhZ21lbnQsXG4gICAgbnVsbCxcbiAgICBzaG93ICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICAhY2FuVXNlRE9NID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUG9ydGFsLFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ3JldXNlTW9kYWxPdmVybGF5ICcgKyBvdmVybGF5Q2xhc3NOYW1lIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlLCBudWxsKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ3JldXNlTW9kYWxQYXJyZW50V3JhcHBlcicgfSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgUm5kLFxuICAgICAgICAgICAgeyBjb25maWc6IHN0YXRlLmNvbmZpZyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNb2RhbENvbXBvbmVudCwgc3RhdGUuY29tcG9uZW50UHJvcHMpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApIDogd2l0aFJuZCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEZyYWdtZW50LFxuICAgICAgICBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogJ3JldXNlTW9kYWxPdmVybGF5ICcgKyBvdmVybGF5Q2xhc3NOYW1lIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlLCBudWxsKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7IGNsYXNzTmFtZTogJ3JldXNlTW9kYWxQYXJlbnRXcmFwcGVyJyB9LFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBSbmQsXG4gICAgICAgICAgICB7IGNvbmZpZzogc3RhdGUuY29uZmlnIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1vZGFsQ29tcG9uZW50LCBzdGF0ZS5jb21wb25lbnRQcm9wcylcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBGcmFnbWVudCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdyZXVzZU1vZGFsT3ZlcmxheSAnICsgb3ZlcmxheUNsYXNzTmFtZSB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDbG9zZSwgbnVsbCksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdyZXVzZU1vZGFsUGFyZW50V3JhcHBlcicgfSxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgUmVhY3RTcHJpbmcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbmZpZ3M6IHN0YXRlLmNvbmZpZyxcbiAgICAgICAgICAgICAgc3ByaW5nU3RhdGU6IHNwcmluZ1N0YXRlLFxuICAgICAgICAgICAgICBzdHlsZTogc3ByaW5nU3R5bGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1vZGFsQ29tcG9uZW50LCBzdGF0ZS5jb21wb25lbnRQcm9wcylcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmV4cG9ydCB7IG9wZW5Nb2RhbCwgY2xvc2VNb2RhbCB9OyIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlc2l6YWJsZSB9IGZyb20gJ3JlLXJlc2l6YWJsZSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XG5cbnZhciBEcmFnZ2FibGUgPSByZXF1aXJlKFwicmVhY3QtZHJhZ2dhYmxlXCIpO1xyXG52YXIgcmVzaXphYmxlU3R5bGUgPSB7XHJcbiAgICB3aWR0aDogXCJhdXRvXCIsXHJcbiAgICBoZWlnaHQ6IFwiYXV0b1wiLFxyXG4gICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcclxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICB0b3A6IDAsXHJcbiAgICBsZWZ0OiAwLFxyXG59O1xyXG52YXIgUm5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJuZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJuZChwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWF4V2lkdGg6IHByb3BzLm1heFdpZHRoLFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IHByb3BzLm1heEhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLm9uUmVzaXplU3RhcnQgPSBfdGhpcy5vblJlc2l6ZVN0YXJ0LmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLm9uUmVzaXplID0gX3RoaXMub25SZXNpemUuYmluZChfdGhpcyk7XHJcbiAgICAgICAgX3RoaXMub25SZXNpemVTdG9wID0gX3RoaXMub25SZXNpemVTdG9wLmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLm9uRHJhZ1N0YXJ0ID0gX3RoaXMub25EcmFnU3RhcnQuYmluZChfdGhpcyk7XHJcbiAgICAgICAgX3RoaXMub25EcmFnID0gX3RoaXMub25EcmFnLmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLm9uRHJhZ1N0b3AgPSBfdGhpcy5vbkRyYWdTdG9wLmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLmdldE1heFNpemVzRnJvbVByb3BzID0gX3RoaXMuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMuYmluZChfdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUm5kLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldE9mZnNldEZyb21QYXJlbnQoKSwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcDtcclxuICAgICAgICB2YXIgX2IgPSB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCksIHggPSBfYi54LCB5ID0gX2IueTtcclxuICAgICAgICB0aGlzLmRyYWdnYWJsZS5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIHg6IHggLSBsZWZ0LFxyXG4gICAgICAgICAgICB5OiB5IC0gdG9wLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEhBQ0s6IEFwcGx5IHBvc2l0aW9uIGFkanVzdG1lbnRcclxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gSEFDSzogVG8gZ2V0IGByZWFjdC1kcmFnZ2FibGVgIHN0YXRlIHggYW5kIHkuXHJcbiAgICBSbmQucHJvdG90eXBlLmdldERyYWdnYWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuZHJhZ2dhYmxlLnN0YXRlLCB4ID0gX2EueCwgeSA9IF9hLnk7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZSAmJiB0aGlzLnJlc2l6YWJsZS5wYXJlbnROb2RlO1xyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUuZ2V0UGFyZW50U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemFibGUuZ2V0UGFyZW50U2l6ZSgpO1xyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdHlwZW9mIHRoaXMucHJvcHMubWF4V2lkdGggPT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRoaXMucHJvcHMubWF4V2lkdGg7XHJcbiAgICAgICAgdmFyIG1heEhlaWdodCA9IHR5cGVvZiB0aGlzLnByb3BzLm1heEhlaWdodCA9PT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGhpcy5wcm9wcy5tYXhIZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHsgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCB9O1xyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUuZ2V0U2VsZkVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXphYmxlICYmIHRoaXMucmVzaXphYmxlLnJlc2l6YWJsZTtcclxuICAgIH07XHJcbiAgICBSbmQucHJvdG90eXBlLmdldE9mZnNldEhlaWdodCA9IGZ1bmN0aW9uIChib3VuZGFyeSkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucHJvcHMuc2NhbGU7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmJvdW5kcykge1xyXG4gICAgICAgICAgICBjYXNlIFwid2luZG93XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IC8gc2NhbGU7XHJcbiAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQgLyBzY2FsZTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBib3VuZGFyeS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUuZ2V0T2Zmc2V0V2lkdGggPSBmdW5jdGlvbiAoYm91bmRhcnkpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5ib3VuZHMpIHtcclxuICAgICAgICAgICAgY2FzZSBcIndpbmRvd1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIC8gc2NhbGU7XHJcbiAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAvIHNjYWxlO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdW5kYXJ5Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSbmQucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdTdGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0KGUsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMucHJvcHMuYm91bmRzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcclxuICAgICAgICB2YXIgYm91bmRhcnk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSBcInBhcmVudFwiKSB7XHJcbiAgICAgICAgICAgIGJvdW5kYXJ5ID0gcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJib2R5XCIpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFJlY3RfMSA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudExlZnRfMSA9IHBhcmVudFJlY3RfMS5sZWZ0O1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50VG9wXzEgPSBwYXJlbnRSZWN0XzEudG9wO1xyXG4gICAgICAgICAgICB2YXIgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdF8xID0gLShwYXJlbnRMZWZ0XzEgLSBwYXJlbnQub2Zmc2V0TGVmdCAqIHNjYWxlIC0gYm9keVJlY3QubGVmdCkgLyBzY2FsZTtcclxuICAgICAgICAgICAgdmFyIHRvcF8xID0gLShwYXJlbnRUb3BfMSAtIHBhcmVudC5vZmZzZXRUb3AgKiBzY2FsZSAtIGJvZHlSZWN0LnRvcCkgLyBzY2FsZTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLSB0aGlzLnJlc2l6YWJsZS5zaXplLndpZHRoICogc2NhbGUpIC8gc2NhbGUgKyBsZWZ0XzE7XHJcbiAgICAgICAgICAgIHZhciBib3R0b20gPSAoZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCAqIHNjYWxlKSAvIHNjYWxlICsgdG9wXzE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHsgYm91bmRzOiB7IHRvcDogdG9wXzEsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnRfMSB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJ3aW5kb3dcIikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmVjdF8yID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50TGVmdF8yID0gcGFyZW50UmVjdF8yLmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRUb3BfMiA9IHBhcmVudFJlY3RfMi50b3A7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0XzIgPSAtKHBhcmVudExlZnRfMiAtIHBhcmVudC5vZmZzZXRMZWZ0ICogc2NhbGUpIC8gc2NhbGU7XHJcbiAgICAgICAgICAgIHZhciB0b3BfMiA9IC0ocGFyZW50VG9wXzIgLSBwYXJlbnQub2Zmc2V0VG9wICogc2NhbGUpIC8gc2NhbGU7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIHRoaXMucmVzaXphYmxlLnNpemUud2lkdGggKiBzY2FsZSkgLyBzY2FsZSArIGxlZnRfMjtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCAqIHNjYWxlKSAvIHNjYWxlICsgdG9wXzI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHsgYm91bmRzOiB7IHRvcDogdG9wXzIsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnRfMiB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYm91bmRhcnkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMucHJvcHMuYm91bmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoYm91bmRhcnkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgIShwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYm91bmRhcnlSZWN0ID0gYm91bmRhcnkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdmFyIGJvdW5kYXJ5TGVmdCA9IGJvdW5kYXJ5UmVjdC5sZWZ0O1xyXG4gICAgICAgIHZhciBib3VuZGFyeVRvcCA9IGJvdW5kYXJ5UmVjdC50b3A7XHJcbiAgICAgICAgdmFyIHBhcmVudFJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdmFyIHBhcmVudExlZnQgPSBwYXJlbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgdmFyIHBhcmVudFRvcCA9IHBhcmVudFJlY3QudG9wO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gKGJvdW5kYXJ5TGVmdCAtIHBhcmVudExlZnQpIC8gc2NhbGU7XHJcbiAgICAgICAgdmFyIHRvcCA9IGJvdW5kYXJ5VG9wIC0gcGFyZW50VG9wO1xyXG4gICAgICAgIGlmICghdGhpcy5yZXNpemFibGUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXRGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgICAgdG9wOiB0b3AgLSBvZmZzZXQudG9wLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyAoYm91bmRhcnkub2Zmc2V0V2lkdGggLSB0aGlzLnJlc2l6YWJsZS5zaXplLndpZHRoKSAtIG9mZnNldC5sZWZ0IC8gc2NhbGUsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IHRvcCArIChib3VuZGFyeS5vZmZzZXRIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCkgLSBvZmZzZXQudG9wLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCAtIG9mZnNldC5sZWZ0IC8gc2NhbGUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUm5kLnByb3RvdHlwZS5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uRHJhZykge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXRGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25EcmFnKGUsIF9fYXNzaWduKHt9LCBkYXRhLCB7IHg6IGRhdGEueCAtIG9mZnNldC5sZWZ0LCB5OiBkYXRhLnkgLSBvZmZzZXQudG9wIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUm5kLnByb3RvdHlwZS5vbkRyYWdTdG9wID0gZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdTdG9wKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0T2Zmc2V0RnJvbVBhcmVudCgpLCBsZWZ0ID0gX2EubGVmdCwgdG9wXzMgPSBfYS50b3A7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoZSwgX19hc3NpZ24oe30sIGRhdGEsIHsgeDogZGF0YS54ICsgbGVmdCwgeTogZGF0YS55ICsgdG9wXzMgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSbmQucHJvdG90eXBlLm9uUmVzaXplU3RhcnQgPSBmdW5jdGlvbiAoZSwgZGlyLCBlbGVtZW50UmVmKSB7XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucHJvcHMuc2NhbGU7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsOiB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgICAgIHZhciBib3VuZGFyeSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSBcInBhcmVudFwiKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHBhcmVudF8xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSBcImJvZHlcIikge1xyXG4gICAgICAgICAgICAgICAgYm91bmRhcnkgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSBcIndpbmRvd1wiKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHdpbmRvdztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnByb3BzLmJvdW5kcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNlbGZfMSA9IHRoaXMuZ2V0U2VsZkVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKHNlbGZfMSBpbnN0YW5jZW9mIEVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIChib3VuZGFyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGJvdW5kYXJ5ID09PSB3aW5kb3cpICYmXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRfMSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmdldE1heFNpemVzRnJvbVByb3BzKCksIG1heFdpZHRoID0gX2EubWF4V2lkdGgsIG1heEhlaWdodCA9IF9hLm1heEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTaXplID0gdGhpcy5nZXRQYXJlbnRTaXplKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGggJiYgdHlwZW9mIG1heFdpZHRoID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heFdpZHRoLmVuZHNXaXRoKFwiJVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIobWF4V2lkdGgucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IHBhcmVudFNpemUud2lkdGggKiByYXRpbztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF4V2lkdGguZW5kc1dpdGgoXCJweFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE51bWJlcihtYXhXaWR0aC5yZXBsYWNlKFwicHhcIiwgXCJcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgJiYgdHlwZW9mIG1heEhlaWdodCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQuZW5kc1dpdGgoXCIlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IE51bWJlcihtYXhIZWlnaHQucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBwYXJlbnRTaXplLndpZHRoICogcmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heEhlaWdodC5lbmRzV2l0aChcInB4XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IE51bWJlcihtYXhIZWlnaHQucmVwbGFjZShcInB4XCIsIFwiXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZlJlY3QgPSBzZWxmXzEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZkxlZnQgPSBzZWxmUmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGZUb3AgPSBzZWxmUmVjdC50b3A7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnlSZWN0ID0gdGhpcy5wcm9wcy5ib3VuZHMgPT09IFwid2luZG93XCIgPyB7IGxlZnQ6IDAsIHRvcDogMCB9IDogYm91bmRhcnkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnlMZWZ0ID0gYm91bmRhcnlSZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnlUb3AgPSBib3VuZGFyeVJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFdpZHRoID0gdGhpcy5nZXRPZmZzZXRXaWR0aChib3VuZGFyeSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gdGhpcy5nZXRPZmZzZXRIZWlnaHQoYm91bmRhcnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0xlZnQgPSBkaXIudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzUmlnaHQgPSBkaXIudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc1RvcCA9IGRpci5zdGFydHNXaXRoKFwidG9wXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0JvdHRvbSA9IGRpci5zdGFydHNXaXRoKFwiYm90dG9tXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0xlZnQgJiYgdGhpcy5yZXNpemFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gKHNlbGZMZWZ0IC0gYm91bmRhcnlMZWZ0KSAvIHNjYWxlICsgdGhpcy5yZXNpemFibGUuc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWF4V2lkdGg6IG1heCA+IE51bWJlcihtYXhXaWR0aCkgPyBtYXhXaWR0aCA6IG1heCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElORk86IFRvIHNldCBib3VuZHMgaW4gYGxvY2sgYXNwZWN0IHJhdGlvIHdpdGggYm91bmRzYCBjYXNlLiBTZWUgYWxzbyB0aGF0IHN0b3J5LlxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1JpZ2h0IHx8ICh0aGlzLnByb3BzLmxvY2tBc3BlY3RSYXRpbyAmJiAhaGFzTGVmdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gb2Zmc2V0V2lkdGggKyAoYm91bmRhcnlMZWZ0IC0gc2VsZkxlZnQpIC8gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1heFdpZHRoOiBtYXggPiBOdW1iZXIobWF4V2lkdGgpID8gbWF4V2lkdGggOiBtYXggfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzVG9wICYmIHRoaXMucmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IChzZWxmVG9wIC0gYm91bmRhcnlUb3ApIC8gc2NhbGUgKyB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXggPiBOdW1iZXIobWF4SGVpZ2h0KSA/IG1heEhlaWdodCA6IG1heCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElORk86IFRvIHNldCBib3VuZHMgaW4gYGxvY2sgYXNwZWN0IHJhdGlvIHdpdGggYm91bmRzYCBjYXNlLiBTZWUgYWxzbyB0aGF0IHN0b3J5LlxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JvdHRvbSB8fCAodGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8gJiYgIWhhc1RvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gb2Zmc2V0SGVpZ2h0ICsgKGJvdW5kYXJ5VG9wIC0gc2VsZlRvcCkgLyBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXggPiBOdW1iZXIobWF4SGVpZ2h0KSA/IG1heEhlaWdodCA6IG1heCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogdGhpcy5wcm9wcy5tYXhXaWR0aCxcclxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogdGhpcy5wcm9wcy5tYXhIZWlnaHQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblJlc2l6ZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdGFydChlLCBkaXIsIGVsZW1lbnRSZWYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSbmQucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKGUsIGRpcmVjdGlvbiwgZWxlbWVudFJlZiwgZGVsdGEpIHtcclxuICAgICAgICB2YXIgeDtcclxuICAgICAgICB2YXIgeTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXRGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgaWYgKC9sZWZ0L2kudGVzdChkaXJlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHggPSB0aGlzLnN0YXRlLm9yaWdpbmFsLnggLSBkZWx0YS53aWR0aDtcclxuICAgICAgICAgICAgLy8gSU5GTzogSWYgdW5jb250cm9sbGVkIGNvbXBvbmVudCwgYXBwbHkgeCBwb3NpdGlvbiBieSByZXNpemUgdG8gZHJhZ2dhYmxlLlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLnNldFN0YXRlKHsgeDogeCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4ICs9IG9mZnNldC5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL3RvcC9pLnRlc3QoZGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICB5ID0gdGhpcy5zdGF0ZS5vcmlnaW5hbC55IC0gZGVsdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBJTkZPOiBJZiB1bmNvbnRyb2xsZWQgY29tcG9uZW50LCBhcHBseSB5IHBvc2l0aW9uIGJ5IHJlc2l6ZSB0byBkcmFnZ2FibGUuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuc2V0U3RhdGUoeyB5OiB5IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHkgKz0gb2Zmc2V0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25SZXNpemUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB4ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpLnggKyBvZmZzZXQubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHkgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCkueSArIG9mZnNldC50b3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZShlLCBkaXJlY3Rpb24sIGVsZW1lbnRSZWYsIGRlbHRhLCB7XHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUub25SZXNpemVTdG9wID0gZnVuY3Rpb24gKGUsIGRpcmVjdGlvbiwgZWxlbWVudFJlZiwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldE1heFNpemVzRnJvbVByb3BzKCksIG1heFdpZHRoID0gX2EubWF4V2lkdGgsIG1heEhlaWdodCA9IF9hLm1heEhlaWdodDtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCB9KTtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblJlc2l6ZVN0b3ApIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplU3RvcChlLCBkaXJlY3Rpb24sIGVsZW1lbnRSZWYsIGRlbHRhLCBwb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlc2l6YWJsZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucmVzaXphYmxlLnVwZGF0ZVNpemUoeyB3aWR0aDogc2l6ZS53aWR0aCwgaGVpZ2h0OiBzaXplLmhlaWdodCB9KTtcclxuICAgIH07XHJcbiAgICBSbmQucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUuc2V0U3RhdGUocG9zaXRpb24pO1xyXG4gICAgfTtcclxuICAgIFJuZC5wcm90b3R5cGUuZ2V0T2Zmc2V0RnJvbVBhcmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcy5nZXRTZWxmRWxlbWVudCgpO1xyXG4gICAgICAgIGlmICghcGFyZW50IHx8IHNlbGYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHZhciBwYXJlbnRMZWZ0ID0gcGFyZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgIHZhciBwYXJlbnRUb3AgPSBwYXJlbnRSZWN0LnRvcDtcclxuICAgICAgICB2YXIgc2VsZlJlY3QgPSBzZWxmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0RHJhZ2dhYmxlUG9zaXRpb24oKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBzZWxmUmVjdC5sZWZ0IC0gcGFyZW50TGVmdCAtIHBvc2l0aW9uLnggKiBzY2FsZSxcclxuICAgICAgICAgICAgdG9wOiBzZWxmUmVjdC50b3AgLSBwYXJlbnRUb3AgLSBwb3NpdGlvbi55ICogc2NhbGUsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBSbmQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRpc2FibGVEcmFnZ2luZyA9IF9hLmRpc2FibGVEcmFnZ2luZywgc3R5bGUgPSBfYS5zdHlsZSwgZHJhZ0hhbmRsZUNsYXNzTmFtZSA9IF9hLmRyYWdIYW5kbGVDbGFzc05hbWUsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIG9uTW91c2VEb3duID0gX2Eub25Nb3VzZURvd24sIGRyYWdBeGlzID0gX2EuZHJhZ0F4aXMsIGRyYWdHcmlkID0gX2EuZHJhZ0dyaWQsIGJvdW5kcyA9IF9hLmJvdW5kcywgZW5hYmxlVXNlclNlbGVjdEhhY2sgPSBfYS5lbmFibGVVc2VyU2VsZWN0SGFjaywgY2FuY2VsID0gX2EuY2FuY2VsLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBvblJlc2l6ZVN0YXJ0ID0gX2Eub25SZXNpemVTdGFydCwgb25SZXNpemUgPSBfYS5vblJlc2l6ZSwgb25SZXNpemVTdG9wID0gX2Eub25SZXNpemVTdG9wLCBvbkRyYWdTdGFydCA9IF9hLm9uRHJhZ1N0YXJ0LCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uRHJhZ1N0b3AgPSBfYS5vbkRyYWdTdG9wLCByZXNpemVIYW5kbGVTdHlsZXMgPSBfYS5yZXNpemVIYW5kbGVTdHlsZXMsIHJlc2l6ZUhhbmRsZUNsYXNzZXMgPSBfYS5yZXNpemVIYW5kbGVDbGFzc2VzLCBlbmFibGVSZXNpemluZyA9IF9hLmVuYWJsZVJlc2l6aW5nLCByZXNpemVHcmlkID0gX2EucmVzaXplR3JpZCwgcmVzaXplSGFuZGxlV3JhcHBlckNsYXNzID0gX2EucmVzaXplSGFuZGxlV3JhcHBlckNsYXNzLCByZXNpemVIYW5kbGVXcmFwcGVyU3R5bGUgPSBfYS5yZXNpemVIYW5kbGVXcmFwcGVyU3R5bGUsIHNjYWxlID0gX2Euc2NhbGUsIHJlc2l6YWJsZVByb3BzID0gX19yZXN0KF9hLCBbXCJkaXNhYmxlRHJhZ2dpbmdcIiwgXCJzdHlsZVwiLCBcImRyYWdIYW5kbGVDbGFzc05hbWVcIiwgXCJwb3NpdGlvblwiLCBcIm9uTW91c2VEb3duXCIsIFwiZHJhZ0F4aXNcIiwgXCJkcmFnR3JpZFwiLCBcImJvdW5kc1wiLCBcImVuYWJsZVVzZXJTZWxlY3RIYWNrXCIsIFwiY2FuY2VsXCIsIFwiY2hpbGRyZW5cIiwgXCJvblJlc2l6ZVN0YXJ0XCIsIFwib25SZXNpemVcIiwgXCJvblJlc2l6ZVN0b3BcIiwgXCJvbkRyYWdTdGFydFwiLCBcIm9uRHJhZ1wiLCBcIm9uRHJhZ1N0b3BcIiwgXCJyZXNpemVIYW5kbGVTdHlsZXNcIiwgXCJyZXNpemVIYW5kbGVDbGFzc2VzXCIsIFwiZW5hYmxlUmVzaXppbmdcIiwgXCJyZXNpemVHcmlkXCIsIFwicmVzaXplSGFuZGxlV3JhcHBlckNsYXNzXCIsIFwicmVzaXplSGFuZGxlV3JhcHBlclN0eWxlXCIsIFwic2NhbGVcIl0pO1xyXG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSB0aGlzLnByb3BzLmRlZmF1bHQgPyBfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcy5kZWZhdWx0KSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBSZW1vdmUgdW5rbm93biBwcm9wcywgc2VlIGFsc28gaHR0cHM6Ly9yZWFjdGpzLm9yZy93YXJuaW5ncy91bmtub3duLXByb3AuaHRtbFxyXG4gICAgICAgIGRlbGV0ZSByZXNpemFibGVQcm9wcy5kZWZhdWx0O1xyXG4gICAgICAgIHZhciBjdXJzb3JTdHlsZSA9IGRpc2FibGVEcmFnZ2luZyB8fCBkcmFnSGFuZGxlQ2xhc3NOYW1lID8geyBjdXJzb3I6IFwiYXV0b1wiIH0gOiB7IGN1cnNvcjogXCJtb3ZlXCIgfTtcclxuICAgICAgICB2YXIgaW5uZXJTdHlsZSA9IF9fYXNzaWduKHt9LCByZXNpemFibGVTdHlsZSwgY3Vyc29yU3R5bGUsIHN0eWxlKTtcclxuICAgICAgICB2YXIgX2IgPSB0aGlzLmdldE9mZnNldEZyb21QYXJlbnQoKSwgbGVmdCA9IF9iLmxlZnQsIHRvcCA9IF9iLnRvcDtcclxuICAgICAgICB2YXIgZHJhZ2dhYmxlUG9zaXRpb247XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGRyYWdnYWJsZVBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCAtIGxlZnQsXHJcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55IC0gdG9wLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRHJhZ2dhYmxlLCB7IHJlZjogZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2FibGUgPSBjO1xyXG4gICAgICAgICAgICB9LCBoYW5kbGU6IGRyYWdIYW5kbGVDbGFzc05hbWUgPyBcIi5cIiArIGRyYWdIYW5kbGVDbGFzc05hbWUgOiB1bmRlZmluZWQsIGRlZmF1bHRQb3NpdGlvbjogZGVmYXVsdFZhbHVlLCBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsIG9uRHJhZzogdGhpcy5vbkRyYWcsIG9uU3RvcDogdGhpcy5vbkRyYWdTdG9wLCBheGlzOiBkcmFnQXhpcywgZGlzYWJsZWQ6IGRpc2FibGVEcmFnZ2luZywgZ3JpZDogZHJhZ0dyaWQsIGJvdW5kczogYm91bmRzID8gdGhpcy5zdGF0ZS5ib3VuZHMgOiB1bmRlZmluZWQsIHBvc2l0aW9uOiBkcmFnZ2FibGVQb3NpdGlvbiwgZW5hYmxlVXNlclNlbGVjdEhhY2s6IGVuYWJsZVVzZXJTZWxlY3RIYWNrLCBjYW5jZWw6IGNhbmNlbCwgc2NhbGU6IHNjYWxlIH0sXHJcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoUmVzaXphYmxlLCBfX2Fzc2lnbih7fSwgcmVzaXphYmxlUHJvcHMsIHsgcmVmOiBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6YWJsZSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZGVmYXVsdFNpemU6IGRlZmF1bHRWYWx1ZSwgc2l6ZTogdGhpcy5wcm9wcy5zaXplLCBlbmFibGU6IGVuYWJsZVJlc2l6aW5nLCBvblJlc2l6ZVN0YXJ0OiB0aGlzLm9uUmVzaXplU3RhcnQsIG9uUmVzaXplOiB0aGlzLm9uUmVzaXplLCBvblJlc2l6ZVN0b3A6IHRoaXMub25SZXNpemVTdG9wLCBzdHlsZTogaW5uZXJTdHlsZSwgbWluV2lkdGg6IHRoaXMucHJvcHMubWluV2lkdGgsIG1pbkhlaWdodDogdGhpcy5wcm9wcy5taW5IZWlnaHQsIG1heFdpZHRoOiB0aGlzLmlzUmVzaXppbmcgPyB0aGlzLnN0YXRlLm1heFdpZHRoIDogdGhpcy5wcm9wcy5tYXhXaWR0aCwgbWF4SGVpZ2h0OiB0aGlzLmlzUmVzaXppbmcgPyB0aGlzLnN0YXRlLm1heEhlaWdodCA6IHRoaXMucHJvcHMubWF4SGVpZ2h0LCBncmlkOiByZXNpemVHcmlkLCBoYW5kbGVXcmFwcGVyQ2xhc3M6IHJlc2l6ZUhhbmRsZVdyYXBwZXJDbGFzcywgaGFuZGxlV3JhcHBlclN0eWxlOiByZXNpemVIYW5kbGVXcmFwcGVyU3R5bGUsIGxvY2tBc3BlY3RSYXRpbzogdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8sIGxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGg6IHRoaXMucHJvcHMubG9ja0FzcGVjdFJhdGlvRXh0cmFXaWR0aCwgbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQ6IHRoaXMucHJvcHMubG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQsIGhhbmRsZVN0eWxlczogcmVzaXplSGFuZGxlU3R5bGVzLCBoYW5kbGVDbGFzc2VzOiByZXNpemVIYW5kbGVDbGFzc2VzLCBzY2FsZTogdGhpcy5wcm9wcy5zY2FsZSB9KSwgY2hpbGRyZW4pKSk7XHJcbiAgICB9O1xyXG4gICAgUm5kLmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICBtYXhXaWR0aDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICAgICAgbWF4SGVpZ2h0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcclxuICAgICAgICBzY2FsZTogMSxcclxuICAgICAgICBvblJlc2l6ZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IH0sXHJcbiAgICAgICAgb25SZXNpemU6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICBvblJlc2l6ZVN0b3A6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKCkgeyB9LFxyXG4gICAgICAgIG9uRHJhZzogZnVuY3Rpb24gKCkgeyB9LFxyXG4gICAgICAgIG9uRHJhZ1N0b3A6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gUm5kO1xyXG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgeyBSbmQgfTtcbiIsIi8vXG4vLyBNYWluXG4vL1xuXG5mdW5jdGlvbiBtZW1vaXplIChmbiwgb3B0aW9ucykge1xuICB2YXIgY2FjaGUgPSBvcHRpb25zICYmIG9wdGlvbnMuY2FjaGVcbiAgICA/IG9wdGlvbnMuY2FjaGVcbiAgICA6IGNhY2hlRGVmYXVsdFxuXG4gIHZhciBzZXJpYWxpemVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZXJcbiAgICA/IG9wdGlvbnMuc2VyaWFsaXplclxuICAgIDogc2VyaWFsaXplckRlZmF1bHRcblxuICB2YXIgc3RyYXRlZ3kgPSBvcHRpb25zICYmIG9wdGlvbnMuc3RyYXRlZ3lcbiAgICA/IG9wdGlvbnMuc3RyYXRlZ3lcbiAgICA6IHN0cmF0ZWd5RGVmYXVsdFxuXG4gIHJldHVybiBzdHJhdGVneShmbiwge1xuICAgIGNhY2hlOiBjYWNoZSxcbiAgICBzZXJpYWxpemVyOiBzZXJpYWxpemVyXG4gIH0pXG59XG5cbi8vXG4vLyBTdHJhdGVneVxuLy9cblxuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgLy8gfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICd1bnNhZmUnIHByaW1pdGl2ZSBmb3Igb3VyIG5lZWRzXG59XG5cbmZ1bmN0aW9uIG1vbmFkaWMgKGZuLCBjYWNoZSwgc2VyaWFsaXplciwgYXJnKSB7XG4gIHZhciBjYWNoZUtleSA9IGlzUHJpbWl0aXZlKGFyZykgPyBhcmcgOiBzZXJpYWxpemVyKGFyZylcblxuICB2YXIgY29tcHV0ZWRWYWx1ZSA9IGNhY2hlLmdldChjYWNoZUtleSlcbiAgaWYgKHR5cGVvZiBjb21wdXRlZFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbXB1dGVkVmFsdWUgPSBmbi5jYWxsKHRoaXMsIGFyZylcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNvbXB1dGVkVmFsdWUpXG4gIH1cblxuICByZXR1cm4gY29tcHV0ZWRWYWx1ZVxufVxuXG5mdW5jdGlvbiB2YXJpYWRpYyAoZm4sIGNhY2hlLCBzZXJpYWxpemVyKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKVxuICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemVyKGFyZ3MpXG5cbiAgdmFyIGNvbXB1dGVkVmFsdWUgPSBjYWNoZS5nZXQoY2FjaGVLZXkpXG4gIGlmICh0eXBlb2YgY29tcHV0ZWRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb21wdXRlZFZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNvbXB1dGVkVmFsdWUpXG4gIH1cblxuICByZXR1cm4gY29tcHV0ZWRWYWx1ZVxufVxuXG5mdW5jdGlvbiBhc3NlbWJsZSAoZm4sIGNvbnRleHQsIHN0cmF0ZWd5LCBjYWNoZSwgc2VyaWFsaXplKSB7XG4gIHJldHVybiBzdHJhdGVneS5iaW5kKFxuICAgIGNvbnRleHQsXG4gICAgZm4sXG4gICAgY2FjaGUsXG4gICAgc2VyaWFsaXplXG4gIClcbn1cblxuZnVuY3Rpb24gc3RyYXRlZ3lEZWZhdWx0IChmbiwgb3B0aW9ucykge1xuICB2YXIgc3RyYXRlZ3kgPSBmbi5sZW5ndGggPT09IDEgPyBtb25hZGljIDogdmFyaWFkaWNcblxuICByZXR1cm4gYXNzZW1ibGUoXG4gICAgZm4sXG4gICAgdGhpcyxcbiAgICBzdHJhdGVneSxcbiAgICBvcHRpb25zLmNhY2hlLmNyZWF0ZSgpLFxuICAgIG9wdGlvbnMuc2VyaWFsaXplclxuICApXG59XG5cbmZ1bmN0aW9uIHN0cmF0ZWd5VmFyaWFkaWMgKGZuLCBvcHRpb25zKSB7XG4gIHZhciBzdHJhdGVneSA9IHZhcmlhZGljXG5cbiAgcmV0dXJuIGFzc2VtYmxlKFxuICAgIGZuLFxuICAgIHRoaXMsXG4gICAgc3RyYXRlZ3ksXG4gICAgb3B0aW9ucy5jYWNoZS5jcmVhdGUoKSxcbiAgICBvcHRpb25zLnNlcmlhbGl6ZXJcbiAgKVxufVxuXG5mdW5jdGlvbiBzdHJhdGVneU1vbmFkaWMgKGZuLCBvcHRpb25zKSB7XG4gIHZhciBzdHJhdGVneSA9IG1vbmFkaWNcblxuICByZXR1cm4gYXNzZW1ibGUoXG4gICAgZm4sXG4gICAgdGhpcyxcbiAgICBzdHJhdGVneSxcbiAgICBvcHRpb25zLmNhY2hlLmNyZWF0ZSgpLFxuICAgIG9wdGlvbnMuc2VyaWFsaXplclxuICApXG59XG5cbi8vXG4vLyBTZXJpYWxpemVyXG4vL1xuXG5mdW5jdGlvbiBzZXJpYWxpemVyRGVmYXVsdCAoKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudHMpXG59XG5cbi8vXG4vLyBDYWNoZVxuLy9cblxuZnVuY3Rpb24gT2JqZWN0V2l0aG91dFByb3RvdHlwZUNhY2hlICgpIHtcbiAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbn1cblxuT2JqZWN0V2l0aG91dFByb3RvdHlwZUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAoa2V5IGluIHRoaXMuY2FjaGUpXG59XG5cbk9iamVjdFdpdGhvdXRQcm90b3R5cGVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5jYWNoZVtrZXldXG59XG5cbk9iamVjdFdpdGhvdXRQcm90b3R5cGVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdGhpcy5jYWNoZVtrZXldID0gdmFsdWVcbn1cblxudmFyIGNhY2hlRGVmYXVsdCA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0V2l0aG91dFByb3RvdHlwZUNhY2hlKClcbiAgfVxufVxuXG4vL1xuLy8gQVBJXG4vL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVcbm1vZHVsZS5leHBvcnRzLnN0cmF0ZWdpZXMgPSB7XG4gIHZhcmlhZGljOiBzdHJhdGVneVZhcmlhZGljLFxuICBtb25hZGljOiBzdHJhdGVneU1vbmFkaWNcbn1cbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxyXFxuICogT3ZlcmxheVNjcm9sbGJhcnNcXHJcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmEvT3ZlcmxheVNjcm9sbGJhcnNcXHJcXG4gKlxcclxcbiAqIFZlcnNpb246IDEuMTMuMFxcclxcbiAqXFxyXFxuICogQ29weXJpZ2h0IEtpbmdTb3JhIHwgUmVuZSBIYWFzLlxcclxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYVxcclxcbiAqXFxyXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcclxcbiAqIERhdGU6IDAyLjA4LjIwMjBcXHJcXG4gKi9cXHJcXG5cXHJcXG4vKlxcclxcbk9WRVJMQVkgU0NST0xMQkFSUyBDT1JFOlxcclxcbiovXFxyXFxuXFxyXFxuaHRtbC5vcy1odG1sLFxcclxcbmh0bWwub3MtaHRtbCA+IC5vcy1ob3N0IHtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcXHJcXG4gICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcXHJcXG4gICAgbWluLXdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcXHJcXG4gICAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50OyAvKiBjb3VsZCBiZSBwb3NpdGlvbjogZml4ZWQ7IGJ1dCBpdCBjYXVzZXMgaXNzdWVzIG9uIGlPUyAoLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSAqL1xcclxcbn1cXHJcXG5odG1sLm9zLWh0bWwgPiAub3MtaG9zdCA+IC5vcy1wYWRkaW5nIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlOyAvKiBjb3VsZCBiZSBwb3NpdGlvbjogZml4ZWQ7IGJ1dCBpdCBjYXVzZXMgaXNzdWVzIG9uIGlPUyAoLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSAqL1xcclxcbn1cXHJcXG5ib2R5Lm9zLWRyYWdnaW5nLFxcclxcbmJvZHkub3MtZHJhZ2dpbmcgKiB7XFxyXFxuICAgIGN1cnNvcjogZGVmYXVsdDtcXHJcXG59XFxyXFxuLm9zLWhvc3QsXFxyXFxuLm9zLWhvc3QtdGV4dGFyZWEge1xcclxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICAgIG92ZXJmbG93OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxuICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxuICAgIC13ZWJraXQtYm94LWFsaWduOiBzdGFydDtcXHJcXG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBzdGFydDtcXHJcXG4gICAgICAgICAgICAgICAgLW1zLWdyaWQtcm93LWFsaWduOiBmbGV4LXN0YXJ0O1xcclxcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbn1cXHJcXG4ub3MtaG9zdC1mbGV4Ym94IHtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbn1cXHJcXG4ub3MtaG9zdC1mbGV4Ym94ID4gLm9zLXNpemUtYXV0by1vYnNlcnZlciB7XFxyXFxuICAgIGhlaWdodDogaW5oZXJpdCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3MtaG9zdC1mbGV4Ym94ID4gLm9zLWNvbnRlbnQtZ2x1ZSB7XFxyXFxuICAgIGZsZXgtZ3JvdzogMTtcXHJcXG4gICAgZmxleC1zaHJpbms6IDA7XFxyXFxufVxcclxcbi5vcy1ob3N0LWZsZXhib3ggPiAub3Mtc2l6ZS1hdXRvLW9ic2VydmVyLFxcclxcbi5vcy1ob3N0LWZsZXhib3ggPiAub3MtY29udGVudC1nbHVlIHtcXHJcXG4gICAgbWluLWhlaWdodDogMDtcXHJcXG4gICAgbWluLXdpZHRoOiAwO1xcclxcbiAgICBmbGV4LWdyb3c6IDA7XFxyXFxuICAgIGZsZXgtc2hyaW5rOiAxO1xcclxcbiAgICBmbGV4LWJhc2lzOiBhdXRvO1xcclxcbn1cXHJcXG4jb3MtZHVtbXktc2Nyb2xsYmFyLXNpemUge1xcclxcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIC1tcy1maWx0ZXI6ICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0wKSc7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcXHJcXG4gICAgaGVpZ2h0OiA1MDBweDtcXHJcXG4gICAgd2lkdGg6IDUwMHB4O1xcclxcbn1cXHJcXG4jb3MtZHVtbXktc2Nyb2xsYmFyLXNpemUgPiBkaXYge1xcclxcbiAgICB3aWR0aDogMjAwJTtcXHJcXG4gICAgaGVpZ2h0OiAyMDAlOyBcXHJcXG4gICAgbWFyZ2luOiAxMHB4IDA7XFxyXFxufVxcclxcbi8qIGZpeCByZXN0cmljdGVkIG1lYXN1cmluZyAqL1xcclxcbiNvcy1kdW1teS1zY3JvbGxiYXItc2l6ZTpiZWZvcmUsXFxyXFxuI29zLWR1bW15LXNjcm9sbGJhci1zaXplOmFmdGVyLFxcclxcbi5vcy1jb250ZW50OmJlZm9yZSxcXHJcXG4ub3MtY29udGVudDphZnRlciB7XFxyXFxuICAgIGNvbnRlbnQ6ICcnO1xcclxcbiAgICBkaXNwbGF5OiB0YWJsZTtcXHJcXG4gICAgd2lkdGg6IDAuMDFweDtcXHJcXG4gICAgaGVpZ2h0OiAwLjAxcHg7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAwO1xcclxcbiAgICBmb250LXNpemU6IDA7XFxyXFxuICAgIGZsZXgtZ3JvdzogMDtcXHJcXG4gICAgZmxleC1zaHJpbms6IDA7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG59XFxyXFxuI29zLWR1bW15LXNjcm9sbGJhci1zaXplLFxcclxcbi5vcy12aWV3cG9ydCB7XFxyXFxuICAgIC1tcy1vdmVyZmxvdy1zdHlsZTogc2Nyb2xsYmFyICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy12aWV3cG9ydC1uYXRpdmUtc2Nyb2xsYmFycy1pbnZpc2libGUjb3MtZHVtbXktc2Nyb2xsYmFyLXNpemUsXFxyXFxuLm9zLXZpZXdwb3J0LW5hdGl2ZS1zY3JvbGxiYXJzLWludmlzaWJsZS5vcy12aWV3cG9ydCB7XFxyXFxuICAgIHNjcm9sbGJhci13aWR0aDogbm9uZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3Mtdmlld3BvcnQtbmF0aXZlLXNjcm9sbGJhcnMtaW52aXNpYmxlI29zLWR1bW15LXNjcm9sbGJhci1zaXplOjotd2Via2l0LXNjcm9sbGJhcixcXHJcXG4ub3Mtdmlld3BvcnQtbmF0aXZlLXNjcm9sbGJhcnMtaW52aXNpYmxlLm9zLXZpZXdwb3J0Ojotd2Via2l0LXNjcm9sbGJhcixcXHJcXG4ub3Mtdmlld3BvcnQtbmF0aXZlLXNjcm9sbGJhcnMtaW52aXNpYmxlI29zLWR1bW15LXNjcm9sbGJhci1zaXplOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXIsXFxyXFxuLm9zLXZpZXdwb3J0LW5hdGl2ZS1zY3JvbGxiYXJzLWludmlzaWJsZS5vcy12aWV3cG9ydDo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVyIHtcXHJcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICB3aWR0aDogMHB4ICFpbXBvcnRhbnQ7XFxyXFxuICAgIGhlaWdodDogMHB4ICFpbXBvcnRhbnQ7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbiAhaW1wb3J0YW50O1xcclxcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3MtY29udGVudC1nbHVlIHtcXHJcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBpbmhlcml0O1xcclxcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XFxyXFxuICAgIG1heC1oZWlnaHQ6IDEwMCU7XFxyXFxuICAgIG1heC13aWR0aDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4ub3MtcGFkZGluZyB7XFxyXFxuICAgIC13ZWJraXQtYm94LXNpemluZzogaW5oZXJpdDtcXHJcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xcclxcbiAgICBkaXJlY3Rpb246IGluaGVyaXQ7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3ZlcmZsb3c6IHZpc2libGU7XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gICAgbGVmdDogMDtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcclxcbiAgICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcXHJcXG5cXHR6LWluZGV4OiAwO1xcclxcbn1cXHJcXG4ub3MtaG9zdC1vdmVyZmxvdyA+IC5vcy1wYWRkaW5nIHtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG59XFxyXFxuLm9zLXZpZXdwb3J0IHtcXHJcXG4gICAgZGlyZWN0aW9uOiBpbmhlcml0ICFpbXBvcnRhbnQ7XFxyXFxuICAgIC13ZWJraXQtYm94LXNpemluZzogaW5oZXJpdCAhaW1wb3J0YW50O1xcclxcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGluaGVyaXQgIWltcG9ydGFudDtcXHJcXG4gICAgcmVzaXplOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIG91dGxpbmU6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xcclxcbn1cXHJcXG4ub3MtY29udGVudC1hcnJhbmdlIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB6LWluZGV4OiAtMTtcXHJcXG4gICAgbWluLWhlaWdodDogMXB4O1xcclxcbiAgICBtaW4td2lkdGg6IDFweDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5vcy1jb250ZW50IHtcXHJcXG4gICAgZGlyZWN0aW9uOiBpbmhlcml0O1xcclxcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDtcXHJcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94ICFpbXBvcnRhbnQ7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxyXFxufVxcclxcbi5vcy1jb250ZW50ID4gLm9zLXRleHRhcmVhIHtcXHJcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94ICFpbXBvcnRhbnQ7XFxyXFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50O1xcclxcbiAgICBkaXJlY3Rpb246IGluaGVyaXQgIWltcG9ydGFudDtcXHJcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXHJcXG4gICAgb3V0bGluZTogMHB4IG5vbmUgdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDtcXHJcXG4gICAgdG9wOiAwICFpbXBvcnRhbnQ7XFxyXFxuICAgIGxlZnQ6IDAgIWltcG9ydGFudDtcXHJcXG4gICAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDBweCAhaW1wb3J0YW50O1xcclxcbiAgICBmbG9hdDogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICBmaWx0ZXI6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIHJlc2l6ZTogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICBtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgbWF4LWhlaWdodDogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIC13ZWJraXQtcGVyc3BlY3RpdmU6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZTogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XFxyXFxuICAgIHotaW5kZXg6IDEgIWltcG9ydGFudDtcXHJcXG4gICAgY2xpcDogYXV0byAhaW1wb3J0YW50O1xcclxcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmUgIWltcG9ydGFudDtcXHJcXG4gICAgcGFkZGluZzogMHB4O1xcclxcbn1cXHJcXG4ub3MtaG9zdC1ydGwgPiAub3MtcGFkZGluZyA+IC5vcy12aWV3cG9ydCA+IC5vcy1jb250ZW50ID4gLm9zLXRleHRhcmVhIHtcXHJcXG4gICAgcmlnaHQ6IDAgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLWNvbnRlbnQgPiAub3MtdGV4dGFyZWEtY292ZXIge1xcclxcbiAgICB6LWluZGV4OiAtMTtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5vcy1jb250ZW50ID4gLm9zLXRleHRhcmVhW3dyYXA9J29mZiddIHtcXHJcXG4gICAgd2hpdGUtc3BhY2U6IHByZSAhaW1wb3J0YW50O1xcclxcbiAgICBtYXJnaW46IDBweCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3MtdGV4dC1pbmhlcml0IHtcXHJcXG4gICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxyXFxuICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7XFxyXFxuICAgIGZvbnQtc3R5bGU6IGluaGVyaXQ7XFxyXFxuICAgIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogaW5oZXJpdDtcXHJcXG4gICAgZm9udC12YXJpYW50OiBpbmhlcml0O1xcclxcbiAgICB0ZXh0LXRyYW5zZm9ybTogaW5oZXJpdDtcXHJcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcclxcbiAgICB0ZXh0LWluZGVudDogaW5oZXJpdDtcXHJcXG4gICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcXHJcXG4gICAgdGV4dC1zaGFkb3c6IGluaGVyaXQ7XFxyXFxuICAgIHRleHQtb3ZlcmZsb3c6IGluaGVyaXQ7XFxyXFxuICAgIGxldHRlci1zcGFjaW5nOiBpbmhlcml0O1xcclxcbiAgICB3b3JkLXNwYWNpbmc6IGluaGVyaXQ7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcclxcbiAgICB1bmljb2RlLWJpZGk6IGluaGVyaXQ7XFxyXFxuICAgIGRpcmVjdGlvbjogaW5oZXJpdDtcXHJcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxyXFxuICAgIGN1cnNvcjogdGV4dDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlcixcXHJcXG4ub3MtcmVzaXplLW9ic2VydmVyLWhvc3Qge1xcclxcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGluaGVyaXQ7XFxyXFxuICAgICAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICB6LWluZGV4OiAtMTtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0IHtcXHJcXG4gICAgcGFkZGluZzogaW5oZXJpdDtcXHJcXG4gICAgYm9yZGVyOiBpbmhlcml0O1xcclxcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcclxcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0Lm9ic2VydmVkIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0ID4gLm9zLXJlc2l6ZS1vYnNlcnZlcixcXHJcXG4ub3MtcmVzaXplLW9ic2VydmVyLWhvc3Qub2JzZXJ2ZWQgPiAub3MtcmVzaXplLW9ic2VydmVyIHtcXHJcXG4gICAgaGVpZ2h0OiAyMDAlO1xcclxcbiAgICB3aWR0aDogMjAwJTtcXHJcXG4gICAgcGFkZGluZzogaW5oZXJpdDtcXHJcXG4gICAgYm9yZGVyOiBpbmhlcml0O1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcclxcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcclxcbn1cXHJcXG4ub3MtcmVzaXplLW9ic2VydmVyLWhvc3Qub2JzZXJ2ZWQgPiAub3MtcmVzaXplLW9ic2VydmVyLFxcclxcbi5vcy1yZXNpemUtb2JzZXJ2ZXItaG9zdC5vYnNlcnZlZCA+IC5vcy1yZXNpemUtb2JzZXJ2ZXI6YmVmb3JlIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgICBmbGV4LWdyb3c6IDE7XFxyXFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcclxcbiAgICBmbGV4LWJhc2lzOiBhdXRvO1xcclxcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0Lm9ic2VydmVkID4gLm9zLXJlc2l6ZS1vYnNlcnZlcjpiZWZvcmUge1xcclxcbiAgICBjb250ZW50OiAnJztcXHJcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXHJcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXHJcXG4gICAgcGFkZGluZzogaW5oZXJpdDtcXHJcXG4gICAgYm9yZGVyOiBpbmhlcml0O1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxufVxcclxcbi5vcy1zaXplLWF1dG8tb2JzZXJ2ZXIge1xcclxcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGluaGVyaXQgIWltcG9ydGFudDtcXHJcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0ICFpbXBvcnRhbnQ7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IGluaGVyaXQ7XFxyXFxuICAgIG1heC13aWR0aDogMXB4O1xcclxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICAgIGZsb2F0OiBsZWZ0O1xcclxcbiAgICBtYXgtaGVpZ2h0OiAxcHg7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIHotaW5kZXg6IC0xO1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICBmbGV4LWdyb3c6IGluaGVyaXQ7XFxyXFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcclxcbiAgICBmbGV4LWJhc2lzOiAwO1xcclxcbn1cXHJcXG4ub3Mtc2l6ZS1hdXRvLW9ic2VydmVyID4gLm9zLXJlc2l6ZS1vYnNlcnZlciB7XFxyXFxuICAgIHdpZHRoOiAxMDAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAwJTtcXHJcXG4gICAgbWluLWhlaWdodDogMXB4O1xcclxcbiAgICBtaW4td2lkdGg6IDFweDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1pdGVtIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIHotaW5kZXg6IC0xO1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICBkaXJlY3Rpb246IGx0ciAhaW1wb3J0YW50O1xcclxcbiAgICBmbGV4OiBub25lICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1yZXNpemUtb2JzZXJ2ZXItaXRlbS1maW5hbCB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgbGVmdDogMDtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICBmbGV4OiBub25lICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1yZXNpemUtb2JzZXJ2ZXIge1xcclxcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMC4wMDFzO1xcclxcbiAgICBhbmltYXRpb24tZHVyYXRpb246IDAuMDAxcztcXHJcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tbmFtZTogb3MtcmVzaXplLW9ic2VydmVyLWR1bW15LWFuaW1hdGlvbjtcXHJcXG4gICAgYW5pbWF0aW9uLW5hbWU6IG9zLXJlc2l6ZS1vYnNlcnZlci1kdW1teS1hbmltYXRpb247XFxyXFxufVxcclxcbm9iamVjdC5vcy1yZXNpemUtb2JzZXJ2ZXIge1xcclxcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDtcXHJcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94ICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbkAtd2Via2l0LWtleWZyYW1lcyBvcy1yZXNpemUtb2JzZXJ2ZXItZHVtbXktYW5pbWF0aW9uIHtcXHJcXG4gICAgZnJvbSB7XFxyXFxuICAgICAgICB6LWluZGV4OiAwO1xcclxcbiAgICB9XFxyXFxuICAgIHRvIHtcXHJcXG4gICAgICAgIHotaW5kZXg6IC0xO1xcclxcbiAgICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgb3MtcmVzaXplLW9ic2VydmVyLWR1bW15LWFuaW1hdGlvbiB7XFxyXFxuICAgIGZyb20ge1xcclxcbiAgICAgICAgei1pbmRleDogMDtcXHJcXG4gICAgfVxcclxcbiAgICB0byB7XFxyXFxuICAgICAgICB6LWluZGV4OiAtMTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbkNVU1RPTSBTQ1JPTExCQVJTIEFORCBDT1JORVIgQ09SRTpcXHJcXG4qL1xcclxcblxcclxcbi5vcy1ob3N0LXRyYW5zaXRpb24gPiAub3Mtc2Nyb2xsYmFyLFxcclxcbi5vcy1ob3N0LXRyYW5zaXRpb24gPiAub3Mtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzLCB2aXNpYmlsaXR5IDAuM3MsIHRvcCAwLjNzLCByaWdodCAwLjNzLCBib3R0b20gMC4zcywgbGVmdCAwLjNzO1xcclxcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MsIHZpc2liaWxpdHkgMC4zcywgdG9wIDAuM3MsIHJpZ2h0IDAuM3MsIGJvdHRvbSAwLjNzLCBsZWZ0IDAuM3M7XFxyXFxufVxcclxcbmh0bWwub3MtaHRtbCA+IC5vcy1ob3N0ID4gLm9zLXNjcm9sbGJhciB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsgLyogY291bGQgYmUgcG9zaXRpb246IGZpeGVkOyBidXQgaXQgY2F1c2VzIGlzc3VlcyBvbiBpT1MgKC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgKi9cXHJcXG4gICAgei1pbmRleDogOTk5OTk5OyAvKiBoaWdoZXN0IHotaW5kZXggb2YgdGhlIHBhZ2UgKi9cXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhcixcXHJcXG4ub3Mtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gICAgLW1zLWZpbHRlcjogJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTEwMCknO1xcclxcbiAgICB6LWluZGV4OiAxO1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXIge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci10cmFjayB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHBhZGRpbmc6IDAgIWltcG9ydGFudDtcXHJcXG4gICAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItaGFuZGxlIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci1oYW5kbGUtb2ZmLFxcclxcbi5vcy1zY3JvbGxiYXItdHJhY2stb2ZmIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXIub3Mtc2Nyb2xsYmFyLXVudXNhYmxlLFxcclxcbi5vcy1zY3JvbGxiYXIub3Mtc2Nyb2xsYmFyLXVudXNhYmxlICoge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyLm9zLXNjcm9sbGJhci11bnVzYWJsZSAub3Mtc2Nyb2xsYmFyLWhhbmRsZSB7XFxyXFxuICAgIG9wYWNpdHk6IDAgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIHtcXHJcXG4gICAgYm90dG9tOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIHtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICByaWdodDogMDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcnRsID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIHtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxufVxcclxcbi5vcy1ob3N0LXJ0bCA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwge1xcclxcbiAgICByaWdodDogYXV0bztcXHJcXG4gICAgbGVmdDogMDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcnRsID4gLm9zLXNjcm9sbGJhci1jb3JuZXIge1xcclxcbiAgICByaWdodDogYXV0bztcXHJcXG4gICAgbGVmdDogMDtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci1hdXRvLWhpZGRlbixcXHJcXG4ub3MtcGFkZGluZyArIC5vcy1zY3JvbGxiYXItY29ybmVyLFxcclxcbi5vcy1ob3N0LXJlc2l6ZS1kaXNhYmxlZC5vcy1ob3N0LXNjcm9sbGJhci1ob3Jpem9udGFsLWhpZGRlbiA+IC5vcy1zY3JvbGxiYXItY29ybmVyLFxcclxcbi5vcy1ob3N0LXNjcm9sbGJhci1ob3Jpem9udGFsLWhpZGRlbiA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCxcXHJcXG4ub3MtaG9zdC1yZXNpemUtZGlzYWJsZWQub3MtaG9zdC1zY3JvbGxiYXItdmVydGljYWwtaGlkZGVuID4gLm9zLXNjcm9sbGJhci1jb3JuZXIsXFxyXFxuLm9zLWhvc3Qtc2Nyb2xsYmFyLXZlcnRpY2FsLWhpZGRlbiA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwsXFxyXFxuLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsLm9zLXNjcm9sbGJhci1hdXRvLWhpZGRlbiArIC5vcy1zY3JvbGxiYXItdmVydGljYWwgKyAub3Mtc2Nyb2xsYmFyLWNvcm5lcixcXHJcXG4ub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgKyAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsLm9zLXNjcm9sbGJhci1hdXRvLWhpZGRlbiArIC5vcy1zY3JvbGxiYXItY29ybmVyLFxcclxcbi5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbC5vcy1zY3JvbGxiYXItYXV0by1oaWRkZW4gKyAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsLm9zLXNjcm9sbGJhci1hdXRvLWhpZGRlbiArIC5vcy1zY3JvbGxiYXItY29ybmVyIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci1jb3JuZXItcmVzaXplLWJvdGgge1xcclxcbiAgICBjdXJzb3I6IG53c2UtcmVzaXplO1xcclxcbn1cXHJcXG4ub3MtaG9zdC1ydGwgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUtYm90aCB7XFxyXFxuICAgIGN1cnNvcjogbmVzdy1yZXNpemU7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItY29ybmVyLXJlc2l6ZS1ob3Jpem9udGFsIHtcXHJcXG4gICAgY3Vyc29yOiBldy1yZXNpemU7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItY29ybmVyLXJlc2l6ZS12ZXJ0aWNhbCB7XFxyXFxuICAgIGN1cnNvcjogbnMtcmVzaXplO1xcclxcbn1cXHJcXG4ub3MtZHJhZ2dpbmcgLm9zLXNjcm9sbGJhci1jb3JuZXIub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUge1xcclxcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxyXFxufVxcclxcbi5vcy1ob3N0LXJlc2l6ZS1kaXNhYmxlZC5vcy1ob3N0LXNjcm9sbGJhci1ob3Jpem9udGFsLWhpZGRlbiA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwge1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcmVzaXplLWRpc2FibGVkLm9zLWhvc3Qtc2Nyb2xsYmFyLXZlcnRpY2FsLWhpZGRlbiA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCxcXHJcXG4ub3MtaG9zdC1ydGwub3MtaG9zdC1yZXNpemUtZGlzYWJsZWQub3MtaG9zdC1zY3JvbGxiYXItdmVydGljYWwtaGlkZGVuID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIHtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXI6aG92ZXIsXFxyXFxuLm9zLXNjcm9sbGJhci1jb3JuZXIub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUge1xcclxcbiAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XFxyXFxuICAgIHZpc2liaWxpdHk6IHZpc2libGUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci1jb3JuZXIub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUge1xcclxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtQSE4yWnlBZ0lIaHRiRzV6T21SalBTSm9kSFJ3T2k4dmNIVnliQzV2Y21jdlpHTXZaV3hsYldWdWRITXZNUzR4THlJZ0lDQjRiV3h1Y3pwall6MGlhSFIwY0RvdkwyTnlaV0YwYVhabFkyOXRiVzl1Y3k1dmNtY3Zibk1qSWlBZ0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SWdJQ0I0Yld4dWN6cHpkbWM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlBZ0lIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ0lDQjNhV1IwYUQwaU1UQWlJQ0FnYUdWcFoyaDBQU0l4TUNJZ0lDQjJaWEp6YVc5dVBTSXhMakVpUGlBZ1BHY2dJQ0FnSUhSeVlXNXpabTl5YlQwaWRISmhibk5zWVhSbEtEQXNMVEV3TkRJdU16WXlNaWtpSUNBZ0lDQnpkSGxzWlQwaVpHbHpjR3hoZVRwcGJteHBibVVpUGlBZ0lDQThjR0YwYUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak1EQXdNREF3TzJacGJHd3RiM0JoWTJsMGVUb3dMalE1TkRFeE56WTFPMlpwYkd3dGNuVnNaVHBsZG1WdWIyUmtPM04wY205clpUcHViMjVsSWlBZ0lDQWdJQ0JrUFNKdElEY3VOREkwTWpFNE55d3hNRFF5TGpNMk1qSWdZeUF0TUM0M01qTTFOemt5TERBZ0xURXVNekV3TVRVMk1pd3dMalU0TmpZZ0xURXVNekV3TVRVMk1pd3hMak14TURJZ01Dd3dMakk1T1NBd0xqRXdORE0wTVRrc01DNDFOekVnTUM0eU56STVORGt5TERBdU56a3hOU0F3TGpJd09URXdNalFzTUM0eE5ERXpJREF1TkRZMU5qSXdOaXd3TGpJeE9EUWdNQzQzTXpZNU5qSTVMREF1TWpFNE5DQXdMamN5TXpVM09UTXNNQ0F4TGpNeE1ERTFOak1zTFRBdU5UZzJOaUF4TGpNeE1ERTFOak1zTFRFdU16RXdNaUF3TEMwd0xqSTNNVE1nTFRBdU1EYzNNRGt6TEMwd0xqVXlOemdnTFRBdU1qRTRNelU1TkN3dE1DNDNNemNnTFRBdU1qSXdORGswTVN3dE1DNHhOamcySUMwd0xqUTVNalUwTkRNc0xUQXVNamN5T1NBdE1DNDNPVEUxTlRJNExDMHdMakkzTWprZ2VpQnRJREFzTXk0d09EUXpJR01nTFRBdU56SXpOVGM1TWl3d0lDMHhMak14TURFMU5qSXNNQzQxT0RZMklDMHhMak14TURFMU5qSXNNUzR6TVRBeUlEQXNNQzR5T1RrZ01DNHhNRFF6TkRFNUxEQXVOVGN4SURBdU1qY3lPVFE1TWl3d0xqYzVNVFVnTUM0eU1Ea3hNREkwTERBdU1UUXhNeUF3TGpRMk5UWXlNRFlzTUM0eU1UZzBJREF1TnpNMk9UWXlPU3d3TGpJeE9EUWdNQzQzTWpNMU56a3pMREFnTVM0ek1UQXhOVFl6TEMwd0xqVTROallnTVM0ek1UQXhOVFl6TEMweExqTXhNRElnTUN3dE1DNHlOekV6SUMwd0xqQTNOekE1TXl3dE1DNDFNamM0SUMwd0xqSXhPRE0xT1RRc0xUQXVOek0yT1NBdE1DNHlNakEwT1RReExDMHdMakUyT0RZZ0xUQXVORGt5TlRRME15d3RNQzR5TnpNZ0xUQXVOemt4TlRVeU9Dd3RNQzR5TnpNZ2VpQnRJQzB6TGpBNE5ETXlOakVzTUNCaklDMHdMamN5TXpVM09UTXNNQ0F0TVM0ek1UQXhOVFl6TERBdU5UZzJOaUF0TVM0ek1UQXhOVFl6TERFdU16RXdNaUF3TERBdU1qazVJREF1TVRBME16UXhPU3d3TGpVM01TQXdMakkzTWprME9USXNNQzQzT1RFMUlEQXVNakE1TVRBeU5Dd3dMakUwTVRNZ01DNDBOalUyTWpBM0xEQXVNakU0TkNBd0xqY3pOamsyTWprc01DNHlNVGcwSURBdU56SXpOVGM1TXl3d0lERXVNekV3TVRVMk15d3RNQzQxT0RZMklERXVNekV3TVRVMk15d3RNUzR6TVRBeUlEQXNMVEF1TWpjeE15QXRNQzR3Tnpjd09UTXNMVEF1TlRJM09DQXRNQzR5TVRnek5UazBMQzB3TGpjek5qa2dMVEF1TWpJd05EazBMQzB3TGpFMk9EWWdMVEF1TkRreU5UUTBNaXd0TUM0eU56TWdMVEF1TnpreE5UVXlOeXd0TUM0eU56TWdlaUJ0SUMwekxqQXlPVGN6TmpRc015NHdNams0SUVNZ01DNDFPRFkxTnpZNU15d3hNRFE0TGpRM05qTWdNQ3d4TURRNUxqQTJNamdnTUN3eE1EUTVMamM0TmpRZ1l5QXdMREF1TWprNUlEQXVNVEEwTXpReE9Td3dMalUzTVRFZ01DNHlOekk1TkRreU1pd3dMamM1TVRZZ01DNHlNRGt4TURJeU9Td3dMakUwTVRJZ01DNDBOalUyTWpBMk5Td3dMakl4T0RNZ01DNDNNelk1TmpJNE9Dd3dMakl4T0RNZ01DNDNNak0xTnprekxEQWdNUzR6TVRBeE5UWXpMQzB3TGpVNE5qVWdNUzR6TVRBeE5UWXpMQzB4TGpNeE1ERWdNQ3d0TUM0eU56RTBJQzB3TGpBM056QTVNeXd0TUM0MU1qYzVJQzB3TGpJeE9ETTFPVFFzTFRBdU56TTNJQzB3TGpJeU1EUTVOREVzTFRBdU1UWTROaUF0TUM0ME9USTFORFF6TEMwd0xqSTNNamtnTFRBdU56a3hOVFV5T0N3dE1DNHlOekk1SUhvZ2JTQXpMakF5T1Rjek5qUXNNQ0JqSUMwd0xqY3lNelUzT1RNc01DQXRNUzR6TVRBeE5UWXpMREF1TlRnMk5TQXRNUzR6TVRBeE5UWXpMREV1TXpFd01TQXdMREF1TWprNUlEQXVNVEEwTXpReE9Td3dMalUzTVRFZ01DNHlOekk1TkRreUxEQXVOemt4TmlBd0xqSXdPVEV3TWpRc01DNHhOREV5SURBdU5EWTFOakl3Tnl3d0xqSXhPRE1nTUM0M016WTVOakk1TERBdU1qRTRNeUF3TGpjeU16VTNPVE1zTUNBeExqTXhNREUxTmpNc0xUQXVOVGcyTlNBeExqTXhNREUxTmpNc0xURXVNekV3TVNBd0xDMHdMakkzTVRRZ0xUQXVNRGMzTURrekxDMHdMalV5TnprZ0xUQXVNakU0TXpVNU5Dd3RNQzQzTXpjZ0xUQXVNakl3TkRrMExDMHdMakUyT0RZZ0xUQXVORGt5TlRRME1pd3RNQzR5TnpJNUlDMHdMamM1TVRVMU1qY3NMVEF1TWpjeU9TQjZJRzBnTXk0d09EUXpNall4TERBZ1l5QXRNQzQzTWpNMU56a3lMREFnTFRFdU16RXdNVFUyTWl3d0xqVTROalVnTFRFdU16RXdNVFUyTWl3eExqTXhNREVnTUN3d0xqSTVPU0F3TGpFd05ETTBNVGtzTUM0MU56RXhJREF1TWpjeU9UUTVNaXd3TGpjNU1UWWdNQzR5TURreE1ESTBMREF1TVRReE1pQXdMalEyTlRZeU1EWXNNQzR5TVRneklEQXVOek0yT1RZeU9Td3dMakl4T0RNZ01DNDNNak0xTnprekxEQWdNUzR6TVRBeE5UWXpMQzB3TGpVNE5qVWdNUzR6TVRBeE5UWXpMQzB4TGpNeE1ERWdNQ3d0TUM0eU56RTBJQzB3TGpBM056QTVNeXd0TUM0MU1qYzVJQzB3TGpJeE9ETTFPVFFzTFRBdU56TTNJQzB3TGpJeU1EUTVOREVzTFRBdU1UWTROaUF0TUM0ME9USTFORFF6TEMwd0xqSTNNamtnTFRBdU56a3hOVFV5T0N3dE1DNHlOekk1SUhvaUx6NGdJRHd2Wno0Z0lEeG5JQ0FnSUNCemRIbHNaVDBpWkdsemNHeGhlVHBwYm14cGJtVWlQaUFnSUNBOGNHRjBhQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qWm1abVptWm1PMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcGxkbVZ1YjJSa08zTjBjbTlyWlRwdWIyNWxJaUFnSUNBZ0lDQmtQU0p0SURndU1qRTFOemN4TlN3d0xqSTNNamswT1RJeUlHTWdNQzR4TkRFeU5qWTNMREF1TWpBNU1UQXlNamtnTUM0eU1UZ3pOVGswTERBdU5EWTFOakl3TmpVZ01DNHlNVGd6TlRrMExEQXVOek0yT1RZeU9EZ2dNQ3d3TGpjeU16VTNPVE1nTFRBdU5UZzJOVGMzTERFdU16RXdNVFUyTXlBdE1TNHpNVEF4TlRZekxERXVNekV3TVRVMk15QXRNQzR5TnpFek5ESXpMREFnTFRBdU5USTNPRFl3TlN3dE1DNHdOemN3T1RNZ0xUQXVOek0yT1RZeU9Td3RNQzR5TVRnek5UazBJREF1TWpNNU5ERXdOQ3d3TGpNeE16QTROVGtnTUM0Mk1USTJNell5TERBdU5URTROakF6TlNBeExqQXpOekl3Tnl3d0xqVXhPRFl3TXpVZ01DNDNNak0xTnprekxEQWdNUzR6TVRBeE5UWXpMQzB3TGpVNE5qVTNOeUF4TGpNeE1ERTFOak1zTFRFdU16RXdNVFUyTXlBd0xDMHdMalF5TkRVM01EYzJJQzB3TGpJd05UVXhOellzTFRBdU56azNOemsyTlRrZ0xUQXVOVEU0TmpBek5Td3RNUzR3TXpjeU1EWTVPQ0I2SUcwZ01Dd3pMakE0TkRNeU5qRTRJR01nTUM0eE5ERXlOalkzTERBdU1qQTVNVEF5TXlBd0xqSXhPRE0xT1RRc01DNDBOalUyTWpBMklEQXVNakU0TXpVNU5Dd3dMamN6TmprMk1qa2dNQ3d3TGpjeU16VTNPVE1nTFRBdU5UZzJOVGMzTERFdU16RXdNVFUyTWlBdE1TNHpNVEF4TlRZekxERXVNekV3TVRVMk1pQXRNQzR5TnpFek5ESXpMREFnTFRBdU5USTNPRFl3TlN3dE1DNHdOemN3T1RNZ0xUQXVOek0yT1RZeU9Td3RNQzR5TVRnek5Ua3pJREF1TWpNNU5ERXdOQ3d3TGpNeE16QTROVGtnTUM0Mk1USTJNell5TERBdU5URTROakF6TlNBeExqQXpOekl3Tnl3d0xqVXhPRFl3TXpVZ01DNDNNak0xTnprekxEQWdNUzR6TVRBeE5UWXpMQzB3TGpVNE5qVTNOeUF4TGpNeE1ERTFOak1zTFRFdU16RXdNVFUyTXlBd0xDMHdMalF5TkRVM01EZ2dMVEF1TWpBMU5URTNOaXd0TUM0M09UYzNPVFkzSUMwd0xqVXhPRFl3TXpVc0xURXVNRE0zTWpBM0lIb2diU0F0TXk0d09EUXpNall5TERBZ1l5QXdMakUwTVRJMk5qY3NNQzR5TURreE1ESXpJREF1TWpFNE16VTVOQ3d3TGpRMk5UWXlNRFlnTUM0eU1UZ3pOVGswTERBdU56TTJPVFl5T1NBd0xEQXVOekl6TlRjNU15QXRNQzQxT0RZMU56Y3NNUzR6TVRBeE5UWXlJQzB4TGpNeE1ERTFOak1zTVM0ek1UQXhOVFl5SUMwd0xqSTNNVE0wTWpJc01DQXRNQzQxTWpjNE5qQTFMQzB3TGpBM056QTVNeUF0TUM0M016WTVOakk1TEMwd0xqSXhPRE0xT1RNZ01DNHlNemswTVRBMExEQXVNekV6TURnMU9TQXdMall4TWpZek5qTXNNQzQxTVRnMk1ETTFJREV1TURNM01qQTNNU3d3TGpVeE9EWXdNelVnTUM0M01qTTFOemt6TERBZ01TNHpNVEF4TlRZeUxDMHdMalU0TmpVM055QXhMak14TURFMU5qSXNMVEV1TXpFd01UVTJNeUF3TEMwd0xqUXlORFUzTURnZ0xUQXVNakExTlRFM05Td3RNQzQzT1RjM09UWTNJQzB3TGpVeE9EWXdNelVzTFRFdU1ETTNNakEzSUhvZ1RTQXlMakV3TVRjd09TdzJMak00TnpBeE1UY2dZeUF3TGpFME1USTJOamNzTUM0eU1Ea3hNREkwSURBdU1qRTRNelU1TkN3d0xqUTJOVFl5TURZZ01DNHlNVGd6TlRrMExEQXVOek0yT1RZeU9TQXdMREF1TnpJek5UYzVNeUF0TUM0MU9EWTFOemNzTVM0ek1UQXhOVFl6SUMweExqTXhNREUxTmpNc01TNHpNVEF4TlRZeklDMHdMakkzTVRNME1qSXpMREFnTFRBdU5USTNPRFl3TlRrc0xUQXVNRGMzTURreklDMHdMamN6TmprMk1qZzRMQzB3TGpJeE9ETTFPVFFnTUM0eU16azBNVEF6T1N3d0xqTXhNekE0TlRrZ01DNDJNVEkyTXpZeU1pd3dMalV4T0RZd016VWdNUzR3TXpjeU1EWTVPQ3d3TGpVeE9EWXdNelVnTUM0M01qTTFOemt6TERBZ01TNHpNVEF4TlRZekxDMHdMalU0TmpVM055QXhMak14TURFMU5qTXNMVEV1TXpFd01UVTJNeUF3TEMwd0xqUXlORFUzTURnZ0xUQXVNakExTlRFM05pd3RNQzQzT1RjM09UWTJJQzB3TGpVeE9EWXdNelVzTFRFdU1ETTNNakEzSUhvZ2JTQXpMakF5T1Rjek5qTXNNQ0JqSURBdU1UUXhNalkyTnl3d0xqSXdPVEV3TWpRZ01DNHlNVGd6TlRrMExEQXVORFkxTmpJd05pQXdMakl4T0RNMU9UUXNNQzQzTXpZNU5qSTVJREFzTUM0M01qTTFOemt6SUMwd0xqVTROalUzTnl3eExqTXhNREUxTmpNZ0xURXVNekV3TVRVMk15d3hMak14TURFMU5qTWdMVEF1TWpjeE16UXlNaXd3SUMwd0xqVXlOemcyTURVc0xUQXVNRGMzTURreklDMHdMamN6TmprMk1qa3NMVEF1TWpFNE16VTVOQ0F3TGpJek9UUXhNRFFzTUM0ek1UTXdPRFU1SURBdU5qRXlOak0yTXl3d0xqVXhPRFl3TXpVZ01TNHdNemN5TURjeExEQXVOVEU0TmpBek5TQXdMamN5TXpVM09UTXNNQ0F4TGpNeE1ERTFOaklzTFRBdU5UZzJOVGMzSURFdU16RXdNVFUyTWl3dE1TNHpNVEF4TlRZeklEQXNMVEF1TkRJME5UY3dPQ0F0TUM0eU1EVTFNVGMxTEMwd0xqYzVOemM1TmpZZ0xUQXVOVEU0TmpBek5Td3RNUzR3TXpjeU1EY2dlaUJ0SURNdU1EZzBNekkyTWl3d0lHTWdNQzR4TkRFeU5qWTNMREF1TWpBNU1UQXlOQ0F3TGpJeE9ETTFPVFFzTUM0ME5qVTJNakEySURBdU1qRTRNelU1TkN3d0xqY3pOamsyTWprZ01Dd3dMamN5TXpVM09UTWdMVEF1TlRnMk5UYzNMREV1TXpFd01UVTJNeUF0TVM0ek1UQXhOVFl6TERFdU16RXdNVFUyTXlBdE1DNHlOekV6TkRJekxEQWdMVEF1TlRJM09EWXdOU3d0TUM0d056Y3dPVE1nTFRBdU56TTJPVFl5T1N3dE1DNHlNVGd6TlRrMElEQXVNak01TkRFd05Dd3dMak14TXpBNE5Ua2dNQzQyTVRJMk16WXlMREF1TlRFNE5qQXpOU0F4TGpBek56SXdOeXd3TGpVeE9EWXdNelVnTUM0M01qTTFOemt6TERBZ01TNHpNVEF4TlRZekxDMHdMalU0TmpVM055QXhMak14TURFMU5qTXNMVEV1TXpFd01UVTJNeUF3TEMwd0xqUXlORFUzTURnZ0xUQXVNakExTlRFM05pd3RNQzQzT1RjM09UWTJJQzB3TGpVeE9EWXdNelVzTFRFdU1ETTNNakEzSUhvaUlDOCtJQ0E4TDJjK1BDOXpkbWMrKTtcXHJcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXHJcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMTAwJSAxMDAlO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYXV0byAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3MtaG9zdC1ydGwgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lci5vcy1zY3JvbGxiYXItY29ybmVyLXJlc2l6ZSB7XFxyXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7XFxyXFxuICAgIHRyYW5zZm9ybTogc2NhbGUoLTEsIDEpO1xcclxcbn1cXHJcXG4ub3MtaG9zdC1vdmVyZmxvdyB7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW4gIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLWhvc3Qtb3ZlcmZsb3cteCB7XFxyXFxufSBcXHJcXG4ub3MtaG9zdC1vdmVyZmxvdy15IHtcXHJcXG59IFxcclxcblxcclxcbi8qXFxyXFxuVEhFTUVTOlxcclxcbiovXFxyXFxuXFxyXFxuLyogTk9ORSBUSEVNRTogKi9cXHJcXG4ub3MtdGhlbWUtbm9uZSA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCxcXHJcXG4ub3MtdGhlbWUtbm9uZSA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwsXFxyXFxuLm9zLXRoZW1lLW5vbmUgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLW5vbmUgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUge1xcclxcbiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xcclxcbiAgICBtaW4td2lkdGg6IDEwcHg7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IDEwcHg7XFxyXFxufVxcclxcbi8qIERBUksgJiBMSUdIVCBUSEVNRTogKi9cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCxcXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwge1xcclxcbiAgICByaWdodDogMTBweDtcXHJcXG4gICAgaGVpZ2h0OiAxMHB4O1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCB7XFxyXFxuICAgIGJvdHRvbTogMTBweDtcXHJcXG4gICAgd2lkdGg6IDEwcHg7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrLm9zLWhvc3QtcnRsID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsLFxcclxcbi5vcy10aGVtZS1saWdodC5vcy1ob3N0LXJ0bCA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCB7XFxyXFxuICAgIGxlZnQ6IDEwcHg7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXItY29ybmVyLFxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXItY29ybmVyIHtcXHJcXG4gICAgaGVpZ2h0OiAxMHB4O1xcclxcbiAgICB3aWR0aDogMTBweDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lcixcXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXIsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhciB7XFxyXFxuICAgIHBhZGRpbmc6IDJweDtcXHJcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXIub3Mtc2Nyb2xsYmFyLXVudXNhYmxlLFxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXIub3Mtc2Nyb2xsYmFyLXVudXNhYmxlIHtcXHJcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2ssXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sge1xcclxcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsID4gLm9zLXNjcm9sbGJhci10cmFjayA+IC5vcy1zY3JvbGxiYXItaGFuZGxlIHtcXHJcXG4gICAgbWluLXdpZHRoOiAzMHB4O1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZSB7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IDMwcHg7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrLm9zLWhvc3QtdHJhbnNpdGlvbiA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0Lm9zLWhvc3QtdHJhbnNpdGlvbiA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUge1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4zcztcXHJcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzO1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZSxcXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrLFxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrIHtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyID4gLm9zLXNjcm9sbGJhci10cmFjayA+IC5vcy1zY3JvbGxiYXItaGFuZGxlIHtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjQpO1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyID4gLm9zLXNjcm9sbGJhci10cmFjayA+IC5vcy1zY3JvbGxiYXItaGFuZGxlIHtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpO1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXI6aG92ZXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC41NSk7XFxyXFxufVxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXI6aG92ZXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC41NSk7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZS5hY3RpdmUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC43KTtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZS5hY3RpdmUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC43KTtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgLm9zLXNjcm9sbGJhci1oYW5kbGU6YmVmb3JlLFxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCAub3Mtc2Nyb2xsYmFyLWhhbmRsZTpiZWZvcmUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSB7XFxyXFxuICAgIGNvbnRlbnQ6ICcnO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrLm9zLWhvc3Qtc2Nyb2xsYmFyLWhvcml6b250YWwtaGlkZGVuID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtZGFyay5vcy1ob3N0LXNjcm9sbGJhci12ZXJ0aWNhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtbGlnaHQub3MtaG9zdC1zY3JvbGxiYXItaG9yaXpvbnRhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgLm9zLXNjcm9sbGJhci1oYW5kbGU6YmVmb3JlLFxcclxcbi5vcy10aGVtZS1saWdodC5vcy1ob3N0LXNjcm9sbGJhci12ZXJ0aWNhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgLm9zLXNjcm9sbGJhci1oYW5kbGU6YmVmb3JlIHtcXHJcXG4gICAgdG9wOiAtNnB4O1xcclxcbiAgICBib3R0b206IC0ycHg7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCAub3Mtc2Nyb2xsYmFyLWhhbmRsZTpiZWZvcmUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCAub3Mtc2Nyb2xsYmFyLWhhbmRsZTpiZWZvcmUge1xcclxcbiAgICBsZWZ0OiAtNnB4O1xcclxcbiAgICByaWdodDogLTJweDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcnRsLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtaG9zdC1ydGwub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSB7XFxyXFxuICAgIHJpZ2h0OiAtNnB4O1xcclxcbiAgICBsZWZ0OiAtMnB4O1xcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vbm9kZV9tb2R1bGVzL292ZXJsYXlzY3JvbGxiYXJzL2Nzcy9PdmVybGF5U2Nyb2xsYmFycy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7Ozs7Ozs7Ozs7O0VBV0U7O0FBRUY7O0NBRUM7O0FBRUQ7O0lBRUksY0FBYztJQUNkLGdCQUFnQjtJQUNoQiw4QkFBc0I7WUFBdEIsc0JBQXNCO0lBQ3RCLHVCQUF1QjtJQUN2QixzQkFBc0I7SUFDdEIsMEJBQTBCO0lBQzFCLDJCQUEyQjtJQUMzQixvQkFBb0I7SUFDcEIsNkJBQTZCLEVBQUUsOEZBQThGO0FBQ2pJO0FBQ0E7SUFDSSxrQkFBa0IsRUFBRSw4RkFBOEY7QUFDdEg7QUFDQTs7SUFFSSxlQUFlO0FBQ25CO0FBQ0E7O0lBRUksa0JBQWtCO0lBQ2xCLDRCQUE0QjtJQUlwQixzQkFBc0I7SUFFMUIsaUJBQWlCO0lBR2IsMkJBQTJCO0lBRS9CLHlCQUF5QjtJQUM3Qix3QkFBd0I7UUFDcEIscUJBQXFCO2dCQUNiLDhCQUE4QjtZQUNsQyx1QkFBdUI7QUFDbkM7QUFDQTtJQUNJLDJCQUEyQjtJQUczQixhQUFhO0FBQ2pCO0FBQ0E7SUFDSSwwQkFBMEI7QUFDOUI7QUFDQTtJQUdZLFlBQVk7SUFFaEIsY0FBYztBQUN0QjtBQUNBOztJQUVJLGFBQWE7SUFDYixZQUFZO0lBR0osWUFBWTtJQUVoQixjQUFjO0lBRWQsZ0JBQWdCO0FBQ3hCO0FBQ0E7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LDZCQUE2QjtBQUNqQztBQUNBO0lBQ0ksbUNBQW1DO0FBQ3ZDO0FBQ0E7Ozs7SUFJSSxXQUFXO0lBQ1gsa0JBQWtCO0lBQ2xCLE9BQU87SUFDUCxRQUFRO0lBQ1IsTUFBTTtJQUNOLFNBQVM7SUFDVCxjQUFjO0FBQ2xCO0FBQ0E7Ozs7SUFJSSxhQUFhO0FBQ2pCO0FBQ0E7O0lBRUksU0FBUztJQUNULFlBQVk7QUFDaEI7QUFDQTs7SUFFSSxVQUFVO0lBQ1YsV0FBVztBQUNmO0FBQ0E7O0lBRUksV0FBVztJQUNYLFVBQVU7QUFDZFwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiFcXHJcXG4gKiBPdmVybGF5U2Nyb2xsYmFyc1xcclxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYS9PdmVybGF5U2Nyb2xsYmFyc1xcclxcbiAqXFxyXFxuICogVmVyc2lvbjogMS4xMy4wXFxyXFxuICpcXHJcXG4gKiBDb3B5cmlnaHQgS2luZ1NvcmEgfCBSZW5lIEhhYXMuXFxyXFxuICogaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhXFxyXFxuICpcXHJcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxyXFxuICogRGF0ZTogMDIuMDguMjAyMFxcclxcbiAqL1xcclxcblxcclxcbi8qXFxyXFxuT1ZFUkxBWSBTQ1JPTExCQVJTIENPUkU6XFxyXFxuKi9cXHJcXG5cXHJcXG5odG1sLm9zLWh0bWwsXFxyXFxuaHRtbC5vcy1odG1sID4gLm9zLWhvc3Qge1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIG1pbi13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xcclxcbiAgICBtaW4taGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIG1hcmdpbjogMCAhaW1wb3J0YW50O1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDsgLyogY291bGQgYmUgcG9zaXRpb246IGZpeGVkOyBidXQgaXQgY2F1c2VzIGlzc3VlcyBvbiBpT1MgKC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgKi9cXHJcXG59XFxyXFxuaHRtbC5vcy1odG1sID4gLm9zLWhvc3QgPiAub3MtcGFkZGluZyB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsgLyogY291bGQgYmUgcG9zaXRpb246IGZpeGVkOyBidXQgaXQgY2F1c2VzIGlzc3VlcyBvbiBpT1MgKC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgKi9cXHJcXG59XFxyXFxuYm9keS5vcy1kcmFnZ2luZyxcXHJcXG5ib2R5Lm9zLWRyYWdnaW5nICoge1xcclxcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxyXFxufVxcclxcbi5vcy1ob3N0LFxcclxcbi5vcy1ob3N0LXRleHRhcmVhIHtcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgICBvdmVyZmxvdzogdmlzaWJsZSAhaW1wb3J0YW50O1xcclxcbiAgICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcclxcbiAgICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXHJcXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIC1tcy1mbGV4LXdyYXA6IG5vd3JhcDtcXHJcXG4gICAgICAgIGZsZXgtd3JhcDogbm93cmFwO1xcclxcbiAgICAtd2Via2l0LWJveC1wYWNrOiBzdGFydDtcXHJcXG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IHN0YXJ0O1xcclxcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXHJcXG4gICAgLW1zLWZsZXgtbGluZS1wYWNrOiBzdGFydDtcXHJcXG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxuICAgIC13ZWJraXQtYm94LWFsaWduOiBzdGFydDtcXHJcXG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBzdGFydDtcXHJcXG4gICAgICAgICAgICAgICAgLW1zLWdyaWQtcm93LWFsaWduOiBmbGV4LXN0YXJ0O1xcclxcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbn1cXHJcXG4ub3MtaG9zdC1mbGV4Ym94IHtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xcclxcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXHJcXG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxufVxcclxcbi5vcy1ob3N0LWZsZXhib3ggPiAub3Mtc2l6ZS1hdXRvLW9ic2VydmVyIHtcXHJcXG4gICAgaGVpZ2h0OiBpbmhlcml0ICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1ob3N0LWZsZXhib3ggPiAub3MtY29udGVudC1nbHVlIHtcXHJcXG4gICAgLXdlYmtpdC1ib3gtZmxleDogMTtcXHJcXG4gICAgICAgIC1tcy1mbGV4LXBvc2l0aXZlOiAxO1xcclxcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcXHJcXG4gICAgLW1zLWZsZXgtbmVnYXRpdmU6IDA7XFxyXFxuICAgICAgICBmbGV4LXNocmluazogMDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtZmxleGJveCA+IC5vcy1zaXplLWF1dG8tb2JzZXJ2ZXIsXFxyXFxuLm9zLWhvc3QtZmxleGJveCA+IC5vcy1jb250ZW50LWdsdWUge1xcclxcbiAgICBtaW4taGVpZ2h0OiAwO1xcclxcbiAgICBtaW4td2lkdGg6IDA7XFxyXFxuICAgIC13ZWJraXQtYm94LWZsZXg6IDA7XFxyXFxuICAgICAgICAtbXMtZmxleC1wb3NpdGl2ZTogMDtcXHJcXG4gICAgICAgICAgICBmbGV4LWdyb3c6IDA7XFxyXFxuICAgIC1tcy1mbGV4LW5lZ2F0aXZlOiAxO1xcclxcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XFxyXFxuICAgIC1tcy1mbGV4LXByZWZlcnJlZC1zaXplOiBhdXRvO1xcclxcbiAgICAgICAgZmxleC1iYXNpczogYXV0bztcXHJcXG59XFxyXFxuI29zLWR1bW15LXNjcm9sbGJhci1zaXplIHtcXHJcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICAtbXMtZmlsdGVyOiAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9MCknO1xcclxcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuICAgIG92ZXJmbG93OiBzY3JvbGw7XFxyXFxuICAgIGhlaWdodDogNTAwcHg7XFxyXFxuICAgIHdpZHRoOiA1MDBweDtcXHJcXG59XFxyXFxuI29zLWR1bW15LXNjcm9sbGJhci1zaXplID4gZGl2IHtcXHJcXG4gICAgd2lkdGg6IDIwMCU7XFxyXFxuICAgIGhlaWdodDogMjAwJTsgXFxyXFxuICAgIG1hcmdpbjogMTBweCAwO1xcclxcbn1cXHJcXG4vKiBmaXggcmVzdHJpY3RlZCBtZWFzdXJpbmcgKi9cXHJcXG4jb3MtZHVtbXktc2Nyb2xsYmFyLXNpemU6YmVmb3JlLFxcclxcbiNvcy1kdW1teS1zY3JvbGxiYXItc2l6ZTphZnRlcixcXHJcXG4ub3MtY29udGVudDpiZWZvcmUsXFxyXFxuLm9zLWNvbnRlbnQ6YWZ0ZXIge1xcclxcbiAgICBjb250ZW50OiAnJztcXHJcXG4gICAgZGlzcGxheTogdGFibGU7XFxyXFxuICAgIHdpZHRoOiAwLjAxcHg7XFxyXFxuICAgIGhlaWdodDogMC4wMXB4O1xcclxcbiAgICBsaW5lLWhlaWdodDogMDtcXHJcXG4gICAgZm9udC1zaXplOiAwO1xcclxcbiAgICBmbGV4LWdyb3c6IDA7XFxyXFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcclxcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxufVxcclxcbiNvcy1kdW1teS1zY3JvbGxiYXItc2l6ZSxcXHJcXG4ub3Mtdmlld3BvcnQge1xcclxcbiAgICAtbXMtb3ZlcmZsb3ctc3R5bGU6IHNjcm9sbGJhciAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3Mtdmlld3BvcnQtbmF0aXZlLXNjcm9sbGJhcnMtaW52aXNpYmxlI29zLWR1bW15LXNjcm9sbGJhci1zaXplLFxcclxcbi5vcy12aWV3cG9ydC1uYXRpdmUtc2Nyb2xsYmFycy1pbnZpc2libGUub3Mtdmlld3BvcnQge1xcclxcbiAgICBzY3JvbGxiYXItd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLXZpZXdwb3J0LW5hdGl2ZS1zY3JvbGxiYXJzLWludmlzaWJsZSNvcy1kdW1teS1zY3JvbGxiYXItc2l6ZTo6LXdlYmtpdC1zY3JvbGxiYXIsXFxyXFxuLm9zLXZpZXdwb3J0LW5hdGl2ZS1zY3JvbGxiYXJzLWludmlzaWJsZS5vcy12aWV3cG9ydDo6LXdlYmtpdC1zY3JvbGxiYXIsXFxyXFxuLm9zLXZpZXdwb3J0LW5hdGl2ZS1zY3JvbGxiYXJzLWludmlzaWJsZSNvcy1kdW1teS1zY3JvbGxiYXItc2l6ZTo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVyLFxcclxcbi5vcy12aWV3cG9ydC1uYXRpdmUtc2Nyb2xsYmFycy1pbnZpc2libGUub3Mtdmlld3BvcnQ6Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgd2lkdGg6IDBweCAhaW1wb3J0YW50O1xcclxcbiAgICBoZWlnaHQ6IDBweCAhaW1wb3J0YW50O1xcclxcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDtcXHJcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLWNvbnRlbnQtZ2x1ZSB7XFxyXFxuICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XFxyXFxuICAgIG1heC1oZWlnaHQ6IDEwMCU7XFxyXFxuICAgIG1heC13aWR0aDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4ub3MtcGFkZGluZyB7XFxyXFxuICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XFxyXFxuICAgIGRpcmVjdGlvbjogaW5oZXJpdDtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxuICAgIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxyXFxuICAgIGhlaWdodDogYXV0byAhaW1wb3J0YW50O1xcclxcblxcdHotaW5kZXg6IDA7XFxyXFxufVxcclxcbi5vcy1ob3N0LW92ZXJmbG93ID4gLm9zLXBhZGRpbmcge1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbn1cXHJcXG4ub3Mtdmlld3BvcnQge1xcclxcbiAgICBkaXJlY3Rpb246IGluaGVyaXQgIWltcG9ydGFudDtcXHJcXG4gICAgYm94LXNpemluZzogaW5oZXJpdCAhaW1wb3J0YW50O1xcclxcbiAgICByZXNpemU6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgb3V0bGluZTogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIHRvcDogMDtcXHJcXG4gICAgbGVmdDogMDtcXHJcXG4gICAgYm90dG9tOiAwO1xcclxcbiAgICByaWdodDogMDtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxyXFxufVxcclxcbi5vcy1jb250ZW50LWFycmFuZ2Uge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHotaW5kZXg6IC0xO1xcclxcbiAgICBtaW4taGVpZ2h0OiAxcHg7XFxyXFxuICAgIG1pbi13aWR0aDogMXB4O1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuLm9zLWNvbnRlbnQge1xcclxcbiAgICBkaXJlY3Rpb246IGluaGVyaXQ7XFxyXFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDtcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXHJcXG59XFxyXFxuLm9zLWNvbnRlbnQgPiAub3MtdGV4dGFyZWEge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94ICFpbXBvcnRhbnQ7XFxyXFxuICAgIGRpcmVjdGlvbjogaW5oZXJpdCAhaW1wb3J0YW50O1xcclxcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcclxcbiAgICBvdXRsaW5lOiAwcHggbm9uZSB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50O1xcclxcbiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xcclxcbiAgICB0b3A6IDAgIWltcG9ydGFudDtcXHJcXG4gICAgbGVmdDogMCAhaW1wb3J0YW50O1xcclxcbiAgICBtYXJnaW46IDAgIWltcG9ydGFudDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMHB4ICFpbXBvcnRhbnQ7XFxyXFxuICAgIGZsb2F0OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIC13ZWJraXQtZmlsdGVyOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgICAgICAgICAgZmlsdGVyOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICByZXNpemU6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgbWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIG1heC1oZWlnaHQ6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgYm94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICAtd2Via2l0LXBlcnNwZWN0aXZlOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgICAgICAgICAgcGVyc3BlY3RpdmU6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xcclxcbiAgICB6LWluZGV4OiAxICFpbXBvcnRhbnQ7XFxyXFxuICAgIGNsaXA6IGF1dG8gIWltcG9ydGFudDtcXHJcXG4gICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lICFpbXBvcnRhbnQ7XFxyXFxuICAgIHBhZGRpbmc6IDBweDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcnRsID4gLm9zLXBhZGRpbmcgPiAub3Mtdmlld3BvcnQgPiAub3MtY29udGVudCA+IC5vcy10ZXh0YXJlYSB7XFxyXFxuICAgIHJpZ2h0OiAwICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1jb250ZW50ID4gLm9zLXRleHRhcmVhLWNvdmVyIHtcXHJcXG4gICAgei1pbmRleDogLTE7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4ub3MtY29udGVudCA+IC5vcy10ZXh0YXJlYVt3cmFwPSdvZmYnXSB7XFxyXFxuICAgIHdoaXRlLXNwYWNlOiBwcmUgIWltcG9ydGFudDtcXHJcXG4gICAgbWFyZ2luOiAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLXRleHQtaW5oZXJpdCB7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcclxcbiAgICBmb250LXNpemU6IGluaGVyaXQ7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcclxcbiAgICBmb250LXN0eWxlOiBpbmhlcml0O1xcclxcbiAgICBmb250LXZhcmlhbnQ6IGluaGVyaXQ7XFxyXFxuICAgIHRleHQtdHJhbnNmb3JtOiBpbmhlcml0O1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XFxyXFxuICAgIHRleHQtaW5kZW50OiBpbmhlcml0O1xcclxcbiAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcclxcbiAgICB0ZXh0LXNoYWRvdzogaW5oZXJpdDtcXHJcXG4gICAgdGV4dC1vdmVyZmxvdzogaW5oZXJpdDtcXHJcXG4gICAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7XFxyXFxuICAgIHdvcmQtc3BhY2luZzogaW5oZXJpdDtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxyXFxuICAgIHVuaWNvZGUtYmlkaTogaW5oZXJpdDtcXHJcXG4gICAgZGlyZWN0aW9uOiBpbmhlcml0O1xcclxcbiAgICBjb2xvcjogaW5oZXJpdDtcXHJcXG4gICAgY3Vyc29yOiB0ZXh0O1xcclxcbn1cXHJcXG4ub3MtcmVzaXplLW9ic2VydmVyLFxcclxcbi5vcy1yZXNpemUtb2JzZXJ2ZXItaG9zdCB7XFxyXFxuICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gICAgei1pbmRleDogLTE7XFxyXFxufVxcclxcbi5vcy1yZXNpemUtb2JzZXJ2ZXItaG9zdCB7XFxyXFxuICAgIHBhZGRpbmc6IGluaGVyaXQ7XFxyXFxuICAgIGJvcmRlcjogaW5oZXJpdDtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXHJcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0Lm9ic2VydmVkIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0ID4gLm9zLXJlc2l6ZS1vYnNlcnZlcixcXHJcXG4ub3MtcmVzaXplLW9ic2VydmVyLWhvc3Qub2JzZXJ2ZWQgPiAub3MtcmVzaXplLW9ic2VydmVyIHtcXHJcXG4gICAgaGVpZ2h0OiAyMDAlO1xcclxcbiAgICB3aWR0aDogMjAwJTtcXHJcXG4gICAgcGFkZGluZzogaW5oZXJpdDtcXHJcXG4gICAgYm9yZGVyOiBpbmhlcml0O1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0Lm9ic2VydmVkID4gLm9zLXJlc2l6ZS1vYnNlcnZlcixcXHJcXG4ub3MtcmVzaXplLW9ic2VydmVyLWhvc3Qub2JzZXJ2ZWQgPiAub3MtcmVzaXplLW9ic2VydmVyOmJlZm9yZSB7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgZmxleC1ncm93OiAxO1xcclxcbiAgICBmbGV4LXNocmluazogMDtcXHJcXG4gICAgZmxleC1iYXNpczogYXV0bztcXHJcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0Lm9ic2VydmVkID4gLm9zLXJlc2l6ZS1vYnNlcnZlcjpiZWZvcmUge1xcclxcbiAgICBjb250ZW50OiAnJztcXHJcXG4gICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxyXFxuICAgIHBhZGRpbmc6IGluaGVyaXQ7XFxyXFxuICAgIGJvcmRlcjogaW5oZXJpdDtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbn1cXHJcXG4ub3Mtc2l6ZS1hdXRvLW9ic2VydmVyIHtcXHJcXG4gICAgYm94LXNpemluZzogaW5oZXJpdCAhaW1wb3J0YW50O1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiBpbmhlcml0O1xcclxcbiAgICBtYXgtd2lkdGg6IDFweDtcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgbWF4LWhlaWdodDogMXB4O1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgICB6LWluZGV4OiAtMTtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gICAgLXdlYmtpdC1ib3gtZmxleDogaW5oZXJpdDtcXHJcXG4gICAgICAgIC1tcy1mbGV4LXBvc2l0aXZlOiBpbmhlcml0O1xcclxcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogaW5oZXJpdDtcXHJcXG4gICAgLW1zLWZsZXgtbmVnYXRpdmU6IDA7XFxyXFxuICAgICAgICBmbGV4LXNocmluazogMDtcXHJcXG4gICAgLW1zLWZsZXgtcHJlZmVycmVkLXNpemU6IDA7XFxyXFxuICAgICAgICBmbGV4LWJhc2lzOiAwO1xcclxcbn1cXHJcXG4ub3Mtc2l6ZS1hdXRvLW9ic2VydmVyID4gLm9zLXJlc2l6ZS1vYnNlcnZlciB7XFxyXFxuICAgIHdpZHRoOiAxMDAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAwJTtcXHJcXG4gICAgbWluLWhlaWdodDogMXB4O1xcclxcbiAgICBtaW4td2lkdGg6IDFweDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1pdGVtIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIHotaW5kZXg6IC0xO1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICBkaXJlY3Rpb246IGx0ciAhaW1wb3J0YW50O1xcclxcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwICFpbXBvcnRhbnQ7XFxyXFxuICAgIC1tcy1mbGV4OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIGZsZXg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLXJlc2l6ZS1vYnNlcnZlci1pdGVtLWZpbmFsIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xcclxcbiAgICB0cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuICAgIC13ZWJraXQtYm94LWZsZXg6IDAgIWltcG9ydGFudDtcXHJcXG4gICAgLW1zLWZsZXg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG4gICAgZmxleDogbm9uZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3MtcmVzaXplLW9ic2VydmVyIHtcXHJcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246IDAuMDAxcztcXHJcXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjAwMXM7XFxyXFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IG9zLXJlc2l6ZS1vYnNlcnZlci1kdW1teS1hbmltYXRpb247XFxyXFxuICAgIGFuaW1hdGlvbi1uYW1lOiBvcy1yZXNpemUtb2JzZXJ2ZXItZHVtbXktYW5pbWF0aW9uO1xcclxcbn1cXHJcXG5vYmplY3Qub3MtcmVzaXplLW9ic2VydmVyIHtcXHJcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgb3MtcmVzaXplLW9ic2VydmVyLWR1bW15LWFuaW1hdGlvbiB7XFxyXFxuICAgIGZyb20ge1xcclxcbiAgICAgICAgei1pbmRleDogMDtcXHJcXG4gICAgfVxcclxcbiAgICB0byB7XFxyXFxuICAgICAgICB6LWluZGV4OiAtMTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5Aa2V5ZnJhbWVzIG9zLXJlc2l6ZS1vYnNlcnZlci1kdW1teS1hbmltYXRpb24ge1xcclxcbiAgICBmcm9tIHtcXHJcXG4gICAgICAgIHotaW5kZXg6IDA7XFxyXFxuICAgIH1cXHJcXG4gICAgdG8ge1xcclxcbiAgICAgICAgei1pbmRleDogLTE7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5DVVNUT00gU0NST0xMQkFSUyBBTkQgQ09STkVSIENPUkU6XFxyXFxuKi9cXHJcXG5cXHJcXG4ub3MtaG9zdC10cmFuc2l0aW9uID4gLm9zLXNjcm9sbGJhcixcXHJcXG4ub3MtaG9zdC10cmFuc2l0aW9uID4gLm9zLXNjcm9sbGJhci1jb3JuZXIge1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcywgdmlzaWJpbGl0eSAwLjNzLCB0b3AgMC4zcywgcmlnaHQgMC4zcywgYm90dG9tIDAuM3MsIGxlZnQgMC4zcztcXHJcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzLCB2aXNpYmlsaXR5IDAuM3MsIHRvcCAwLjNzLCByaWdodCAwLjNzLCBib3R0b20gMC4zcywgbGVmdCAwLjNzO1xcclxcbn1cXHJcXG5odG1sLm9zLWh0bWwgPiAub3MtaG9zdCA+IC5vcy1zY3JvbGxiYXIge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7IC8qIGNvdWxkIGJlIHBvc2l0aW9uOiBmaXhlZDsgYnV0IGl0IGNhdXNlcyBpc3N1ZXMgb24gaU9TICgtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2gpICovXFxyXFxuICAgIHotaW5kZXg6IDk5OTk5OTsgLyogaGlnaGVzdCB6LWluZGV4IG9mIHRoZSBwYWdlICovXFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXIsXFxyXFxuLm9zLXNjcm9sbGJhci1jb3JuZXIge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIC1tcy1maWx0ZXI6ICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0xMDApJztcXHJcXG4gICAgei1pbmRleDogMTtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci1jb3JuZXIge1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItdHJhY2sge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XFxyXFxuICAgIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyLWhhbmRsZSB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItaGFuZGxlLW9mZixcXHJcXG4ub3Mtc2Nyb2xsYmFyLXRyYWNrLW9mZiB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyLm9zLXNjcm9sbGJhci11bnVzYWJsZSxcXHJcXG4ub3Mtc2Nyb2xsYmFyLm9zLXNjcm9sbGJhci11bnVzYWJsZSAqIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci5vcy1zY3JvbGxiYXItdW51c2FibGUgLm9zLXNjcm9sbGJhci1oYW5kbGUge1xcclxcbiAgICBvcGFjaXR5OiAwICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCB7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgbGVmdDogMDtcXHJcXG59XFxyXFxuLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCB7XFxyXFxuICAgIHRvcDogMDtcXHJcXG4gICAgcmlnaHQ6IDA7XFxyXFxufVxcclxcbi5vcy1ob3N0LXJ0bCA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCB7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbn1cXHJcXG4ub3MtaG9zdC1ydGwgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIHtcXHJcXG4gICAgcmlnaHQ6IGF1dG87XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxufVxcclxcbi5vcy1ob3N0LXJ0bCA+IC5vcy1zY3JvbGxiYXItY29ybmVyIHtcXHJcXG4gICAgcmlnaHQ6IGF1dG87XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItYXV0by1oaWRkZW4sXFxyXFxuLm9zLXBhZGRpbmcgKyAub3Mtc2Nyb2xsYmFyLWNvcm5lcixcXHJcXG4ub3MtaG9zdC1yZXNpemUtZGlzYWJsZWQub3MtaG9zdC1zY3JvbGxiYXItaG9yaXpvbnRhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLWNvcm5lcixcXHJcXG4ub3MtaG9zdC1zY3JvbGxiYXItaG9yaXpvbnRhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwsXFxyXFxuLm9zLWhvc3QtcmVzaXplLWRpc2FibGVkLm9zLWhvc3Qtc2Nyb2xsYmFyLXZlcnRpY2FsLWhpZGRlbiA+IC5vcy1zY3JvbGxiYXItY29ybmVyLFxcclxcbi5vcy1ob3N0LXNjcm9sbGJhci12ZXJ0aWNhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsLFxcclxcbi5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbC5vcy1zY3JvbGxiYXItYXV0by1oaWRkZW4gKyAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsICsgLm9zLXNjcm9sbGJhci1jb3JuZXIsXFxyXFxuLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsICsgLm9zLXNjcm9sbGJhci12ZXJ0aWNhbC5vcy1zY3JvbGxiYXItYXV0by1oaWRkZW4gKyAub3Mtc2Nyb2xsYmFyLWNvcm5lcixcXHJcXG4ub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwub3Mtc2Nyb2xsYmFyLWF1dG8taGlkZGVuICsgLm9zLXNjcm9sbGJhci12ZXJ0aWNhbC5vcy1zY3JvbGxiYXItYXV0by1oaWRkZW4gKyAub3Mtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItY29ybmVyLXJlc2l6ZS1ib3RoIHtcXHJcXG4gICAgY3Vyc29yOiBud3NlLXJlc2l6ZTtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcnRsID4gLm9zLXNjcm9sbGJhci1jb3JuZXItcmVzaXplLWJvdGgge1xcclxcbiAgICBjdXJzb3I6IG5lc3ctcmVzaXplO1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUtaG9yaXpvbnRhbCB7XFxyXFxuICAgIGN1cnNvcjogZXctcmVzaXplO1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUtdmVydGljYWwge1xcclxcbiAgICBjdXJzb3I6IG5zLXJlc2l6ZTtcXHJcXG59XFxyXFxuLm9zLWRyYWdnaW5nIC5vcy1zY3JvbGxiYXItY29ybmVyLm9zLXNjcm9sbGJhci1jb3JuZXItcmVzaXplIHtcXHJcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcclxcbn1cXHJcXG4ub3MtaG9zdC1yZXNpemUtZGlzYWJsZWQub3MtaG9zdC1zY3JvbGxiYXItaG9yaXpvbnRhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIHtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxufVxcclxcbi5vcy1ob3N0LXJlc2l6ZS1kaXNhYmxlZC5vcy1ob3N0LXNjcm9sbGJhci12ZXJ0aWNhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwsXFxyXFxuLm9zLWhvc3QtcnRsLm9zLWhvc3QtcmVzaXplLWRpc2FibGVkLm9zLWhvc3Qtc2Nyb2xsYmFyLXZlcnRpY2FsLWhpZGRlbiA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCB7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbn1cXHJcXG4ub3Mtc2Nyb2xsYmFyOmhvdmVyLFxcclxcbi5vcy1zY3JvbGxiYXItY29ybmVyLm9zLXNjcm9sbGJhci1jb3JuZXItcmVzaXplIHtcXHJcXG4gICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xcclxcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1zY3JvbGxiYXItY29ybmVyLm9zLXNjcm9sbGJhci1jb3JuZXItcmVzaXplIHtcXHJcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrUEhOMlp5QWdJSGh0Ykc1ek9tUmpQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012Wld4bGJXVnVkSE12TVM0eEx5SWdJQ0I0Yld4dWN6cGpZejBpYUhSMGNEb3ZMMk55WldGMGFYWmxZMjl0Ylc5dWN5NXZjbWN2Ym5NaklpQWdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUlnSUNCNGJXeHVjenB6ZG1jOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklpQWdJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdJQ0IzYVdSMGFEMGlNVEFpSUNBZ2FHVnBaMmgwUFNJeE1DSWdJQ0IyWlhKemFXOXVQU0l4TGpFaVBpQWdQR2NnSUNBZ0lIUnlZVzV6Wm05eWJUMGlkSEpoYm5Oc1lYUmxLREFzTFRFd05ESXVNell5TWlraUlDQWdJQ0J6ZEhsc1pUMGlaR2x6Y0d4aGVUcHBibXhwYm1VaVBpQWdJQ0E4Y0dGMGFDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pNREF3TURBd08yWnBiR3d0YjNCaFkybDBlVG93TGpRNU5ERXhOelkxTzJacGJHd3RjblZzWlRwbGRtVnViMlJrTzNOMGNtOXJaVHB1YjI1bElpQWdJQ0FnSUNCa1BTSnRJRGN1TkRJME1qRTROeXd4TURReUxqTTJNaklnWXlBdE1DNDNNak0xTnpreUxEQWdMVEV1TXpFd01UVTJNaXd3TGpVNE5qWWdMVEV1TXpFd01UVTJNaXd4TGpNeE1ESWdNQ3d3TGpJNU9TQXdMakV3TkRNME1Ua3NNQzQxTnpFZ01DNHlOekk1TkRreUxEQXVOemt4TlNBd0xqSXdPVEV3TWpRc01DNHhOREV6SURBdU5EWTFOakl3Tml3d0xqSXhPRFFnTUM0M016WTVOakk1TERBdU1qRTROQ0F3TGpjeU16VTNPVE1zTUNBeExqTXhNREUxTmpNc0xUQXVOVGcyTmlBeExqTXhNREUxTmpNc0xURXVNekV3TWlBd0xDMHdMakkzTVRNZ0xUQXVNRGMzTURrekxDMHdMalV5TnpnZ0xUQXVNakU0TXpVNU5Dd3RNQzQzTXpjZ0xUQXVNakl3TkRrME1Td3RNQzR4TmpnMklDMHdMalE1TWpVME5ETXNMVEF1TWpjeU9TQXRNQzQzT1RFMU5USTRMQzB3TGpJM01qa2dlaUJ0SURBc015NHdPRFF6SUdNZ0xUQXVOekl6TlRjNU1pd3dJQzB4TGpNeE1ERTFOaklzTUM0MU9EWTJJQzB4TGpNeE1ERTFOaklzTVM0ek1UQXlJREFzTUM0eU9Ua2dNQzR4TURRek5ERTVMREF1TlRjeElEQXVNamN5T1RRNU1pd3dMamM1TVRVZ01DNHlNRGt4TURJMExEQXVNVFF4TXlBd0xqUTJOVFl5TURZc01DNHlNVGcwSURBdU56TTJPVFl5T1N3d0xqSXhPRFFnTUM0M01qTTFOemt6TERBZ01TNHpNVEF4TlRZekxDMHdMalU0TmpZZ01TNHpNVEF4TlRZekxDMHhMak14TURJZ01Dd3RNQzR5TnpFeklDMHdMakEzTnpBNU15d3RNQzQxTWpjNElDMHdMakl4T0RNMU9UUXNMVEF1TnpNMk9TQXRNQzR5TWpBME9UUXhMQzB3TGpFMk9EWWdMVEF1TkRreU5UUTBNeXd0TUM0eU56TWdMVEF1TnpreE5UVXlPQ3d0TUM0eU56TWdlaUJ0SUMwekxqQTRORE15TmpFc01DQmpJQzB3TGpjeU16VTNPVE1zTUNBdE1TNHpNVEF4TlRZekxEQXVOVGcyTmlBdE1TNHpNVEF4TlRZekxERXVNekV3TWlBd0xEQXVNams1SURBdU1UQTBNelF4T1N3d0xqVTNNU0F3TGpJM01qazBPVElzTUM0M09URTFJREF1TWpBNU1UQXlOQ3d3TGpFME1UTWdNQzQwTmpVMk1qQTNMREF1TWpFNE5DQXdMamN6TmprMk1qa3NNQzR5TVRnMElEQXVOekl6TlRjNU15d3dJREV1TXpFd01UVTJNeXd0TUM0MU9EWTJJREV1TXpFd01UVTJNeXd0TVM0ek1UQXlJREFzTFRBdU1qY3hNeUF0TUM0d056Y3dPVE1zTFRBdU5USTNPQ0F0TUM0eU1UZ3pOVGswTEMwd0xqY3pOamtnTFRBdU1qSXdORGswTEMwd0xqRTJPRFlnTFRBdU5Ea3lOVFEwTWl3dE1DNHlOek1nTFRBdU56a3hOVFV5Tnl3dE1DNHlOek1nZWlCdElDMHpMakF5T1Rjek5qUXNNeTR3TWprNElFTWdNQzQxT0RZMU56WTVNeXd4TURRNExqUTNOak1nTUN3eE1EUTVMakEyTWpnZ01Dd3hNRFE1TGpjNE5qUWdZeUF3TERBdU1qazVJREF1TVRBME16UXhPU3d3TGpVM01URWdNQzR5TnpJNU5Ea3lNaXd3TGpjNU1UWWdNQzR5TURreE1ESXlPU3d3TGpFME1USWdNQzQwTmpVMk1qQTJOU3d3TGpJeE9ETWdNQzQzTXpZNU5qSTRPQ3d3TGpJeE9ETWdNQzQzTWpNMU56a3pMREFnTVM0ek1UQXhOVFl6TEMwd0xqVTROalVnTVM0ek1UQXhOVFl6TEMweExqTXhNREVnTUN3dE1DNHlOekUwSUMwd0xqQTNOekE1TXl3dE1DNDFNamM1SUMwd0xqSXhPRE0xT1RRc0xUQXVOek0zSUMwd0xqSXlNRFE1TkRFc0xUQXVNVFk0TmlBdE1DNDBPVEkxTkRRekxDMHdMakkzTWprZ0xUQXVOemt4TlRVeU9Dd3RNQzR5TnpJNUlIb2diU0F6TGpBeU9UY3pOalFzTUNCaklDMHdMamN5TXpVM09UTXNNQ0F0TVM0ek1UQXhOVFl6TERBdU5UZzJOU0F0TVM0ek1UQXhOVFl6TERFdU16RXdNU0F3TERBdU1qazVJREF1TVRBME16UXhPU3d3TGpVM01URWdNQzR5TnpJNU5Ea3lMREF1TnpreE5pQXdMakl3T1RFd01qUXNNQzR4TkRFeUlEQXVORFkxTmpJd055d3dMakl4T0RNZ01DNDNNelk1TmpJNUxEQXVNakU0TXlBd0xqY3lNelUzT1RNc01DQXhMak14TURFMU5qTXNMVEF1TlRnMk5TQXhMak14TURFMU5qTXNMVEV1TXpFd01TQXdMQzB3TGpJM01UUWdMVEF1TURjM01Ea3pMQzB3TGpVeU56a2dMVEF1TWpFNE16VTVOQ3d0TUM0M016Y2dMVEF1TWpJd05EazBMQzB3TGpFMk9EWWdMVEF1TkRreU5UUTBNaXd0TUM0eU56STVJQzB3TGpjNU1UVTFNamNzTFRBdU1qY3lPU0I2SUcwZ015NHdPRFF6TWpZeExEQWdZeUF0TUM0M01qTTFOemt5TERBZ0xURXVNekV3TVRVMk1pd3dMalU0TmpVZ0xURXVNekV3TVRVMk1pd3hMak14TURFZ01Dd3dMakk1T1NBd0xqRXdORE0wTVRrc01DNDFOekV4SURBdU1qY3lPVFE1TWl3d0xqYzVNVFlnTUM0eU1Ea3hNREkwTERBdU1UUXhNaUF3TGpRMk5UWXlNRFlzTUM0eU1UZ3pJREF1TnpNMk9UWXlPU3d3TGpJeE9ETWdNQzQzTWpNMU56a3pMREFnTVM0ek1UQXhOVFl6TEMwd0xqVTROalVnTVM0ek1UQXhOVFl6TEMweExqTXhNREVnTUN3dE1DNHlOekUwSUMwd0xqQTNOekE1TXl3dE1DNDFNamM1SUMwd0xqSXhPRE0xT1RRc0xUQXVOek0zSUMwd0xqSXlNRFE1TkRFc0xUQXVNVFk0TmlBdE1DNDBPVEkxTkRRekxDMHdMakkzTWprZ0xUQXVOemt4TlRVeU9Dd3RNQzR5TnpJNUlIb2lMejRnSUR3dlp6NGdJRHhuSUNBZ0lDQnpkSGxzWlQwaVpHbHpjR3hoZVRwcGJteHBibVVpUGlBZ0lDQThjR0YwYUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvalptWm1abVptTzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHBsZG1WdWIyUmtPM04wY205clpUcHViMjVsSWlBZ0lDQWdJQ0JrUFNKdElEZ3VNakUxTnpjeE5Td3dMakkzTWprME9USXlJR01nTUM0eE5ERXlOalkzTERBdU1qQTVNVEF5TWprZ01DNHlNVGd6TlRrMExEQXVORFkxTmpJd05qVWdNQzR5TVRnek5UazBMREF1TnpNMk9UWXlPRGdnTUN3d0xqY3lNelUzT1RNZ0xUQXVOVGcyTlRjM0xERXVNekV3TVRVMk15QXRNUzR6TVRBeE5UWXpMREV1TXpFd01UVTJNeUF0TUM0eU56RXpOREl6TERBZ0xUQXVOVEkzT0RZd05Td3RNQzR3Tnpjd09UTWdMVEF1TnpNMk9UWXlPU3d0TUM0eU1UZ3pOVGswSURBdU1qTTVOREV3TkN3d0xqTXhNekE0TlRrZ01DNDJNVEkyTXpZeUxEQXVOVEU0TmpBek5TQXhMakF6TnpJd055d3dMalV4T0RZd016VWdNQzQzTWpNMU56a3pMREFnTVM0ek1UQXhOVFl6TEMwd0xqVTROalUzTnlBeExqTXhNREUxTmpNc0xURXVNekV3TVRVMk15QXdMQzB3TGpReU5EVTNNRGMySUMwd0xqSXdOVFV4TnpZc0xUQXVOemszTnprMk5Ua2dMVEF1TlRFNE5qQXpOU3d0TVM0d016Y3lNRFk1T0NCNklHMGdNQ3d6TGpBNE5ETXlOakU0SUdNZ01DNHhOREV5TmpZM0xEQXVNakE1TVRBeU15QXdMakl4T0RNMU9UUXNNQzQwTmpVMk1qQTJJREF1TWpFNE16VTVOQ3d3TGpjek5qazJNamtnTUN3d0xqY3lNelUzT1RNZ0xUQXVOVGcyTlRjM0xERXVNekV3TVRVMk1pQXRNUzR6TVRBeE5UWXpMREV1TXpFd01UVTJNaUF0TUM0eU56RXpOREl6TERBZ0xUQXVOVEkzT0RZd05Td3RNQzR3Tnpjd09UTWdMVEF1TnpNMk9UWXlPU3d0TUM0eU1UZ3pOVGt6SURBdU1qTTVOREV3TkN3d0xqTXhNekE0TlRrZ01DNDJNVEkyTXpZeUxEQXVOVEU0TmpBek5TQXhMakF6TnpJd055d3dMalV4T0RZd016VWdNQzQzTWpNMU56a3pMREFnTVM0ek1UQXhOVFl6TEMwd0xqVTROalUzTnlBeExqTXhNREUxTmpNc0xURXVNekV3TVRVMk15QXdMQzB3TGpReU5EVTNNRGdnTFRBdU1qQTFOVEUzTml3dE1DNDNPVGMzT1RZM0lDMHdMalV4T0RZd016VXNMVEV1TURNM01qQTNJSG9nYlNBdE15NHdPRFF6TWpZeUxEQWdZeUF3TGpFME1USTJOamNzTUM0eU1Ea3hNREl6SURBdU1qRTRNelU1TkN3d0xqUTJOVFl5TURZZ01DNHlNVGd6TlRrMExEQXVOek0yT1RZeU9TQXdMREF1TnpJek5UYzVNeUF0TUM0MU9EWTFOemNzTVM0ek1UQXhOVFl5SUMweExqTXhNREUxTmpNc01TNHpNVEF4TlRZeUlDMHdMakkzTVRNME1qSXNNQ0F0TUM0MU1qYzROakExTEMwd0xqQTNOekE1TXlBdE1DNDNNelk1TmpJNUxDMHdMakl4T0RNMU9UTWdNQzR5TXprME1UQTBMREF1TXpFek1EZzFPU0F3TGpZeE1qWXpOak1zTUM0MU1UZzJNRE0xSURFdU1ETTNNakEzTVN3d0xqVXhPRFl3TXpVZ01DNDNNak0xTnprekxEQWdNUzR6TVRBeE5UWXlMQzB3TGpVNE5qVTNOeUF4TGpNeE1ERTFOaklzTFRFdU16RXdNVFUyTXlBd0xDMHdMalF5TkRVM01EZ2dMVEF1TWpBMU5URTNOU3d0TUM0M09UYzNPVFkzSUMwd0xqVXhPRFl3TXpVc0xURXVNRE0zTWpBM0lIb2dUU0F5TGpFd01UY3dPU3cyTGpNNE56QXhNVGNnWXlBd0xqRTBNVEkyTmpjc01DNHlNRGt4TURJMElEQXVNakU0TXpVNU5Dd3dMalEyTlRZeU1EWWdNQzR5TVRnek5UazBMREF1TnpNMk9UWXlPU0F3TERBdU56SXpOVGM1TXlBdE1DNDFPRFkxTnpjc01TNHpNVEF4TlRZeklDMHhMak14TURFMU5qTXNNUzR6TVRBeE5UWXpJQzB3TGpJM01UTTBNakl6TERBZ0xUQXVOVEkzT0RZd05Ua3NMVEF1TURjM01Ea3pJQzB3TGpjek5qazJNamc0TEMwd0xqSXhPRE0xT1RRZ01DNHlNemswTVRBek9Td3dMak14TXpBNE5Ua2dNQzQyTVRJMk16WXlNaXd3TGpVeE9EWXdNelVnTVM0d016Y3lNRFk1T0N3d0xqVXhPRFl3TXpVZ01DNDNNak0xTnprekxEQWdNUzR6TVRBeE5UWXpMQzB3TGpVNE5qVTNOeUF4TGpNeE1ERTFOak1zTFRFdU16RXdNVFUyTXlBd0xDMHdMalF5TkRVM01EZ2dMVEF1TWpBMU5URTNOaXd0TUM0M09UYzNPVFkySUMwd0xqVXhPRFl3TXpVc0xURXVNRE0zTWpBM0lIb2diU0F6TGpBeU9UY3pOak1zTUNCaklEQXVNVFF4TWpZMk55d3dMakl3T1RFd01qUWdNQzR5TVRnek5UazBMREF1TkRZMU5qSXdOaUF3TGpJeE9ETTFPVFFzTUM0M016WTVOakk1SURBc01DNDNNak0xTnpreklDMHdMalU0TmpVM055d3hMak14TURFMU5qTWdMVEV1TXpFd01UVTJNeXd4TGpNeE1ERTFOak1nTFRBdU1qY3hNelF5TWl3d0lDMHdMalV5TnpnMk1EVXNMVEF1TURjM01Ea3pJQzB3TGpjek5qazJNamtzTFRBdU1qRTRNelU1TkNBd0xqSXpPVFF4TURRc01DNHpNVE13T0RVNUlEQXVOakV5TmpNMk15d3dMalV4T0RZd016VWdNUzR3TXpjeU1EY3hMREF1TlRFNE5qQXpOU0F3TGpjeU16VTNPVE1zTUNBeExqTXhNREUxTmpJc0xUQXVOVGcyTlRjM0lERXVNekV3TVRVMk1pd3RNUzR6TVRBeE5UWXpJREFzTFRBdU5ESTBOVGN3T0NBdE1DNHlNRFUxTVRjMUxDMHdMamM1TnpjNU5qWWdMVEF1TlRFNE5qQXpOU3d0TVM0d016Y3lNRGNnZWlCdElETXVNRGcwTXpJMk1pd3dJR01nTUM0eE5ERXlOalkzTERBdU1qQTVNVEF5TkNBd0xqSXhPRE0xT1RRc01DNDBOalUyTWpBMklEQXVNakU0TXpVNU5Dd3dMamN6TmprMk1qa2dNQ3d3TGpjeU16VTNPVE1nTFRBdU5UZzJOVGMzTERFdU16RXdNVFUyTXlBdE1TNHpNVEF4TlRZekxERXVNekV3TVRVMk15QXRNQzR5TnpFek5ESXpMREFnTFRBdU5USTNPRFl3TlN3dE1DNHdOemN3T1RNZ0xUQXVOek0yT1RZeU9Td3RNQzR5TVRnek5UazBJREF1TWpNNU5ERXdOQ3d3TGpNeE16QTROVGtnTUM0Mk1USTJNell5TERBdU5URTROakF6TlNBeExqQXpOekl3Tnl3d0xqVXhPRFl3TXpVZ01DNDNNak0xTnprekxEQWdNUzR6TVRBeE5UWXpMQzB3TGpVNE5qVTNOeUF4TGpNeE1ERTFOak1zTFRFdU16RXdNVFUyTXlBd0xDMHdMalF5TkRVM01EZ2dMVEF1TWpBMU5URTNOaXd0TUM0M09UYzNPVFkySUMwd0xqVXhPRFl3TXpVc0xURXVNRE0zTWpBM0lIb2lJQzgrSUNBOEwyYytQQzl6ZG1jKyk7XFxyXFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IDEwMCUgMTAwJTtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG8gIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcnRsID4gLm9zLXNjcm9sbGJhci1jb3JuZXIub3Mtc2Nyb2xsYmFyLWNvcm5lci1yZXNpemUge1xcclxcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoLTEsIDEpO1xcclxcbiAgICB0cmFuc2Zvcm06IHNjYWxlKC0xLCAxKTtcXHJcXG59XFxyXFxuLm9zLWhvc3Qtb3ZlcmZsb3cge1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy1ob3N0LW92ZXJmbG93LXgge1xcclxcbn0gXFxyXFxuLm9zLWhvc3Qtb3ZlcmZsb3cteSB7XFxyXFxufSBcXHJcXG5cXHJcXG4vKlxcclxcblRIRU1FUzpcXHJcXG4qL1xcclxcblxcclxcbi8qIE5PTkUgVEhFTUU6ICovXFxyXFxuLm9zLXRoZW1lLW5vbmUgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwsXFxyXFxuLm9zLXRoZW1lLW5vbmUgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsLFxcclxcbi5vcy10aGVtZS1ub25lID4gLm9zLXNjcm9sbGJhci1jb3JuZXIge1xcclxcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5vcy10aGVtZS1ub25lID4gLm9zLXNjcm9sbGJhci1jb3JuZXItcmVzaXplIHtcXHJcXG4gICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDtcXHJcXG4gICAgbWluLXdpZHRoOiAxMHB4O1xcclxcbiAgICBtaW4taGVpZ2h0OiAxMHB4O1xcclxcbn1cXHJcXG4vKiBEQVJLICYgTElHSFQgVEhFTUU6ICovXFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIHtcXHJcXG4gICAgcmlnaHQ6IDEwcHg7XFxyXFxuICAgIGhlaWdodDogMTBweDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsLFxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwge1xcclxcbiAgICBib3R0b206IDEwcHg7XFxyXFxuICAgIHdpZHRoOiAxMHB4O1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyay5vcy1ob3N0LXJ0bCA+IC5vcy1zY3JvbGxiYXItaG9yaXpvbnRhbCxcXHJcXG4ub3MtdGhlbWUtbGlnaHQub3MtaG9zdC1ydGwgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwge1xcclxcbiAgICBsZWZ0OiAxMHB4O1xcclxcbiAgICByaWdodDogMDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lcixcXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLWNvcm5lciB7XFxyXFxuICAgIGhlaWdodDogMTBweDtcXHJcXG4gICAgd2lkdGg6IDEwcHg7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhci1jb3JuZXIsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci1jb3JuZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLFxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXIge1xcclxcbiAgICBwYWRkaW5nOiAycHg7XFxyXFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXIub3Mtc2Nyb2xsYmFyLXVudXNhYmxlLFxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXIub3Mtc2Nyb2xsYmFyLXVudXNhYmxlIHtcXHJcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2ssXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sge1xcclxcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsID4gLm9zLXNjcm9sbGJhci10cmFjayA+IC5vcy1zY3JvbGxiYXItaGFuZGxlIHtcXHJcXG4gICAgbWluLXdpZHRoOiAzMHB4O1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXItdmVydGljYWwgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZSB7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IDMwcHg7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrLm9zLWhvc3QtdHJhbnNpdGlvbiA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0Lm9zLWhvc3QtdHJhbnNpdGlvbiA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUge1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4zcztcXHJcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzO1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZSxcXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrLFxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrIHtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyID4gLm9zLXNjcm9sbGJhci10cmFjayA+IC5vcy1zY3JvbGxiYXItaGFuZGxlIHtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjQpO1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyID4gLm9zLXNjcm9sbGJhci10cmFjayA+IC5vcy1zY3JvbGxiYXItaGFuZGxlIHtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpO1xcclxcbn1cXHJcXG4ub3MtdGhlbWUtZGFyayA+IC5vcy1zY3JvbGxiYXI6aG92ZXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC41NSk7XFxyXFxufVxcclxcbi5vcy10aGVtZS1saWdodCA+IC5vcy1zY3JvbGxiYXI6aG92ZXIgPiAub3Mtc2Nyb2xsYmFyLXRyYWNrID4gLm9zLXNjcm9sbGJhci1oYW5kbGUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC41NSk7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZS5hY3RpdmUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIC43KTtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhciA+IC5vcy1zY3JvbGxiYXItdHJhY2sgPiAub3Mtc2Nyb2xsYmFyLWhhbmRsZS5hY3RpdmUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC43KTtcXHJcXG59XFxyXFxuLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgLm9zLXNjcm9sbGJhci1oYW5kbGU6YmVmb3JlLFxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCAub3Mtc2Nyb2xsYmFyLWhhbmRsZTpiZWZvcmUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSB7XFxyXFxuICAgIGNvbnRlbnQ6ICcnO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGJvdHRvbTogMDtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrLm9zLWhvc3Qtc2Nyb2xsYmFyLWhvcml6b250YWwtaGlkZGVuID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtZGFyay5vcy1ob3N0LXNjcm9sbGJhci12ZXJ0aWNhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtbGlnaHQub3MtaG9zdC1zY3JvbGxiYXItaG9yaXpvbnRhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgLm9zLXNjcm9sbGJhci1oYW5kbGU6YmVmb3JlLFxcclxcbi5vcy10aGVtZS1saWdodC5vcy1ob3N0LXNjcm9sbGJhci12ZXJ0aWNhbC1oaWRkZW4gPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhci1ob3Jpem9udGFsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgLm9zLXNjcm9sbGJhci1oYW5kbGU6YmVmb3JlIHtcXHJcXG4gICAgdG9wOiAtNnB4O1xcclxcbiAgICBib3R0b206IC0ycHg7XFxyXFxufVxcclxcbi5vcy10aGVtZS1kYXJrID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCAub3Mtc2Nyb2xsYmFyLWhhbmRsZTpiZWZvcmUsXFxyXFxuLm9zLXRoZW1lLWxpZ2h0ID4gLm9zLXNjcm9sbGJhci12ZXJ0aWNhbCAub3Mtc2Nyb2xsYmFyLWhhbmRsZTpiZWZvcmUge1xcclxcbiAgICBsZWZ0OiAtNnB4O1xcclxcbiAgICByaWdodDogLTJweDtcXHJcXG59XFxyXFxuLm9zLWhvc3QtcnRsLm9zLXRoZW1lLWRhcmsgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSxcXHJcXG4ub3MtaG9zdC1ydGwub3MtdGhlbWUtbGlnaHQgPiAub3Mtc2Nyb2xsYmFyLXZlcnRpY2FsIC5vcy1zY3JvbGxiYXItaGFuZGxlOmJlZm9yZSB7XFxyXFxuICAgIHJpZ2h0OiAtNnB4O1xcclxcbiAgICBsZWZ0OiAtMnB4O1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgT3ZlcmxheVNjcm9sbGJhcnMgZnJvbSAnb3ZlcmxheXNjcm9sbGJhcnMnO1xyXG5cclxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuY2xhc3MgT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5fb3NJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb3NUYXJnZXRSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcclxuICAgIH1cclxuICAgIG9zSW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29zSW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBvc1RhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3NUYXJnZXRSZWYuY3VycmVudCB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgdGhpcy5fb3NJbnN0YW5jZSA9IE92ZXJsYXlTY3JvbGxiYXJzKHRoaXMub3NUYXJnZXQoKSwgdGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9LCB0aGlzLnByb3BzLmV4dGVuc2lvbnMpO1xyXG4gICAgICAgIG1lcmdlSG9zdENsYXNzTmFtZXModGhpcy5fb3NJbnN0YW5jZSwgdGhpcy5wcm9wcy5jbGFzc05hbWUpO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgaWYgKE92ZXJsYXlTY3JvbGxiYXJzLnZhbGlkKHRoaXMuX29zSW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29zSW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9vc0luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XHJcbiAgICAgICAgaWYgKE92ZXJsYXlTY3JvbGxiYXJzLnZhbGlkKHRoaXMuX29zSW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29zSW5zdGFuY2Uub3B0aW9ucyh0aGlzLnByb3BzLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAocHJldlByb3BzLmNsYXNzTmFtZSAhPT0gdGhpcy5wcm9wcy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlSG9zdENsYXNzTmFtZXModGhpcy5fb3NJbnN0YW5jZSwgdGhpcy5wcm9wcy5jbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgZGl2UHJvcHMgPSBfX3Jlc3QoX2EsIFtcIm9wdGlvbnNcIiwgXCJleHRlbnNpb25zXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl0pO1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBcIm9zLWhvc3RcIiB9LCBkaXZQcm9wcywgeyByZWY6IHRoaXMuX29zVGFyZ2V0UmVmIH0pLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0XCIgfSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3MtcGFkZGluZ1wiIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLXZpZXdwb3J0XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLWNvbnRlbnRcIiB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKSkpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLXNjcm9sbGJhciBvcy1zY3JvbGxiYXItaG9yaXpvbnRhbCBcIiB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXItdHJhY2tcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3Mtc2Nyb2xsYmFyLWhhbmRsZVwiIH0pKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci12ZXJ0aWNhbFwiIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLXNjcm9sbGJhci10cmFja1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXItaGFuZGxlXCIgfSkpKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXItY29ybmVyXCIgfSkpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtZXJnZUhvc3RDbGFzc05hbWVzKG9zSW5zdGFuY2UsIGNsYXNzTmFtZSkge1xyXG4gICAgaWYgKE92ZXJsYXlTY3JvbGxiYXJzLnZhbGlkKG9zSW5zdGFuY2UpKSB7XHJcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSBvc0luc3RhbmNlLmdldEVsZW1lbnRzKCk7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAoXm9zLWhvc3QoWy1fXS4rfCkkKXwke29zSW5zdGFuY2Uub3B0aW9ucygpLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMvZywgXCIkfFwiKX0kYCwgJ2cnKTtcclxuICAgICAgICBjb25zdCBvc0NsYXNzTmFtZXMgPSBob3N0LmNsYXNzTmFtZS5zcGxpdCgnICcpXHJcbiAgICAgICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLm1hdGNoKHJlZ2V4KSlcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICBob3N0LmNsYXNzTmFtZSA9IGAke29zQ2xhc3NOYW1lc30gJHtjbGFzc05hbWUgfHwgJyd9YDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgT3ZlcmxheVNjcm9sbGJhcnNDb21wb25lbnQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3ZlcmxheXNjcm9sbGJhcnMtcmVhY3QuZXNtLmpzLm1hcFxyXG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi01LTEhLi4vLi4vbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTUtMiEuL092ZXJsYXlTY3JvbGxiYXJzLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi01LTEhLi4vLi4vbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTUtMiEuL092ZXJsYXlTY3JvbGxiYXJzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtNS0xIS4uLy4uL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi01LTIhLi9PdmVybGF5U2Nyb2xsYmFycy5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiLyohXHJcbiAqIE92ZXJsYXlTY3JvbGxiYXJzXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LaW5nU29yYS9PdmVybGF5U2Nyb2xsYmFyc1xyXG4gKlxyXG4gKiBWZXJzaW9uOiAxLjEzLjBcclxuICpcclxuICogQ29weXJpZ2h0IEtpbmdTb3JhIHwgUmVuZSBIYWFzLlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmFcclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKiBEYXRlOiAwMi4wOC4yMDIwXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhY3RvcnkoZ2xvYmFsLCBnbG9iYWwuZG9jdW1lbnQsIHVuZGVmaW5lZCk7IH0pO1xyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0JylcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYmFsLCBnbG9iYWwuZG9jdW1lbnQsIHVuZGVmaW5lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgZmFjdG9yeShnbG9iYWwsIGdsb2JhbC5kb2N1bWVudCwgdW5kZWZpbmVkKTtcclxufSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsXHJcbiAgICBmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgICAgIHZhciBQTFVHSU5OQU1FID0gJ092ZXJsYXlTY3JvbGxiYXJzJztcclxuICAgICAgICB2YXIgVFlQRVMgPSB7XHJcbiAgICAgICAgICAgIG86ICdvYmplY3QnLFxyXG4gICAgICAgICAgICBmOiAnZnVuY3Rpb24nLFxyXG4gICAgICAgICAgICBhOiAnYXJyYXknLFxyXG4gICAgICAgICAgICBzOiAnc3RyaW5nJyxcclxuICAgICAgICAgICAgYjogJ2Jvb2xlYW4nLFxyXG4gICAgICAgICAgICBuOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgdTogJ3VuZGVmaW5lZCcsXHJcbiAgICAgICAgICAgIHo6ICdudWxsJ1xyXG4gICAgICAgICAgICAvL2QgOiAnZGF0ZScsXHJcbiAgICAgICAgICAgIC8vZSA6ICdlcnJvcicsXHJcbiAgICAgICAgICAgIC8vciA6ICdyZWdleHAnLFxyXG4gICAgICAgICAgICAvL3kgOiAnc3ltYm9sJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIExFWElDT04gPSB7XHJcbiAgICAgICAgICAgIGM6ICdjbGFzcycsXHJcbiAgICAgICAgICAgIHM6ICdzdHlsZScsXHJcbiAgICAgICAgICAgIGk6ICdpZCcsXHJcbiAgICAgICAgICAgIGw6ICdsZW5ndGgnLFxyXG4gICAgICAgICAgICBwOiAncHJvdG90eXBlJyxcclxuICAgICAgICAgICAgdGk6ICd0YWJpbmRleCcsXHJcbiAgICAgICAgICAgIG9IOiAnb2Zmc2V0SGVpZ2h0JyxcclxuICAgICAgICAgICAgY0g6ICdjbGllbnRIZWlnaHQnLFxyXG4gICAgICAgICAgICBzSDogJ3Njcm9sbEhlaWdodCcsXHJcbiAgICAgICAgICAgIG9XOiAnb2Zmc2V0V2lkdGgnLFxyXG4gICAgICAgICAgICBjVzogJ2NsaWVudFdpZHRoJyxcclxuICAgICAgICAgICAgc1c6ICdzY3JvbGxXaWR0aCcsXHJcbiAgICAgICAgICAgIGhPUDogJ2hhc093blByb3BlcnR5JyxcclxuICAgICAgICAgICAgYkNSOiAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIFZFTkRPUlMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvVmVuZG9yX1ByZWZpeFxyXG4gICAgICAgICAgICB2YXIganNDYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgY3NzQ2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGNzc1ByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctby0nLCAnLW1zLSddO1xyXG4gICAgICAgICAgICB2YXIganNQcmVmaXhlcyA9IFsnV2ViS2l0JywgJ01veicsICdPJywgJ01TJ107XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpcnN0TGV0dGVyVG9VcHBlcihzdHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBfY3NzUHJlZml4ZXM6IGNzc1ByZWZpeGVzLFxyXG4gICAgICAgICAgICAgICAgX2pzUHJlZml4ZXM6IGpzUHJlZml4ZXMsXHJcbiAgICAgICAgICAgICAgICBfY3NzUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNzc0NhY2hlW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzQ2FjaGVbTEVYSUNPTi5oT1BdKG5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBwZXJjYXNlZE5hbWUgPSBmaXJzdExldHRlclRvVXBwZXIobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsbVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylbTEVYSUNPTi5zXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0UG9zc2liaWxpdGllcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHY7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJWZW5kb3JXaXRob3V0RGFzaGVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNzc1ByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJWZW5kb3JXaXRob3V0RGFzaGVzID0gY3NzUHJlZml4ZXNbaV0ucmVwbGFjZSgvLS9nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBvc3NpYmlsaXRpZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCAvL3RyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1ByZWZpeGVzW2ldICsgbmFtZSwgLy8td2Via2l0LXRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJWZW5kb3JXaXRob3V0RGFzaGVzICsgdXBwZXJjYXNlZE5hbWUsIC8vd2Via2l0VHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RMZXR0ZXJUb1VwcGVyKGN1cnJWZW5kb3JXaXRob3V0RGFzaGVzKSArIHVwcGVyY2FzZWROYW1lIC8vV2Via2l0VHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDwgcmVzdWx0UG9zc2liaWxpdGllc1tMRVhJQ09OLmxdOyB2KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbG1TdHlsZVtyZXN1bHRQb3NzaWJpbGl0aWVzW3ZdXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0UG9zc2liaWxpdGllc1t2XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2FjaGVbbmFtZV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBfY3NzUHJvcGVydHlWYWx1ZTogZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZXMsIHN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcHJvcGVydHkgKyAnICcgKyB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNzc0NhY2hlW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzQ2FjaGVbTEVYSUNPTi5oT1BdKG5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHVtbXlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpW0xFWElDT04uc107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3NibGVWYWx1ZXMgPSB2YWx1ZXMuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlcGFyZWRTdWZmaXggPSBzdWZmaXggfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3A7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcG9zc2JsZVZhbHVlc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IHYgPCBWRU5ET1JTLl9jc3NQcmVmaXhlc1tMRVhJQ09OLmxdOyB2KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSB2IDwgMCA/IHBvc3NibGVWYWx1ZXNbaV0gOiBWRU5ET1JTLl9jc3NQcmVmaXhlc1t2XSArIHBvc3NibGVWYWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1teVN0eWxlLmNzc1RleHQgPSBwcm9wZXJ0eSArICc6JyArIHByb3AgKyBwcmVwYXJlZFN1ZmZpeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdW1teVN0eWxlW0xFWElDT04ubF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjc3NDYWNoZVtuYW1lXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9qc0FQSTogZnVuY3Rpb24gKG5hbWUsIGlzSW50ZXJmYWNlLCBmYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ganNDYWNoZVtuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc0NhY2hlW0xFWElDT04uaE9QXShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB3aW5kb3dbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwganNQcmVmaXhlc1tMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgd2luZG93Wyhpc0ludGVyZmFjZSA/IGpzUHJlZml4ZXNbaV0gOiBqc1ByZWZpeGVzW2ldLnRvTG93ZXJDYXNlKCkpICsgZmlyc3RMZXR0ZXJUb1VwcGVyKG5hbWUpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAganNDYWNoZVtuYW1lXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBmYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgdmFyIENPTVBBVElCSUxJVFkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiB3aW5kb3dTaXplKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4ID8gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W0xFWElDT04uY1ddIHx8IGRvY3VtZW50LmJvZHlbTEVYSUNPTi5jV10gOiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W0xFWElDT04uY0hdIHx8IGRvY3VtZW50LmJvZHlbTEVYSUNPTi5jSF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzT2JqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gVFlQRVMuZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ2FuJ3QgYmluZCBmdW5jdGlvbiFcIjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDVcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHByb3RvID0gTEVYSUNPTi5wO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFBcmdzID0gQXJyYXlbcHJvdG9dLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICAgICAgICAgIHZhciBmTk9QID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgPyB0aGlzIDogdGhpc09iaiwgYUFyZ3MuY29uY2F0KEFycmF5W3Byb3RvXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTsgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZnVuY1twcm90b10pXHJcbiAgICAgICAgICAgICAgICAgICAgZk5PUFtwcm90b10gPSBmdW5jW3Byb3RvXTsgLy8gRnVuY3Rpb24ucHJvdG90eXBlIGRvZXNuJ3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgZkJvdW5kW3Byb3RvXSA9IG5ldyBmTk9QKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZCb3VuZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB3aW5kb3cgd2lkdGguXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfG51bWJlcn0gVGhlIGN1cnJlbnQgd2luZG93IHdpZHRoIGluIHBpeGVsLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB3VzogYmluZCh3aW5kb3dTaXplLCAwLCB0cnVlKSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgd2luZG93IGhlaWdodC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVtYmVyfSBUaGUgY3VycmVudCB3aW5kb3cgaGVpZ2h0IGluIHBpeGVsLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB3SDogYmluZCh3aW5kb3dTaXplLCAwKSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgT2JqZWN0IG9yIHVuZGVmaW5lZCBpZiBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge011dGF0aW9uT2JzZXJ2ZXJ8Knx1bmRlZmluZWR9IFRoZSBNdXRhdGlvbnNPYnNlcnZlciBPYmplY3Qgb3IgdW5kZWZpbmVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBtTzogYmluZChWRU5ET1JTLl9qc0FQSSwgMCwgJ011dGF0aW9uT2JzZXJ2ZXInLCB0cnVlKSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIFJlc2l6ZU9ic2VydmVyIE9iamVjdCBvciB1bmRlZmluZWQgaWYgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtNdXRhdGlvbk9ic2VydmVyfCp8dW5kZWZpbmVkfSBUaGUgUmVzaXplT2JzZXJ2ZXIgT2JqZWN0IG9yIHVuZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgck86IGJpbmQoVkVORE9SUy5fanNBUEksIDAsICdSZXNpemVPYnNlcnZlcicsIHRydWUpLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgUmVxdWVzdEFuaW1hdGlvbkZyYW1lIG1ldGhvZCBvciBpdCdzIGNvcnJlc3BvbmRpbmcgcG9seWZpbGwuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7KnxGdW5jdGlvbn0gVGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZSBtZXRob2Qgb3IgaXQncyBjb3JyZXNwb25kaW5nIHBvbHlmaWxsLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByQUY6IGJpbmQoVkVORE9SUy5fanNBUEksIDAsICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLCBmYWxzZSwgZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmMsIDEwMDAgLyA2MCk7IH0pLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgQ2FuY2VsQW5pbWF0aW9uRnJhbWUgbWV0aG9kIG9yIGl0J3MgY29ycmVzcG9uZGluZyBwb2x5ZmlsbC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfEZ1bmN0aW9ufSBUaGUgQ2FuY2VsQW5pbWF0aW9uRnJhbWUgbWV0aG9kIG9yIGl0J3MgY29ycmVzcG9uZGluZyBwb2x5ZmlsbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY0FGOiBiaW5kKFZFTkRPUlMuX2pzQVBJLCAwLCAnY2FuY2VsQW5pbWF0aW9uRnJhbWUnLCBmYWxzZSwgZnVuY3Rpb24gKGlkKSB7IHJldHVybiB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY3VycmVudCB0aW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBub3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3cgJiYgRGF0ZS5ub3coKSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTdG9wcyB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBvZiB3aGljaCB0aGUgcHJvcGFnYXRpb24gc2hhbGwgYmUgc3RvcGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBzdHBQOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBnaXZlbiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgb2Ygd2hpY2ggdGhlIGRlZmF1bHQgYWN0aW9uIHNoYWxsIGJlIHByZXZlbnRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcHJ2RDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LmNhbmNlbGFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIHBhZ2VYIGFuZCBwYWdlWSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1vdXNlIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBtb3VzZSBldmVudCBvZiB3aGljaCB0aGUgcGFnZVggYW5kIHBhZ2VYIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB4ID0gcGFnZVggdmFsdWUsIHkgPSBwYWdlWSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcGFnZTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyUGFnZSA9ICdwYWdlJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQ2xpZW50ID0gJ2NsaWVudCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clggPSAnWCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clkgPSAnWSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudERvYyA9IHRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBldmVudERvYy5ib2R5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRvdWNoIGV2ZW50IHJldHVybiByZXR1cm4gcGFnZVgvWSBvZiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRvdWNoW3N0clBhZ2UgKyBzdHJYXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRvdWNoW3N0clBhZ2UgKyBzdHJZXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBub3QgbmF0aXZlIHN1cHBvcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnRbc3RyUGFnZSArIHN0clhdICYmIGV2ZW50W3N0ckNsaWVudCArIHN0clhdICYmIGV2ZW50W3N0ckNsaWVudCArIHN0clhdICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBldmVudFtzdHJDbGllbnQgKyBzdHJYXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGV2ZW50W3N0ckNsaWVudCArIHN0clldICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvYyAmJiBkb2MuY2xpZW50VG9wIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgfHwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBldmVudFtzdHJQYWdlICsgc3RyWF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGV2ZW50W3N0clBhZ2UgKyBzdHJZXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgY2xpY2tlZCBtb3VzZSBidXR0b24gb2YgdGhlIGdpdmVuIG1vdXNlIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBtb3VzZSBldmVudCBvZiB3aGljaCB0aGUgY2xpY2tlZCBidXR0b24gc2hhbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHRoZSBjbGlja2VkIG1vdXNlIGJ1dHRvbi4gKDAgOiBub25lIHwgMSA6IGxlZnRCdXR0b24gfCAyIDogbWlkZGxlQnV0dG9uIHwgMyA6IHJpZ2h0QnV0dG9uKVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBtQnRuOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYnV0dG9uICYgMSA/IDEgOiAoYnV0dG9uICYgMiA/IDMgOiAoYnV0dG9uICYgNCA/IDIgOiAwKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LndoaWNoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENoZWNrcyB3aGV0aGVyIGEgaXRlbSBpcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXRzIGluZGV4LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gb2Ygd2hpY2ggdGhlIHBvc2l0aW9uIGluIHRoZSBhcnJheSBzaGFsbCBiZSBkZXRlcm1pbmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGFyciBUaGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgemVybyBiYXNlZCBpbmRleCBvZiB0aGUgaXRlbSBvciAtMSBpZiB0aGUgaXRlbSBpc24ndCBpbiB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGluQTogZnVuY3Rpb24gKGl0ZW0sIGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Tb21ldGllbXMgaW4gSUUgYSBcIlNDUklQVDcwXCIgUGVybWlzc2lvbiBkZW5pZWQgZXJyb3Igb2NjdXJzIGlmIEhUTUwgZWxlbWVudHMgaW4gYSBpRnJhbWUgYXJlIGNvbXBhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldID09PSBpdGVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGFyciBUaGUgcG90ZW50aWFsIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaXNBOiBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IEFycmF5LmlzQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZiA/IGRlZihhcnIpIDogdGhpcy50eXBlKGFycikgPT0gVFlQRVMuYTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmUgdGhlIGludGVybmFsIEphdmFTY3JpcHQgW1tDbGFzc11dIG9mIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3Qgb2Ygd2hpY2ggdGhlIHR5cGUgc2hhbGwgYmUgZGV0ZXJtaW5lZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0eXBlIG9mIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogKyAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqICsgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdFtMRVhJQ09OLnBdLnRvU3RyaW5nLmNhbGwob2JqKS5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKylcXF0kLywgJyQxJykudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGJpbmQ6IGJpbmRcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIHZlbmRvci1wcmVmaXhlZCBDU1MgcHJvcGVydHkgYnkgdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBGb3IgZXhhbXBsZSB0aGUgZ2l2ZW4gbmFtZSBpcyBcInRyYW5zZm9ybVwiIGFuZCB5b3UncmUgdXNpbmcgYSBvbGQgRmlyZWZveCBicm93c2VyIHRoZW4gdGhlIHJldHVybmVkIHZhbHVlIHdvdWxkIGJlIFwiLW1vei10cmFuc2Zvcm1cIi5cclxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBicm93c2VyIGRvZXNuJ3QgbmVlZCBhIHZlbmRvci1wcmVmaXgsIHRoZW4gdGhlIHJldHVybmVkIHN0cmluZyBpcyB0aGUgZ2l2ZW4gbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZSBhdCBhbGwgKG5vdCBldmVuIHdpdGggYSB2ZW5kb3ItcHJlZml4KSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbnVsbC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwcm9wTmFtZSBUaGUgdW5wcmVmaXhlZCBDU1MgcHJvcGVydHkgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVGhlIHZlbmRvci1wcmVmaXhlZCBDU1MgcHJvcGVydHkgb3IgbnVsbCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGdpdmVuIENTUyBwcm9wZXJ0eS5cclxuXHJcbiAgICAgICAgICAgICAgICBjc3NQcm9wOiBmdW5jdGlvbihwcm9wTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWRU5ET1JTLl9jc3NQcm9wZXJ0eShwcm9wTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuXHJcblxyXG4gICAgICAgIHZhciBNQVRIID0gTWF0aDtcclxuICAgICAgICB2YXIgSlFVRVJZID0gd2luZG93LmpRdWVyeTtcclxuICAgICAgICB2YXIgRUFTSU5HID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9lYXNpbmdzTWF0aCA9IHtcclxuICAgICAgICAgICAgICAgIHA6IE1BVEguUEksXHJcbiAgICAgICAgICAgICAgICBjOiBNQVRILmNvcyxcclxuICAgICAgICAgICAgICAgIHM6IE1BVEguc2luLFxyXG4gICAgICAgICAgICAgICAgdzogTUFUSC5wb3csXHJcbiAgICAgICAgICAgICAgICB0OiBNQVRILnNxcnQsXHJcbiAgICAgICAgICAgICAgICBuOiBNQVRILmFzaW4sXHJcbiAgICAgICAgICAgICAgICBhOiBNQVRILmFicyxcclxuICAgICAgICAgICAgICAgIG86IDEuNzAxNThcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICB4IDogY3VycmVudCBwZXJjZW50ICgwIC0gMSksXHJcbiAgICAgICAgICAgICB0IDogY3VycmVudCB0aW1lIChkdXJhdGlvbiAqIHBlcmNlbnQpLFxyXG4gICAgICAgICAgICAgYiA6IHN0YXJ0IHZhbHVlIChmcm9tKSxcclxuICAgICAgICAgICAgIGMgOiBlbmQgdmFsdWUgKHRvKSxcclxuICAgICAgICAgICAgIGQgOiBkdXJhdGlvblxyXG5cclxuICAgICAgICAgICAgIGVhc2luZ05hbWUgOiBmdW5jdGlvbih4LCB0LCBiLCBjLCBkKSB7IHJldHVybiBlYXNlZFZhbHVlOyB9XHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN3aW5nOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgLSBfZWFzaW5nc01hdGguYyh4ICogX2Vhc2luZ3NNYXRoLnApIC8gMjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluUXVhZDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyBjIC8gMiAqIHQgKiB0ICsgYiA6IC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodCAvPSBkIC8gMikgPCAxKSA/IGMgLyAyICogdCAqIHQgKiB0ICsgYiA6IGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgLSAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodCAvPSBkIC8gMikgPCAxKSA/IGMgLyAyICogdCAqIHQgKiB0ICogdCArIGIgOiAtYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRRdWludDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKiB0ICsgYiA6IGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5TaW5lOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYyAqIF9lYXNpbmdzTWF0aC5jKHQgLyBkICogKF9lYXNpbmdzTWF0aC5wIC8gMikpICsgYyArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dFNpbmU6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiBfZWFzaW5nc01hdGgucyh0IC8gZCAqIChfZWFzaW5nc01hdGgucCAvIDIpKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0U2luZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgLyAyICogKF9lYXNpbmdzTWF0aC5jKF9lYXNpbmdzTWF0aC5wICogdCAvIGQpIC0gMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbkV4cG86IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0ID09IDApID8gYiA6IGMgKiBfZWFzaW5nc01hdGgudygyLCAxMCAqICh0IC8gZCAtIDEpKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dEV4cG86IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0ID09IGQpID8gYiArIGMgOiBjICogKC1fZWFzaW5nc01hdGgudygyLCAtMTAgKiB0IC8gZCkgKyAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0RXhwbzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSAwKSByZXR1cm4gYjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSBkKSByZXR1cm4gYiArIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHJldHVybiBjIC8gMiAqIF9lYXNpbmdzTWF0aC53KDIsIDEwICogKHQgLSAxKSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjIC8gMiAqICgtX2Vhc2luZ3NNYXRoLncoMiwgLTEwICogLS10KSArIDIpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5DaXJjOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYyAqIChfZWFzaW5nc01hdGgudCgxIC0gKHQgLz0gZCkgKiB0KSAtIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0Q2lyYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqIF9lYXNpbmdzTWF0aC50KDEgLSAodCA9IHQgLyBkIC0gMSkgKiB0KSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gLWMgLyAyICogKF9lYXNpbmdzTWF0aC50KDEgLSB0ICogdCkgLSAxKSArIGIgOiBjIC8gMiAqIChfZWFzaW5nc01hdGgudCgxIC0gKHQgLT0gMikgKiB0KSArIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5FbGFzdGljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gX2Vhc2luZ3NNYXRoLm87IHZhciBwID0gMDsgdmFyIGEgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IDApIHJldHVybiBiOyBpZiAoKHQgLz0gZCkgPT0gMSkgcmV0dXJuIGIgKyBjOyBpZiAoIXApIHAgPSBkICogLjM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBfZWFzaW5nc01hdGguYShjKSkgeyBhID0gYzsgcyA9IHAgLyA0OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBzID0gcCAvICgyICogX2Vhc2luZ3NNYXRoLnApICogX2Vhc2luZ3NNYXRoLm4oYyAvIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtKGEgKiBfZWFzaW5nc01hdGgudygyLCAxMCAqICh0IC09IDEpKSAqIF9lYXNpbmdzTWF0aC5zKCh0ICogZCAtIHMpICogKDIgKiBfZWFzaW5nc01hdGgucCkgLyBwKSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gX2Vhc2luZ3NNYXRoLm87IHZhciBwID0gMDsgdmFyIGEgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID09IDApIHJldHVybiBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAvPSBkKSA9PSAxKSByZXR1cm4gYiArIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwKSBwID0gZCAqIC4zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgX2Vhc2luZ3NNYXRoLmEoYykpIHsgYSA9IGM7IHMgPSBwIC8gNDsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcyA9IHAgLyAoMiAqIF9lYXNpbmdzTWF0aC5wKSAqIF9lYXNpbmdzTWF0aC5uKGMgLyBhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAqIF9lYXNpbmdzTWF0aC53KDIsIC0xMCAqIHQpICogX2Vhc2luZ3NNYXRoLnMoKHQgKiBkIC0gcykgKiAoMiAqIF9lYXNpbmdzTWF0aC5wKSAvIHApICsgYyArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IF9lYXNpbmdzTWF0aC5vOyB2YXIgcCA9IDA7IHZhciBhID0gYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSAwKSByZXR1cm4gYjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgLz0gZCAvIDIpID09IDIpIHJldHVybiBiICsgYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXApIHAgPSBkICogKC4zICogMS41KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IF9lYXNpbmdzTWF0aC5hKGMpKSB7IGEgPSBjOyBzID0gcCAvIDQ7IH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHMgPSBwIC8gKDIgKiBfZWFzaW5nc01hdGgucCkgKiBfZWFzaW5nc01hdGgubihjIC8gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCAxKSByZXR1cm4gLS41ICogKGEgKiBfZWFzaW5nc01hdGgudygyLCAxMCAqICh0IC09IDEpKSAqIF9lYXNpbmdzTWF0aC5zKCh0ICogZCAtIHMpICogKDIgKiBfZWFzaW5nc01hdGgucCkgLyBwKSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhICogX2Vhc2luZ3NNYXRoLncoMiwgLTEwICogKHQgLT0gMSkpICogX2Vhc2luZ3NNYXRoLnMoKHQgKiBkIC0gcykgKiAoMiAqIF9lYXNpbmdzTWF0aC5wKSAvIHApICogLjUgKyBjICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5CYWNrOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCwgcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzIHx8IF9lYXNpbmdzTWF0aC5vO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogKChzICsgMSkgKiB0IC0gcykgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRCYWNrOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCwgcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzIHx8IF9lYXNpbmdzTWF0aC5vO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCwgcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzIHx8IF9lYXNpbmdzTWF0aC5vO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSkgKyBiIDogYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbkJvdW5jZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAtIHRoaXMuZWFzZU91dEJvdW5jZSh4LCBkIC0gdCwgMCwgYywgZCkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSA3LjU2MjU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0IC89IGQpIDwgKDEgLyAyLjc1KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqIChvICogdCAqIHQpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKG8gKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIC43NSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqIChvICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgLjkzNzUpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqIChvICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIC45ODQzNzUpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodCA8IGQgLyAyKSA/IHRoaXMuZWFzZUluQm91bmNlKHgsIHQgKiAyLCAwLCBjLCBkKSAqIC41ICsgYiA6IHRoaXMuZWFzZU91dEJvdW5jZSh4LCB0ICogMiAtIGQsIDAsIGMsIGQpICogLjUgKyBjICogLjUgKyBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBURVJNUyBPRiBVU0UgLSBFQVNJTkcgRVFVQVRJT05TXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBPcGVuIHNvdXJjZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UuIFxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogQ29weXJpZ2h0IMOCwqkgMjAwMSBSb2JlcnQgUGVubmVyXHJcbiAgICAgICAgICAgICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBcclxuICAgICAgICAgICAgICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgXHJcbiAgICAgICAgICAgICAqIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAgICAgICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3QgXHJcbiAgICAgICAgICAgICAqIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIFxyXG4gICAgICAgICAgICAgKiBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBcclxuICAgICAgICAgICAgICogb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgXHJcbiAgICAgICAgICAgICAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxyXG4gICAgICAgICAgICAgKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICAgICAgICAgICAgICogIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICAgICAgICAgICAgICogIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURVxyXG4gICAgICAgICAgICAgKiAgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIFxyXG4gICAgICAgICAgICAgKiBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gICAgICAgICAgICAgKiAgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgXHJcbiAgICAgICAgICAgICAqIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgdmFyIEZSQU1FV09SSyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfcm5vdGh0bWx3aGl0ZSA9ICgvW15cXHgyMFxcdFxcclxcblxcZl0rL2cpO1xyXG4gICAgICAgICAgICB2YXIgX3N0clNwYWNlID0gJyAnO1xyXG4gICAgICAgICAgICB2YXIgX3N0ckVtcHR5ID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsTGVmdCA9ICdzY3JvbGxMZWZ0JztcclxuICAgICAgICAgICAgdmFyIF9zdHJTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJztcclxuICAgICAgICAgICAgdmFyIF9hbmltYXRpb25zID0gW107XHJcbiAgICAgICAgICAgIHZhciBfdHlwZSA9IENPTVBBVElCSUxJVFkudHlwZTtcclxuICAgICAgICAgICAgdmFyIF9jc3NOdW1iZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmbGV4R3JvdzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZsZXhTaHJpbms6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcmRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9ycGhhbnM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB3aWRvd3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB6b29tOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBleHRlbmQoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3JjLCBjb3B5SXNBcnJheSwgY29weSwgbmFtZSwgb3B0aW9ucywgY2xvbmUsIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMSxcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHNbTEVYSUNPTi5sXSxcclxuICAgICAgICAgICAgICAgICAgICBkZWVwID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKF90eXBlKHRhcmdldCkgPT0gVFlQRVMuYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBpID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcclxuICAgICAgICAgICAgICAgIGlmIChfdHlwZSh0YXJnZXQpICE9IFRZUEVTLm8gJiYgIV90eXBlKHRhcmdldCkgPT0gVFlQRVMuZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IEZha2VqUXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKGlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gQ09NUEFUSUJJTElUWS5pc0EoY29weSkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBDT01QQVRJQklMSVRZLmlzQShzcmMpID8gc3JjIDogW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBjb3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaW5BcnJheShpdGVtLCBhcnIsIGZyb21JbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleCB8fCAwOyBpIDwgYXJyW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldID09PSBpdGVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdHlwZShvYmopID09IFRZUEVTLmY7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iaikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmogfHwgX3R5cGUob2JqKSAhPSBUWVBFUy5vKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3RvID0gTEVYSUNPTi5wO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0W3Byb3RvXS5oYXNPd25Qcm9wZXJ0eTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNPd25Db25zdHJ1Y3RvciA9IGhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY29uc3RydWN0b3InKTtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNJc1Byb3RvdHlwZU9mID0gb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvcltwcm90b10gJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmouY29uc3RydWN0b3JbcHJvdG9dLCAnaXNQcm90b3R5cGVPZicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc093bkNvbnN0cnVjdG9yICYmICFoYXNJc1Byb3RvdHlwZU9mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHsgLyoqLyB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90eXBlKGtleSkgPT0gVFlQRVMudSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2gob2JqLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBvYmpbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9ICEhb2JqICYmIFtMRVhJQ09OLmxdIGluIG9iaiAmJiBvYmpbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gX3R5cGUob2JqKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHQpID8gZmFsc2UgOiAodCA9PSBUWVBFUy5hIHx8IGxlbmd0aCA9PT0gMCB8fCBfdHlwZShsZW5ndGgpID09IFRZUEVTLm4gJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKF9ybm90aHRtbHdoaXRlKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnMuam9pbihfc3RyU3BhY2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaGVzKGVsZW0sIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUxpc3QgPSAoZWxlbS5wYXJlbnROb2RlIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gbm9kZUxpc3RbTEVYSUNPTi5sXTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlTGlzdFtpXSA9PSBlbGVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGluc2VydEFkamFjZW50RWxlbWVudChlbCwgc3RyYXRlZ3ksIGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFtMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFkamFjZW50RWxlbWVudChlbCwgc3RyYXRlZ3ksIGNoaWxkW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90eXBlKGNoaWxkKSA9PSBUWVBFUy5zKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsLmluc2VydEFkamFjZW50SFRNTChzdHJhdGVneSwgY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGVsLmluc2VydEFkamFjZW50RWxlbWVudChzdHJhdGVneSwgY2hpbGQubm9kZVR5cGUgPyBjaGlsZCA6IGNoaWxkWzBdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0Q1NTVmFsKGVsLCBwcm9wLCB2YWwpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsW0xFWElDT04uc11bcHJvcF0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxbTEVYSUNPTi5zXVtwcm9wXSA9IHBhcnNlQ1NTVmFsKHByb3AsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VDU1NWYWwocHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV9jc3NOdW1iZXJbcHJvcC50b0xvd2VyQ2FzZSgpXSAmJiBfdHlwZSh2YWwpID09IFRZUEVTLm4pXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9ICdweCc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGFydE5leHRBbmltYXRpb25JblEoYW5pbU9iaiwgcmVtb3ZlRnJvbVEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0QW5pbTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVGcm9tUSAhPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbU9iai5xLnNwbGljZSgwLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltT2JqLnFbTEVYSUNPTi5sXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0QW5pbSA9IGFuaW1PYmoucVswXTtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKGFuaW1PYmouZWwsIG5leHRBbmltLnByb3BzLCBuZXh0QW5pbS5kdXJhdGlvbiwgbmV4dEFuaW0uZWFzaW5nLCBuZXh0QW5pbS5jb21wbGV0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluQXJyYXkoYW5pbU9iaiwgX2FuaW1hdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRBbmltYXRpb25WYWx1ZShlbCwgcHJvcCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBfc3RyU2Nyb2xsTGVmdCB8fCBwcm9wID09PSBfc3RyU2Nyb2xsVG9wKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsW3Byb3BdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q1NTVmFsKGVsLCBwcm9wLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFuaW1hdGUoZWwsIHByb3BzLCBvcHRpb25zLCBlYXNpbmcsIGNvbXBsZXRlLCBndWFyYW50ZWVkTmV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc09wdGlvbnMgPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciB0byA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltT2JqO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BlY2lhbEVhc2luZztcclxuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzID0gb3B0aW9ucy5wcm9ncmVzcztcclxuICAgICAgICAgICAgICAgICAgICBzdGVwID0gb3B0aW9ucy5zdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmcgPSBvcHRpb25zLnNwZWNpYWxFYXNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nID0gc3BlY2lhbEVhc2luZyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgNDAwO1xyXG4gICAgICAgICAgICAgICAgZWFzaW5nID0gZWFzaW5nIHx8ICdzd2luZyc7XHJcbiAgICAgICAgICAgICAgICBndWFyYW50ZWVkTmV4dCA9IGd1YXJhbnRlZWROZXh0IHx8IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgX2FuaW1hdGlvbnNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9hbmltYXRpb25zW2ldLmVsID09PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltT2JqID0gX2FuaW1hdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFuaW1PYmopIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHE6IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBfYW5pbWF0aW9ucy5wdXNoKGFuaW1PYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gX3N0clNjcm9sbExlZnQgfHwga2V5ID09PSBfc3RyU2Nyb2xsVG9wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tW2tleV0gPSBlbFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVtrZXldID0gRmFrZWpRdWVyeShlbCkuY3NzKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tW2tleV0gIT09IHByb3BzW2tleV0gJiYgcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1trZXldID0gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVOb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVZhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9WYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVhc2VkVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGFwc2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxUG9zID0gZ3VhcmFudGVlZE5leHQgPyAwIDogaW5BcnJheShxT2JqLCBhbmltT2JqLnEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogdG8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBoYXNPcHRpb25zID8gb3B0aW9ucyA6IGR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IGVhc2luZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocVBvcyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcVBvcyA9IGFuaW1PYmoucVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltT2JqLnEucHVzaChxT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxUG9zID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVTdGFydCA9IENPTVBBVElCSUxJVFkubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lTm93ID0gQ09NUEFUSUJJTElUWS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGFwc2VkID0gKHRpbWVOb3cgLSB0aW1lU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHFPYmouc3RvcCB8fCBlbGFwc2VkID49IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAxIC0gKChNQVRILm1heCgwLCB0aW1lU3RhcnQgKyBkdXJhdGlvbiAtIHRpbWVOb3cpIC8gZHVyYXRpb24pIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tVmFsID0gcGFyc2VGbG9hdChmcm9tW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1ZhbCA9IHBhcnNlRmxvYXQodG9ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhc2VkVmFsID0gKHRvVmFsIC0gZnJvbVZhbCkgKiBFQVNJTkdbc3BlY2lhbEVhc2luZ1trZXldIHx8IGVhc2luZ10ocGVyY2VudCwgcGVyY2VudCAqIGR1cmF0aW9uLCAwLCAxLCBkdXJhdGlvbikgKyBmcm9tVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBbmltYXRpb25WYWx1ZShlbCwga2V5LCBlYXNlZFZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHN0ZXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwKGVhc2VkVmFsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbTogZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDoga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmcm9tVmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdzogZWFzZWRWYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB0b1ZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHBlcmNlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IGVhc2luZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYWNpYWxFYXNpbmc6IHNwZWNpYWxFYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBzdGVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHRpbWVTdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb2dyZXNzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3Moe30sIHBlcmNlbnQsIE1BVEgubWF4KDAsIGR1cmF0aW9uIC0gZWxhcHNlZCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TmV4dEFuaW1hdGlvbkluUShhbmltT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29tcGxldGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxT2JqLmZyYW1lID0gQ09NUEFUSUJJTElUWS5yQUYoKShmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcU9iai5mcmFtZSA9IENPTVBBVElCSUxJVFkuckFGKCkoZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uVmFsdWUoZWwsIGtleSwgdG9ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5leHRBbmltYXRpb25JblEoYW5pbU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChndWFyYW50ZWVkTmV4dClcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE5leHRBbmltYXRpb25JblEoYW5pbU9iaik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0b3AoZWwsIGNsZWFyUSwganVtcFRvRW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbU9iajtcclxuICAgICAgICAgICAgICAgIHZhciBxT2JqO1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgX2FuaW1hdGlvbnNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbU9iaiA9IF9hbmltYXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltT2JqLmVsID09PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbU9iai5xW0xFWElDT04ubF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxT2JqID0gYW5pbU9iai5xWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcU9iai5zdG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuY0FGKCkocU9iai5mcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltT2JqLnEuc3BsaWNlKDAsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdW1wVG9FbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gcU9iai5wcm9wcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uVmFsdWUoZWwsIGtleSwgcU9iai5wcm9wc1trZXldKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xlYXJRKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1PYmoucSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TmV4dEFuaW1hdGlvbkluUShhbmltT2JqLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBlbGVtZW50SXNWaXNpYmxlKGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISEoZWxbTEVYSUNPTi5vV10gfHwgZWxbTEVYSUNPTi5vSF0gfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKVtMRVhJQ09OLmxdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gRmFrZWpRdWVyeShzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tMRVhJQ09OLmxdID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gbmV3IEZha2VqUXVlcnkoKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsbXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF90eXBlKHNlbGVjdG9yKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IuY2hhckF0KDApID09PSAnPCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbXMgPSBlbC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZWxtc1tMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxtc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlKGVsZW1lbnRzKSAhPSBUWVBFUy5zICYmICghaXNBcnJheUxpa2UoZWxlbWVudHMpIHx8IGVsZW1lbnRzID09PSB3aW5kb3cgfHwgZWxlbWVudHMgPT09IGVsZW1lbnRzLnNlbGYpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50c1tMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VbaV0gPSBlbGVtZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVtMRVhJQ09OLmxdID0gZWxlbWVudHNbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIEZha2VqUXVlcnlbTEVYSUNPTi5wXSA9IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0VWRU5UUzpcclxuXHJcbiAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgX3N0ckVtcHR5KS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW19zdHJFbXB0eV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWVMZW5ndGggPSBldmVudE5hbWVbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnROYW1lTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lW2ldLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsLmRldGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBldmVudE5hbWVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZVtpXSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IF9zdHJFbXB0eSkubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtfc3RyRW1wdHldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lTGVuZ3RoID0gZXZlbnROYW1lW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZVtpXSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC5kZXRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnROYW1lTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWVbaV0sIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgb25lOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gKGV2ZW50TmFtZSB8fCBfc3RyRW1wdHkpLm1hdGNoKF9ybm90aHRtbHdoaXRlKSB8fCBbX3N0ckVtcHR5XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gRmFrZWpRdWVyeSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRmFrZWpRdWVyeS5lYWNoKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGksIG9uZUV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5vZmYob25lRXZlbnROYW1lLCBvbmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5vbihvbmVFdmVudE5hbWUsIG9uZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmZpcmVFdmVudCgnb24nICsgZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvL0RPTSBOT0RFIElOU0VSVElORyAvIFJFTU9WSU5HOlxyXG5cclxuICAgICAgICAgICAgICAgIGFwcGVuZDogZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IGluc2VydEFkamFjZW50RWxlbWVudCh0aGlzLCAnYmVmb3JlZW5kJywgY2hpbGQpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcHJlcGVuZDogZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IGluc2VydEFkamFjZW50RWxlbWVudCh0aGlzLCAnYWZ0ZXJiZWdpbicsIGNoaWxkKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGJlZm9yZTogZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IGluc2VydEFkamFjZW50RWxlbWVudCh0aGlzLCAnYmVmb3JlYmVnaW4nLCBjaGlsZCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBhZnRlcjogZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IGluc2VydEFkamFjZW50RWxlbWVudCh0aGlzLCAnYWZ0ZXJlbmQnLCBjaGlsZCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQXJyYXkocGFyZW50LCBwYXJlbnRzKSA9PT0gLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnRzW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHBhcmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbC5maXJzdENoaWxkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShlbC5maXJzdENoaWxkLCBlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgd3JhcEFsbDogZnVuY3Rpb24gKHdyYXBwZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IEZha2VqUXVlcnkod3JhcHBlckhUTUwpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWVwZXN0ID0gd3JhcHBlcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZXNbMF0ucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gbm9kZXNbMF0ucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkZWVwZXN0LmNoaWxkTm9kZXNbTEVYSUNPTi5sXSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBlc3QgPSBkZWVwZXN0LmNoaWxkTm9kZXNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IG5vZGVzW0xFWElDT04ubF0gLSBpOyBkZWVwZXN0LmZpcnN0Q2hpbGQgPT09IG5vZGVzWzBdICYmIGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVlcGVzdC5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IHByZXZpb3VzU2libGluZyA/IHByZXZpb3VzU2libGluZy5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUod3JhcHBlciwgbmV4dFNpYmxpbmcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgd3JhcElubmVyOiBmdW5jdGlvbiAod3JhcHBlckhUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gRmFrZWpRdWVyeSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gZWwuY29udGVudHMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50c1tMRVhJQ09OLmxdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudHMud3JhcEFsbCh3cmFwcGVySFRNTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZCh3cmFwcGVySFRNTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHdyYXA6IGZ1bmN0aW9uICh3cmFwcGVySFRNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBGYWtlalF1ZXJ5KHRoaXMpLndyYXBBbGwod3JhcHBlckhUTUwpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vRE9NIE5PREUgTUFOSVBVTEFUSU9OIC8gSU5GT1JNQVRJT046XHJcblxyXG4gICAgICAgICAgICAgICAgY3NzOiBmdW5jdGlvbiAoc3R5bGVzLCB2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3B0U3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldENwdFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlKHN0eWxlcykgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwdFN0eWxlID0gZ2V0Q3B0U3R5bGUgPyBnZXRDcHRTdHlsZShlbCwgbnVsbCkgOiBlbC5jdXJyZW50U3R5bGVbc3R5bGVzXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2h0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5NyBjYW4gYmUgbnVsbCBzb21ldGltZXMgaWYgaWZyYW1lIHdpdGggZGlzcGxheTogbm9uZSAoZmlyZWZveCBvbmx5ISlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDcHRTdHlsZSA/IGNwdFN0eWxlICE9IG51bGwgPyBjcHRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlcykgOiBlbFtMRVhJQ09OLnNdW3N0eWxlc10gOiBjcHRTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENTU1ZhbCh0aGlzLCBzdHlsZXMsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdHlsZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q1NTVmFsKHRoaXMsIGtleSwgc3R5bGVzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0sIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVQcmVwYXJlZCA9IF9zdHJTcGFjZSArIGNsYXNzTmFtZSArIF9zdHJTcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NMaXN0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0aGlzW2krK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKF9zdHJTcGFjZSArIHN0cmlwQW5kQ29sbGFwc2UoZWxlbS5jbGFzc05hbWUgKyBfc3RyRW1wdHkpICsgX3N0clNwYWNlKS5pbmRleE9mKGNsYXNzTmFtZVByZXBhcmVkKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXp6O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0Q2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbG1DbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzID0gY2xhc3NOYW1lLm1hdGNoKF9ybm90aHRtbHdoaXRlKSB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbUNsYXNzTGlzdCA9IGVsZW0uY2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRDbGFzc0xpc3QgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0Q2xhc3NMaXN0ID0gZWxtQ2xhc3NMaXN0ICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRDbGFzc0xpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNsYXp6ID0gY2xhc3Nlc1t2KytdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtQ2xhc3NMaXN0LmFkZChjbGF6eik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJWYWx1ZSA9IGVsZW0uY2xhc3NOYW1lICsgX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKF9zdHJTcGFjZSArIHN0cmlwQW5kQ29sbGFwc2UoY3VyVmFsdWUpICsgX3N0clNwYWNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNsYXp6ID0gY2xhc3Nlc1t2KytdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIuaW5kZXhPZihfc3RyU3BhY2UgKyBjbGF6eiArIF9zdHJTcGFjZSkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciArPSBjbGF6eiArIF9zdHJTcGFjZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1clZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGF6ejtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3VwcG9ydENsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxtQ2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0aGlzW2krK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG1DbGFzc0xpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0Q2xhc3NMaXN0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydENsYXNzTGlzdCA9IGVsbUNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0Q2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbdisrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbUNsYXNzTGlzdC5yZW1vdmUoY2xhenopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVmFsdWUgPSBlbGVtLmNsYXNzTmFtZSArIF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmIChfc3RyU3BhY2UgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIF9zdHJTcGFjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbdisrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YoX3N0clNwYWNlICsgY2xhenogKyBfc3RyU3BhY2UpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoX3N0clNwYWNlICsgY2xhenogKyBfc3RyU3BhY2UsIF9zdHJTcGFjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZShjdXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyB0aGlzW0xFWElDT04uc10uZGlzcGxheSA9ICdub25lJzsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgdGhpc1tMRVhJQ09OLnNdLmRpc3BsYXkgPSAnYmxvY2snOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgYXR0cjogZnVuY3Rpb24gKGF0dHJOYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsID0gdGhpc1tpKytdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKGF0dHJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIG9mZnNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBlbFtMRVhJQ09OLmJDUl0oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbX3N0clNjcm9sbExlZnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W19zdHJTY3JvbGxUb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyBzY3JvbGxUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHNjcm9sbExlZnRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBlbC5vZmZzZXRUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGVsLm9mZnNldExlZnRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbCA9IHRoaXNbaSsrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbFtfc3RyU2Nyb2xsTGVmdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW19zdHJTY3JvbGxMZWZ0XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbCA9IHRoaXNbaSsrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbFtfc3RyU2Nyb2xsVG9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxbX3N0clNjcm9sbFRvcF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHZhbDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vRE9NIFRSQVZFUlNBTCAvIEZJTFRFUklORzpcclxuXHJcbiAgICAgICAgICAgICAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKDApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBlcTogZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZha2VqUXVlcnkodGhpc1tpbmRleCA+PSAwID8gaW5kZXggOiB0aGlzW0xFWElDT04ubF0gKyBpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5KGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2g7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBjaFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWwubWF0Y2hlcyAmJiBlbC5tYXRjaGVzKHNlbGVjdG9yKSkgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5KGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPyBGYWtlalF1ZXJ5KHBhcmVudCkuaXMoc2VsZWN0b3IpIDogdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5KHBhcmVudHMpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBpczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICc6dmlzaWJsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZShlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gJzpoaWRkZW4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlbGVtZW50SXNWaXNpYmxlKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbC5tYXRjaGVzICYmIGVsLm1hdGNoZXMoc2VsZWN0b3IpKSB8fCBtYXRjaGVzKGVsLCBzZWxlY3RvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcyA9IHRoaXMuY2hpbGROb2RlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkc1tMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50cy5wdXNoKGNoaWxkc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5KGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVhY2godGhpcywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9BTklNQVRJT046XHJcblxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHByb3BzLCBkdXJhdGlvbiwgZWFzaW5nLCBjb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBhbmltYXRlKHRoaXMsIHByb3BzLCBkdXJhdGlvbiwgZWFzaW5nLCBjb21wbGV0ZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoY2xlYXJRLCBqdW1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHN0b3AodGhpcywgY2xlYXJRLCBqdW1wKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBleHRlbmQoRmFrZWpRdWVyeSwge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kOiBleHRlbmQsXHJcbiAgICAgICAgICAgICAgICBpbkFycmF5OiBpbkFycmF5LFxyXG4gICAgICAgICAgICAgICAgaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcclxuICAgICAgICAgICAgICAgIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXHJcbiAgICAgICAgICAgICAgICBlYWNoOiBlYWNoXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEZha2VqUXVlcnk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgICB2YXIgSU5TVEFOQ0VTID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90YXJnZXRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2VQcm9wZXJ0eVN0cmluZyA9ICdfX292ZXJsYXlTY3JvbGxiYXJzX18nO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVyLCB1bnJlZ2lzdGVyIG9yIGdldCBhIGNlcnRhaW4gKG9yIGFsbCkgaW5zdGFuY2VzLlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcjogUGFzcyB0aGUgdGFyZ2V0IGFuZCB0aGUgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqIFVucmVnaXN0ZXI6IFBhc3MgdGhlIHRhcmdldCBhbmQgbnVsbC5cclxuICAgICAgICAgICAgICogR2V0IEluc3RhbmNlOiBQYXNzIHRoZSB0YXJnZXQgZnJvbSB3aGljaCB0aGUgaW5zdGFuY2Ugc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgKiBHZXQgVGFyZ2V0czogUGFzcyBubyBhcmd1bWVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCB0byB3aGljaCB0aGUgaW5zdGFuY2Ugc2hhbGwgYmUgcmVnaXN0ZXJlZCAvIGZyb20gd2hpY2ggdGhlIGluc3RhbmNlIHNoYWxsIGJlIHVucmVnaXN0ZXJlZCAvIHRoZSBpbnN0YW5jZSBzaGFsbCBiZSBnb3RcclxuICAgICAgICAgICAgICogQHBhcmFtIGluc3RhbmNlIFRoZSBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp8dm9pZH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gdGFyZ2V0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJndW1lbnRzW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGFsbCB0YXJnZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90YXJnZXRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVnaXN0ZXIgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W19pbnN0YW5jZVByb3BlcnR5U3RyaW5nXSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBDT01QQVRJQklMSVRZLmluQSh0YXJnZXQsIF90YXJnZXRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91bnJlZ2lzdGVyIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldFtfaW5zdGFuY2VQcm9wZXJ0eVN0cmluZ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IGluc3RhbmNlIGZyb20gdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90YXJnZXRzW2luZGV4XVtfaW5zdGFuY2VQcm9wZXJ0eVN0cmluZ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHZhciBQTFVHSU4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3BsdWdpbjtcclxuICAgICAgICAgICAgdmFyIF9wbHVnaW5zR2xvYmFscztcclxuICAgICAgICAgICAgdmFyIF9wbHVnaW5zQXV0b1VwZGF0ZUxvb3A7XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luc0V4dGVuc2lvbnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIF9wbHVnaW5zT3B0aW9ucyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IENPTVBBVElCSUxJVFkudHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZVRlbXBsYXRlVHlwZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMuYiwgLy9ib29sZWFuXHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMubiwgLy9udW1iZXJcclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5zLCAvL3N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLmEsIC8vYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5vLCAvL29iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLmYsIC8vZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy56ICAvL251bGxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdHJpY3RlZFN0cmluZ3NTcGxpdCA9ICcgJztcclxuICAgICAgICAgICAgICAgIHZhciByZXN0cmljdGVkU3RyaW5nc1Bvc3NpYmlsaXRpZXNTcGxpdCA9ICc6JztcclxuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVBbGxvd2VkVmFsdWVzID0gW1RZUEVTLnosIFRZUEVTLnNdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bWJlckFsbG93ZWRWYWx1ZXMgPSBUWVBFUy5uO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvb2xlYW5OdWxsQWxsb3dlZFZhbHVlcyA9IFtUWVBFUy56LCBUWVBFUy5iXTtcclxuICAgICAgICAgICAgICAgIHZhciBib29sZWFuVHJ1ZVRlbXBsYXRlID0gW3RydWUsIFRZUEVTLmJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvb2xlYW5GYWxzZVRlbXBsYXRlID0gW2ZhbHNlLCBUWVBFUy5iXTtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja1RlbXBsYXRlID0gW251bGwsIFtUWVBFUy56LCBUWVBFUy5mXV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlT25Mb2FkVGVtcGxhdGUgPSBbWydpbWcnXSwgW1RZUEVTLnMsIFRZUEVTLmEsIFRZUEVTLnpdXTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmhlcml0ZWRBdHRyc1RlbXBsYXRlID0gW1snc3R5bGUnLCAnY2xhc3MnXSwgW1RZUEVTLnMsIFRZUEVTLmEsIFRZUEVTLnpdXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXNpemVBbGxvd2VkVmFsdWVzID0gJ246bm9uZSBiOmJvdGggaDpob3Jpem9udGFsIHY6dmVydGljYWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3JBbGxvd2VkVmFsdWVzID0gJ3YtaDp2aXNpYmxlLWhpZGRlbiB2LXM6dmlzaWJsZS1zY3JvbGwgczpzY3JvbGwgaDpoaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNWaXNpYmlsaXR5QWxsb3dlZFZhbHVlcyA9ICd2OnZpc2libGUgaDpoaWRkZW4gYTphdXRvJztcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzQXV0b0hpZGVBbGxvd2VkVmFsdWVzID0gJ246bmV2ZXIgczpzY3JvbGwgbDpsZWF2ZSBtOm1vdmUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnNEZWZhdWx0c0FuZFRlbXBsYXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogWydvcy10aGVtZS1kYXJrJywgY2xhc3NOYW1lQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICByZXNpemU6IFsnbm9uZScsIHJlc2l6ZUFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vbmUgfHwgYm90aCAgfHwgaG9yaXpvbnRhbCB8fCB2ZXJ0aWNhbCB8fCBuIHx8IGIgfHwgaCB8fCB2XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUF1dG9DYXBhYmxlOiBib29sZWFuVHJ1ZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpcEFsd2F5czogYm9vbGVhblRydWVUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplUlRMOiBib29sZWFuVHJ1ZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0Fic29sdXRlOiBib29sZWFuRmFsc2VUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZTogW251bGwsIGJvb2xlYW5OdWxsQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlIHx8IG51bGxcclxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlSW50ZXJ2YWw6IFszMywgbnVtYmVyQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgICAgICAgICAgICAvL251bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU9uTG9hZDogdXBkYXRlT25Mb2FkVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RyaW5nIHx8IGFycmF5IHx8IG51bGxcclxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd05hdGl2ZVNjcm9sbGJhcnM6IGJvb2xlYW5GYWxzZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZTogYm9vbGVhblRydWVUZW1wbGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QmVoYXZpb3I6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogWydzY3JvbGwnLCBvdmVyZmxvd0JlaGF2aW9yQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgICAgICAgICAvL3Zpc2libGUtaGlkZGVuICB8fCB2aXNpYmxlLXNjcm9sbCB8fCBoaWRkZW4gfHwgc2Nyb2xsIHx8IHYtaCB8fCB2LXMgfHwgaCB8fCBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IFsnc2Nyb2xsJywgb3ZlcmZsb3dCZWhhdmlvckFsbG93ZWRWYWx1ZXNdICAgICAgICAgICAgICAgICAgICAgLy92aXNpYmxlLWhpZGRlbiAgfHwgdmlzaWJsZS1zY3JvbGwgfHwgaGlkZGVuIHx8IHNjcm9sbCB8fCB2LWggfHwgdi1zIHx8IGggfHwgc1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBbJ2F1dG8nLCBzY3JvbGxiYXJzVmlzaWJpbGl0eUFsbG93ZWRWYWx1ZXNdLCAgICAgICAgIC8vdmlzaWJsZSB8fCBoaWRkZW4gfHwgYXV0byB8fCB2IHx8IGggfHwgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvSGlkZTogWyduZXZlcicsIHNjcm9sbGJhcnNBdXRvSGlkZUFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgIC8vbmV2ZXIgfHwgc2Nyb2xsIHx8IGxlYXZlIHx8IG1vdmUgfHwgbiB8fCBzIHx8IGwgfHwgbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvSGlkZURlbGF5OiBbODAwLCBudW1iZXJBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAgICAgICAgICAgIC8vbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdTY3JvbGxpbmc6IGJvb2xlYW5UcnVlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrU2Nyb2xsaW5nOiBib29sZWFuRmFsc2VUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoU3VwcG9ydDogYm9vbGVhblRydWVUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBIYW5kbGU6IGJvb2xlYW5GYWxzZVRlbXBsYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5XaWR0aDogYm9vbGVhbkZhbHNlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5IZWlnaHQ6IGJvb2xlYW5GYWxzZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0ZWRBdHRyczogaW5oZXJpdGVkQXR0cnNUZW1wbGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RyaW5nIHx8IGFycmF5IHx8IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkluaXRpYWxpemVkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkluaXRpYWxpemF0aW9uV2l0aGRyYXduOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRlc3Ryb3llZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbFN0YXJ0OiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbFN0b3A6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk92ZXJmbG93Q2hhbmdlZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk92ZXJmbG93QW1vdW50Q2hhbmdlZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdGlvbkNoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbnRlbnRTaXplQ2hhbmdlZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkhvc3RTaXplQ2hhbmdlZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZWQ6IGNhbGxiYWNrVGVtcGxhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbnVsbCB8fCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN1cnNpdmUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2JqW0xFWElDT04uaE9QXShrZXkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxUeXBlID0gdHlwZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbFR5cGUgPT0gVFlQRVMuYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbFt0ZW1wbGF0ZSA/IDEgOiAwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbFR5cGUgPT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHJlY3Vyc2l2ZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzaXZlKEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnNEZWZhdWx0c0FuZFRlbXBsYXRlKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRzOiBjb252ZXJ0KCksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF90ZW1wbGF0ZTogY29udmVydCh0cnVlKSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVmFsaWRhdGVzIHRoZSBwYXNzZWQgb2JqZWN0IGJ5IHRoZSBwYXNzZWQgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHdoaWNoIHNoYWxsIGJlIHZhbGlkYXRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdGVtcGxhdGUgVGhlIHRlbXBsYXRlIHdoaWNoIGRlZmluZXMgdGhlIGFsbG93ZWQgdmFsdWVzIGFuZCB0eXBlcy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gd3JpdGVFcnJvcnMgVHJ1ZSBpZiBlcnJvcnMgc2hhbGwgYmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkaWZmT2JqIElmIGEgb2JqZWN0IGlzIHBhc3NlZCB0aGVuIG9ubHkgdmFsaWQgZGlmZmVyZW5jZXMgdG8gdGhpcyBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e319IEEgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHR3byBvYmplY3RzIGNhbGxlZCBcImRlZmF1bHRcIiBhbmQgXCJwcmVwYXJlZFwiIHdoaWNoIGNvbnRhaW5zIG9ubHkgdGhlIHZhbGlkIHByb3BlcnRpZXMgb2YgdGhlIHBhc3NlZCBvcmlnaW5hbCBvYmplY3QgYW5kIGRpc2NhcmRzIG5vdCBkaWZmZXJlbnQgdmFsdWVzIGNvbXBhcmVkIHRvIHRoZSBwYXNzZWQgZGlmZk9iai5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBfdmFsaWRhdGU6IGZ1bmN0aW9uIChvYmosIHRlbXBsYXRlLCB3cml0ZUVycm9ycywgZGlmZk9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RDb3B5ID0gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluQXJyYXkgPSBGUkFNRVdPUksuaW5BcnJheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRW1wdHlPYmogPSBGUkFNRVdPUksuaXNFbXB0eU9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrT2JqZWN0UHJvcHMgPSBmdW5jdGlvbiAoZGF0YSwgdGVtcGxhdGUsIGRpZmZEYXRhLCB2YWxpZGF0ZWRPcHRpb25zLCB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWQsIHByZXZQcm9wTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVtMRVhJQ09OLmhPUF0ocHJvcCkgJiYgZGF0YVtMRVhJQ09OLmhPUF0ocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRGlmZiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVWYWx1ZSA9IHRlbXBsYXRlW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVWYWx1ZVR5cGUgPSB0eXBlKHRlbXBsYXRlVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVJc0NvbXBsZXggPSB0ZW1wbGF0ZVZhbHVlVHlwZSA9PSBUWVBFUy5vO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVUeXBlcyA9ICFDT01QQVRJQklMSVRZLmlzQSh0ZW1wbGF0ZVZhbHVlKSA/IFt0ZW1wbGF0ZVZhbHVlXSA6IHRlbXBsYXRlVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhRGlmZlZhbHVlID0gZGlmZkRhdGFbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVmFsdWUgPSBkYXRhW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVZhbHVlVHlwZSA9IHR5cGUoZGF0YVZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BQcmVmaXggPSBwcmV2UHJvcE5hbWUgPyBwcmV2UHJvcE5hbWUgKyAnLicgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gXCJUaGUgb3B0aW9uIFxcXCJcIiArIHByb3BQcmVmaXggKyBwcm9wICsgXCJcXFwiIHdhc24ndCBzZXQsIGJlY2F1c2VcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yUG9zc2libGVUeXBlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JSZXN0cmljdGVkU3RyaW5ncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1NwbGl0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzUmVzdHJpY3RlZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFpblBvc3NpYmlsaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGo7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhRGlmZlZhbHVlID0gZGF0YURpZmZWYWx1ZSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhRGlmZlZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgdGVtcGxhdGUgaGFzIGEgb2JqZWN0IGFzIHZhbHVlLCBpdCBtZWFucyB0aGF0IHRoZSBvcHRpb25zIGFyZSBjb21wbGV4ICh2ZXJzY2hhY2h0ZWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVJc0NvbXBsZXggJiYgZGF0YVZhbHVlVHlwZSA9PSBUWVBFUy5vKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRPcHRpb25zW3Byb3BdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWRbcHJvcF0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrT2JqZWN0UHJvcHMoZGF0YVZhbHVlLCB0ZW1wbGF0ZVZhbHVlLCBkYXRhRGlmZlZhbHVlLCB2YWxpZGF0ZWRPcHRpb25zW3Byb3BdLCB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWRbcHJvcF0sIHByb3BQcmVmaXggKyBwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5lYWNoKFtkYXRhLCB2YWxpZGF0ZWRPcHRpb25zLCB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWRdLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHlPYmoodmFsdWVbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGVtcGxhdGVJc0NvbXBsZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wbGF0ZVR5cGVzW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJUeXBlID0gdGVtcGxhdGVUeXBlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVZhbHVlVHlwZSA9IHR5cGUoY3VyclR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgY3VycnR5cGUgaXMgc3RyaW5nIGFuZCBzdGFydHMgd2l0aCByZXN0cmljdGVkU3RyaW5nUHJlZml4IGFuZCBlbmQgd2l0aCByZXN0cmljdGVkU3RyaW5nU3VmZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXN0cmljdGVkVmFsdWUgPSB0ZW1wbGF0ZVZhbHVlVHlwZSA9PSBUWVBFUy5zICYmIGluQXJyYXkoY3VyclR5cGUsIHBvc3NpYmxlVGVtcGxhdGVUeXBlcykgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclBvc3NpYmxlVHlwZXMucHVzaChUWVBFUy5zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3BsaXQgaXQgaW50byBhIGFycmF5IHdoaWNoIGNvbnRhaW5zIGFsbCBwb3NzaWJsZSB2YWx1ZXMgZm9yIGV4YW1wbGU6IFtcInk6eWVzXCIsIFwibjpub1wiLCBcIm06bWF5YmVcIl1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1NwbGl0ID0gY3VyclR5cGUuc3BsaXQocmVzdHJpY3RlZFN0cmluZ3NTcGxpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVzdHJpY3RlZFN0cmluZ3MgPSBlcnJvclJlc3RyaWN0ZWRTdHJpbmdzLmNvbmNhdChyZXN0cmljdGVkU3RyaW5nVmFsdWVzU3BsaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDwgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1NwbGl0W0xFWElDT04ubF07IHYrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zcGxpdCB0aGUgcG9zc2libGUgdmFsdWVzIGludG8gdGhlaXIgcG9zc2liaWxpdGVpcyBmb3IgZXhhbXBsZTogW1wieVwiLCBcInllc1wiXSAtPiB0aGUgZmlyc3QgaXMgYWx3YXlzIHRoZSBtYWluUG9zc2liaWxpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXQgPSByZXN0cmljdGVkU3RyaW5nVmFsdWVzU3BsaXRbdl0uc3BsaXQocmVzdHJpY3RlZFN0cmluZ3NQb3NzaWJpbGl0aWVzU3BsaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpblBvc3NpYmlsaXR5ID0gcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0W0xFWElDT04ubF07IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgYW55IHBvc3NpYmlsaXR5IG1hdGNoZXMgd2l0aCB0aGUgZGF0YVZhbHVlLCBpdHMgdmFsaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZhbHVlID09PSByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0W2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JQb3NzaWJsZVR5cGVzLnB1c2goY3VyclR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWYWx1ZVR5cGUgPT09IGN1cnJUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEaWZmID0gZGF0YVZhbHVlICE9PSBkYXRhRGlmZlZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaWZmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRPcHRpb25zW3Byb3BdID0gZGF0YVZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkVmFsdWUgPyBpbkFycmF5KGRhdGFEaWZmVmFsdWUsIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXQpIDwgMCA6IGlzRGlmZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkW3Byb3BdID0gaXNSZXN0cmljdGVkVmFsdWUgPyBtYWluUG9zc2liaWxpdHkgOiBkYXRhVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh3cml0ZUVycm9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvciArIFwiIGl0IGRvZXNuJ3QgYWNjZXB0IHRoZSB0eXBlIFsgXCIgKyBkYXRhVmFsdWVUeXBlLnRvVXBwZXJDYXNlKCkgKyBcIiBdIHdpdGggdGhlIHZhbHVlIG9mIFxcXCJcIiArIGRhdGFWYWx1ZSArIFwiXFxcIi5cXHJcXG5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQWNjZXB0ZWQgdHlwZXMgYXJlOiBbIFwiICsgZXJyb3JQb3NzaWJsZVR5cGVzLmpvaW4oJywgJykudG9VcHBlckNhc2UoKSArIFwiIF0uXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3JSZXN0cmljdGVkU3RyaW5nc1tsZW5ndGhdID4gMCA/IFwiXFxyXFxuVmFsaWQgc3RyaW5ncyBhcmU6IFsgXCIgKyBlcnJvclJlc3RyaWN0ZWRTdHJpbmdzLmpvaW4oJywgJykuc3BsaXQocmVzdHJpY3RlZFN0cmluZ3NQb3NzaWJpbGl0aWVzU3BsaXQpLmpvaW4oJywgJykgKyBcIiBdLlwiIDogJycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja09iamVjdFByb3BzKG9iamVjdENvcHksIHRlbXBsYXRlLCBkaWZmT2JqIHx8IHt9LCB2YWxpZGF0ZWRPcHRpb25zLCB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgdmFsdWVzIHdoaWNoIGFyZW4ndCBzcGVjaWZpZWQgaW4gdGhlIHRlbXBsYXRlIHRvIHRoZSBmaW5pc2hlZCB2YWxpZGF0ZWQgb2JqZWN0IHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlaW5nIGRpc2NhcmRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihrZWVwRm9yZWlnblByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHZhbGlkYXRlZE9wdGlvbnMsIG9iamVjdENvcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWQsIG9iamVjdENvcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmoob2JqZWN0Q29weSkgJiYgd3JpdGVFcnJvcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgZGlzY2FyZGVkIGR1ZSB0byBpbnZhbGlkaXR5OlxcclxcbicgKyB3aW5kb3cuSlNPTi5zdHJpbmdpZnkob2JqZWN0Q29weSwgbnVsbCwgMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0OiB2YWxpZGF0ZWRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ByZXBhcmVkOiB2YWxpZGF0ZWRPcHRpb25zUHJlcGFyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0oKSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIG9iamVjdCB3aGljaCBjb250YWlucyBnbG9iYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBsdWdpbiBhbmQgZWFjaCBpbnN0YW5jZSBvZiBpdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXRPdmVybGF5U2Nyb2xsYmFyc1N0YXRpY3MoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV9wbHVnaW5zR2xvYmFscylcclxuICAgICAgICAgICAgICAgICAgICBfcGx1Z2luc0dsb2JhbHMgPSBuZXcgT3ZlcmxheVNjcm9sbGJhcnNHbG9iYWxzKF9wbHVnaW5zT3B0aW9ucy5fZGVmYXVsdHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfcGx1Z2luc0F1dG9VcGRhdGVMb29wKVxyXG4gICAgICAgICAgICAgICAgICAgIF9wbHVnaW5zQXV0b1VwZGF0ZUxvb3AgPSBuZXcgT3ZlcmxheVNjcm9sbGJhcnNBdXRvVXBkYXRlTG9vcChfcGx1Z2luc0dsb2JhbHMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGdsb2JhbCBvYmplY3QgZm9yIHRoZSBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3RzLiBJdCBjb250YWlucyByZXNvdXJjZXMgd2hpY2ggZXZlcnkgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0IG5lZWRzLiBUaGlzIG9iamVjdCBpcyBpbml0aWFsaXplZCBvbmx5IG9uY2U6IGlmIHRoZSBmaXJzdCBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3QgZ2V0cyBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIGRlZmF1bHRPcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gT3ZlcmxheVNjcm9sbGJhcnNHbG9iYWxzKGRlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Jhc2UgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ck92ZXJmbG93ID0gJ292ZXJmbG93JztcclxuICAgICAgICAgICAgICAgIHZhciBzdHJIaWRkZW4gPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZhciBzdHJTY3JvbGwgPSAnc2Nyb2xsJztcclxuICAgICAgICAgICAgICAgIHZhciBib2R5RWxlbWVudCA9IEZSQU1FV09SSygnYm9keScpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhckR1bW15RWxlbWVudCA9IEZSQU1FV09SSygnPGRpdiBpZD1cIm9zLWR1bW15LXNjcm9sbGJhci1zaXplXCI+PGRpdj48L2Rpdj48L2Rpdj4nKTtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJEdW1teUVsZW1lbnQwID0gc2Nyb2xsYmFyRHVtbXlFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR1bW15Q29udGFpbmVyQ2hpbGQgPSBGUkFNRVdPUksoc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmNoaWxkcmVuKCdkaXYnKS5lcSgwKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm9keUVsZW1lbnQuYXBwZW5kKHNjcm9sbGJhckR1bW15RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuaGlkZSgpLnNob3coKTsgLy9maXggSUU4IGJ1ZyAoaW5jb3JyZWN0IG1lYXN1cmluZylcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlU2Nyb2xsYmFyU2l6ZSA9IGNhbGNOYXRpdmVTY3JvbGxiYXJTaXplKHNjcm9sbGJhckR1bW15RWxlbWVudDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogbmF0aXZlU2Nyb2xsYmFyU2l6ZS54ID09PSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IG5hdGl2ZVNjcm9sbGJhclNpemUueSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBtc2llID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RySW5kZXhPZiA9ICdpbmRleE9mJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyU3ViU3RyaW5nID0gJ3N1YnN0cmluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zaWUgPSB1YVtzdHJJbmRleE9mXSgnTVNJRSAnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpZGVudCA9IHVhW3N0ckluZGV4T2ZdKCdUcmlkZW50LycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gdWFbc3RySW5kZXhPZl0oJ0VkZ2UvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ2ID0gdWFbc3RySW5kZXhPZl0oJ3J2OicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlSW50RnVuYyA9IHBhcnNlSW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAobXNpZSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50RnVuYyh1YVtzdHJTdWJTdHJpbmddKG1zaWUgKyA1LCB1YVtzdHJJbmRleE9mXSgnLicsIG1zaWUpKSwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJRSAxMSA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmlkZW50ID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnRGdW5jKHVhW3N0clN1YlN0cmluZ10ocnYgKyAzLCB1YVtzdHJJbmRleE9mXSgnLicsIHJ2KSksIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWRnZSAoSUUgMTIrKSA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlZGdlID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnRGdW5jKHVhW3N0clN1YlN0cmluZ10oZWRnZSArIDUsIHVhW3N0ckluZGV4T2ZdKCcuJywgZWRnZSkpLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIGJyb3dzZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBGUkFNRVdPUksuZXh0ZW5kKF9iYXNlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIG1zaWU6IG1zaWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZUxvb3A6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGVSZWNvbW1lbmRlZDogIUNPTVBBVElCSUxJVFkubU8oKSxcclxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJTaXplOiBuYXRpdmVTY3JvbGxiYXJTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQ6IG5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFyU3R5bGluZzogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuYWRkQ2xhc3MoJ29zLXZpZXdwb3J0LW5hdGl2ZS1zY3JvbGxiYXJzLWludmlzaWJsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHNjcm9sbGJhckR1bW15RWxlbWVudC5jc3MoJ3Njcm9sbGJhci13aWR0aCcpID09PSAnbm9uZScgJiYgKG1zaWUgPiA5IHx8ICFtc2llKSkgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2Nyb2xsYmFyRHVtbXlFbGVtZW50MCwgJzo6LXdlYmtpdC1zY3JvbGxiYXInKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgPT09ICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHsgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9maXggb3BlcmEgYnVnOiBzY3JvbGxiYXIgc3R5bGVzIHdpbGwgb25seSBhcHBlYXIgaWYgb3ZlcmZsb3cgdmFsdWUgaXMgc2Nyb2xsIG9yIGF1dG8gZHVyaW5nIHRoZSBhY3RpdmF0aW9uIG9mIHRoZSBzdHlsZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hbmQgc2V0IG92ZXJmbG93IHRvIHNjcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhckR1bW15RWxlbWVudC5jc3Moc3RyT3ZlcmZsb3csIHN0ckhpZGRlbikuaGlkZSgpLmNzcyhzdHJPdmVyZmxvdywgc3RyU2Nyb2xsKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIChzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04ub0hdIC0gc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLmNIXSkgPT09IDAgJiYgKHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5vV10gLSBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uY1ddKSA9PT0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplOiB7IHg6IDMwLCB5OiAzMCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNzc0NhbGM6IFZFTkRPUlMuX2Nzc1Byb3BlcnR5VmFsdWUoJ3dpZHRoJywgJ2NhbGMnLCAnKDFweCknKSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWRNZWFzdXJpbmc6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQzOTMwNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIDEuMTEuMCBhbHdheXMgZmFsc2UgLT4gZml4ZWQgdmlhIENTUyAoaG9wZWZ1bGx5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKHN0ck92ZXJmbG93LCBzdHJIaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5zV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uc0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5jc3Moc3RyT3ZlcmZsb3csICd2aXNpYmxlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxTaXplMiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5zV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uc0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoc2Nyb2xsU2l6ZS53IC0gc2Nyb2xsU2l6ZTIudykgIT09IDAgfHwgKHNjcm9sbFNpemUuaCAtIHNjcm9sbFNpemUyLmgpICE9PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAgICAgcnRsU2Nyb2xsQmVoYXZpb3I6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5jc3MoeyAnb3ZlcmZsb3cteSc6IHN0ckhpZGRlbiwgJ292ZXJmbG93LXgnOiBzdHJTY3JvbGwsICdkaXJlY3Rpb24nOiAncnRsJyB9KS5zY3JvbGxMZWZ0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVtbXlDb250YWluZXJPZmZzZXQgPSBzY3JvbGxiYXJEdW1teUVsZW1lbnQub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0ID0gZHVtbXlDb250YWluZXJDaGlsZC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmEvT3ZlcmxheVNjcm9sbGJhcnMvaXNzdWVzLzE4N1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuc2Nyb2xsTGVmdCgtOTk5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXRBZnRlclNjcm9sbCA9IGR1bW15Q29udGFpbmVyQ2hpbGQub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29yaWdpbiBkaXJlY3Rpb24gPSBkZXRlcm1pbmVzIGlmIHRoZSB6ZXJvIHNjcm9sbCBwb3NpdGlvbiBpcyBvbiB0aGUgbGVmdCBvciByaWdodCBzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLydpJyBtZWFucyAnaW52ZXJ0JyAoaSA9PT0gdHJ1ZSBtZWFucyB0aGF0IHRoZSBheGlzIG11c3QgYmUgaW52ZXJ0ZWQgdG8gYmUgY29ycmVjdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSA9IG9uIHRoZSBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmFsc2UgPSBvbiB0aGUgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTogZHVtbXlDb250YWluZXJPZmZzZXQubGVmdCA9PT0gZHVtbXlDb250YWluZXJDaGlsZE9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9uZWdhdGl2ZSA9IGRldGVybWluZXMgaWYgdGhlIG1heGltdW0gc2Nyb2xsIGlzIHBvc2l0aXZlIG9yIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyduJyBtZWFucyAnbmVnYXRlJyAobiA9PT0gdHJ1ZSBtZWFucyB0aGF0IHRoZSBheGlzIG11c3QgYmUgbmVnYXRlZCB0byBiZSBjb3JyZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlID0gbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmFsc2UgPSBwb3NpdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogZHVtbXlDb250YWluZXJDaGlsZE9mZnNldC5sZWZ0ICE9PSBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0QWZ0ZXJTY3JvbGwubGVmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydFRyYW5zZm9ybTogISFWRU5ET1JTLl9jc3NQcm9wZXJ0eSgndHJhbnNmb3JtJyksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydFRyYW5zaXRpb246ICEhVkVORE9SUy5fY3NzUHJvcGVydHkoJ3RyYW5zaXRpb24nKSxcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0UGFzc2l2ZUV2ZW50czogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0UmVzaXplT2JzZXJ2ZXI6ICEhQ09NUEFUSUJJTElUWS5yTygpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRNdXRhdGlvbk9ic2VydmVyOiAhIUNPTVBBVElCSUxJVFkubU8oKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LnJlbW92ZUF0dHIoTEVYSUNPTi5zKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NhdGNoIHpvb20gZXZlbnQ6XHJcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhYnMgPSBNQVRILmFicztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93V2lkdGggPSBDT01QQVRJQklMSVRZLndXKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd0hlaWdodCA9IENPTVBBVElCSUxJVFkud0goKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93RHByID0gZ2V0V2luZG93RFBSKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSU5TVEFOQ0VTKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1cgPSBDT01QQVRJQklMSVRZLndXKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SCA9IENPTVBBVElCSUxJVFkud0goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVcgPSBuZXdXIC0gd2luZG93V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFIID0gbmV3SCAtIHdpbmRvd0hlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFXID09PSAwICYmIGRlbHRhSCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhV1JhdGlvID0gTUFUSC5yb3VuZChuZXdXIC8gKHdpbmRvd1dpZHRoIC8gMTAwLjApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YUhSYXRpbyA9IE1BVEgucm91bmQobmV3SCAvICh3aW5kb3dIZWlnaHQgLyAxMDAuMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFic0RlbHRhVyA9IGFicyhkZWx0YVcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFic0RlbHRhSCA9IGFicyhkZWx0YUgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFic0RlbHRhV1JhdGlvID0gYWJzKGRlbHRhV1JhdGlvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNEZWx0YUhSYXRpbyA9IGFicyhkZWx0YUhSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RFBSID0gZ2V0V2luZG93RFBSKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhSXNCaWdnZXIgPSBhYnNEZWx0YVcgPiAyICYmIGFic0RlbHRhSCA+IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICFkaWZmZXJlbmNlSXNCaWdnZXJUaGFuT25lKGFic0RlbHRhV1JhdGlvLCBhYnNEZWx0YUhSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHByQ2hhbmdlZCA9IG5ld0RQUiAhPT0gd2luZG93RHByICYmIHdpbmRvd0RwciA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNab29tID0gZGVsdGFJc0JpZ2dlciAmJiBkaWZmZXJlbmNlICYmIGRwckNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkU2Nyb2xsYmFyU2l6ZSA9IF9iYXNlLm5hdGl2ZVNjcm9sbGJhclNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2Nyb2xsYmFyU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNab29tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUVsZW1lbnQuYXBwZW5kKHNjcm9sbGJhckR1bW15RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2Nyb2xsYmFyU2l6ZSA9IF9iYXNlLm5hdGl2ZVNjcm9sbGJhclNpemUgPSBjYWxjTmF0aXZlU2Nyb2xsYmFyU2l6ZShzY3JvbGxiYXJEdW1teUVsZW1lbnRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkU2Nyb2xsYmFyU2l6ZS54ICE9PSBuZXdTY3JvbGxiYXJTaXplLnggfHwgb2xkU2Nyb2xsYmFyU2l6ZS55ICE9PSBuZXdTY3JvbGxiYXJTaXplLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmVhY2goSU5TVEFOQ0VTKCksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJTlNUQU5DRVModGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5TVEFOQ0VTKHRoaXMpLnVwZGF0ZSgnem9vbScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93V2lkdGggPSBuZXdXO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SGVpZ2h0ID0gbmV3SDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0RwciA9IG5ld0RQUjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpZmZlcmVuY2VJc0JpZ2dlclRoYW5PbmUodmFsT25lLCB2YWxUd28pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFic1ZhbE9uZSA9IGFicyh2YWxPbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzVmFsVHdvID0gYWJzKHZhbFR3byk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKGFic1ZhbE9uZSA9PT0gYWJzVmFsVHdvIHx8IGFic1ZhbE9uZSArIDEgPT09IGFic1ZhbFR3byB8fCBhYnNWYWxPbmUgLSAxID09PSBhYnNWYWxUd28pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0V2luZG93RFBSKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZERQSSA9IHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc0RQSSA9IHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkgfHwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IChkRFBJIC8gc0RQSSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksod2luZG93KS5vbigncmVzaXplJywgb25SZXNpemUpO1xyXG4gICAgICAgICAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWxjTmF0aXZlU2Nyb2xsYmFyU2l6ZShtZWFzdXJlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1lYXN1cmVFbGVtZW50W0xFWElDT04ub0hdIC0gbWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jSF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG1lYXN1cmVFbGVtZW50W0xFWElDT04ub1ddIC0gbWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jV11cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIG9iamVjdCB3aGljaCBtYW5hZ2VzIHRoZSBhdXRvIHVwZGF0ZSBsb29wIGZvciBhbGwgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0cy4gVGhpcyBvYmplY3QgaXMgaW5pdGlhbGl6ZWQgb25seSBvbmNlOiBpZiB0aGUgZmlyc3QgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0IGdldHMgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gT3ZlcmxheVNjcm9sbGJhcnNBdXRvVXBkYXRlTG9vcChnbG9iYWxzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Jhc2UgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pbkFycmF5ID0gRlJBTUVXT1JLLmluQXJyYXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2dldE5vdyA9IENPTVBBVElCSUxJVFkubm93O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJBdXRvVXBkYXRlID0gJ2F1dG9VcGRhdGUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJBdXRvVXBkYXRlSW50ZXJ2YWwgPSBfc3RyQXV0b1VwZGF0ZSArICdJbnRlcnZhbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckxlbmd0aCA9IExFWElDT04ubDtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcGluZ0luc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29waW5nSW5zdGFuY2VzSW50ZXJ2YWxDYWNoZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wSXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcEludGVydmFsRGVmYXVsdCA9IDMzO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wSW50ZXJ2YWwgPSBfbG9vcEludGVydmFsRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcFRpbWVPbGQgPSBfZ2V0Tm93KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BJRDtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgYXV0byB1cGRhdGUgbG9vcCB3aGljaCB3aWxsIHJ1biBldmVyeSA1MCBtaWxsaXNlY29uZHMgb3IgbGVzcyBpZiB0aGUgdXBkYXRlIGludGVydmFsIG9mIGEgaW5zdGFuY2UgaXMgbG93ZXIgdGhhbiA1MCBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbG9vcGluZ0luc3RhbmNlc1tfc3RyTGVuZ3RoXSA+IDAgJiYgX2xvb3BJc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcElEID0gQ09NUEFUSUJJTElUWS5yQUYoKShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZU5ldyA9IF9nZXROb3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVEZWx0YSA9IHRpbWVOZXcgLSBfbG9vcFRpbWVPbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb3dlc3RJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VBdXRvVXBkYXRlQWxsb3dlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQXV0b1VwZGF0ZUludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm93O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVEZWx0YSA+IF9sb29wSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wVGltZU9sZCA9IHRpbWVOZXcgLSAodGltZURlbHRhICUgX2xvb3BJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RJbnRlcnZhbCA9IF9sb29wSW50ZXJ2YWxEZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbG9vcGluZ0luc3RhbmNlc1tfc3RyTGVuZ3RoXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBfbG9vcGluZ0luc3RhbmNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMgPSBpbnN0YW5jZS5vcHRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlQXV0b1VwZGF0ZUFsbG93ZWQgPSBpbnN0YW5jZU9wdGlvbnNbX3N0ckF1dG9VcGRhdGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbCA9IE1BVEgubWF4KDEsIGluc3RhbmNlT3B0aW9uc1tfc3RyQXV0b1VwZGF0ZUludGVydmFsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9IF9nZXROb3coKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaW5zdGFuY2VBdXRvVXBkYXRlQWxsb3dlZCA9PT0gdHJ1ZSB8fCBpbnN0YW5jZUF1dG9VcGRhdGVBbGxvd2VkID09PSBudWxsKSAmJiAobm93IC0gX2xvb3BpbmdJbnN0YW5jZXNJbnRlcnZhbENhY2hlW2ldKSA+IGluc3RhbmNlQXV0b1VwZGF0ZUludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS51cGRhdGUoJ2F1dG8nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29waW5nSW5zdGFuY2VzSW50ZXJ2YWxDYWNoZVtpXSA9IG5ldyBEYXRlKG5vdyArPSBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdEludGVydmFsID0gTUFUSC5tYXgoMSwgTUFUSC5taW4obG93ZXN0SW50ZXJ2YWwsIGluc3RhbmNlQXV0b1VwZGF0ZUludGVydmFsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJbnRlcnZhbCA9IGxvd2VzdEludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJbnRlcnZhbCA9IF9sb29wSW50ZXJ2YWxEZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGQgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UgdG8gdGhlIGF1dG8gdXBkYXRlIGxvb3AuIE9ubHkgc3VjY2Vzc2Z1bCBpZiB0aGUgaW5zdGFuY2UgaXNuJ3QgYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2hpY2ggc2hhbGwgYmUgdXBkYXRlZCBpbiBhIGxvb3AgYXV0b21hdGljYWxseS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UuYWRkID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pbkFycmF5KGluc3RhbmNlLCBfbG9vcGluZ0luc3RhbmNlcykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29waW5nSW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlc0ludGVydmFsQ2FjaGUucHVzaChfZ2V0Tm93KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2xvb3BpbmdJbnN0YW5jZXNbX3N0ckxlbmd0aF0gPiAwICYmICFfbG9vcElzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcElzQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbHMuYXV0b1VwZGF0ZUxvb3AgPSBfbG9vcElzQWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZSBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSBmcm9tIHRoZSBhdXRvIHVwZGF0ZSBsb29wLiBPbmx5IHN1Y2Nlc3NmdWwgaWYgdGhlIGluc3RhbmNlIHdhcyBhZGRlZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHdoaWNoIHNoYWxsIGJlIHVwZGF0ZWQgaW4gYSBsb29wIGF1dG9tYXRpY2FsbHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF9pbkFycmF5KGluc3RhbmNlLCBfbG9vcGluZ0luc3RhbmNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgZnJvbSBsb29waW5nSW5zdGFuY2VzIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BpbmdJbnN0YW5jZXNJbnRlcnZhbENhY2hlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29waW5nSW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvcnJlY3QgdXBkYXRlIGxvb3AgYmVoYXZpb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9sb29waW5nSW5zdGFuY2VzW19zdHJMZW5ndGhdID09PSAwICYmIF9sb29wSXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbHMuYXV0b1VwZGF0ZUxvb3AgPSBfbG9vcElzQWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9sb29wSUQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuY0FGKCkoX2xvb3BJRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJRCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgb2JqZWN0IHdoaWNoIG1hbmFnZXMgdGhlIHNjcm9sbGJhcnMgdmlzaWJpbGl0eSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBwbHVnaW5UYXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdGhlIHNjcm9sbGJhcnMgc2hhbGwgYmUgaGlkZGVuLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY3VzdG9tIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBjdXN0b20gZXh0ZW5zaW9ucy5cclxuICAgICAgICAgICAgICogQHBhcmFtIGdsb2JhbHNcclxuICAgICAgICAgICAgICogQHBhcmFtIGF1dG9VcGRhdGVMb29wXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE92ZXJsYXlTY3JvbGxiYXJzSW5zdGFuY2UocGx1Z2luVGFyZ2V0RWxlbWVudCwgb3B0aW9ucywgZXh0ZW5zaW9ucywgZ2xvYmFscywgYXV0b1VwZGF0ZUxvb3ApIHtcclxuICAgICAgICAgICAgICAgIC8vc2hvcnRjdXRzXHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IENPTVBBVElCSUxJVFkudHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBpbkFycmF5ID0gRlJBTUVXT1JLLmluQXJyYXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWFjaCA9IEZSQU1FV09SSy5lYWNoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFrZSBjb3JyZWN0IGluc3RhbmNlb2ZcclxuICAgICAgICAgICAgICAgIHZhciBfYmFzZSA9IG5ldyBfcGx1Z2luKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1ld29ya1Byb3RvID0gRlJBTUVXT1JLW0xFWElDT04ucF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiBwYXNzZWQgZWxlbWVudCBpcyBubyBIVE1MIGVsZW1lbnQ6IHNraXAgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KHBsdWdpblRhcmdldEVsZW1lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIHBhc3NlZCBlbGVtZW50IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQ6IHNldCBwYXNzZWQgb3B0aW9ucyBpZiB0aGVyZSBhcmUgYW55IGFuZCByZXR1cm4gaXRzIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICBpZiAoSU5TVEFOQ0VTKHBsdWdpblRhcmdldEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3QgPSBJTlNUQU5DRVMocGx1Z2luVGFyZ2V0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdC5vcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2xvYmFsczpcclxuICAgICAgICAgICAgICAgIHZhciBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZDtcclxuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfcnRsU2Nyb2xsQmVoYXZpb3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2F1dG9VcGRhdGVSZWNvbW1lbmRlZDtcclxuICAgICAgICAgICAgICAgIHZhciBfbXNpZVZlcnNpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgX25hdGl2ZVNjcm9sbGJhclN0eWxpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc0NhbGM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX25hdGl2ZVNjcm9sbGJhclNpemU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N1cHBvcnRUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdXBwb3J0VHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdXBwb3J0UGFzc2l2ZUV2ZW50cztcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydFJlc2l6ZU9ic2VydmVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdXBwb3J0TXV0YXRpb25PYnNlcnZlcjtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzdHJpY3RlZE1lYXN1cmluZztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2dlbmVyYWwgcmVhZG9ubHk6XHJcbiAgICAgICAgICAgICAgICB2YXIgX2luaXRpYWxpemVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9kZXN0cm95ZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2lzVGV4dGFyZWE7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2lzQm9keTtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnRNaXhlZDtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9tRXhpc3RzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2VuZXJhbDpcclxuICAgICAgICAgICAgICAgIHZhciBfaXNCb3JkZXJCb3g7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZDtcclxuICAgICAgICAgICAgICAgIHZhciBfcGFkZGluZ1g7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BhZGRpbmdZO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ib3JkZXJYO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ib3JkZXJZO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tYXJnaW5YO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tYXJnaW5ZO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pc1JUTDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2xlZXBpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRCb3JkZXJTaXplID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbEhvcml6b250YWxJbmZvID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbFZlcnRpY2FsSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF92aWV3cG9ydFNpemUgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBfbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbmFtaW5nOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1pbnVzSGlkZGVuID0gJy1oaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNYXJnaW5NaW51cyA9ICdtYXJnaW4tJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyUGFkZGluZ01pbnVzID0gJ3BhZGRpbmctJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyQm9yZGVyTWludXMgPSAnYm9yZGVyLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clRvcCA9ICd0b3AnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJSaWdodCA9ICdyaWdodCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckJvdHRvbSA9ICdib3R0b20nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJMZWZ0ID0gJ2xlZnQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNaW5NaW51cyA9ICdtaW4tJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWF4TWludXMgPSAnbWF4LSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0cldpZHRoID0gJ3dpZHRoJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RySGVpZ2h0ID0gJ2hlaWdodCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckZsb2F0ID0gJ2Zsb2F0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyRW1wdHkgPSAnJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyQXV0byA9ICdhdXRvJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU3luYyA9ICdzeW5jJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsID0gJ3Njcm9sbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckh1bmRyZWRQZXJjZW50ID0gJzEwMCUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJYID0gJ3gnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJZID0gJ3knO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJEb3QgPSAnLic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNwYWNlID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTY3JvbGxiYXIgPSAnc2Nyb2xsYmFyJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWludXNIb3Jpem9udGFsID0gJy1ob3Jpem9udGFsJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWludXNWZXJ0aWNhbCA9ICctdmVydGljYWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTY3JvbGxMZWZ0ID0gX3N0clNjcm9sbCArICdMZWZ0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsVG9wID0gX3N0clNjcm9sbCArICdUb3AnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50ID0gJ21vdXNlZG93biB0b3VjaHN0YXJ0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTW91c2VUb3VjaFVwRXZlbnQgPSAnbW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQgPSAnbW91c2Vtb3ZlIHRvdWNobW92ZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1vdXNlRW50ZXIgPSAnbW91c2VlbnRlcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1vdXNlTGVhdmUgPSAnbW91c2VsZWF2ZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0cktleURvd25FdmVudCA9ICdrZXlkb3duJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyS2V5VXBFdmVudCA9ICdrZXl1cCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNlbGVjdFN0YXJ0RXZlbnQgPSAnc2VsZWN0c3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJUcmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eSA9ICdfX292ZXJsYXlTY3JvbGxiYXJzUk9fXyc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jbGFzcyBuYW1lczpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jYXNzTmFtZXNQcmVmaXggPSAnb3MtJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSFRNTEVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2h0bWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0RWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAnaG9zdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbiA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctZm9yZWlnbic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RUZXh0YXJlYUVsZW1lbnQgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXRleHRhcmVhJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhckhvcml6b250YWxIaWRkZW4gPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLScgKyBfc3RyU2Nyb2xsYmFyICsgX3N0ck1pbnVzSG9yaXpvbnRhbCArIF9zdHJNaW51c0hpZGRlbjtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhclZlcnRpY2FsSGlkZGVuID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy0nICsgX3N0clNjcm9sbGJhciArIF9zdHJNaW51c1ZlcnRpY2FsICsgX3N0ck1pbnVzSGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0VHJhbnNpdGlvbiA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctdHJhbnNpdGlvbic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RSVEwgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXJ0bCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RSZXNpemVEaXNhYmxlZCA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctcmVzaXplLWRpc2FibGVkJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFNjcm9sbGluZyA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctc2Nyb2xsaW5nJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdE92ZXJmbG93ID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy1vdmVyZmxvdyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctb3ZlcmZsb3cnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dYID0gX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyArICcteCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RPdmVyZmxvd1kgPSBfY2xhc3NOYW1lSG9zdE92ZXJmbG93ICsgJy15JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICd0ZXh0YXJlYSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVRleHRhcmVhQ292ZXJFbGVtZW50ID0gX2NsYXNzTmFtZVRleHRhcmVhRWxlbWVudCArICctY292ZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVQYWRkaW5nRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAncGFkZGluZyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVZpZXdwb3J0RWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAndmlld3BvcnQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNJbnZpc2libGUgPSBfY2xhc3NOYW1lVmlld3BvcnRFbGVtZW50ICsgJy1uYXRpdmUtc2Nyb2xsYmFycy1pbnZpc2libGUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCA9IF9jbGFzc05hbWVWaWV3cG9ydEVsZW1lbnQgKyAnLW5hdGl2ZS1zY3JvbGxiYXJzLW92ZXJsYWlkJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lQ29udGVudEVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2NvbnRlbnQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVDb250ZW50QXJyYW5nZUVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2NvbnRlbnQtYXJyYW5nZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUNvbnRlbnRHbHVlRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAnY29udGVudC1nbHVlJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3NpemUtYXV0by1vYnNlcnZlcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAncmVzaXplLW9ic2VydmVyJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAncmVzaXplLW9ic2VydmVyLWl0ZW0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1GaW5hbEVsZW1lbnQgPSBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRWxlbWVudCArICctZmluYWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVUZXh0SW5oZXJpdCA9IF9jYXNzTmFtZXNQcmVmaXggKyAndGV4dC1pbmhlcml0JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyID0gX2Nhc3NOYW1lc1ByZWZpeCArIF9zdHJTY3JvbGxiYXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrID0gX2NsYXNzTmFtZVNjcm9sbGJhciArICctdHJhY2snO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJUcmFja09mZiA9IF9jbGFzc05hbWVTY3JvbGxiYXJUcmFjayArICctb2ZmJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlID0gX2NsYXNzTmFtZVNjcm9sbGJhciArICctaGFuZGxlJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlT2ZmID0gX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZSArICctb2ZmJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyVW51c2FibGUgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgJy11bnVzYWJsZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4gPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgJy0nICsgX3N0ckF1dG8gKyBfc3RyTWludXNIaWRkZW47XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lciA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyAnLWNvcm5lcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSA9IF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXIgKyAnLXJlc2l6ZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUIgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplICsgJy1ib3RoJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplSCA9IF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUgKyBfc3RyTWludXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVWID0gX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSArIF9zdHJNaW51c1ZlcnRpY2FsO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJIb3Jpem9udGFsID0gX2NsYXNzTmFtZVNjcm9sbGJhciArIF9zdHJNaW51c0hvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhclZlcnRpY2FsID0gX2NsYXNzTmFtZVNjcm9sbGJhciArIF9zdHJNaW51c1ZlcnRpY2FsO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVEcmFnZ2luZyA9IF9jYXNzTmFtZXNQcmVmaXggKyAnZHJhZ2dpbmcnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVUaGVtZU5vbmUgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3RoZW1lLW5vbmUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVzRHluYW1pY0Rlc3Ryb3kgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc0ludmlzaWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrT2ZmLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGVPZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhclVudXNhYmxlLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZGVuLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUIsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUgsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZVYsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZURyYWdnaW5nXS5qb2luKF9zdHJTcGFjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFja3M6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfY2FsbGJhY2tzSW5pdFFldWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vYXR0cnMgdmlld3BvcnQgc2hhbGwgaW5oZXJpdCBmcm9tIHRhcmdldFx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3ZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0ID0gW0xFWElDT04udGldO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vb3B0aW9uczpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9kZWZhdWx0T3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHZhciBfY3VycmVudE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9leHRlbnNpb25zOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2V4dGVuc2lvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBfZXh0ZW5zaW9uc1ByaXZhdGVNZXRob2RzID0gJ2FkZGVkIHJlbW92ZWQgb24gY29udHJhY3QnO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdXBkYXRlXHRcclxuICAgICAgICAgICAgICAgIHZhciBfbGFzdFVwZGF0ZVRpbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N3YWxsb3dlZFVwZGF0ZUhpbnRzID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N3YWxsb3dlZFVwZGF0ZVRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N3YWxsb3dVcGRhdGVMYWcgPSA0MjtcclxuICAgICAgICAgICAgICAgIHZhciBfdXBkYXRlT25Mb2FkRXZlbnROYW1lID0gJ2xvYWQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF91cGRhdGVPbkxvYWRFbG1zID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ET00gZWxlbWVudHM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfd2luZG93RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9odG1sRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfYm9keUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RhcmdldEVsZW1lbnQ7ICAgICAgICAgICAgICAgICAgICAgLy90aGUgdGFyZ2V0IGVsZW1lbnQgb2YgdGhpcyBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3RcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9ob3N0RWxlbWVudDsgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGhvc3QgZWxlbWVudCBvZiB0aGlzIE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdCAtPiBtYXkgYmUgdGhlIHNhbWUgYXMgdGFyZ2V0RWxlbWVudFx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50OyAgICAgICAgICAgLy9vYnNlcnZlcyBzaXplIGF1dG8gY2hhbmdlc1x0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NpemVPYnNlcnZlckVsZW1lbnQ7ICAgICAgICAgICAgICAgLy9vYnNlcnZlcyBzaXplIGFuZCBwYWRkaW5nIGNoYW5nZXNcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9wYWRkaW5nRWxlbWVudDsgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlcyB0aGUgcGFkZGluZ1x0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3ZpZXdwb3J0RWxlbWVudDsgICAgICAgICAgICAgICAgICAgLy9pcyB0aGUgdmlld3BvcnQgb2Ygb3VyIHNjcm9sbGJhciBtb2RlbFx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRFbGVtZW50OyAgICAgICAgICAgICAgICAgICAgLy90aGUgZWxlbWVudCB3aGljaCBob2xkcyB0aGUgY29udGVudFx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRBcnJhbmdlRWxlbWVudDsgICAgICAgICAgICAgLy9pcyBuZWVkZWQgZm9yIGNvcnJlY3Qgc2l6aW5nIG9mIHRoZSBjb250ZW50IGVsZW1lbnQgKG9ubHkgaWYgbmF0aXZlIHNjcm9sbGJhcnMgYXJlIG92ZXJsYXlzKVx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRHbHVlRWxlbWVudDsgICAgICAgICAgICAgICAgLy9oYXMgYWx3YXlzIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGVsZW1lbnRcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUNvdmVyRWxlbWVudDsgICAgICAgICAgICAgIC8vb25seSBhcHBsaWVkIGlmIHRhcmdldCBpcyBhIHRleHRhcmVhIGVsZW1lbnQuIFVzZWQgZm9yIGNvcnJlY3Qgc2l6ZSBjYWxjdWxhdGlvbiBhbmQgZm9yIHByZXZlbnRpb24gb2YgdW5jb250cm9sbGVkIHNjcm9sbGluZ1x0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhckNvcm5lckVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJIb3Jpem9udGFsVHJhY2tFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJIb3Jpem9udGFsSGFuZGxlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJWZXJ0aWNhbFRyYWNrRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF93aW5kb3dFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudEVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RhcmdldEVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hvc3RFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplQXV0b09ic2VydmVyRWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZU9ic2VydmVyRWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfcGFkZGluZ0VsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudEVsZW1lbnROYXRpdmU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9DYWNoZTpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9ob3N0U2l6ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hcnJhbmdlQ29udGVudFNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfaGFzT3ZlcmZsb3dDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfaGlkZU92ZXJmbG93Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3dpZHRoQXV0b0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9oZWlnaHRBdXRvQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc0JveFNpemluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NQYWRkaW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc0JvcmRlckNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NNYXJnaW5DYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzRGlyZWN0aW9uQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc0RpcmVjdGlvbkRldGVjdGVkQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BhZGRpbmdBYnNvbHV0ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGlwQWx3YXlzQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRHbHVlU2l6ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93QW1vdW50Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2lnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfYXV0b1VwZGF0ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplQXV0b0NhcGFibGVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudEVsZW1lbnRTY3JvbGxTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfaG9zdEVsZW1lbnRTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc1Zpc2liaWxpdHlDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9yZXNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfbm9ybWFsaXplUlRMQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9vbGRDbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhQXV0b1dyYXBwaW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhSW5mb0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYVNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFEeW5IZWlnaHRDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFEeW5XaWR0aENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ib2R5TWluU2l6ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF91cGRhdGVBdXRvQ2FjaGUgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL011dGF0aW9uT2JzZXJ2ZXI6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckhvc3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVySG9zdENhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudENhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZDtcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckF0dHJzVGV4dGFyZWEgPSBbJ3dyYXAnLCAnY29scycsICdyb3dzJ107XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJBdHRyc0hvc3QgPSBbTEVYSUNPTi5pLCBMRVhJQ09OLmMsIExFWElDT04ucywgJ29wZW4nXS5jb25jYXQoX3ZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2V2ZW50czpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9kZXN0cm95RXZlbnRzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLy90ZXh0YXJlYTpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUhhc0ZvY3VzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFyczpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVUaW1lb3V0SWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmVUaW1lb3V0SWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZURlbGF5O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVOZXZlcjtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0hhbmRsZUhvdmVyZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVzaXplXHRcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzaXplTm9uZTtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzaXplQm90aDtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzaXplSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzaXplVmVydGljYWw7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBFdmVudCBMaXN0ZW5lciA9PT09Ly9cdFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlx0XHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgYSBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LiBcdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVyIHNoYWxsIGJlIGFwcGxpZWQgb3IgcmVtb3ZlZC5cdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZXMgVGhlIG5hbWUocykgb2YgdGhlIGV2ZW50cy5cdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBtZXRob2Qgd2hpY2ggc2hhbGwgYmUgY2FsbGVkLlx0XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcmVtb3ZlIFRydWUgaWYgdGhlIGhhbmRsZXIgc2hhbGwgYmUgcmVtb3ZlZCwgZmFsc2Ugb3IgdW5kZWZpbmVkIGlmIHRoZSBoYW5kbGVyIHNoYWxsIGJlIGFkZGVkLlx0XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcGFzc2l2ZU9yT3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGxpc3RlbmVyLCByZW1vdmUsIHBhc3NpdmVPck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGVkID0gQ09NUEFUSUJJTElUWS5pc0EoZXZlbnROYW1lcykgJiYgQ09NUEFUSUJJTElUWS5pc0EobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnYWRkRXZlbnRMaXN0ZW5lcic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSBjb2xsZWN0ZWQgPyBmYWxzZSA6IGV2ZW50TmFtZXMuc3BsaXQoX3N0clNwYWNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhc3NpdmVPck9wdGlvbnNJc09iaiA9IEZSQU1FV09SSy5pc1BsYWluT2JqZWN0KHBhc3NpdmVPck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXNzaXZlID0gKF9zdXBwb3J0UGFzc2l2ZUV2ZW50cyAmJiAocGFzc2l2ZU9yT3B0aW9uc0lzT2JqID8gKHBhc3NpdmVPck9wdGlvbnMuX3Bhc3NpdmUpIDogcGFzc2l2ZU9yT3B0aW9ucykpIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gcGFzc2l2ZU9yT3B0aW9uc0lzT2JqICYmIChwYXNzaXZlT3JPcHRpb25zLl9jYXB0dXJlIHx8IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlUGFyYW0gPSBfc3VwcG9ydFBhc3NpdmVFdmVudHMgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IHBhc3NpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmU6IGNhcHR1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSA6IGNhcHR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBldmVudE5hbWVzW0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lc1tpXSwgbGlzdGVuZXJbaV0sIHJlbW92ZSwgcGFzc2l2ZU9yT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50c1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9zdXBwb3J0UGFzc2l2ZUV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF1bbWV0aG9kXShldmVudHNbaV0sIGxpc3RlbmVyLCBuYXRpdmVQYXJhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W29uT2ZmXShldmVudHNbaV0sIGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWVzLCBsaXN0ZW5lciwgcGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lcywgbGlzdGVuZXIsIGZhbHNlLCBwYXNzaXZlKTtcclxuICAgICAgICAgICAgICAgICAgICBfZGVzdHJveUV2ZW50cy5wdXNoKENPTVBBVElCSUxJVFkuYmluZChzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyLCAwLCBlbGVtZW50LCBldmVudE5hbWVzLCBsaXN0ZW5lciwgdHJ1ZSwgcGFzc2l2ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBSZXNpemUgT2JzZXJ2ZXIgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgYSByZXNpemUgb2JzZXJ2ZXIgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSByZXNpemUgb2JzZXJ2ZXIgc2hhbGwgYmUgYWRkZWQgb3IgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvbkVsZW1lbnRSZXNpemVkQ2FsbGJhY2sgVGhlIGNhbGxiYWNrIHdoaWNoIGlzIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIHJlc2l6ZSBvYnNlcnZlciByZWdpc3RlcnMgYSBzaXplIGNoYW5nZSBvciBmYWxzZSAvIHVuZGVmaW5lZCBpZiB0aGUgcmVzaXplT2JzZXJ2ZXIgc2hhbGwgYmUgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBSZXNpemVPYnNlcnZlcih0YXJnZXRFbGVtZW50LCBvbkVsZW1lbnRSZXNpemVkQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaXplT2JzZXJ2ZXIgPSBDT01QQVRJQklMSVRZLnJPKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJBbmltYXRpb25TdGFydEV2ZW50ID0gJ2FuaW1hdGlvbnN0YXJ0IG1vekFuaW1hdGlvblN0YXJ0IHdlYmtpdEFuaW1hdGlvblN0YXJ0IE1TQW5pbWF0aW9uU3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQ2hpbGROb2RlcyA9ICdjaGlsZE5vZGVzJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0U2Nyb2xsID0gMzMzMzMzMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXShjb25zdFNjcm9sbClbX3N0clNjcm9sbExlZnRdKF9pc1JUTCA/IF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLWNvbnN0U2Nyb2xsIDogX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAwIDogY29uc3RTY3JvbGwgOiBjb25zdFNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVsZW1lbnRSZXNpemVkQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgcmVzaXplIG9ic2VydmVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25FbGVtZW50UmVzaXplZENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5hZGRDbGFzcygnb2JzZXJ2ZWQnKS5hcHBlbmQoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkpLmNvbnRlbnRzKClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gZWxlbWVudFtfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eV0gPSBuZXcgcmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX21zaWVWZXJzaW9uID4gOSB8fCAhX2F1dG9VcGRhdGVSZWNvbW1lbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LnByZXBlbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGl2KHsgYzogX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQsIGRpcjogJ2x0cicgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRmluYWxFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdih7IGM6IF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1GaW5hbEVsZW1lbnQsIHN0eWxlOiAnd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJScgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlckVsZW1lbnQgPSB0YXJnZXRFbGVtZW50WzBdW3N0ckNoaWxkTm9kZXNdWzBdW3N0ckNoaWxkTm9kZXNdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hyaW5rRWxlbWVudCA9IEZSQU1FV09SSyhvYnNlcnZlckVsZW1lbnRbc3RyQ2hpbGROb2Rlc11bMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kRWxlbWVudCA9IEZSQU1FV09SSyhvYnNlcnZlckVsZW1lbnRbc3RyQ2hpbGROb2Rlc11bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kRWxlbWVudENoaWxkID0gRlJBTUVXT1JLKGV4cGFuZEVsZW1lbnRbMF1bc3RyQ2hpbGROb2Rlc11bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhDYWNoZSA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodENhY2hlID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNEaXJ0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJBRklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVTY3JvbGxiYXJTaXplID0gZ2xvYmFscy5uYXRpdmVTY3JvbGxiYXJTaXplOyAvL2NhcmUgZG9uJ3QgbWFrZSBjaGFuZ2VzIHRvIHRoaXMgb2JqZWN0ISEhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVSZXNldFdpZHRoID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub1ddICsgbmF0aXZlU2Nyb2xsYmFyU2l6ZS54ICogZmFjdG9yICsgbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ICogZmFjdG9yICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueCArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVSZXNldEhlaWdodCA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9IXSArIG5hdGl2ZVNjcm9sbGJhclNpemUueCAqIGZhY3RvciArIG5hdGl2ZVNjcm9sbGJhclNpemUueSAqIGZhY3RvciArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnggKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkQ1NTW19zdHJXaWR0aF0gPSBzaXplUmVzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRDaGlsZENTU1tfc3RySGVpZ2h0XSA9IHNpemVSZXNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRFbGVtZW50Q2hpbGQuY3NzKGV4cGFuZENoaWxkQ1NTKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKHNpemVSZXNldFdpZHRoKVtfc3RyU2Nyb2xsVG9wXShzaXplUmVzZXRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNocmlua0VsZW1lbnRbX3N0clNjcm9sbExlZnRdKHNpemVSZXNldFdpZHRoKVtfc3RyU2Nyb2xsVG9wXShzaXplUmVzZXRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShjb25zdFNjcm9sbClbX3N0clNjcm9sbFRvcF0oY29uc3RTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oY29uc3RTY3JvbGwpW19zdHJTY3JvbGxUb3BdKGNvbnN0U2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uUmVzaXplZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJBRklkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEaXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhDYWNoZSA9IGN1cnJXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodENhY2hlID0gY3VyckhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycldpZHRoID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckhlaWdodCA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9IXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlydHkgPSBjdXJyV2lkdGggIT0gd2lkdGhDYWNoZSB8fCBjdXJySGVpZ2h0ICE9IGhlaWdodENhY2hlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBpc0RpcnR5ICYmICFyQUZJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuY0FGKCkockFGSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJBRklkID0gQ09NUEFUSUJJTElUWS5yQUYoKShvblJlc2l6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV2ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzaXplZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXJFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQob2JzZXJ2ZXJFbGVtZW50Q1NTLCBfc3RyRW1wdHksIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0oKG5hdGl2ZVNjcm9sbGJhclNpemUueSArIDEpICogZmFjdG9yKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhclNpemUueCAqIC1mYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJTaXplLnkgKiAtZmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSgobmF0aXZlU2Nyb2xsYmFyU2l6ZS54ICsgMSkgKiBmYWN0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLKG9ic2VydmVyRWxlbWVudCkuY3NzKG9ic2VydmVyRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnQub24oX3N0clNjcm9sbCwgb25TY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmtFbGVtZW50Lm9uKF9zdHJTY3JvbGwsIG9uU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5vbihzdHJBbmltYXRpb25TdGFydEV2ZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xldHMgYXNzdW1lIHRoYXQgdGhlIGRpdnMgd2lsbCBuZXZlciBiZSB0aGF0IGxhcmdlIGFuZCBhIGNvbnN0YW50IHZhbHVlIGlzIGVub3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRDaGlsZENTU1tfc3RyV2lkdGhdID0gY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkQ1NTW19zdHJIZWlnaHRdID0gY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnRDaGlsZC5jc3MoZXhwYW5kQ2hpbGRDU1MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2hFdmVudCA9IF9kb2N1bWVudEVsZW1lbnROYXRpdmUuYXR0YWNoRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0lFID0gX21zaWVWZXJzaW9uICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5wcmVwZW5kKGdlbmVyYXRlRGl2KF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdCh0YXJnZXRFbGVtZW50LCBfc3RyRG90ICsgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudClbMF0uYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IF9kb2N1bWVudEVsZW1lbnROYXRpdmUuY3JlYXRlRWxlbWVudChUWVBFUy5vKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoTEVYSUNPTi50aSwgJy0xJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouc2V0QXR0cmlidXRlKExFWElDT04uYywgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3bmQgPSB0aGlzLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bmQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHduZC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoudHlwZSA9ICd0ZXh0L2h0bWwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSUUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5wcmVwZW5kKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZGF0YSA9ICdhYm91dDpibGFuayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSUUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5wcmVwZW5kKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9uKHN0ckFuaW1hdGlvblN0YXJ0RXZlbnQsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudFswXSA9PT0gX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IF9ob3N0RWxlbWVudC5jc3MoJ2RpcmVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0VmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXIgIT09IF9jc3NEaXJlY3Rpb25EZXRlY3RlZENhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyID09PSAnbHRyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTGVmdF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyUmlnaHRdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdFZhbHVlID0gY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckxlZnRdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJSaWdodF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnRWYWx1ZSA9IF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLWNvbnN0U2Nyb2xsIDogX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAwIDogY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2V4ZWN1dGlvbiBvcmRlciBpcyBpbXBvcnRhbnQgZm9yIElFISEhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudC5jaGlsZHJlbigpLmVxKDApLmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnRbX3N0clNjcm9sbExlZnRdKHNjcm9sbExlZnRWYWx1ZSlbX3N0clNjcm9sbFRvcF0oY29uc3RTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Nzc0RpcmVjdGlvbkRldGVjdGVkQ2FjaGUgPSBkaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25DaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgX3N0clNjcm9sbCwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25DaGFuZ2VkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHJlc2l6ZSBvYnNlcnZlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5jb250ZW50cygpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVPYnNlcnZlck9iaiA9IGVsZW1lbnRbX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVPYnNlcnZlck9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlck9iai5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50W19zdHJSZXNpemVPYnNlcnZlclByb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUodGFyZ2V0RWxlbWVudC5jaGlsZHJlbihfc3RyRG90ICsgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkuZXEoMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRnJlZXplcyBvciB1bmZyZWV6ZXMgdGhlIGdpdmVuIHJlc2l6ZSBvYnNlcnZlci5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSB0YXJnZXQgcmVzaXplIG9ic2VydmVyIGlzIGFwcGxpZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZnJlZXplIFRydWUgaWYgdGhlIHJlc2l6ZSBvYnNlcnZlciBzaGFsbCBiZSBmcm96ZW4sIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZyZWV6ZVJlc2l6ZU9ic2VydmVyKHRhcmdldEVsZW1lbnQsIGZyZWV6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZnJlZXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5jb250ZW50cygpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHldLnVub2JzZXJ2ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LmNoaWxkcmVuKF9zdHJEb3QgKyBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KS5lcSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHRhcmdldEVsZW1lbnQuY3NzKF9zdHJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSB0YXJnZXRFbGVtZW50LmNzcyhfc3RySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSB3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RySGVpZ2h0XSA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5jc3MoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFJlc2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LmNvbnRlbnRzKClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eV0ub2JzZXJ2ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSB7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJIZWlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuY2hpbGRyZW4oX3N0ckRvdCArIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpLmVxKDApLmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IE11dGF0aW9uIE9ic2VydmVycyA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgTXV0YXRpb25PYnNlcnZlcnMgZm9yIHRoZSBob3N0IGFuZCBjb250ZW50IEVsZW1lbnQgaWYgdGhleSBhcmUgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVNdXRhdGlvbk9ic2VydmVycygpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRNdXRhdGlvbk9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbk9ic2VydmVyQ29udGVudExhZyA9IDExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25PYnNlcnZlciA9IENPTVBBVElCSUxJVFkubU8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRMYXN0VXBkYXRlID0gQ09NUEFUSUJJTElUWS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uVGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25BdHRyTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uSXNDbGFzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZE11dGF0aW9uVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q2xhc3NWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0Q2xhc3NOYW1lUmVnZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VGltZW91dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2sgPSBmdW5jdGlvbiAobXV0YXRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9VcGRhdGVGb3JjZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRBdHRycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgIV9zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gobXV0YXRpb25zLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25UYXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uQXR0ck5hbWUgPSBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklzQ2xhc3MgPSBtdXRhdGlvbkF0dHJOYW1lID09PSBMRVhJQ09OLmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZE11dGF0aW9uVmFsID0gbXV0YXRpb24ub2xkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NsYXNzVmFsID0gbXV0YXRpb25UYXJnZXQuY2xhc3NOYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kb21FeGlzdHMgJiYgbXV0YXRpb25Jc0NsYXNzICYmICFkb1VwZGF0ZUZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvbGQgY2xhc3MgdmFsdWUgY29udGFpbnMgX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbiBhbmQgbmV3IGNsYXNzIHZhbHVlIGRvZXNuJ3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRNdXRhdGlvblZhbC5pbmRleE9mKF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24pID4gLTEgJiYgbmV3Q2xhc3NWYWwuaW5kZXhPZihfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0Q2xhc3NOYW1lUmVnZXggPSBjcmVhdGVIb3N0Q2xhc3NOYW1lUmVnRXhwKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudE5hdGl2ZS5jbGFzc05hbWUgPSBuZXdDbGFzc1ZhbC5zcGxpdChfc3RyU3BhY2UpLmNvbmNhdChvbGRNdXRhdGlvblZhbC5zcGxpdChfc3RyU3BhY2UpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5tYXRjaChob3N0Q2xhc3NOYW1lUmVnZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKF9zdHJTcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGUgPSBkb1VwZGF0ZUZvcmNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGUgPSBtdXRhdGlvbklzQ2xhc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhvc3RDbGFzc05hbWVzQ2hhbmdlZChvbGRNdXRhdGlvblZhbCwgbmV3Q2xhc3NWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtdXRhdGlvbkF0dHJOYW1lID09PSBMRVhJQ09OLnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvbGRNdXRhdGlvblZhbCAhPT0gbXV0YXRpb25UYXJnZXRbTEVYSUNPTi5zXS5jc3NUZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEF0dHJzLnB1c2gobXV0YXRpb25BdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KG11dGF0ZWRBdHRycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1VwZGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKGRvVXBkYXRlRm9yY2UgfHwgX3N0ckF1dG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgIV9zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gobXV0YXRpb25zLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGUgPSBpc1Vua25vd25NdXRhdGlvbihtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBDT01QQVRJQklMSVRZLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQXV0byA9IChfaGVpZ2h0QXV0b0NhY2hlIHx8IF93aWR0aEF1dG9DYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRMYXN0VXBkYXRlID0gbm93O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGNvbHMsIHJvd3Mgb3Igd3JhcCBhdHRyIHdhcyBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVVwZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbnRlbnRUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJDb250ZW50TGFnIDw9IDAgfHwgbm93IC0gY29udGVudExhc3RVcGRhdGUgPiBtdXRhdGlvbk9ic2VydmVyQ29udGVudExhZyB8fCAhc2l6ZUF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KGFjdGlvbiwgbXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJIb3N0ID0gbmV3IG11dGF0aW9uT2JzZXJ2ZXIoX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQgPSBuZXcgbXV0YXRpb25PYnNlcnZlcihfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ29ubmVjdHMgdGhlIE11dGF0aW9uT2JzZXJ2ZXJzIGlmIHRoZXkgYXJlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXIgJiYgIV9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckhvc3Qub2JzZXJ2ZShfaG9zdEVsZW1lbnROYXRpdmUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogX211dGF0aW9uT2JzZXJ2ZXJBdHRyc0hvc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQub2JzZXJ2ZShfaXNUZXh0YXJlYSA/IF90YXJnZXRFbGVtZW50TmF0aXZlIDogX2NvbnRlbnRFbGVtZW50TmF0aXZlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlOiAhX2lzVGV4dGFyZWEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3Q6ICFfaXNUZXh0YXJlYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6ICFfaXNUZXh0YXJlYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogX2lzVGV4dGFyZWEgPyBfbXV0YXRpb25PYnNlcnZlckF0dHJzVGV4dGFyZWEgOiBfbXV0YXRpb25PYnNlcnZlckF0dHJzSG9zdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGlzY29ubmVjdHMgdGhlIE11dGF0aW9uT2JzZXJ2ZXJzIGlmIHRoZXkgYXJlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXIgJiYgX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVySG9zdC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudC5kaXNjb25uZWN0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBFdmVudHMgb2YgZWxlbWVudHMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBob3N0IGVsZW1lbnQgZ2V0cyByZXNpemVkLiBJTVBPUlRBTlQ6IFBhZGRpbmcgY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgdG9vISFcclxuICAgICAgICAgICAgICAgICAqIEl0IHJlZnJlc2hlcyB0aGUgaG9zdFJlc2l6ZWRFdmVudEFyZ3MgYW5kIHRoZSBob3N0U2l6ZVJlc2l6ZUNhY2hlLlxyXG4gICAgICAgICAgICAgICAgICogSWYgdGhlcmUgYXJlIGFueSBzaXplIGNoYW5nZXMsIHRoZSB1cGRhdGUgbWV0aG9kIGdldHMgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0T25SZXNpemVkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBfc2l6ZU9ic2VydmVyRWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IF9zaXplT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04uc0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hlY2tDYWNoZShob3N0U2l6ZSwgX2hvc3RFbGVtZW50U2l6ZUNoYW5nZURldGVjdGVkQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnRTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZSA9IGhvc3RTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7IF9ob3N0U2l6ZUNoYW5nZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIG1vdXNlIGVudGVyIGV2ZW50IG9mIHRoZSBob3N0IGVsZW1lbnQuIFRoaXMgZXZlbnQgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0T25Nb3VzZUVudGVyKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgbW91c2UgbGVhdmUgZXZlbnQgb2YgdGhlIGhvc3QgZWxlbWVudC4gVGhpcyBldmVudCBpcyBvbmx5IG5lZWRlZCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhvc3RPbk1vdXNlTGVhdmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSAmJiAhX2JvZHlFbGVtZW50Lmhhc0NsYXNzKF9jbGFzc05hbWVEcmFnZ2luZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIG1vdXNlIG1vdmUgZXZlbnQgb2YgdGhlIGhvc3QgZWxlbWVudC4gVGhpcyBldmVudCBpcyBvbmx5IG5lZWRlZCBmb3IgdGhlIGF1dG9IaWRlIFwibW92ZVwiIGZlYXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhvc3RPbk1vdXNlTW92ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlVGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSAmJiAhX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQcmV2ZW50cyB0ZXh0IGZyb20gZGVzZWxlY3Rpb24gaWYgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50IGVsZW1lbnQgb24gdGhlIG1vdXNlZG93biBldmVudCBvZiBhIERPTSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBzZWxlY3Qgc3RhcnQgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50T25TZWxlY3RTdGFydChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlx0XHJcbiAgICAgICAgICAgICAgICAgKiBBIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGEgZWxlbWVudCBoYXMgbG9hZGVkLlx0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9uTG9hZENhbGxiYWNrKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsbSA9IEZSQU1FV09SSyhldmVudC50YXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlYWNoVXBkYXRlT25Mb2FkKGZ1bmN0aW9uIChpLCB1cGRhdGVPbkxvYWRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxtLmlzKHVwZGF0ZU9uTG9hZFNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHsgX2NvbnRlbnRTaXplQ2hhbmdlZDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgbW91c2UgJiB0b3VjaCBldmVudHMgb2YgdGhlIGhvc3QgZWxlbWVudC4gKGZvciBoYW5kbGluZyBhdXRvLWhpZGluZyBvZiB0aGUgc2Nyb2xsYmFycylcclxuICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50cyBzaGFsbCBiZSBhZGRlZCBvciByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwSG9zdE1vdXNlVG91Y2hFdmVudHMoZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzdHJveSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBIb3N0TW91c2VUb3VjaEV2ZW50cyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfaG9zdEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LnNwbGl0KF9zdHJTcGFjZSlbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RPbk1vdXNlTW92ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSB8fCBkZXN0cm95KSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfaG9zdEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyTW91c2VFbnRlciwgX3N0ck1vdXNlTGVhdmVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbaG9zdE9uTW91c2VFbnRlciwgaG9zdE9uTW91c2VMZWF2ZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlIHx8IGRlc3Ryb3kpLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgcGx1Z2luIGlzIGluaXRpYWxpemVkIGFuZCB0aGUgbW91c2UgaXMgb3ZlciB0aGUgaG9zdCBlbGVtZW50LCBtYWtlIHRoZSBzY3JvbGxiYXJzIHZpc2libGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pbml0aWFsaXplZCAmJiAhZGVzdHJveSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50Lm9uZSgnbW91c2VvdmVyJywgaG9zdE9uTW91c2VFbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBVcGRhdGUgRGV0ZWN0aW9uID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVhc3VyZXMgdGhlIG1pbiB3aWR0aCBhbmQgbWluIGhlaWdodCBvZiB0aGUgYm9keSBlbGVtZW50IGFuZCByZWZyZXNoZXMgdGhlIHJlbGF0ZWQgY2FjaGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWluIHdpZHRoIG9yIG1pbiBoZWlnaHQgaGFzIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYm9keU1pblNpemVDaGFuZ2VkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5TWluU2l6ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5ICYmIF9jb250ZW50QXJyYW5nZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemUudyA9IHBhcnNlVG9aZXJvT3JOdW1iZXIoX2NvbnRlbnRBcnJhbmdlRWxlbWVudC5jc3MoX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplLmggPSBwYXJzZVRvWmVyb09yTnVtYmVyKF9jb250ZW50QXJyYW5nZUVsZW1lbnQuY3NzKF9zdHJNaW5NaW51cyArIF9zdHJIZWlnaHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemUuYyA9IGNoZWNrQ2FjaGUoYm9keU1pblNpemUsIF9ib2R5TWluU2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemUuZiA9IHRydWU7IC8vZmxhZyBmb3IgXCJtZWFzdXJlZCBhdCBsZWFzdCBvbmNlXCJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2JvZHlNaW5TaXplQ2FjaGUgPSBib2R5TWluU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFib2R5TWluU2l6ZS5jO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjbGFzcyBuYW1lcyByZWFsbHkgY2hhbmdlZCAobmV3IGNsYXNzIHdpdGhvdXQgcGx1Z2luIGhvc3QgcHJlZml4KVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9sZENsYXNzTmFtZXMgVGhlIG9sZCBDbGFzc05hbWUgc3RyaW5nIG9yIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG5ld0NsYXNzTmFtZXMgVGhlIG5ldyBDbGFzc05hbWUgc3RyaW5nIG9yIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNsYXNzIG5hbWVzIGhhcyByZWFsbHkgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0Q2xhc3NOYW1lc0NoYW5nZWQob2xkQ2xhc3NOYW1lcywgbmV3Q2xhc3NOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyQ2xhc3NlcyA9IHR5cGVvZiBuZXdDbGFzc05hbWVzID09IFRZUEVTLnMgPyBuZXdDbGFzc05hbWVzLnNwbGl0KF9zdHJTcGFjZSkgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2xhc3NlcyA9IHR5cGVvZiBvbGRDbGFzc05hbWVzID09IFRZUEVTLnMgPyBvbGRDbGFzc05hbWVzLnNwbGl0KF9zdHJTcGFjZSkgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGdldEFycmF5RGlmZmVyZW5jZXMob2xkQ2xhc3NlcywgY3VyckNsYXNzZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm9uZSB0aGVtZSBmcm9tIGRpZmYgbGlzdCB0byBwcmV2ZW50IHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBpbkFycmF5KF9jbGFzc05hbWVUaGVtZU5vbmUsIGRpZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmLnNwbGljZShpZHgsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZltMRVhJQ09OLmxdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNyZWF0ZUhvc3RDbGFzc05hbWVSZWdFeHAodHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpZmZbaV0ubWF0Y2gocmVnZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtdXRhdGlvbiBpcyBub3QgZnJvbSBhIGZyb20gdGhlIHBsdWdpbiBnZW5lcmF0ZWQgZWxlbWVudC4gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdGV4dGFyZWEgdGhlIG11dGF0aW9uIGlzIGFsd2F5cyB1bmtub3duLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG11dGF0aW9uIFRoZSBtdXRhdGlvbiB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG11dGF0aW9uIGlzIGZyb20gYSB1bmtub3duIGVsZW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNVbmtub3duTXV0YXRpb24obXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uVGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvblR5cGUgPSBtdXRhdGlvbi50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJDbG9zZXN0ID0gJ2Nsb3Nlc3QnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25UYXJnZXQgPT09IF9jb250ZW50RWxlbWVudE5hdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgPT09IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uVHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIChhdHRyaWJ1dGVOYW1lID09PSBMRVhJQ09OLmMgfHwgYXR0cmlidXRlTmFtZSA9PT0gTEVYSUNPTi5zKSAmJiAhX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgY2xhc3NOYW1lIGNoYW5nZXMgYnkgdGhlIHBsdWdpblx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBMRVhJQ09OLmMgJiYgRlJBTUVXT1JLKG11dGF0aW9uVGFyZ2V0KS5oYXNDbGFzcyhfY2xhc3NOYW1lSG9zdEVsZW1lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RDbGFzc05hbWVzQ2hhbmdlZChtdXRhdGlvbi5vbGRWYWx1ZSwgbXV0YXRpb25UYXJnZXQuY2xhc3NOYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb25seSBkbyBpdCBvZiBicm93c2VyIHN1cHBvcnQgaXQgbmF0aXZlbHlcdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG11dGF0aW9uVGFyZ2V0W3N0ckNsb3Nlc3RdICE9IFRZUEVTLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uVGFyZ2V0W3N0ckNsb3Nlc3RdKF9zdHJEb3QgKyBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KSAhPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25UYXJnZXRbc3RyQ2xvc2VzdF0oX3N0ckRvdCArIF9jbGFzc05hbWVTY3JvbGxiYXIpICE9PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblRhcmdldFtzdHJDbG9zZXN0XShfc3RyRG90ICsgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lcikgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250ZW50IHNpemUgd2FzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbnRlbnQgc2l6ZSB3YXMgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVBdXRvQ29udGVudFNpemVDaGFuZ2VkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2xlZXBpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRNZWFzdXJlRWxlbWVudCA9IGdldENvbnRlbnRNZWFzdXJlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVZhbHVlTGVuZ3RoID0gX2lzVGV4dGFyZWEgJiYgX3dpZHRoQXV0b0NhY2hlICYmICFfdGV4dGFyZWFBdXRvV3JhcHBpbmdDYWNoZSA/IF90YXJnZXRFbGVtZW50LnZhbCgpLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldENTUyA9ICFfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQgJiYgX3dpZHRoQXV0b0NhY2hlICYmICFfaXNUZXh0YXJlYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5TWluU2l6ZUM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldENTUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCA9IF9jb250ZW50RWxlbWVudC5jc3MoX3N0ckZsb2F0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJGbG9hdF0gPSBfaXNSVEwgPyBfc3RyUmlnaHQgOiBfc3RyTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudFNjcm9sbFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHc6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNXXSArIHRleHRhcmVhVmFsdWVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNIXSArIHRleHRhcmVhVmFsdWVMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXRDU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJGbG9hdF0gPSBmbG9hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplQyA9IGJvZHlNaW5TaXplQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSBjaGVja0NhY2hlKGNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZSwgX2NvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZUNoYW5nZURldGVjdGVkQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnRTY3JvbGxTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZSA9IGNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWQgfHwgYm9keU1pblNpemVDO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIHdoZW4gYSBhdHRyaWJ1dGUgd2hpY2ggdGhlIE11dGF0aW9uT2JzZXJ2ZXIgd291bGQgb2JzZXJ2ZSBoYXMgY2hhbmdlZC4gIFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb25lIG9mIHRoZSBhdHRyaWJ1dGVzIHdoaWNoIGEgTXV0YXRpb25PYnNlcnZlciB3b3VsZCBvYnNlcnZlIGhhcyBjaGFuZ2VkLCBmYWxzZSBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtZWFuaW5nZnVsQXR0cnNDaGFuZ2VkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2xlZXBpbmcgfHwgX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2VsZW06IF9ob3N0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdHRyczogX211dGF0aW9uT2JzZXJ2ZXJBdHRyc0hvc3QuY29uY2F0KCc6dmlzaWJsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lbGVtOiBfaXNUZXh0YXJlYSA/IF90YXJnZXRFbGVtZW50IDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2F0dHJzOiBfbXV0YXRpb25PYnNlcnZlckF0dHJzVGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVhY2goY2hlY2tzLCBmdW5jdGlvbiAoaW5kZXgsIGNoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjaGVjay5fZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goY2hlY2suX2F0dHJzLCBmdW5jdGlvbiAoaW5kZXgsIGF0dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gYXR0ci5jaGFyQXQoMCkgPT09ICc6JyA/IGVsZW0uaXMoYXR0cikgOiBlbGVtLmF0dHIoYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBfdXBkYXRlQXV0b0NhY2hlW2F0dHJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tDYWNoZShjdXJyLCBjYWNoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEF0dHJzLnB1c2goYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlQXV0b0NhY2hlW2F0dHJdID0gY3VycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KGNoYW5nZWRBdHRycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQXR0cnNbTEVYSUNPTi5sXSA+IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaXMgYSBDU1MgUHJvcGVydHkgb2YgYSBjaGlsZCBlbGVtZW50IGlzIGFmZmVjdGluZyB0aGUgc2Nyb2xsIHNpemUgb2YgdGhlIGNvbnRlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIFRoZSBDU1MgcHJvcGVydHkgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm9wZXJ0eSBpcyBhZmZlY3RpbmcgdGhlIGNvbnRlbnQgc2Nyb2xsIHNpemUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNTaXplQWZmZWN0aW5nQ1NTUHJvcGVydHkocHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaW5pdGlhbGl6ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbGV4R3JvdyA9ICdmbGV4LWdyb3cnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbGV4U2hyaW5rID0gJ2ZsZXgtc2hyaW5rJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxleEJhc2lzID0gJ2ZsZXgtYmFzaXMnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RpbmdQcm9wc1ggPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWF4TWludXMgKyBfc3RyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNYXJnaW5NaW51cyArIF9zdHJMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWFyZ2luTWludXMgKyBfc3RyUmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyUmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LXdlaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd3b3JkLXNwYWNpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4R3JvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleFNocmluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleEJhc2lzXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0aW5nUHJvcHNYQ29udGVudEJveCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clBhZGRpbmdNaW51cyArIF9zdHJMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyUGFkZGluZ01pbnVzICsgX3N0clJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm9yZGVyTWludXMgKyBfc3RyTGVmdCArIF9zdHJXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckJvcmRlck1pbnVzICsgX3N0clJpZ2h0ICsgX3N0cldpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0aW5nUHJvcHNZID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWluTWludXMgKyBfc3RySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWF4TWludXMgKyBfc3RySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWFyZ2luTWludXMgKyBfc3RyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWFyZ2luTWludXMgKyBfc3RyQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGluZS1oZWlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4R3JvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleFNocmluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleEJhc2lzXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0aW5nUHJvcHNZQ29udGVudEJveCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clBhZGRpbmdNaW51cyArIF9zdHJUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJQYWRkaW5nTWludXMgKyBfc3RyQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm9yZGVyTWludXMgKyBfc3RyVG9wICsgX3N0cldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm9yZGVyTWludXMgKyBfc3RyQm90dG9tICsgX3N0cldpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0clMgPSAncyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdHJWUyA9ICd2LXMnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja1ggPSBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLnggPT09IF9zdHJTIHx8IF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUueCA9PT0gX3N0clZTO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja1kgPSBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLnkgPT09IF9zdHJTIHx8IF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUueSA9PT0gX3N0clZTO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplSXNBZmZlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja1Byb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIChhcnIsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldID09PSBuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVJc0FmZmVjdGVkID0gY2hlY2tQcm9wZXJ0eU5hbWUoYWZmZWN0aW5nUHJvcHNZLCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpemVJc0FmZmVjdGVkICYmICFfaXNCb3JkZXJCb3gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplSXNBZmZlY3RlZCA9IGNoZWNrUHJvcGVydHlOYW1lKGFmZmVjdGluZ1Byb3BzWUNvbnRlbnRCb3gsIHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja1ggJiYgIXNpemVJc0FmZmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVJc0FmZmVjdGVkID0gY2hlY2tQcm9wZXJ0eU5hbWUoYWZmZWN0aW5nUHJvcHNYLCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpemVJc0FmZmVjdGVkICYmICFfaXNCb3JkZXJCb3gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplSXNBZmZlY3RlZCA9IGNoZWNrUHJvcGVydHlOYW1lKGFmZmVjdGluZ1Byb3BzWENvbnRlbnRCb3gsIHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplSXNBZmZlY3RlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFVwZGF0ZSA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gdGhlIHZhbHVlcyBmcm9tIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiBhIGF0dHJpYnV0ZSBpcyBvbmx5IHNldCBpZiB0aGUgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkLlxyXG4gICAgICAgICAgICAgICAgICogQGF0dHJzIGF0dHJzIFRoZSBhcnJheSBvZiBhdHRyaWJ1dGVzIHdoaWNoIHNoYWxsIGJlIHNldCBvciB1bmRlZmluZWQgaWYgYWxsIHdoaXRlbGlzdGVkIHNoYWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlld3BvcnRBdHRyc0Zyb21UYXJnZXQoYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IGF0dHJzIHx8IF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBlYWNoKGF0dHJzLCBmdW5jdGlvbiAoaW5kZXgsIGF0dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaW5BKGF0dHIsIF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEF0dHIgPSBfdGFyZ2V0RWxlbWVudC5hdHRyKGF0dHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUodGFyZ2V0QXR0cikgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuYXR0cihhdHRyLCB0YXJnZXRBdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQucmVtb3ZlQXR0cihhdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyB0aGUgdmFyaWFibGVzIGFuZCBzaXplIG9mIHRoZSB0ZXh0YXJlYSBlbGVtZW50LCBhbmQgbWFuYWdlcyB0aGUgc2Nyb2xsIG9uIG5ldyBsaW5lIG9yIG5ldyBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhVXBkYXRlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cmFwQXR0ck9mZiA9ICFfdGV4dGFyZWFBdXRvV3JhcHBpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbldpZHRoID0gX3ZpZXdwb3J0U2l6ZS53O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gX3ZpZXdwb3J0U2l6ZS5oO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb01lYXN1cmUgPSBfd2lkdGhBdXRvQ2FjaGUgfHwgd3JhcEF0dHJPZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IG1pbiBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTWluTWludXMgKyBfc3RyV2lkdGhdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0ckhlaWdodF0gPSBfc3RyRW1wdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCB3aWR0aCBhdXRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmNzcyhjc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdXaWR0aCA9IF90YXJnZXRFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGRvTWVhc3VyZSA/IE1BVEgubWF4KG9yaWdXaWR0aCwgX3RhcmdldEVsZW1lbnROYXRpdmVbTEVYSUNPTi5zV10gLSAxKSA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qd2lkdGggKz0gKF93aWR0aEF1dG9DYWNoZSA/IF9tYXJnaW5YICsgKCFfaXNCb3JkZXJCb3ggPyB3cmFwQXR0ck9mZiA/IDAgOiBfcGFkZGluZ1ggKyBfYm9yZGVyWCA6IDApIDogMCk7Ki9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IG1lYXN1cmVkIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3dpZHRoQXV0b0NhY2hlID8gX3N0ckF1dG8gLyp3aWR0aCovIDogX3N0ckh1bmRyZWRQZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoXSA9IF9zdHJIdW5kcmVkUGVyY2VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGhlaWdodCBhdXRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RySGVpZ2h0XSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5jc3MoY3NzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ0hlaWdodCA9IF90YXJnZXRFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBNQVRILm1heChvcmlnSGVpZ2h0LCBfdGFyZ2V0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNIXSAtIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBlbmQgY29ycmVjdCBzaXplIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckhlaWdodF0gPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUNvdmVyRWxlbWVudC5jc3MoY3NzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgbWluIHdpZHRoIC8gbWluIGhlaWdodCB0byBwcmV2ZW50IHRleHRhcmVhIGNvbGxhcHNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJNaW5NaW51cyArIF9zdHJXaWR0aF0gPSBtaW5XaWR0aCAvKisgKCFfaXNCb3JkZXJCb3ggJiYgX3dpZHRoQXV0b0NhY2hlID8gX3BhZGRpbmdYICsgX2JvcmRlclggOiAwKSovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0ckhlaWdodF0gPSBtaW5IZWlnaHQgLyorICghX2lzQm9yZGVyQm94ICYmIF9oZWlnaHRBdXRvQ2FjaGUgPyBfcGFkZGluZ1kgKyBfYm9yZGVyWSA6IDApKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmNzcyhjc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcmlnaW5hbFdpZHRoOiBvcmlnV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3JpZ2luYWxIZWlnaHQ6IG9yaWdIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZHluYW1pY1dpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9keW5hbWljSGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBwbHVnaW4gYW5kIERPTSB0byB0aGUgY3VycmVudCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIGEgdXBkYXRlIGlzIDEwMCUgcmVxdWlyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdXBkYXRlSGludHMgQSBvYmplY3RzIHdoaWNoIGNvbnRhaW5zIGhpbnRzIGZvciB0aGlzIHVwZGF0ZTpcclxuICAgICAgICAgICAgICAgICAqIHtcclxuICAgICAgICAgICAgICAgICAqICAgX2hvc3RTaXplQ2hhbmdlZCA6IGJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICAgKiAgIF9jb250ZW50U2l6ZUNoYW5nZWQgOiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICogICBfZm9yY2UgOiBib29sZWFuLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPT0gcHJldmVudFN3YWxsb3dpbmdcclxuICAgICAgICAgICAgICAgICAqICAgX2NoYW5nZWRPcHRpb25zIDogeyB9LCAgICAgICAgICAgICAgICAgICAgICAgID09IHByZXZlbnRTd2FsbG93aW5nICYmIHByZXZlbnRTbGVlcFxyXG4gICAgICAgICAgICAgICAgKiAgfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGUodXBkYXRlSGludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3N3YWxsb3dlZFVwZGF0ZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUhpbnRzID0gdXBkYXRlSGludHMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgX3N3YWxsb3dlZFVwZGF0ZUhpbnRzLl9ob3N0U2l6ZUNoYW5nZWQgfD0gdXBkYXRlSGludHMuX2hvc3RTaXplQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICBfc3dhbGxvd2VkVXBkYXRlSGludHMuX2NvbnRlbnRTaXplQ2hhbmdlZCB8PSB1cGRhdGVIaW50cy5fY29udGVudFNpemVDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zd2FsbG93ZWRVcGRhdGVIaW50cy5fZm9yY2UgfD0gdXBkYXRlSGludHMuX2ZvcmNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gQ09NUEFUSUJJTElUWS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdFNpemVDaGFuZ2VkID0gISFfc3dhbGxvd2VkVXBkYXRlSGludHMuX2hvc3RTaXplQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFNpemVDaGFuZ2VkID0gISFfc3dhbGxvd2VkVXBkYXRlSGludHMuX2NvbnRlbnRTaXplQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yY2UgPSAhIV9zd2FsbG93ZWRVcGRhdGVIaW50cy5fZm9yY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRPcHRpb25zID0gdXBkYXRlSGludHMuX2NoYW5nZWRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzd2FsbG93ID0gX3N3YWxsb3dVcGRhdGVMYWcgPiAwICYmIF9pbml0aWFsaXplZCAmJiAhX2Rlc3Ryb3llZCAmJiAhZm9yY2UgJiYgIWNoYW5nZWRPcHRpb25zICYmIChub3cgLSBfbGFzdFVwZGF0ZVRpbWUpIDwgX3N3YWxsb3dVcGRhdGVMYWcgJiYgKCFfaGVpZ2h0QXV0b0NhY2hlICYmICFfd2lkdGhBdXRvQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5SXNIaWRkZW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzd2FsbG93KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3dhbGxvd2VkVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQodXBkYXRlLCBfc3dhbGxvd1VwZGF0ZUxhZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWJvcnQgdXBkYXRlIGR1ZSB0bzpcclxuICAgICAgICAgICAgICAgICAgICAvL2Rlc3Ryb3llZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3dhbGxvd2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc2xlZXBpbmdcclxuICAgICAgICAgICAgICAgICAgICAvL2hvc3QgaXMgaGlkZGVuIG9yIGhhcyBmYWxzZSBkaXNwbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kZXN0cm95ZWQgfHwgc3dhbGxvdyB8fCAoX3NsZWVwaW5nICYmICFjaGFuZ2VkT3B0aW9ucykgfHwgKF9pbml0aWFsaXplZCAmJiAhZm9yY2UgJiYgKGRpc3BsYXlJc0hpZGRlbiA9IF9ob3N0RWxlbWVudC5pcygnOmhpZGRlbicpKSkgfHwgX2hvc3RFbGVtZW50LmNzcygnZGlzcGxheScpID09PSAnaW5saW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfbGFzdFVwZGF0ZVRpbWUgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N3YWxsb3dlZFVwZGF0ZUhpbnRzID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgc2Nyb2xsYmFyIHN0eWxpbmcgaXMgcG9zc2libGUgYW5kIG5hdGl2ZSBzY3JvbGxiYXJzIGFyZW4ndCBvdmVybGFpZCB0aGUgc2Nyb2xsYmFyIHN0eWxpbmcgd2lsbCBiZSBhcHBsaWVkIHdoaWNoIGhpZGVzIHRoZSBuYXRpdmUgc2Nyb2xsYmFycyBjb21wbGV0ZWx5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZyAmJiAhKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uYXRpdmUgc2Nyb2xsYmFycyBhcmUgaGlkZGVuLCBzbyBjaGFuZ2UgdGhlIHZhbHVlcyB0byB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJTaXplLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVmcmVzaCBuYXRpdmUgc2Nyb2xsYmFyIHNpemUgKGluIGNhc2Ugb2Ygem9vbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclNpemUgPSBleHRlbmREZWVwKHt9LCBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhclNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2Nyb2xsYmFyIHBhZGRpbmcgaXMgbmVlZGVkIGZvciBmaXJlZm94LCBiZWNhdXNlIGZpcmVmb3ggaGlkZXMgc2Nyb2xsYmFyIGF1dG9tYXRpY2FsbHkgaWYgdGhlIHNpemUgb2YgdGhlIGRpdiBpcyB0b28gc21hbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNhbGN1bGF0aW9uOiBbc2Nyb2xsYmFyIHNpemUgKzMgKjNdXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCszIGJlY2F1c2Ugb2YgcG9zc2libGUgZGVjb3JhdGlvbiBlLmcuIGJvcmRlcnMsIG1hcmdpbnMgZXRjLiwgYnV0IG9ubHkgaWYgbmF0aXZlIHNjcm9sbGJhciBpcyBOT1QgYSBvdmVybGFpZCBzY3JvbGxiYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCozIGJlY2F1c2UgKDEpaW5jcmVhc2UgLyAoMilkZWNyZWFzZSAtYnV0dG9uIGFuZCAoMylyZXNpemUgaGFuZGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAoX25hdGl2ZVNjcm9sbGJhclNpemUueCArIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ID8gMCA6IDMpKSAqIDMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IChfbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ICsgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgPyAwIDogMykpICogM1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRPcHRpb25zID0gY2hhbmdlZE9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmVlemVSZXNpemVPYnNlcnZlcihfc2l6ZU9ic2VydmVyRWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmVlemVSZXNpemVPYnNlcnZlcihfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tDYWNoZUF1dG9Gb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrQ2FjaGUuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmNvbmNhdChbZm9yY2VdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zYXZlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyU2Nyb2xsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxUb3BdKClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5zY3JvbGxiYXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UHJlcGFyZWRPcHRpb25zVGV4dGFyZWEgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy50ZXh0YXJlYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIHZpc2liaWxpdHk6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNWaXNpYmlsaXR5ID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMudmlzaWJpbGl0eTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzY3JvbGxiYXJzVmlzaWJpbGl0eSwgX3Njcm9sbGJhcnNWaXNpYmlsaXR5Q2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgYXV0b0hpZGU6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNBdXRvSGlkZSA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzLmF1dG9IaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzQXV0b0hpZGVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzY3JvbGxiYXJzQXV0b0hpZGUsIF9zY3JvbGxiYXJzQXV0b0hpZGVDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyBjbGljayBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMuY2xpY2tTY3JvbGxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZywgX3Njcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIGRyYWcgc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMuZHJhZ1Njcm9sbGluZztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZywgX3Njcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NsYXNzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGNsYXNzTmFtZSwgX2NsYXNzTmFtZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXNpemVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaXplID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMucmVzaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShyZXNpemUsIF9yZXNpemVDYWNoZSkgJiYgIV9pc0JvZHk7IC8vYm9keSBjYW4ndCBiZSByZXNpemVkIHNpbmNlIHRoZSB3aW5kb3cgaXRzZWxmIGFjdHMgYXMgcmVzaXplIHBvc3NpYmlsaXR5LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3BhZGRpbmdBYnNvbHV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nQWJzb2x1dGUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5wYWRkaW5nQWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHBhZGRpbmdBYnNvbHV0ZSwgX3BhZGRpbmdBYnNvbHV0ZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jbGlwQWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBBbHdheXMgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5jbGlwQWx3YXlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGlwQWx3YXlzQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoY2xpcEFsd2F5cywgX2NsaXBBbHdheXNDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2l6ZUF1dG9DYXBhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvQ2FwYWJsZSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnNpemVBdXRvQ2FwYWJsZSAmJiAhX2lzQm9keTsgLy9ib2R5IGNhbiBuZXZlciBiZSBzaXplIGF1dG8sIGJlY2F1c2UgaXQgc2hhbGwgYmUgYWx3YXlzIGFzIGJpZyBhcyB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvQ2FwYWJsZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHNpemVBdXRvQ2FwYWJsZSwgX3NpemVBdXRvQ2FwYWJsZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zaG93TmF0aXZlU2Nyb2xsYmFyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMubmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLnNob3dOYXRpdmVTY3JvbGxiYXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZywgX2lnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYXV0b1VwZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdXRvVXBkYXRlID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuYXV0b1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b1VwZGF0ZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGF1dG9VcGRhdGUsIF9hdXRvVXBkYXRlQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL292ZXJmbG93QmVoYXZpb3JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvciA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLm92ZXJmbG93QmVoYXZpb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3JDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShvdmVyZmxvd0JlaGF2aW9yLCBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLCBmb3JjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZHluV2lkdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluV2lkdGggPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zVGV4dGFyZWEuZHluV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluV2lkdGhDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShfdGV4dGFyZWFEeW5XaWR0aENhY2hlLCB0ZXh0YXJlYUR5bldpZHRoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9keW5IZWlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluSGVpZ2h0ID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1RleHRhcmVhLmR5bkhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFEeW5IZWlnaHRDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShfdGV4dGFyZWFEeW5IZWlnaHRDYWNoZSwgdGV4dGFyZWFEeW5IZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgdmlzaWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVOZXZlciA9IHNjcm9sbGJhcnNBdXRvSGlkZSA9PT0gJ24nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgPSBzY3JvbGxiYXJzQXV0b0hpZGUgPT09ICdzJztcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSA9IHNjcm9sbGJhcnNBdXRvSGlkZSA9PT0gJ20nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSA9IHNjcm9sbGJhcnNBdXRvSGlkZSA9PT0gJ2wnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgYXV0b0hpZGVEZWxheVxyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVEZWxheSA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzLmF1dG9IaWRlRGVsYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vb2xkIGNsYXNzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIF9vbGRDbGFzc05hbWUgPSBfY2xhc3NOYW1lQ2FjaGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZU5vbmUgPSByZXNpemUgPT09ICduJztcclxuICAgICAgICAgICAgICAgICAgICBfcmVzaXplQm90aCA9IHJlc2l6ZSA9PT0gJ2InO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNpemVIb3Jpem9udGFsID0gcmVzaXplID09PSAnaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZVZlcnRpY2FsID0gcmVzaXplID09PSAndic7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsaXplUlRMXHJcbiAgICAgICAgICAgICAgICAgICAgX25vcm1hbGl6ZVJUTENhY2hlID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMubm9ybWFsaXplUlRMO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lnbm9yZSBvdmVybGF5IHNjcm9sbGJhciBoaWRpbmdcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID0gaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyAmJiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWZyZXNoIG9wdGlvbnMgY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc1Zpc2liaWxpdHlDYWNoZSA9IHNjcm9sbGJhcnNWaXNpYmlsaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVDYWNoZSA9IHNjcm9sbGJhcnNBdXRvSGlkZTtcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nQ2FjaGUgPSBzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2FjaGUgPSBzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZztcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lQ2FjaGUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZUNhY2hlID0gcmVzaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nQWJzb2x1dGVDYWNoZSA9IHBhZGRpbmdBYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgICAgICBfY2xpcEFsd2F5c0NhY2hlID0gY2xpcEFsd2F5cztcclxuICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9DYXBhYmxlQ2FjaGUgPSBzaXplQXV0b0NhcGFibGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2lnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDYWNoZSA9IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2F1dG9VcGRhdGVDYWNoZSA9IGF1dG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX292ZXJmbG93QmVoYXZpb3JDYWNoZSA9IGV4dGVuZERlZXAoe30sIG92ZXJmbG93QmVoYXZpb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUR5bldpZHRoQ2FjaGUgPSB0ZXh0YXJlYUR5bldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUR5bkhlaWdodENhY2hlID0gdGV4dGFyZWFEeW5IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX2hhc092ZXJmbG93Q2FjaGUgPSBfaGFzT3ZlcmZsb3dDYWNoZSB8fCB7IHg6IGZhbHNlLCB5OiBmYWxzZSB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBjb3JyZWN0IGNsYXNzIG5hbWUgdG8gdGhlIGhvc3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX29sZENsYXNzTmFtZSArIF9zdHJTcGFjZSArIF9jbGFzc05hbWVUaGVtZU5vbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkICYmIGNsYXNzTmFtZSAhPT0gbnVsbCAmJiBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IF9jbGFzc05hbWVUaGVtZU5vbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgY29ycmVjdCBhdXRvIFVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRvVXBkYXRlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b1VwZGF0ZSA9PT0gdHJ1ZSB8fCAoYXV0b1VwZGF0ZSA9PT0gbnVsbCAmJiBfYXV0b1VwZGF0ZVJlY29tbWVuZGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlTG9vcC5hZGQoX2Jhc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZUxvb3AucmVtb3ZlKF9iYXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FjdGl2YXRlIG9yIGRlYWN0aXZhdGUgc2l6ZSBhdXRvIGNhcGFiaWxpdHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnRlbnRHbHVlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudCA9IEZSQU1FV09SSyhnZW5lcmF0ZURpdihfY2xhc3NOYW1lQ29udGVudEdsdWVFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50LmJlZm9yZShfY29udGVudEdsdWVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2l6ZUF1dG9PYnNlcnZlckFkZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudCA9IEZSQU1FV09SSyhnZW5lcmF0ZURpdihfY2xhc3NOYW1lU2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmUgPSBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuYmVmb3JlKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNpemUgPSB7IHc6IC0xLCBoOiAtMSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0NhY2hlKG5ld1NpemUsIG9sZFNpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2luaXRpYWxpemVkICYmIChfaGVpZ2h0QXV0b0NhY2hlICYmIG5ld1NpemUuaCA+IDApIHx8IChfd2lkdGhBdXRvQ2FjaGUgJiYgbmV3U2l6ZS53ID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pbml0aWFsaXplZCAmJiAoIV9oZWlnaHRBdXRvQ2FjaGUgJiYgbmV3U2l6ZS5oID09PSAwKSB8fCAoIV93aWR0aEF1dG9DYWNoZSAmJiBuZXdTaXplLncgPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkU2l6ZSA9IG5ld1NpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maXggaGVpZ2h0QXV0byBkZXRlY3RvciBidWcgaWYgaGVpZ2h0IGlzIGZpeGVkIGJ1dCBjb250ZW50SGVpZ2h0IGlzIDAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgcHJvYmFiaWxpdHkgdGhpcyBidWcgd2lsbCBldmVyIGhhcHBlbiBpcyB2ZXJ5IHZlcnkgbG93LCB0aGF0cyB3aHkgaXRzIG9rIGlmIHdlIHVzZSBjYWxjIHdoaWNoIGlzbid0IHN1cHBvcnRlZCBpbiBJRTguXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jc3NDYWxjICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQuY3NzKF9zdHJIZWlnaHQsIF9jc3NDYWxjICsgJygxMDAlICsgMXB4KScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zaXplQXV0b09ic2VydmVyQWRkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY29udGVudEdsdWVFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIGZvcmNlLCB1cGRhdGUgYWxsIHJlc2l6ZU9ic2VydmVycyB0b29cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnQuZmluZCgnKicpLnRyaWdnZXIoX3N0clNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2l6ZUF1dG9PYnNlcnZlckFkZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LmZpbmQoJyonKS50cmlnZ2VyKF9zdHJTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kaXNwbGF5IGhpZGRlbjpcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5SXNIaWRkZW4gPSBkaXNwbGF5SXNIaWRkZW4gPT09IHVuZGVmaW5lZCA/IF9ob3N0RWxlbWVudC5pcygnOmhpZGRlbicpIDogZGlzcGxheUlzSGlkZGVuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3RleHRhcmVhIEF1dG9XcmFwcGluZzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFBdXRvV3JhcHBpbmcgPSBfaXNUZXh0YXJlYSA/IF90YXJnZXRFbGVtZW50LmF0dHIoJ3dyYXAnKSAhPT0gJ29mZicgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFBdXRvV3JhcHBpbmdDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZSh0ZXh0YXJlYUF1dG9XcmFwcGluZywgX3RleHRhcmVhQXV0b1dyYXBwaW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBkaXJlY3Rpb246XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc0RpcmVjdGlvbiA9IF9ob3N0RWxlbWVudC5jc3MoJ2RpcmVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3NEaXJlY3Rpb25DaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShjc3NEaXJlY3Rpb24sIF9jc3NEaXJlY3Rpb25DYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGJveC1zaXppbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJveFNpemluZyA9IF9ob3N0RWxlbWVudC5jc3MoJ2JveC1zaXppbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm94U2l6aW5nQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoYm94U2l6aW5nLCBfY3NzQm94U2l6aW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBwYWRkaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nID0gZ2V0VG9wUmlnaHRCb3R0b21MZWZ0SG9zdChfc3RyUGFkZGluZ01pbnVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy93aWR0aCArIGhlaWdodCBhdXRvIGRldGVjdGluZyB2YXI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZXhjZXB0aW9uIG9jY3VycyBpbiBJRTggc29tZXRpbWVzICh1bmtub3duIGV4Y2VwdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplQXV0b09ic2VydmVyRWxlbWVudEJDUmVjdCA9IF9zaXplQXV0b09ic2VydmVyQWRkZWQgPyBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmVbTEVYSUNPTi5iQ1JdKCkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9pc1JUTCA9IGNzc0RpcmVjdGlvbiA9PT0gJ3J0bCc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2lzQm9yZGVyQm94ID0gKGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSVExMZWZ0ID0gX2lzUlRMID8gX3N0ckxlZnQgOiBfc3RyUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUlRMUmlnaHQgPSBfaXNSVEwgPyBfc3RyUmlnaHQgOiBfc3RyTGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3Qgd2lkdGggYXV0bzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQXV0b09ic2VydmVyRGV0ZWN0aW9uID0gKF9zaXplQXV0b09ic2VydmVyQWRkZWQgJiYgKF9ob3N0RWxlbWVudC5jc3MoX3N0ckZsb2F0KSAhPT0gJ25vbmUnIC8qfHwgX2lzVGV4dGFyZWEgKi8pKSA/IChNQVRILnJvdW5kKHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0LnJpZ2h0IC0gc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3QubGVmdCkgPT09IDApICYmICghcGFkZGluZ0Fic29sdXRlID8gKF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNXXSAtIF9wYWRkaW5nWCkgPiAwIDogdHJ1ZSkgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlICYmICF3aWR0aEF1dG9PYnNlcnZlckRldGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wQ3Vyckhvc3RXaWR0aCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcEN1cnJDb250ZW50R2x1ZVdpZHRoID0gX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoLCBfc3RyQXV0byk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wTmV3SG9zdFdpZHRoID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhfc3RyV2lkdGgsIHRtcEN1cnJDb250ZW50R2x1ZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uID0gdG1wQ3Vyckhvc3RXaWR0aCAhPT0gdG1wTmV3SG9zdFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoLCB0bXBDdXJySG9zdFdpZHRoICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBOZXdIb3N0V2lkdGggPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vV107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhfc3RyV2lkdGgsIHRtcEN1cnJDb250ZW50R2x1ZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbiA9IHRtcEN1cnJIb3N0V2lkdGggIT09IHRtcE5ld0hvc3RXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhBdXRvID0gKHdpZHRoQXV0b09ic2VydmVyRGV0ZWN0aW9uIHx8IHdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbikgJiYgc2l6ZUF1dG9DYXBhYmxlICYmICFkaXNwbGF5SXNIaWRkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQXV0b0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHdpZHRoQXV0bywgX3dpZHRoQXV0b0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2FzV2lkdGhBdXRvID0gIXdpZHRoQXV0byAmJiBfd2lkdGhBdXRvQ2FjaGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGhlaWdodCBhdXRvOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHRBdXRvID0gX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZCAmJiBzaXplQXV0b0NhcGFibGUgJiYgIWRpc3BsYXlJc0hpZGRlbiA/IChNQVRILnJvdW5kKHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0LmJvdHRvbSAtIHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0LnRvcCkgPT09IDApIC8qICYmICghcGFkZGluZ0Fic29sdXRlICYmIChfbXNpZVZlcnNpb24gPiA5IHx8ICFfbXNpZVZlcnNpb24pID8gdHJ1ZSA6IHRydWUpICovIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodEF1dG9DaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShoZWlnaHRBdXRvLCBfaGVpZ2h0QXV0b0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2FzSGVpZ2h0QXV0byA9ICFoZWlnaHRBdXRvICYmIF9oZWlnaHRBdXRvQ2FjaGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGJvcmRlcjpcclxuICAgICAgICAgICAgICAgICAgICAvL3dlIG5lZWQgdGhlIGJvcmRlciBvbmx5IGlmIGJvcmRlciBib3ggYW5kIGF1dG8gc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVCb3JkZXJYID0gKHdpZHRoQXV0byAmJiBfaXNCb3JkZXJCb3gpIHx8ICFfaXNCb3JkZXJCb3g7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUJvcmRlclkgPSAoaGVpZ2h0QXV0byAmJiBfaXNCb3JkZXJCb3gpIHx8ICFfaXNCb3JkZXJCb3g7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlciA9IGdldFRvcFJpZ2h0Qm90dG9tTGVmdEhvc3QoX3N0ckJvcmRlck1pbnVzLCAnLScgKyBfc3RyV2lkdGgsICF1cGRhdGVCb3JkZXJYLCAhdXBkYXRlQm9yZGVyWSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgbWFyZ2luOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW4gPSBnZXRUb3BSaWdodEJvdHRvbUxlZnRIb3N0KF9zdHJNYXJnaW5NaW51cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdmFycyB0byBhcHBseSBjb3JyZWN0IGNzc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50R2x1ZUVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9mdW5jc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRIb3N0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9oYXMgdG8gYmUgY2xpZW50U2l6ZSBiZWNhdXNlIG9mZnNldFNpemUgcmVzcGVjdCBib3JkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRWaWV3cG9ydFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmlld3BvcnQgc2l6ZSBpcyBwYWRkaW5nIGNvbnRhaW5lciBiZWNhdXNlIGl0IG5ldmVyIGhhcyBwYWRkaW5nLCBtYXJnaW4gYW5kIGEgYm9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGV0ZXJtaW5lIHpvb20gcm91bmRpbmcgZXJyb3IgLT4gc29tZXRpbWVzIHNjcm9sbFdpZHRoL0hlaWdodCBpcyBzbWFsbGVyIHRoYW4gY2xpZW50V2lkdGgvSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBoYXBwZW5zIGFkZCB0aGUgZGlmZmVyZW5jZSB0byB0aGUgdmlld3BvcnRTaXplIHRvIGNvbXBlbnNhdGUgdGhlIHJvdW5kaW5nIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5vV10gKyBNQVRILm1heCgwLCBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jV10gLSBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5zV10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogX3BhZGRpbmdFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdICsgTUFUSC5tYXgoMCwgX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uY0hdIC0gX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uc0hdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IGluZm8gZm9yIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0Fic29sdXRlWCA9IF9wYWRkaW5nWCA9IHBhZGRpbmcubCArIHBhZGRpbmcucjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0Fic29sdXRlWSA9IF9wYWRkaW5nWSA9IHBhZGRpbmcudCArIHBhZGRpbmcuYjtcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQWJzb2x1dGVYICo9IHBhZGRpbmdBYnNvbHV0ZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdBYnNvbHV0ZVkgKj0gcGFkZGluZ0Fic29sdXRlID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZy5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShwYWRkaW5nLCBfY3NzUGFkZGluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgaW5mbyBmb3IgYm9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgX2JvcmRlclggPSBib3JkZXIubCArIGJvcmRlci5yO1xyXG4gICAgICAgICAgICAgICAgICAgIF9ib3JkZXJZID0gYm9yZGVyLnQgKyBib3JkZXIuYjtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXIuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoYm9yZGVyLCBfY3NzQm9yZGVyQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBpbmZvIGZvciBtYXJnaW5cclxuICAgICAgICAgICAgICAgICAgICBfbWFyZ2luWCA9IG1hcmdpbi5sICsgbWFyZ2luLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgX21hcmdpblkgPSBtYXJnaW4udCArIG1hcmdpbi5iO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShtYXJnaW4sIF9jc3NNYXJnaW5DYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVmcmVzaCBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlID0gdGV4dGFyZWFBdXRvV3JhcHBpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc0RpcmVjdGlvbkNhY2hlID0gY3NzRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NCb3hTaXppbmdDYWNoZSA9IGJveFNpemluZztcclxuICAgICAgICAgICAgICAgICAgICBfd2lkdGhBdXRvQ2FjaGUgPSB3aWR0aEF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgX2hlaWdodEF1dG9DYWNoZSA9IGhlaWdodEF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc1BhZGRpbmdDYWNoZSA9IHBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc0JvcmRlckNhY2hlID0gYm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NNYXJnaW5DYWNoZSA9IG1hcmdpbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9JRUZpeCBkaXJlY3Rpb24gY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NEaXJlY3Rpb25DaGFuZ2VkICYmIF9zaXplQXV0b09ic2VydmVyQWRkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudC5jc3MoX3N0ckZsb2F0LCBpc1JUTFJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBwYWRkaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nLmMgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBzaXplQXV0b0NhcGFibGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nRWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdWYWx1ZXMgPSBbcGFkZGluZy50LCBwYWRkaW5nLnIsIHBhZGRpbmcuYiwgcGFkZGluZy5sXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdChjb250ZW50R2x1ZUVsZW1lbnRDU1MsIF9zdHJNYXJnaW5NaW51cywgWy1wYWRkaW5nLnQsIC1wYWRkaW5nLnIsIC1wYWRkaW5nLmIsIC1wYWRkaW5nLmxdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdBYnNvbHV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KHBhZGRpbmdFbGVtZW50Q1NTLCBfc3RyRW1wdHksIHBhZGRpbmdWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KF9pc1RleHRhcmVhID8gdGV4dGFyZWFDU1MgOiBjb250ZW50RWxlbWVudENTUywgX3N0clBhZGRpbmdNaW51cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQocGFkZGluZ0VsZW1lbnRDU1MsIF9zdHJFbXB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQoX2lzVGV4dGFyZWEgPyB0ZXh0YXJlYUNTUyA6IGNvbnRlbnRFbGVtZW50Q1NTLCBfc3RyUGFkZGluZ01pbnVzLCBwYWRkaW5nVmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50LmNzcyhwYWRkaW5nRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmNzcyh0ZXh0YXJlYUNTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3ZpZXdwb3J0IHNpemUgaXMgcGFkZGluZyBjb250YWluZXIgYmVjYXVzZSBpdCBuZXZlciBoYXMgcGFkZGluZywgbWFyZ2luIGFuZCBhIGJvcmRlci5cclxuICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIFRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhU2l6ZSA9IF9pc1RleHRhcmVhID8gdGV4dGFyZWFVcGRhdGUoKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVNpemVDaGFuZ2VkID0gX2lzVGV4dGFyZWEgJiYgY2hlY2tDYWNoZUF1dG9Gb3JjZSh0ZXh0YXJlYVNpemUsIF90ZXh0YXJlYVNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluT3JpZ1NpemUgPSBfaXNUZXh0YXJlYSAmJiB0ZXh0YXJlYVNpemUgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHc6IHRleHRhcmVhRHluV2lkdGggPyB0ZXh0YXJlYVNpemUuX2R5bmFtaWNXaWR0aCA6IHRleHRhcmVhU2l6ZS5fb3JpZ2luYWxXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaDogdGV4dGFyZWFEeW5IZWlnaHQgPyB0ZXh0YXJlYVNpemUuX2R5bmFtaWNIZWlnaHQgOiB0ZXh0YXJlYVNpemUuX29yaWdpbmFsSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYVNpemVDYWNoZSA9IHRleHRhcmVhU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maXggaGVpZ2h0IGF1dG8gLyB3aWR0aCBhdXRvIGluIGNvb3BlcmF0aW9uIHdpdGggY3VycmVudCBwYWRkaW5nICYgYm94U2l6aW5nIGJlaGF2aW9yOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHRBdXRvICYmIChoZWlnaHRBdXRvQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgcGFkZGluZy5jIHx8IGJvcmRlci5jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoZWlnaHRBdXRvQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gX3N0ckh1bmRyZWRQZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhBdXRvICYmICh3aWR0aEF1dG9DaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBwYWRkaW5nLmMgfHwgYm9yZGVyLmMgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0ck1heE1pbnVzICsgX3N0cldpZHRoXSA9IF9zdHJIdW5kcmVkUGVyY2VudDsgLy9JRSBGaXhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod2lkdGhBdXRvQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJGbG9hdF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyTWF4TWludXMgKyBfc3RyV2lkdGhdID0gX3N0ckVtcHR5OyAvL0lFIEZpeFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGV4dGFyZWFEeW5PcmlnU2l6ZS53IHx8IF9zdHJBdXRvIDo6IGRvZXNudCB3b3JrcyBiZWNhdXNlIGFwcGxpZWQgbWFyZ2luIHdpbGwgc2hpZnQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RyQXV0bztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBWRU5ET1JTLl9jc3NQcm9wZXJ0eVZhbHVlKF9zdHJXaWR0aCwgJ21heC1jb250ZW50IGludHJpbnNpYycpIHx8IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyRmxvYXRdID0gaXNSVExSaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyV2lkdGhdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0QXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RleHRhcmVhRHluT3JpZ1NpemUuaCB8fCBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jSF0gOjogdXNlIGZvciBhbnRpIHNjcm9sbCBqdW1waW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IHRleHRhcmVhRHluT3JpZ1NpemUuaCB8fCBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jSF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0b0NhcGFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKGNvbnRlbnRHbHVlRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjb250ZW50RWxlbWVudENTUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vQ0hFQ0tQT0lOVCBIRVJFIH5cclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIFtjb250ZW50KGhvc3QpIGNsaWVudCAvIHNjcm9sbCBzaXplLCBvciB0YXJnZXQgZWxlbWVudCBkaXJlY3Rpb24sIG9yIGNvbnRlbnQoaG9zdCkgbWF4LXNpemVzXSBjaGFuZ2VkLCBvciBmb3JjZSBpcyB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RTaXplQ2hhbmdlZCB8fCBjb250ZW50U2l6ZUNoYW5nZWQgfHwgdGV4dGFyZWFTaXplQ2hhbmdlZCB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCB8fCB3aWR0aEF1dG9DaGFuZ2VkIHx8IHdpZHRoQXV0byB8fCBoZWlnaHRBdXRvQ2hhbmdlZCB8fCBoZWlnaHRBdXRvIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkIHx8IG92ZXJmbG93QmVoYXZpb3JDaGFuZ2VkIHx8IGNsaXBBbHdheXNDaGFuZ2VkIHx8IHJlc2l6ZUNoYW5nZWQgfHwgc2Nyb2xsYmFyc1Zpc2liaWxpdHlDaGFuZ2VkIHx8IHNjcm9sbGJhcnNBdXRvSGlkZUNoYW5nZWQgfHwgc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDaGFuZ2VkIHx8IHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NoYW5nZWQgfHwgdGV4dGFyZWFEeW5XaWR0aENoYW5nZWQgfHwgdGV4dGFyZWFEeW5IZWlnaHRDaGFuZ2VkIHx8IHRleHRhcmVhQXV0b1dyYXBwaW5nQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3ZlcmZsb3cgPSAnb3ZlcmZsb3cnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3ZlcmZsb3dYID0gc3RyT3ZlcmZsb3cgKyAnLXgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3ZlcmZsb3dZID0gc3RyT3ZlcmZsb3cgKyAnLXknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RySGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJWaXNpYmxlID0gJ3Zpc2libGUnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9SZXNldCB0aGUgdmlld3BvcnQgKHZlcnkgaW1wb3J0YW50IGZvciBuYXRpdmVseSBvdmVybGFpZCBzY3JvbGxiYXJzIGFuZCB6b29tIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Rvbid0IGNoYW5nZSB0aGUgb3ZlcmZsb3cgcHJvcCBhcyBpdCBpcyB2ZXJ5IGV4cGVuc2l2ZSBhbmQgYWZmZWN0cyBwZXJmb3JtYW5jZSAhQSBMT1QhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydEVsZW1lbnRSZXNldENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2V0WFRtcCA9IF9oYXNPdmVyZmxvd0NhY2hlLnkgJiYgX2hpZGVPdmVyZmxvd0NhY2hlLnlzICYmICFpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID8gKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgPyBfdmlld3BvcnRFbGVtZW50LmNzcyhpc1JUTExlZnQpIDogLV9uYXRpdmVTY3JvbGxiYXJTaXplLnkpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldEJvdHRvbVRtcCA9IF9oYXNPdmVyZmxvd0NhY2hlLnggJiYgX2hpZGVPdmVyZmxvd0NhY2hlLnhzICYmICFpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID8gKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggPyBfdmlld3BvcnRFbGVtZW50LmNzcyhfc3RyQm90dG9tKSA6IC1fbmF0aXZlU2Nyb2xsYmFyU2l6ZS54KSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQodmlld3BvcnRFbGVtZW50UmVzZXRDU1MsIF9zdHJFbXB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmNzcyh2aWV3cG9ydEVsZW1lbnRSZXNldENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSBzZXZlcmFsIHNpemVzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudE1lYXN1cmVFbGVtZW50ID0gZ2V0Q29udGVudE1lYXN1cmVFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW4gRmlyZWZveCBjb250ZW50IGVsZW1lbnQgaGFzIHRvIGhhdmUgb3ZlcmZsb3cgaGlkZGVuLCBlbHNlIGVsZW1lbnQgbWFyZ2lucyBhcmVuJ3QgY2FsY3VsYXRlZCBwcm9wZXJseSwgdGhpcyBlbGVtZW50IHByZXZlbnRzIHRoaXMgYnVnLCBidXQgb25seSBpZiBzY3JvbGxiYXJzIGFyZW4ndCBvdmVybGFpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VzZSBjbGllbnRTaXplIGJlY2F1c2UgbmF0aXZlbHkgb3ZlcmxhaWRTY3JvbGxiYXJzIGFkZCBib3JkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiB0ZXh0YXJlYUR5bk9yaWdTaXplLncgfHwgY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uY1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogdGV4dGFyZWFEeW5PcmlnU2l6ZS5oIHx8IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLmNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSB0aGUgY29ycmVjdCB2aWV3cG9ydCBzdHlsZSBhbmQgbWVhc3VyZSB2aWV3cG9ydCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTW19zdHJCb3R0b21dID0gd2FzSGVpZ2h0QXV0byA/IF9zdHJFbXB0eSA6IHJlc2V0Qm90dG9tVG1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50UmVzZXRDU1NbaXNSVExMZWZ0XSA9IHdhc1dpZHRoQXV0byA/IF9zdHJFbXB0eSA6IHJlc2V0WFRtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuY3NzKHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgYW5kIGNvcnJlY3Qgc2V2ZXJhbCBzaXplc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdFNpemUgPSBnZXRIb3N0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEFic29sdXRlUmVjdFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBob3N0U2l6ZS53IC0gX21hcmdpblggLSBfYm9yZGVyWCAtIChfaXNCb3JkZXJCb3ggPyAwIDogX3BhZGRpbmdYKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IGhvc3RTaXplLmggLSBfbWFyZ2luWSAtIF9ib3JkZXJZIC0gKF9pc0JvcmRlckJveCA/IDAgOiBfcGFkZGluZ1kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50R2x1ZVNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NsaWVudC9zY3JvbGxTaXplICsgQWJzb2x1dGVQYWRkaW5nIC0+IGJlY2F1c2UgcGFkZGluZyBpcyBvbmx5IGFwcGxpZWQgdG8gdGhlIHBhZGRpbmdFbGVtZW50IGlmIGl0cyBhYnNvbHV0ZSwgc28geW91IGhhdmUgdG8gYWRkIGl0IG1hbnVhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hvc3RTaXplIGlzIGNsaWVudFNpemUgLT4gc28gcGFkZGluZyBzaG91bGQgYmUgYWRkZWQgbWFudWFsbHksIHJpZ2h0PyBGQUxTRSEgQmVjYXVzZSBjb250ZW50IGdsdWUgaXMgaW5zaWRlIGhvc3RFbGVtZW50LCBzbyB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IE1BVEgubWF4KCh3aWR0aEF1dG8gPyBjb250ZW50U2l6ZS53IDogc2Nyb2xsU2l6ZS53KSArIHBhZGRpbmdBYnNvbHV0ZVgsIGhvc3RBYnNvbHV0ZVJlY3RTaXplLncpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogTUFUSC5tYXgoKGhlaWdodEF1dG8gPyBjb250ZW50U2l6ZS5oIDogc2Nyb2xsU2l6ZS5oKSArIHBhZGRpbmdBYnNvbHV0ZVksIGhvc3RBYnNvbHV0ZVJlY3RTaXplLmgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlU2l6ZS5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShjb250ZW50R2x1ZVNpemUsIF9jb250ZW50R2x1ZVNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZVNpemVDYWNoZSA9IGNvbnRlbnRHbHVlU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgY29ycmVjdCBjb250ZW50R2x1ZSBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0b0NhcGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2l6ZSBjb250ZW50R2x1ZSBjb3JyZWN0bHkgdG8gbWFrZSBzdXJlIHRoZSBlbGVtZW50IGhhcyBjb3JyZWN0IHNpemUgaWYgdGhlIHNpemluZyBzd2l0Y2hlcyB0byBhdXRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudEdsdWVTaXplLmMgfHwgKGhlaWdodEF1dG8gfHwgd2lkdGhBdXRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyV2lkdGhdID0gY29udGVudEdsdWVTaXplLnc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gY29udGVudEdsdWVTaXplLmg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGV4dGFyZWEtc2l6ZXMgYXJlIGFscmVhZHkgY2FsY3VsYXRlZCBjb3JyZWN0bHkgYXQgdGhpcyBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VzZSBjbGllbnRTaXplIGJlY2F1c2UgbmF0aXZlbHkgb3ZlcmxhaWRTY3JvbGxiYXJzIGFkZCBib3JkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFDb3ZlckNTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldENvbnRlbnRHbHVlRWxlbWVudENTU2Z1bmN0aW9uID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdoID0gc2Nyb2xsYmFyVmFycy5fd19oO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJXSCA9IHNjcm9sbGJhclZhcnMuX3dpZHRoX2hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b1NpemUgPSBob3Jpem9udGFsID8gd2lkdGhBdXRvIDogaGVpZ2h0QXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyU2l6ZSA9IGhvcml6b250YWwgPyBfYm9yZGVyWCA6IF9ib3JkZXJZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nU2l6ZSA9IGhvcml6b250YWwgPyBfcGFkZGluZ1ggOiBfcGFkZGluZ1k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpblNpemUgPSBob3Jpem9udGFsID8gX21hcmdpblggOiBfbWFyZ2luWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRTaXplID0gX3ZpZXdwb3J0U2l6ZVt3aF0gLSBib3JkZXJTaXplIC0gbWFyZ2luU2l6ZSAtIChfaXNCb3JkZXJCb3ggPyAwIDogcGFkZGluZ1NpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2UgY29udGVudEdsdWUgc2l6ZSAtMSBpZiBlbGVtZW50IGlzIG5vdCBhdXRvIHNpemVkLCB0byBtYWtlIHN1cmUgdGhhdCBhIHJlc2l6ZSBldmVudCBoYXBwZW5zIHdoZW4gdGhlIGVsZW1lbnQgc2hyaW5rc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXV0b1NpemUgfHwgKCFhdXRvU2l6ZSAmJiBib3JkZXIuYykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tzdHJXSF0gPSBob3N0QWJzb2x1dGVSZWN0U2l6ZVt3aF0gLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHNpemUgaXMgYXV0byBhbmQgaG9zdCBpcyBzbWFsbGVyIHRoYW4gc2l6ZSBhcyBtaW4gc2l6ZSwgbWFrZSBjb250ZW50IGdsdWUgc2l6ZSAtMSB0byBtYWtlIHN1cmUgc2l6ZSBjaGFuZ2VzIHdpbGwgYmUgZGV0ZWN0ZWQgKHRoaXMgaXMgb25seSBuZWVkZWQgaWYgcGFkZGluZyBpcyAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRvU2l6ZSAmJiAoY29udGVudFNpemVbd2hdIDwgdmlld3BvcnRTaXplKSAmJiAoaG9yaXpvbnRhbCAmJiBfaXNUZXh0YXJlYSA/ICF0ZXh0YXJlYUF1dG9XcmFwcGluZyA6IHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhQ292ZXJDU1Nbc3RyV0hdID0gcGFyc2VUb1plcm9Pck51bWJlcihfdGV4dGFyZWFDb3ZlckVsZW1lbnQuY3NzKHN0cldIKSkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1Nbc3RyV0hdIC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSBjb250ZW50IGdsdWUgc2l6ZSBpcyBhdCBsZWFzdCAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRTaXplW3doXSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tzdHJXSF0gPSBNQVRILm1heCgxLCBjb250ZW50R2x1ZUVsZW1lbnRDU1Nbc3RyV0hdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50R2x1ZUVsZW1lbnRDU1NmdW5jdGlvbih0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRHbHVlRWxlbWVudENTU2Z1bmN0aW9uKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhQ292ZXJFbGVtZW50LmNzcyh0ZXh0YXJlYUNvdmVyQ1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKGNvbnRlbnRHbHVlRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoQXV0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aEF1dG8gJiYgIV9pc0JvcmRlckJveCAmJiAhX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckZsb2F0XSA9ICdub25lJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgYW5kIHJlc2V0IGNvbnRlbnQgc3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjb250ZW50RWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgYWdhaW4sIGJ1dCB0aGlzIHRpbWUgYWxsIGNvcnJlY3Qgc2l6ZXM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50U2Nyb2xsU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNIXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFNjcm9sbFNpemUuYyA9IGNvbnRlbnRTaXplQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoY29udGVudFNjcm9sbFNpemUsIF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGUgPSBjb250ZW50U2Nyb2xsU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVmcmVzaCB2aWV3cG9ydCBzaXplIGFmdGVyIGNvcnJlY3QgbWVhc3VyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RTaXplID0gZ2V0SG9zdFNpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFNpemVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShob3N0U2l6ZSwgX2hvc3RTaXplQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaG9zdFNpemVDYWNoZSA9IGhvc3RTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpZGVPdmVyZmxvd0ZvcmNlVGV4dGFyZWEgPSBfaXNUZXh0YXJlYSAmJiAoX3ZpZXdwb3J0U2l6ZS53ID09PSAwIHx8IF92aWV3cG9ydFNpemUuaCA9PT0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c092ZXJmbG93QW1vdW50ID0gX292ZXJmbG93QW1vdW50Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9ySXNWUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvcklzVkggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3JJc1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QW1vdW50ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNPdmVyZmxvdyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlkZU92ZXJmbG93ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5TY3JvbGwgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0UmVjdCA9IF9wYWRkaW5nRWxlbWVudE5hdGl2ZVtMRVhJQ09OLmJDUl0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldE92ZXJmbG93VmFyaWFibGVzID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQgPSBnZXRTY3JvbGxiYXJWYXJzKCFob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eUkgPSBzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eSA9IHNjcm9sbGJhclZhcnMuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aCA9IHNjcm9sbGJhclZhcnMuX3dfaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aEhlaWdodCA9IHNjcm9sbGJhclZhcnMuX3dpZHRoX2hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxNYXggPSBfc3RyU2Nyb2xsICsgc2Nyb2xsYmFyVmFycy5fTGVmdF9Ub3AgKyAnTWF4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgPSB2aWV3cG9ydFJlY3Rbd2lkdGhIZWlnaHRdID8gTUFUSC5hYnModmlld3BvcnRSZWN0W3dpZHRoSGVpZ2h0XSAtIF92aWV3cG9ydFNpemVbd2hdKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tGcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgPSBwcmV2aW91c092ZXJmbG93QW1vdW50ICYmIHByZXZpb3VzT3ZlcmZsb3dBbW91bnRbeHldID4gMCAmJiBfdmlld3BvcnRFbGVtZW50TmF0aXZlW3Njcm9sbE1heF0gPT09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9ySXNWU1t4eV0gPSBvdmVyZmxvd0JlaGF2aW9yW3h5XSA9PT0gJ3Ytcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9ySXNWSFt4eV0gPSBvdmVyZmxvd0JlaGF2aW9yW3h5XSA9PT0gJ3YtaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9ySXNTW3h5XSA9IG92ZXJmbG93QmVoYXZpb3JbeHldID09PSAncyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0Ftb3VudFt4eV0gPSBNQVRILm1heCgwLCBNQVRILnJvdW5kKChjb250ZW50U2Nyb2xsU2l6ZVt3aF0gLSBfdmlld3BvcnRTaXplW3doXSkgKiAxMDApIC8gMTAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QW1vdW50W3h5XSAqPSAoaGlkZU92ZXJmbG93Rm9yY2VUZXh0YXJlYSB8fCAoY2hlY2tGcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgJiYgZnJhY3Rpb25hbE92ZXJmbG93QW1vdW50ID4gMCAmJiBmcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgPCAxKSkgPyAwIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc092ZXJmbG93W3h5XSA9IG92ZXJmbG93QW1vdW50W3h5XSA+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9oaWRlT3ZlcmZsb3c6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ggfHwgeSA6IHRydWUgPT09IG92ZXJmbG93IGlzIGhpZGRlbiBieSBcIm92ZXJmbG93OiBzY3JvbGxcIiBPUiBcIm92ZXJmbG93OiBoaWRkZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy94cyB8fCB5cyA6IHRydWUgPT09IG92ZXJmbG93IGlzIGhpZGRlbiBieSBcIm92ZXJmbG93OiBzY3JvbGxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZU92ZXJmbG93W3h5XSA9IG92ZXJmbG93QmVoYXZpb3JJc1ZTW3h5XSB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWSFt4eV0gPyAoaGFzT3ZlcmZsb3dbeHlJXSAmJiAhb3ZlcmZsb3dCZWhhdmlvcklzVlNbeHlJXSAmJiAhb3ZlcmZsb3dCZWhhdmlvcklzVkhbeHlJXSkgOiBoYXNPdmVyZmxvd1t4eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcmZsb3dbeHkgKyAncyddID0gaGlkZU92ZXJmbG93W3h5XSA/IChvdmVyZmxvd0JlaGF2aW9ySXNTW3h5XSB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWU1t4eV0pIDogZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuU2Nyb2xsW3h5XSA9IGhhc092ZXJmbG93W3h5XSAmJiBoaWRlT3ZlcmZsb3dbeHkgKyAncyddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPdmVyZmxvd1ZhcmlhYmxlcyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3ZlcmZsb3dWYXJpYWJsZXMoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dBbW91bnQuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uob3ZlcmZsb3dBbW91bnQsIF9vdmVyZmxvd0Ftb3VudENhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX292ZXJmbG93QW1vdW50Q2FjaGUgPSBvdmVyZmxvd0Ftb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3cuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoaGFzT3ZlcmZsb3csIF9oYXNPdmVyZmxvd0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hhc092ZXJmbG93Q2FjaGUgPSBoYXNPdmVyZmxvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZU92ZXJmbG93LmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGhpZGVPdmVyZmxvdywgX2hpZGVPdmVyZmxvd0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hpZGVPdmVyZmxvd0NhY2hlID0gaGlkZU92ZXJmbG93O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBuYXRpdmUgc2Nyb2xsYmFyIGlzIG92ZXJsYXkgYXQgeCBPUiB5IGF4aXMsIHByZXBhcmUgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54IHx8IF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJEZXNpZ24gPSAncHggc29saWQgdHJhbnNwYXJlbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRBcnJhbmdlRWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmFuZ2VDb250ZW50ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYW5nZUNoYW5nZWQgPSBmb3JjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRDb250ZW50RWxlbWVudENTUztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmZsb3cueCB8fCBoYXNPdmVyZmxvdy55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNvbnRlbnQudyA9IF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgJiYgaGFzT3ZlcmZsb3cueSA/IGNvbnRlbnRTY3JvbGxTaXplLncgKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS55IDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDb250ZW50LmggPSBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIGhhc092ZXJmbG93LnggPyBjb250ZW50U2Nyb2xsU2l6ZS5oICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueCA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoYXJyYW5nZUNvbnRlbnQsIF9hcnJhbmdlQ29udGVudFNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FycmFuZ2VDb250ZW50U2l6ZUNhY2hlID0gYXJyYW5nZUNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJmbG93LmMgfHwgaGlkZU92ZXJmbG93LmMgfHwgY29udGVudFNjcm9sbFNpemUuYyB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQgfHwgd2lkdGhBdXRvIHx8IGhlaWdodEF1dG8gfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBpc1JUTFJpZ2h0XSA9IGNvbnRlbnRFbGVtZW50Q1NTW19zdHJCb3JkZXJNaW51cyArIGlzUlRMUmlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRFbGVtZW50Q1NTID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0ludmVydGVkID0gZ2V0U2Nyb2xsYmFyVmFycyghaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eSA9IHNjcm9sbGJhclZhcnMuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfc3RyQm90dG9tIDogaXNSVExMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW52ZXJ0ZWRBdXRvU2l6ZSA9IGhvcml6b250YWwgPyBoZWlnaHRBdXRvIDogd2lkdGhBdXRvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkW3h5XSAmJiBoYXNPdmVyZmxvd1t4eV0gJiYgaGlkZU92ZXJmbG93W3h5ICsgJ3MnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgc3RyRGlyZWN0aW9uXSA9IGludmVydGVkQXV0b1NpemUgPyAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyA/IF9zdHJFbXB0eSA6IF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplW3h5XSkgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyQm9yZGVyTWludXMgKyBzdHJEaXJlY3Rpb25dID0gKChob3Jpem9udGFsID8gIWludmVydGVkQXV0b1NpemUgOiB0cnVlKSAmJiAhaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZykgPyAoX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemVbeHldICsgYm9yZGVyRGVzaWduKSA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDb250ZW50W3Njcm9sbGJhclZhcnNJbnZlcnRlZC5fd19oXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgc3RyRGlyZWN0aW9uXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckJvcmRlck1pbnVzICsgc3RyRGlyZWN0aW9uXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfdmlld3BvcnRFbGVtZW50LCBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzSW52aXNpYmxlLCAhaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRFbGVtZW50Q1NTKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50RWxlbWVudENTUyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ29udGVudC53ID0gYXJyYW5nZUNvbnRlbnQuaCA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYW5nZUNoYW5nZWQgJiYgIV9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEFycmFuZ2VFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBoaWRlT3ZlcmZsb3cueSA/IGFycmFuZ2VDb250ZW50LncgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEFycmFuZ2VFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gaGlkZU92ZXJmbG93LnggPyBhcnJhbmdlQ29udGVudC5oIDogX3N0ckVtcHR5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9jb250ZW50QXJyYW5nZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRBcnJhbmdlRWxlbWVudCA9IEZSQU1FV09SSyhnZW5lcmF0ZURpdihfY2xhc3NOYW1lQ29udGVudEFycmFuZ2VFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQucHJlcGVuZChfY29udGVudEFycmFuZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRBcnJhbmdlRWxlbWVudC5jc3MoY29udGVudEFycmFuZ2VFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY29udGVudEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nRWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0Vmlld3BvcnRDU1M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3N0U2l6ZUNoYW5nZWQgfHwgaGFzT3ZlcmZsb3cuYyB8fCBoaWRlT3ZlcmZsb3cuYyB8fCBjb250ZW50U2Nyb2xsU2l6ZS5jIHx8IG92ZXJmbG93QmVoYXZpb3JDaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCB8fCBjbGlwQWx3YXlzQ2hhbmdlZCB8fCBoZWlnaHRBdXRvQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW2lzUlRMUmlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRDU1MgPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0ludmVydGVkID0gZ2V0U2Nyb2xsYmFyVmFycyghaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHh5ID0gc2Nyb2xsYmFyVmFycy5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBYWSA9IHNjcm9sbGJhclZhcnMuX1hfWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyRGlyZWN0aW9uID0gaG9yaXpvbnRhbCA/IF9zdHJCb3R0b20gOiBpc1JUTExlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ckRpcmVjdGlvbl0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50Qm9yZGVyU2l6ZVtzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQuX3dfaF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJmbG93W3h5XSAmJiBoaWRlT3ZlcmZsb3dbeHkgKyAncyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJPdmVyZmxvdyArIFhZXSA9IF9zdHJTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nIHx8IF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ckRpcmVjdGlvbl0gPSAtKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkW3h5XSA/IF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplW3h5XSA6IF9uYXRpdmVTY3JvbGxiYXJTaXplW3h5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEJvcmRlclNpemVbc2Nyb2xsYmFyVmFyc0ludmVydGVkLl93X2hdID0gX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWRbeHldID8gX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemVbc2Nyb2xsYmFyVmFyc0ludmVydGVkLl94X3ldIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJPdmVyZmxvdyArIFhZXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRDU1ModHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydENTUyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNjcm9sbCBjb250YWluZXIgaXMgdG9vIHNtYWxsIGFuZCBpZiB0aGVyZSBpcyBhbnkgb3ZlcmZsb3cgd2l0aCBubyBvdmVybGF5IHNjcm9sbGJhciAoYW5kIHNjcm9sbGJhciBzdHlsaW5nIGlzbid0IHBvc3NpYmxlKSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHZpZXdwb3J0IGVsZW1lbnQgZ3JlYXRlciBpbiBzaXplIChGaXJlZm94IGhpZGUgU2Nyb2xsYmFycyBmaXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGZpcmVmb3ggc3RhcnRzIGhpZGluZyBzY3JvbGxiYXJzIG9uIHRvbyBzbWFsbCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGlzIGJlaGF2aW9yIHRoZSBvdmVyZmxvdyBjYWxjdWxhdGlvbiBtYXkgYmUgaW5jb3JyZWN0IG9yIHRoZSBzY3JvbGxiYXJzIHdvdWxkIGFwcGVhciBzdWRkZW5seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkyMjg0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKF92aWV3cG9ydFNpemUuaCA8IF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLnggfHwgX3ZpZXdwb3J0U2l6ZS53IDwgX25hdGl2ZVNjcm9sbGJhck1pblNpemUueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoKGhhc092ZXJmbG93LnggJiYgaGlkZU92ZXJmbG93LnggJiYgIV9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLngpIHx8IChoYXNPdmVyZmxvdy55ICYmIGhpZGVPdmVyZmxvdy55ICYmICFfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0clBhZGRpbmdNaW51cyArIF9zdHJUb3BdID0gX25hdGl2ZVNjcm9sbGJhck1pblNpemUueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgX3N0clRvcF0gPSAtX25hdGl2ZVNjcm9sbGJhck1pblNpemUueDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJQYWRkaW5nTWludXMgKyBpc1JUTFJpZ2h0XSA9IF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIGlzUlRMUmlnaHRdID0gLV9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0clBhZGRpbmdNaW51cyArIF9zdHJUb3BdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIF9zdHJUb3BdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJQYWRkaW5nTWludXMgKyBpc1JUTFJpZ2h0XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBpc1JUTFJpZ2h0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyUGFkZGluZ01pbnVzICsgaXNSVExMZWZ0XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIGlzUlRMTGVmdF0gPSBfc3RyRW1wdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyBhbnkgb3ZlcmZsb3cgKHggT1IgeSBheGlzKSBhbmQgdGhpcyBvdmVyZmxvdyBzaGFsbCBiZSBoaWRkZW4sIG1ha2Ugb3ZlcmZsb3cgaGlkZGVuLCBlbHNlIG92ZXJmbG93IHZpc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaGFzT3ZlcmZsb3cueCAmJiBoaWRlT3ZlcmZsb3cueCkgfHwgKGhhc092ZXJmbG93LnkgJiYgaGlkZU92ZXJmbG93LnkpIHx8IGhpZGVPdmVyZmxvd0ZvcmNlVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29ubHkgaGlkZSBpZiBpcyBUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSAmJiBoaWRlT3ZlcmZsb3dGb3JjZVRleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdFbGVtZW50Q1NTW3N0ck92ZXJmbG93WF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0VsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dZXSA9IHN0ckhpZGRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaXBBbHdheXMgfHwgKG92ZXJmbG93QmVoYXZpb3JJc1ZILnggfHwgb3ZlcmZsb3dCZWhhdmlvcklzVlMueCB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWSC55IHx8IG92ZXJmbG93QmVoYXZpb3JJc1ZTLnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25seSB1bi1oaWRlIGlmIFRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0VsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dYXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0VsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dZXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dYXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dZXSA9IHN0clZpc2libGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5jc3MocGFkZGluZ0VsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5jc3Modmlld3BvcnRFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yY2Ugc29mdCByZWRyYXcgaW4gd2Via2l0IGJlY2F1c2Ugd2l0aG91dCB0aGUgc2Nyb2xsYmFycyB3aWxsIG1heSBhcHBlYXIgYmVjYXVzZSBET00gd29udCBiZSByZWRyYXduIHVuZGVyIHNwZWNpYWwgY29uZGl0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChoYXNPdmVyZmxvdy5jIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCBoZWlnaHRBdXRvQ2hhbmdlZCkgJiYgIShfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTdHlsZSA9IF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5kaXNwbGF5ID0gJ3J1bi1pbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtcCA9IF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGUuZGlzcGxheSA9IF9zdHJFbXB0eTsgLy98fCBkdW1wOyAvL3VzZSBkdW1wIHRvIHByZXZlbnQgaXQgZnJvbSBkZWxldGlvbiBpZiBtaW5pZnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGUud2Via2l0VHJhbnNmb3JtID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yY2UgaGFyZCByZWRyYXcgaW4gd2Via2l0IGlmIG5hdGl2ZSBvdmVybGFpZCBzY3JvbGxiYXJzIHNoYWxsIGFwcGVhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkICYmIGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1wID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZSB0byBkaXJlY3Rpb24gUlRMIGFuZCB3aWR0aCBhdXRvIEJ1Z2ZpeCBpbiBXZWJraXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy93aXRob3V0IHRoaXMgZml4LCB0aGUgRE9NIHN0aWxsIHRoaW5rcyB0aGUgc2Nyb2xsYmFyIGlzIExUUiBhbmQgdGh1cyB0aGUgY29udGVudCBpcyBzaGlmdGVkIHRvIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwgJiYgd2lkdGhBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsb2F0VG1wID0gX2NvbnRlbnRFbGVtZW50LmNzcyhfc3RyRmxvYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NMZWZ0V2l0aG91dEZsb2F0ID0gTUFUSC5yb3VuZChfY29udGVudEVsZW1lbnQuY3NzKF9zdHJGbG9hdCwgX3N0ckVtcHR5KS5jc3MoX3N0ckxlZnQsIF9zdHJFbXB0eSkucG9zaXRpb24oKS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKF9zdHJGbG9hdCwgZmxvYXRUbXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NMZWZ0V2l0aEZsb2F0ID0gTUFUSC5yb3VuZChfY29udGVudEVsZW1lbnQucG9zaXRpb24oKS5sZWZ0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc0xlZnRXaXRob3V0RmxvYXQgIT09IHBvc0xlZnRXaXRoRmxvYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJMZWZ0XSA9IHBvc0xlZnRXaXRob3V0RmxvYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyTGVmdF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjb250ZW50RWxlbWVudENTUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2hhbmRsZSBzY3JvbGwgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhICYmIGNvbnRlbnRTaXplQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhSW5mbyA9IGdldFRleHRhcmVhSW5mbygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRhcmVhSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVJvd3NDaGFuZ2VkID0gX3RleHRhcmVhSW5mb0NhY2hlID09PSB1bmRlZmluZWQgPyB0cnVlIDogdGV4dGFyZWFJbmZvLl9yb3dzICE9PSBfdGV4dGFyZWFJbmZvQ2FjaGUuX3Jvd3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclJvdyA9IHRleHRhcmVhSW5mby5fY3Vyc29yUm93O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JDb2wgPSB0ZXh0YXJlYUluZm8uX2N1cnNvckNvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZXN0Um93ID0gdGV4dGFyZWFJbmZvLl93aWRlc3RSb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RSb3cgPSB0ZXh0YXJlYUluZm8uX3Jvd3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RDb2wgPSB0ZXh0YXJlYUluZm8uX2NvbHVtbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclBvcyA9IHRleHRhcmVhSW5mby5fY3Vyc29yUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvck1heCA9IHRleHRhcmVhSW5mby5fY3Vyc29yTWF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JJc0xhc3RQb3NpdGlvbiA9IChjdXJzb3JQb3MgPj0gY3Vyc29yTWF4ICYmIF90ZXh0YXJlYUhhc0ZvY3VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFTY3JvbGxBbW91bnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6ICghdGV4dGFyZWFBdXRvV3JhcHBpbmcgJiYgKGN1cnNvckNvbCA9PT0gbGFzdENvbCAmJiBjdXJzb3JSb3cgPT09IHdpZGVzdFJvdykpID8gX292ZXJmbG93QW1vdW50Q2FjaGUueCA6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAodGV4dGFyZWFBdXRvV3JhcHBpbmcgPyBjdXJzb3JJc0xhc3RQb3NpdGlvbiB8fCB0ZXh0YXJlYVJvd3NDaGFuZ2VkICYmIChwcmV2aW91c092ZXJmbG93QW1vdW50ID8gKGN1cnJTY3JvbGwueSA9PT0gcHJldmlvdXNPdmVyZmxvd0Ftb3VudC55KSA6IGZhbHNlKSA6IChjdXJzb3JJc0xhc3RQb3NpdGlvbiB8fCB0ZXh0YXJlYVJvd3NDaGFuZ2VkKSAmJiBjdXJzb3JSb3cgPT09IGxhc3RSb3cpID8gX292ZXJmbG93QW1vdW50Q2FjaGUueSA6IC0xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyU2Nyb2xsLnggPSB0ZXh0YXJlYVNjcm9sbEFtb3VudC54ID4gLTEgPyAoX2lzUlRMICYmIF9ub3JtYWxpemVSVExDYWNoZSAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaSA/IDAgOiB0ZXh0YXJlYVNjcm9sbEFtb3VudC54KSA6IGN1cnJTY3JvbGwueDsgLy9pZiBpbnZlcnRlZCwgc2Nyb2xsIHRvIDAgLT4gbm9ybWFsaXplZCB0aGlzIG1lYW5zIHRvIG1heCBzY3JvbGwgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJTY3JvbGwueSA9IHRleHRhcmVhU2Nyb2xsQW1vdW50LnkgPiAtMSA/IHRleHRhcmVhU2Nyb2xsQW1vdW50LnkgOiBjdXJyU2Nyb2xsLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFJbmZvQ2FjaGUgPSB0ZXh0YXJlYUluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1JUTCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaSAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55ICYmIGhhc092ZXJmbG93LnggJiYgX25vcm1hbGl6ZVJUTENhY2hlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclNjcm9sbC54ICs9IF9jb250ZW50Qm9yZGVyU2l6ZS53IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aEF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0QXV0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oY3VyclNjcm9sbC54KVtfc3RyU2Nyb2xsVG9wXShjdXJyU2Nyb2xsLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIG1hbmFnZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eVZpc2libGUgPSBzY3JvbGxiYXJzVmlzaWJpbGl0eSA9PT0gJ3YnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlIaWRkZW4gPSBzY3JvbGxiYXJzVmlzaWJpbGl0eSA9PT0gJ2gnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlBdXRvID0gc2Nyb2xsYmFyc1Zpc2liaWxpdHkgPT09ICdhJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChzaG93WCwgc2hvd1kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dZID0gc2hvd1kgPT09IHVuZGVmaW5lZCA/IHNob3dYIDogc2hvd1k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyQXBwZWFyYW5jZSh0cnVlLCBzaG93WCwgY2FuU2Nyb2xsLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyQXBwZWFyYW5jZShmYWxzZSwgc2hvd1ksIGNhblNjcm9sbC55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2UgY2xhc3MgbmFtZSB3aGljaCBpbmRpY2F0ZXMgc2Nyb2xsYWJsZSBvdmVyZmxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3csIGhpZGVPdmVyZmxvdy54IHx8IGhpZGVPdmVyZmxvdy55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WCwgaGlkZU92ZXJmbG93LngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dZLCBoaWRlT3ZlcmZsb3cueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCBvciByZW1vdmUgcnRsIGNsYXNzIG5hbWUgZm9yIHN0eWxpbmcgcHVycG9zZXMgZXhjZXB0IHdoZW4gaXRzIGJvZHksIHRoZW4gdGhlIHNjcm9sbGJhciBzdGF5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzRGlyZWN0aW9uQ2hhbmdlZCAmJiAhX2lzQm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFJUTCwgX2lzUlRMKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2UgdGhlIHJlc2l6ZSBmZWF0dXJlIChDU1MzIHJlc2l6ZSBcInBvbHlmaWxsXCIgZm9yIHRoaXMgcGx1Z2luKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RSZXNpemVEaXNhYmxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0UmVzaXplRGlzYWJsZWQsIF9yZXNpemVOb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplLCAhX3Jlc2l6ZU5vbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVCLCBfcmVzaXplQm90aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUgsIF9yZXNpemVIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplViwgX3Jlc2l6ZVZlcnRpY2FsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2UgdGhlIHNjcm9sbGJhcnMgZ2VuZXJhbCB2aXNpYmlsaXR5ICsgdGhlIHNjcm9sbGJhciBpbnRlcmFjdGl2aXR5ICh1bnVzYWJsZSBjbGFzcyBuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyc1Zpc2liaWxpdHlDaGFuZ2VkIHx8IG92ZXJmbG93QmVoYXZpb3JDaGFuZ2VkIHx8IGhpZGVPdmVyZmxvdy5jIHx8IGhhc092ZXJmbG93LmMgfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RTY3JvbGxpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNWaXNpYmlsaXR5KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbGJhcnNWaXNpYmlsaXR5QXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eShjYW5TY3JvbGwueCwgY2FuU2Nyb2xsLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsYmFyc1Zpc2liaWxpdHlWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNWaXNpYmlsaXR5KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsYmFyc1Zpc2liaWxpdHlIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc1Zpc2liaWxpdHkoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21hbmFnZSB0aGUgc2Nyb2xsYmFycyBhdXRvIGhpZGUgZmVhdHVyZSAoYXV0byBoaWRlIHRoZW0gYWZ0ZXIgc3BlY2lmaWMgYWN0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhcnNBdXRvSGlkZUNoYW5nZWQgfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwSG9zdE1vdXNlVG91Y2hFdmVudHMoIV9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSAmJiAhX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShfc2Nyb2xsYmFyc0F1dG9IaWRlTmV2ZXIsICFfc2Nyb2xsYmFyc0F1dG9IaWRlTmV2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21hbmFnZSBzY3JvbGxiYXJzIGhhbmRsZSBsZW5ndGggJiBvZmZzZXQgLSBkb24ndCByZW1vdmUhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3N0U2l6ZUNoYW5nZWQgfHwgb3ZlcmZsb3dBbW91bnQuYyB8fCBoZWlnaHRBdXRvQ2hhbmdlZCB8fCB3aWR0aEF1dG9DaGFuZ2VkIHx8IHJlc2l6ZUNoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkIHx8IGNzc0RpcmVjdGlvbkNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVMZW5ndGgodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZUxlbmd0aChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2UgaW50ZXJhY3Rpdml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nQ2hhbmdlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzSW50ZXJhY3RpdmUodHJ1ZSwgc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2hhbmdlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzSW50ZXJhY3RpdmUoZmFsc2UsIHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsbGJhY2tzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkRpcmVjdGlvbkNoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JUTDogX2lzUlRMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyOiBjc3NEaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY3NzRGlyZWN0aW9uQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uSG9zdFNpemVDaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF9ob3N0U2l6ZUNhY2hlLncsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF9ob3N0U2l6ZUNhY2hlLmhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgaG9zdFNpemVDaGFuZ2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25Db250ZW50U2l6ZUNoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGUudyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGUuaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjb250ZW50U2l6ZUNoYW5nZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbk92ZXJmbG93Q2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGhhc092ZXJmbG93LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBoYXNPdmVyZmxvdy55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFNjcm9sbGFibGU6IGhpZGVPdmVyZmxvdy54cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlTY3JvbGxhYmxlOiBoaWRlT3ZlcmZsb3cueXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwcGVkOiBoaWRlT3ZlcmZsb3cueCB8fCBoaWRlT3ZlcmZsb3cueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBoYXNPdmVyZmxvdy5jIHx8IGhpZGVPdmVyZmxvdy5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25PdmVyZmxvd0Ftb3VudENoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBvdmVyZmxvd0Ftb3VudC54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogb3ZlcmZsb3dBbW91bnQueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvdmVyZmxvd0Ftb3VudC5jKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZml4IGJvZHkgbWluIHNpemVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSAmJiBfYm9keU1pblNpemVDYWNoZSAmJiAoX2hhc092ZXJmbG93Q2FjaGUuYyB8fCBfYm9keU1pblNpemVDYWNoZS5jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2l0cyBwb3NzaWJsZSB0aGF0IG5vIG1pbiBzaXplIHdhcyBtZWFzdXJlZCB1bnRpbCBub3csIGJlY2F1c2UgdGhlIGNvbnRlbnQgYXJyYW5nZSBlbGVtZW50IHdhcyBqdXN0IGFkZGVkIG5vdywgaW4gdGhpcyBjYXNlLCBtZWFzdXJlIG5vdyB0aGUgbWluIHNpemUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2JvZHlNaW5TaXplQ2FjaGUuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSAmJiBfaGFzT3ZlcmZsb3dDYWNoZS54KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhfc3RyTWluTWludXMgKyBfc3RyV2lkdGgsIF9ib2R5TWluU2l6ZUNhY2hlLncgKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX2hhc092ZXJmbG93Q2FjaGUueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoX3N0ck1pbk1pbnVzICsgX3N0ckhlaWdodCwgX2JvZHlNaW5TaXplQ2FjaGUuaCArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYm9keU1pblNpemVDYWNoZS5jID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2luaXRpYWxpemVkICYmIGNoYW5nZWRPcHRpb25zLnVwZGF0ZU9uTG9hZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50c09uTG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmVlemVSZXNpemVPYnNlcnZlcihfc2l6ZU9ic2VydmVyRWxlbWVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJlZXplUmVzaXplT2JzZXJ2ZXIoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uVXBkYXRlZCcsIHsgZm9yY2VkOiBmb3JjZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIGZvdW5kIGVsZW1lbnRzIG9mIHdoaWNoIHRoZSBsb2FkIGV2ZW50IHNoYWxsIGJlIGhhbmRsZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzT25Mb2FkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaFVwZGF0ZU9uTG9hZChmdW5jdGlvbiAoaSwgdXBkYXRlT25Mb2FkU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5maW5kKHVwZGF0ZU9uTG9hZFNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgdXBkYXRlT25Mb2FkQ2FsbGJhY2sgYXBwbGllZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmluQShlbCwgX3VwZGF0ZU9uTG9hZEVsbXMpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlT25Mb2FkRWxtcy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLKGVsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9mZihfdXBkYXRlT25Mb2FkRXZlbnROYW1lLCB1cGRhdGVPbkxvYWRDYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihfdXBkYXRlT25Mb2FkRXZlbnROYW1lLCB1cGRhdGVPbkxvYWRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gT3B0aW9ucyA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgbmV3IG9wdGlvbnMgYnV0IGRvZXNuJ3QgY2FsbCB0aGUgdXBkYXRlIG1ldGhvZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuZXdPcHRpb25zIFRoZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG5ldyBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IEEgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBjaGFuZ2VkIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldE9wdGlvbnMobmV3T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRPcHRzID0gX3BsdWdpbnNPcHRpb25zLl92YWxpZGF0ZShuZXdPcHRpb25zLCBfcGx1Z2luc09wdGlvbnMuX3RlbXBsYXRlLCB0cnVlLCBfY3VycmVudE9wdGlvbnMpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50T3B0aW9ucyA9IGV4dGVuZERlZXAoe30sIF9jdXJyZW50T3B0aW9ucywgdmFsaWRhdGVkT3B0cy5fZGVmYXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMgPSBleHRlbmREZWVwKHt9LCBfY3VycmVudFByZXBhcmVkT3B0aW9ucywgdmFsaWRhdGVkT3B0cy5fcHJlcGFyZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkT3B0cy5fcHJlcGFyZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBTdHJ1Y3R1cmUgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCdWlsZHMgb3IgZGVzdHJveXMgdGhlIHdyYXBwZXIgYW5kIGhlbHBlciBET00gZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVzdHJveSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRE9NIHNoYWxsIGJlIGJ1aWxkIG9yIGRlc3Ryb3llZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCdWlsZHMgb3IgZGVzdHJveXMgdGhlIHdyYXBwZXIgYW5kIGhlbHBlciBET00gZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVzdHJveSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRE9NIHNoYWxsIGJlIGJ1aWxkIG9yIGRlc3Ryb3llZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTdHJ1Y3R1cmVET00oZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJQYXJlbnQgPSAncGFyZW50JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJIb3N0ID0gJ29zLXJlc2l6ZS1vYnNlcnZlci1ob3N0JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50RnVsbCA9IF9jbGFzc05hbWVUZXh0YXJlYUVsZW1lbnQgKyBfc3RyU3BhY2UgKyBfY2xhc3NOYW1lVGV4dEluaGVyaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQ2xhc3MgPSBfaXNUZXh0YXJlYSA/IF9zdHJTcGFjZSArIF9jbGFzc05hbWVUZXh0SW5oZXJpdCA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRvcHRBdHRycyA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnRleHRhcmVhLmluaGVyaXRlZEF0dHJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZG9wdEF0dHJzTWFwID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGx5QWRvcHRlZEF0dHJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBwbHlBZG9wdGVkQXR0cnNFbG0gPSBkZXN0cm95ID8gX3RhcmdldEVsZW1lbnQgOiBfaG9zdEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goYWRvcHRBdHRyc01hcCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKHZhbHVlKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBMRVhJQ09OLmMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5QWRvcHRlZEF0dHJzRWxtLmFkZENsYXNzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5QWRvcHRlZEF0dHJzRWxtLmF0dHIoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RFbGVtZW50Q2xhc3NOYW1lcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFRleHRhcmVhRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RSZXNpemVEaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RSVEwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0U2Nyb2xsYmFySG9yaXpvbnRhbEhpZGRlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJWZXJ0aWNhbEhpZGRlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RUcmFuc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFNjcm9sbGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RPdmVyZmxvd1gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lVGhlbWVOb25lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lVGV4dEluaGVyaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVDYWNoZV0uam9pbihfc3RyU3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0RWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dldCBob3N0IGVsZW1lbnQgYXMgZmlyc3QgZWxlbWVudCwgYmVjYXVzZSB0aGF0J3MgdGhlIG1vc3QgdXBwZXIgZWxlbWVudCBhbmQgcmVxdWlyZWQgZm9yIHRoZSBvdGhlciBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudCA9IF9ob3N0RWxlbWVudCB8fCAoX2lzVGV4dGFyZWEgPyAoX2RvbUV4aXN0cyA/IF90YXJnZXRFbGVtZW50W3N0clBhcmVudF0oKVtzdHJQYXJlbnRdKClbc3RyUGFyZW50XSgpW3N0clBhcmVudF0oKSA6IEZSQU1FV09SSyhnZW5lcmF0ZURpdihfY2xhc3NOYW1lSG9zdFRleHRhcmVhRWxlbWVudCkpKSA6IF90YXJnZXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQgPSBfY29udGVudEVsZW1lbnQgfHwgc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZUNvbnRlbnRFbGVtZW50ICsgdGV4dGFyZWFDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudCA9IF92aWV3cG9ydEVsZW1lbnQgfHwgc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVZpZXdwb3J0RWxlbWVudCArIHRleHRhcmVhQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudCA9IF9wYWRkaW5nRWxlbWVudCB8fCBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lUGFkZGluZ0VsZW1lbnQgKyB0ZXh0YXJlYUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudCA9IF9zaXplT2JzZXJ2ZXJFbGVtZW50IHx8IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKGNsYXNzTmFtZVJlc2l6ZU9ic2VydmVySG9zdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhQ292ZXJFbGVtZW50ID0gX3RleHRhcmVhQ292ZXJFbGVtZW50IHx8IChfaXNUZXh0YXJlYSA/IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVUZXh0YXJlYUNvdmVyRWxlbWVudCkgOiB1bmRlZmluZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGlzIGNsYXNzIHRvIHdvcmthcm91bmQgY2xhc3MgY2hhbmdpbmcgaXNzdWVzIHdpdGggVUkgZnJhbWV3b3JrcyBlc3BlY2lhbGx5IFZ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL29uIGRlc3Ryb3ksIHJlbW92ZSBhbGwgZ2VuZXJhdGVkIGNsYXNzIG5hbWVzIGZyb20gdGhlIGhvc3QgZWxlbWVudCBiZWZvcmUgY29sbGVjdGluZyB0aGUgYWRvcHRlZCBhdHRyaWJ1dGVzIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vdG8gcHJldmVudCBhZG9wdGluZyBnZW5lcmF0ZWQgY2xhc3MgbmFtZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdHJveSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBob3N0RWxlbWVudENsYXNzTmFtZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbGxlY3QgYWxsIGFkb3B0ZWQgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGFkb3B0QXR0cnMgPSB0eXBlKGFkb3B0QXR0cnMpID09IFRZUEVTLnMgPyBhZG9wdEF0dHJzLnNwbGl0KF9zdHJTcGFjZSkgOiBhZG9wdEF0dHJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmlzQShhZG9wdEF0dHJzKSAmJiBfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGFkb3B0QXR0cnMsIGZ1bmN0aW9uIChpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSh2KSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRvcHRBdHRyc01hcFt2XSA9IGRlc3Ryb3kgPyBfaG9zdEVsZW1lbnQuYXR0cih2KSA6IF90YXJnZXRFbGVtZW50LmF0dHIodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfY3VycmVudFByZXBhcmVkT3B0aW9ucy5zaXplQXV0b0NhcGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbWVudENTU1tfc3RyV2lkdGhdID0gX3RhcmdldEVsZW1lbnQuY3NzKF9zdHJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSBfdGFyZ2V0RWxlbWVudC5jc3MoX3N0ckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZG9tRXhpc3RzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmFkZENsYXNzKF9jbGFzc05hbWVUZXh0SW5oZXJpdCkud3JhcChfaG9zdEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8valF1ZXJ5IGNsb25lcyBlbGVtZW50cyBpbiB3cmFwIGZ1bmN0aW9ucywgc28gd2UgaGF2ZSB0byBzZWxlY3QgdGhlbSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50ID0gX3RhcmdldEVsZW1lbnRbc3RyUGFyZW50XSgpLmNzcyhob3N0RWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIGNvcnJlY3QgY2xhc3MgdG8gdGhlIHRhcmdldCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfdGFyZ2V0RWxlbWVudCwgX2lzVGV4dGFyZWEgPyBjbGFzc05hbWVUZXh0YXJlYUVsZW1lbnRGdWxsIDogX2NsYXNzTmFtZUhvc3RFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dyYXAgdGhlIGNvbnRlbnQgaW50byB0aGUgZ2VuZXJhdGVkIGVsZW1lbnRzIHRvIGNyZWF0ZSB0aGUgcmVxdWlyZWQgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQud3JhcElubmVyKF9jb250ZW50RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud3JhcElubmVyKF92aWV3cG9ydEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndyYXBJbm5lcihfcGFkZGluZ0VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByZXBlbmQoX3NpemVPYnNlcnZlckVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8valF1ZXJ5IGNsb25lcyBlbGVtZW50cyBpbiB3cmFwIGZ1bmN0aW9ucywgc28gd2UgaGF2ZSB0byBzZWxlY3QgdGhlbSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50ID0gZmluZEZpcnN0KF9ob3N0RWxlbWVudCwgX3N0ckRvdCArIF9jbGFzc05hbWVDb250ZW50RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50ID0gZmluZEZpcnN0KF9ob3N0RWxlbWVudCwgX3N0ckRvdCArIF9jbGFzc05hbWVWaWV3cG9ydEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50ID0gZmluZEZpcnN0KF9ob3N0RWxlbWVudCwgX3N0ckRvdCArIF9jbGFzc05hbWVQYWRkaW5nRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LnByZXBlbmQoX3RleHRhcmVhQ292ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUFkb3B0ZWRBdHRycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfdmlld3BvcnRFbGVtZW50LCBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzSW52aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF92aWV3cG9ydEVsZW1lbnQsIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2h0bWxFbGVtZW50LCBfY2xhc3NOYW1lSFRNTEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmUgPSBfc2l6ZU9ic2VydmVyRWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50TmF0aXZlID0gX2hvc3RFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnROYXRpdmUgPSBfcGFkZGluZ0VsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnROYXRpdmUgPSBfdmlld3BvcnRFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnROYXRpdmUgPSBfY29udGVudEVsZW1lbnRbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWaWV3cG9ydEF0dHJzRnJvbVRhcmdldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kb21FeGlzdHMgJiYgX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NsZWFyIHNpemUgb2JzZXJ2ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplT2JzZXJ2ZXJFbGVtZW50LmNoaWxkcmVuKCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIHN0eWxlIHByb3BlcnR5IGFuZCBjbGFzc2VzIGZyb20gYWxyZWFkeSBnZW5lcmF0ZWQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goW19wYWRkaW5nRWxlbWVudCwgX3ZpZXdwb3J0RWxlbWVudCwgX2NvbnRlbnRFbGVtZW50LCBfdGV4dGFyZWFDb3ZlckVsZW1lbnRdLCBmdW5jdGlvbiAoaSwgZWxtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbG0ucmVtb3ZlQXR0cihMRVhJQ09OLnMpLCBfY2xhc3NOYW1lc0R5bmFtaWNEZXN0cm95KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCBjbGFzc2VzIHRvIHRoZSBob3N0IGVsZW1lbnQgd2hpY2ggd2FzIHJlbW92ZWQgcHJldmlvdXNseSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIF9pc1RleHRhcmVhID8gX2NsYXNzTmFtZUhvc3RUZXh0YXJlYUVsZW1lbnQgOiBfY2xhc3NOYW1lSG9zdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgc2l6ZSBvYnNlcnZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF9zaXplT2JzZXJ2ZXJFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Vud3JhcCB0aGUgY29udGVudCB0byByZXN0b3JlIERPTVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNvbnRlbnRzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW53cmFwKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW53cmFwKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudW53cmFwKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQudW53cmFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF9ob3N0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF90ZXh0YXJlYUNvdmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlBZG9wdGVkQXR0cnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQucmVtb3ZlQXR0cihMRVhJQ09OLnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaHRtbEVsZW1lbnQsIF9jbGFzc05hbWVIVE1MRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBvciByZW1vdmVzIGFsbCB3cmFwcGVyIGVsZW1lbnRzIGludGVyYWN0aXZpdHkgZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIEV2ZW50cyBzaGFsbCBiZSBhZGRlZCBvciByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZUV2ZW50cygpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFLZXlEb3duUmVzdHJpY3RlZEtleUNvZGVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMTIsIDExMywgMTE0LCAxMTUsIDExNiwgMTE3LCAxMTgsIDExOSwgMTIwLCAxMjEsIDEyMywgICAgLy9GMSB0byBGMTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgMzMsIDM0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcGFnZSB1cCwgcGFnZSBkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDM3LCAzOCwgMzksIDQwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xlZnQsIHVwLCByaWdodCwgZG93biBhcnJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTYsIDE3LCAxOCwgMTksIDIwLCAxNDQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2hpZnQsIEN0cmwsIEFsdCwgUGF1c2UsIENhcHNMb2NrLCBOdW1Mb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhVXBkYXRlSW50ZXJ2YWxJRDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU3RvcFRpbWVvdXRJZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU3RvcERlbGF5ID0gMTc1O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJGb2N1cyA9ICdmb2N1cyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRhcmVhKGRvQ2xlYXJJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUoX3N0ckF1dG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9DbGVhckludGVydmFsICYmIF9hdXRvVXBkYXRlUmVjb21tZW5kZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRleHRhcmVhVXBkYXRlSW50ZXJ2YWxJRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25TY3JvbGwoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKF9ydGxTY3JvbGxCZWhhdmlvci5pICYmIF9ub3JtYWxpemVSVExDYWNoZSA/IDk5OTk5OTkgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFPbkRyb3AoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uRm9jdXMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUhhc0ZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBzdHJGb2N1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25Gb2N1c291dCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhSGFzRm9jdXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgc3RyRm9jdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUZXh0YXJlYSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFPbktleURvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQXJyYXkoa2V5Q29kZSwgdGV4dGFyZWFLZXlEb3duUmVzdHJpY3RlZEtleUNvZGVzKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0W0xFWElDT04ubF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUZXh0YXJlYSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhVXBkYXRlSW50ZXJ2YWxJRCA9IHNldEludGVydmFsKHVwZGF0ZVRleHRhcmVhLCAxMDAwIC8gNjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQXJyYXkoa2V5Q29kZSwgdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0KSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0LnB1c2goa2V5Q29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFPbktleVVwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShrZXlDb2RlLCB0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQXJyYXkoa2V5Q29kZSwgdGV4dGFyZWFLZXlEb3duUmVzdHJpY3RlZEtleUNvZGVzKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3RbTEVYSUNPTi5sXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUZXh0YXJlYSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb250ZW50T25UcmFuc2l0aW9uRW5kKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYXV0b1VwZGF0ZUNhY2hlID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NpemVBZmZlY3RpbmdDU1NQcm9wZXJ0eShldmVudC5wcm9wZXJ0eU5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdmlld3BvcnRPblNjcm9sbChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFN0b3BUaW1lb3V0SWQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsU3RvcFRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0U2Nyb2xsaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25TY3JvbGxTdGFydCcsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGEgc2Nyb2xsYmFycyBoYW5kbGUgZ2V0cyBkcmFnZ2VkLCB0aGUgbW91c2Vtb3ZlIGV2ZW50IGlzIHJlc3BvbnNpYmxlIGZvciByZWZyZXNoaW5nIHRoZSBoYW5kbGUgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2JlY2F1c2UgaWYgQ1NTIHNjcm9sbC1zbmFwIGlzIHVzZWQsIHRoZSBoYW5kbGUgb2Zmc2V0IGdldHMgb25seSByZWZyZXNoZWQgb24gZXZlcnkgc25hcCBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGxvb2tzIGxhZ2d5ICYgY2x1bmt5LCBpdCBsb29rcyBtdWNoIGJldHRlciBpZiB0aGUgb2Zmc2V0IHJlZnJlc2hlcyB3aXRoIHRoZSBtb3VzZW1vdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uU2Nyb2xsJywgZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFN0b3BUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9PblNjcm9sbFN0b3A6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxTdG9wVGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsU3RvcFRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZU92ZXJsYXlTY3JvbGxiYXJzQXJlQWN0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0U2Nyb2xsaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uU2Nyb2xsU3RvcCcsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzY3JvbGxTdG9wRGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbXNpZVZlcnNpb24gPiA5IHx8ICFfYXV0b1VwZGF0ZVJlY29tbWVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfdGFyZ2V0RWxlbWVudCwgJ2lucHV0JywgdXBkYXRlVGV4dGFyZWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3RhcmdldEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJLZXlEb3duRXZlbnQsIF9zdHJLZXlVcEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGV4dGFyZWFPbktleURvd24sIHRleHRhcmVhT25LZXlVcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfdGFyZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyU2Nyb2xsLCAnZHJvcCcsIHN0ckZvY3VzLCBzdHJGb2N1cyArICdvdXQnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZXh0YXJlYU9uU2Nyb2xsLCB0ZXh0YXJlYU9uRHJvcCwgdGV4dGFyZWFPbkZvY3VzLCB0ZXh0YXJlYU9uRm9jdXNvdXRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKF9jb250ZW50RWxlbWVudCwgX3N0clRyYW5zaXRpb25FbmRFdmVudCwgY29udGVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKF92aWV3cG9ydEVsZW1lbnQsIF9zdHJTY3JvbGwsIHZpZXdwb3J0T25TY3JvbGwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gU2Nyb2xsYmFycyA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEJ1aWxkcyBvciBkZXN0cm95cyBhbGwgc2Nyb2xsYmFyIERPTSBlbGVtZW50cyAoc2Nyb2xsYmFyLCB0cmFjaywgaGFuZGxlKVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERPTSBzaGFsbCBiZSBidWlsZCBvciBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU2Nyb2xsYmFyc0RPTShkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdE9yR2VuZXJhdGVTY3JvbGxiYXJET00gPSBmdW5jdGlvbiAoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJDbGFzc05hbWUgPSBpc0hvcml6b250YWwgPyBfY2xhc3NOYW1lU2Nyb2xsYmFySG9yaXpvbnRhbCA6IF9jbGFzc05hbWVTY3JvbGxiYXJWZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhciA9IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVTY3JvbGxiYXIgKyBfc3RyU3BhY2UgKyBzY3JvbGxiYXJDbGFzc05hbWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2ssIHNjcm9sbGJhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlLCBzY3JvbGxiYXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZG9tRXhpc3RzICYmICFkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXIuYXBwZW5kKHRyYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLmFwcGVuZChoYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcjogc2Nyb2xsYmFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RyYWNrOiB0cmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oYW5kbGU6IGhhbmRsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzZXRTY3JvbGxiYXJET00oaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyID0gc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBzY3JvbGxiYXJWYXJzLl90cmFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNjcm9sbGJhclZhcnMuX2hhbmRsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzICYmIF9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChbc2Nyb2xsYmFyLCB0cmFjaywgaGFuZGxlXSwgZnVuY3Rpb24gKGksIGVsbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsbS5yZW1vdmVBdHRyKExFWElDT04ucyksIF9jbGFzc05hbWVzRHluYW1pY0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoc2Nyb2xsYmFyIHx8IHNlbGVjdE9yR2VuZXJhdGVTY3JvbGxiYXJET00oaXNIb3Jpem9udGFsKS5fc2Nyb2xsYmFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEVsZW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEVsZW1lbnRzID0gc2VsZWN0T3JHZW5lcmF0ZVNjcm9sbGJhckRPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWxFbGVtZW50cyA9IHNlbGVjdE9yR2VuZXJhdGVTY3JvbGxiYXJET00oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudCA9IGhvcml6b250YWxFbGVtZW50cy5fc2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudCA9IGhvcml6b250YWxFbGVtZW50cy5fdHJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJIb3Jpem9udGFsSGFuZGxlRWxlbWVudCA9IGhvcml6b250YWxFbGVtZW50cy5faGFuZGxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50ID0gdmVydGljYWxFbGVtZW50cy5fc2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyVmVydGljYWxUcmFja0VsZW1lbnQgPSB2ZXJ0aWNhbEVsZW1lbnRzLl90cmFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudCA9IHZlcnRpY2FsRWxlbWVudHMuX2hhbmRsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50LmFmdGVyKF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50LmFmdGVyKF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U2Nyb2xsYmFyRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFNjcm9sbGJhckRPTSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGFsbCBzY3JvbGxiYXIgaW50ZXJhY3Rpdml0eSBldmVudHMuICh0cmFjayBhbmQgaGFuZGxlIGRyYWdnaW5nLCBjbGlja2luZywgc2Nyb2xsaW5nKVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGlzSG9yaXpvbnRhbCBUcnVlIGlmIHRoZSB0YXJnZXQgc2Nyb2xsYmFyIGlzIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciwgZmFsc2UgaWYgdGhlIHRhcmdldCBzY3JvbGxiYXIgaXMgdGhlIHZlcnRpY2FsIHNjcm9sbGJhci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTY3JvbGxiYXJFdmVudHMoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnNJbmZvID0gc2Nyb2xsYmFyVmFycy5faW5mbztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zaWRlSUZyYW1lID0gX3dpbmRvd0VsZW1lbnROYXRpdmUudG9wICE9PSBfd2luZG93RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeHkgPSBzY3JvbGxiYXJWYXJzLl94X3k7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIFhZID0gc2Nyb2xsYmFyVmFycy5fWF9ZO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGwgPSBfc3RyU2Nyb2xsICsgc2Nyb2xsYmFyVmFycy5fTGVmdF9Ub3A7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckFjdGl2ZSA9ICdhY3RpdmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJTbmFwSGFuZGxlID0gJ3NuYXBIYW5kbGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJDbGlja0V2ZW50ID0gJ2NsaWNrJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRHVyYXRpb25GYWN0b3IgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmNyZWFzZURlY3JlYXNlU2Nyb2xsQW1vdW50S2V5Q29kZXMgPSBbMTYsIDE3XTsgLy9zaGlmdCwgY3RybFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja1RpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93blNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25JbnZlcnRlZFNjYWxlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9tc2llVmVyc2lvbiAmJiBpbnNpZGVJRnJhbWUgPyBldmVudFsnc2NyZWVuJyArIFhZXSA6IENPTVBBVElCSUxJVFkucGFnZShldmVudClbeHldOyAvL3VzZSBzY3JlZW4gY29vcmRpbmF0ZXMgaW4gRURHRSAmIElFIGJlY2F1c2UgdGhlIHBhZ2UgdmFsdWVzIGFyZSBpbmNvcnJlY3QgaW4gZnJhbWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRQcmVwYXJlZFNjcm9sbGJhcnNPcHRpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuc2Nyb2xsYmFyc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5jcmVhc2VUcmFja1Njcm9sbEFtb3VudCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRHVyYXRpb25GYWN0b3IgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbER1cmF0aW9uRmFjdG9yID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc3RvcENsaWNrRXZlbnRQcm9wYWdhdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudEtleURvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQXJyYXkoZXZlbnQua2V5Q29kZSwgaW5jcmVhc2VEZWNyZWFzZVNjcm9sbEFtb3VudEtleUNvZGVzKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVhc2VUcmFja1Njcm9sbEFtb3VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudEtleVVwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGV2ZW50LmtleUNvZGUsIGluY3JlYXNlRGVjcmVhc2VTY3JvbGxBbW91bnRLZXlDb2RlcykgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzVG91Y2hFdmVudCA9IG9yaWdpbmFsRXZlbnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NsZWVwaW5nIHx8IF9kZXN0cm95ZWQgfHwgbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSB8fCAhX3Njcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2FjaGUgfHwgKGlzVG91Y2hFdmVudCAmJiAhZ2V0UHJlcGFyZWRTY3JvbGxiYXJzT3B0aW9uKCd0b3VjaFN1cHBvcnQnKSkgPyBmYWxzZSA6IENPTVBBVElCSUxJVFkubUJ0bihldmVudCkgPT09IDEgfHwgaXNUb3VjaEV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudERyYWdNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tMZW5ndGggPSBzY3JvbGxiYXJWYXJzSW5mby5fdHJhY2tMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxSYW5nZSA9IHNjcm9sbGJhclZhcnNJbmZvLl9tYXhTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUmF3ID0gKGdldFBvaW50ZXJQb3NpdGlvbihldmVudCkgLSBtb3VzZURvd25PZmZzZXQpICogbW91c2VEb3duSW52ZXJ0ZWRTY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEZWx0YVBlcmNlbnQgPSBzY3JvbGxSYXcgLyAodHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbERlbHRhID0gKHNjcm9sbFJhbmdlICogc2Nyb2xsRGVsdGFQZXJjZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERlbHRhID0gaXNGaW5pdGUoc2Nyb2xsRGVsdGEpID8gc2Nyb2xsRGVsdGEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1JUTCAmJiBpc0hvcml6b250YWwgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbERlbHRhICo9IC0xO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXShNQVRILnJvdW5kKG1vdXNlRG93blNjcm9sbCArIHNjcm9sbERlbHRhKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGlzSG9yaXpvbnRhbCwgbW91c2VEb3duU2Nyb2xsICsgc2Nyb2xsRGVsdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3N1cHBvcnRQYXNzaXZlRXZlbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRNb3VzZVRvdWNoVXAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudE1vdXNlVG91Y2hVcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQsIF9zdHJNb3VzZVRvdWNoVXBFdmVudCwgX3N0cktleURvd25FdmVudCwgX3N0cktleVVwRXZlbnQsIF9zdHJTZWxlY3RTdGFydEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudERyYWdNb3ZlLCBkb2N1bWVudE1vdXNlVG91Y2hVcCwgZG9jdW1lbnRLZXlEb3duLCBkb2N1bWVudEtleVVwLCBkb2N1bWVudE9uU2VsZWN0U3RhcnRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuckFGKCkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsIHN0ckNsaWNrRXZlbnQsIHN0b3BDbGlja0V2ZW50UHJvcGFnYXRpb24sIHRydWUsIHsgX2NhcHR1cmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ib2R5RWxlbWVudCwgX2NsYXNzTmFtZURyYWdnaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2Nyb2xsYmFyVmFycy5faGFuZGxlLCBzdHJBY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzY3JvbGxiYXJWYXJzLl90cmFjaywgc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLCBzdHJBY3RpdmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duU2Nyb2xsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25PZmZzZXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bkludmVydGVkU2NhbGUgPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVhc2VUcmFja1Njcm9sbEFtb3VudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS5zY3JvbGxTdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodHJhY2tUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVGltZW91dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmJDUl0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZUluc2lkZUhvc3QgPSBldmVudC5jbGllbnRYID49IHJlY3QubGVmdCAmJiBldmVudC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZlbnQuY2xpZW50WSA+PSByZWN0LnRvcCAmJiBldmVudC5jbGllbnRZIDw9IHJlY3QuYm90dG9tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgbW91c2UgaXMgb3V0c2lkZSBob3N0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW91c2VJbnNpZGVIb3N0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RPbk1vdXNlTGVhdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbkhhbmRsZU1vdXNlVG91Y2hEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVNb3VzZVRvdWNoRG93bkFjdGlvbihldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uSGFuZGxlTW91c2VUb3VjaERvd25BY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duU2Nyb2xsID0gX3ZpZXdwb3J0RWxlbWVudFtzY3JvbGxdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNjcm9sbCA9IGlzTmFOKG1vdXNlRG93blNjcm9sbCkgPyAwIDogbW91c2VEb3duU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzUlRMICYmIGlzSG9yaXpvbnRhbCAmJiAhX3J0bFNjcm9sbEJlaGF2aW9yLm4gfHwgIV9pc1JUTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNjcm9sbCA9IG1vdXNlRG93blNjcm9sbCA8IDAgPyAwIDogbW91c2VEb3duU2Nyb2xsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZSA9IGdldEhvc3RFbGVtZW50SW52ZXJ0ZWRTY2FsZSgpW3h5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duT2Zmc2V0ID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcyA9ICFnZXRQcmVwYXJlZFNjcm9sbGJhcnNPcHRpb24oc3RyU25hcEhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ib2R5RWxlbWVudCwgX2NsYXNzTmFtZURyYWdnaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2Nyb2xsYmFyVmFycy5faGFuZGxlLCBzdHJBY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY3JvbGxiYXJWYXJzLl9zY3JvbGxiYXIsIHN0ckFjdGl2ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQsIF9zdHJNb3VzZVRvdWNoVXBFdmVudCwgX3N0clNlbGVjdFN0YXJ0RXZlbnRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50RHJhZ01vdmUsIGRvY3VtZW50TW91c2VUb3VjaFVwLCBkb2N1bWVudE9uU2VsZWN0U3RhcnRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5yQUYoKShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2RvY3VtZW50RWxlbWVudCwgc3RyQ2xpY2tFdmVudCwgc3RvcENsaWNrRXZlbnRQcm9wYWdhdGlvbiwgZmFsc2UsIHsgX2NhcHR1cmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbXNpZVZlcnNpb24gfHwgIV9kb2N1bWVudE1peGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25UcmFja01vdXNlVG91Y2hEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlVG9WaWV3cG9ydFJhdGlvID0gc2Nyb2xsYmFyVmFycy5faW5mby5faGFuZGxlTGVuZ3RoIC8gTWF0aC5yb3VuZChNQVRILm1pbigxLCBfdmlld3BvcnRTaXplW3Njcm9sbGJhclZhcnMuX3dfaF0gLyBfY29udGVudFNjcm9sbFNpemVDYWNoZVtzY3JvbGxiYXJWYXJzLl93X2hdKSAqIHNjcm9sbGJhclZhcnMuX2luZm8uX3RyYWNrTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEaXN0YW5jZSA9IE1BVEgucm91bmQoX3ZpZXdwb3J0U2l6ZVtzY3JvbGxiYXJWYXJzLl93X2hdICogaGFuZGxlVG9WaWV3cG9ydFJhdGlvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxCYXNlRHVyYXRpb24gPSAyNzAgKiBoYW5kbGVUb1ZpZXdwb3J0UmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRmlyc3RJdGVyYXRpb25EZWxheSA9IDQwMCAqIGhhbmRsZVRvVmlld3BvcnRSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFja09mZnNldCA9IHNjcm9sbGJhclZhcnMuX3RyYWNrLm9mZnNldCgpW3Njcm9sbGJhclZhcnMuX2xlZnRfdG9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHJsS2V5ID0gZXZlbnQuY3RybEtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW50U2Nyb2xsID0gZXZlbnQuc2hpZnRLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudFNjcm9sbFRyYW5zaXRpb24gPSBpbnN0YW50U2Nyb2xsICYmIGN0cmxLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNGaXJzdEl0ZXJhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWFzaW5nID0gJ2xpbmVhcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVhc2VTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluaXNoZWRDb25kaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQWN0aW9uRmluc2lzaGVkID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGlzSG9yaXpvbnRhbCwgdHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEFjdGlvbkluc3RhbnRGaW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBY3Rpb25GaW5zaXNoZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZU1vdXNlVG91Y2hEb3duQWN0aW9uKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VPZmZzZXQgPSAobW91c2VEb3duT2Zmc2V0IC0gdHJhY2tPZmZzZXQpICogbW91c2VEb3duSW52ZXJ0ZWRTY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9mZnNldCA9IHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFja0xlbmd0aCA9IHNjcm9sbGJhclZhcnNJbmZvLl90cmFja0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUxlbmd0aCA9IHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxSYW5nZSA9IHNjcm9sbGJhclZhcnNJbmZvLl9tYXhTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyU2Nyb2xsID0gc2Nyb2xsYmFyVmFyc0luZm8uX2N1cnJlbnRTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEdXJhdGlvbiA9IHNjcm9sbEJhc2VEdXJhdGlvbiAqIHNjcm9sbER1cmF0aW9uRmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dERlbGF5ID0gaXNGaXJzdEl0ZXJhdGlvbiA/IE1BVEgubWF4KHNjcm9sbEZpcnN0SXRlcmF0aW9uRGVsYXksIHNjcm9sbER1cmF0aW9uKSA6IHNjcm9sbER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gc2Nyb2xsUmFuZ2UgKiAoKG1vdXNlT2Zmc2V0IC0gKGhhbmRsZUxlbmd0aCAvIDIpKSAvICh0cmFja0xlbmd0aCAtIGhhbmRsZUxlbmd0aCkpOyAvLyAxMDAlICogcG9zaXRpb25QZXJjZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydGxJc05vcm1hbCA9IF9pc1JUTCAmJiBpc0hvcml6b250YWwgJiYgKCghX3J0bFNjcm9sbEJlaGF2aW9yLmkgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5uKSB8fCBfbm9ybWFsaXplUlRMQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVhc2VTY3JvbGxDb25kaXRpb24gPSBydGxJc05vcm1hbCA/IGhhbmRsZU9mZnNldCA8IG1vdXNlT2Zmc2V0IDogaGFuZGxlT2Zmc2V0ID4gbW91c2VPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxPYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogZnVuY3Rpb24gKG5vdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtzY3JvbGxdKG5vdyk7IC8vaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvaXNzdWVzLzQzNDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwsIG5vdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50U2Nyb2xsUG9zaXRpb24gPSBpc0Zpbml0ZShpbnN0YW50U2Nyb2xsUG9zaXRpb24pID8gaW5zdGFudFNjcm9sbFBvc2l0aW9uIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gX2lzUlRMICYmIGlzSG9yaXpvbnRhbCAmJiAhX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAoc2Nyb2xsUmFuZ2UgLSBpbnN0YW50U2Nyb2xsUG9zaXRpb24pIDogaW5zdGFudFNjcm9sbFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9fYmFzZS5zY3JvbGxTdG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFudFNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtzY3JvbGxdKGluc3RhbnRTY3JvbGxQb3NpdGlvbik7IC8vc2Nyb2xsIGluc3RhbnRseSB0byBuZXcgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW50U2Nyb2xsVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gYWZ0ZXIgaW5zdGFudCBzY3JvbGwgKGluIGNhc2UgQ1NTIFNuYXAgUG9pbnRzIGFyZSB1c2VkKSB0byBnZXQgdGhlIGNvcnJlY3Qgc25hcHBlZCBzY3JvbGwgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FuZCB0aGUgYW5pbWF0aW9uIHN0b3BzIGF0IHRoZSBjb3JyZWN0IHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gX3ZpZXdwb3J0RWxlbWVudFtzY3JvbGxdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGwgYmFjayB0byB0aGUgcG9zaXRpb24gYmVmb3JlIGluc3RhbnQgc2Nyb2xsaW5nIHNvIGFuaW1hdGlvbiBjYW4gYmUgcGVyZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtzY3JvbGxdKGN1cnJTY3JvbGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50U2Nyb2xsUG9zaXRpb24gPSBydGxJc05vcm1hbCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaSA/IChzY3JvbGxSYW5nZSAtIGluc3RhbnRTY3JvbGxQb3NpdGlvbikgOiBpbnN0YW50U2Nyb2xsUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gcnRsSXNOb3JtYWwgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm4gPyAtaW5zdGFudFNjcm9sbFBvc2l0aW9uIDogaW5zdGFudFNjcm9sbFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxPYmpbeHldID0gaW5zdGFudFNjcm9sbFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbChzY3JvbGxPYmosIGV4dGVuZERlZXAoYW5pbWF0aW9uT2JqLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMzAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBzY3JvbGxBY3Rpb25JbnN0YW50RmluaXNoZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQWN0aW9uSW5zdGFudEZpbmlzaGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyZWFzZVNjcm9sbCA9IGlzRmlyc3RJdGVyYXRpb24gPyBkZWNyZWFzZVNjcm9sbENvbmRpdGlvbiA6IGRlY3JlYXNlU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRDb25kaXRpb24gPSBydGxJc05vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGRlY3JlYXNlU2Nyb2xsID8gaGFuZGxlT2Zmc2V0ICsgaGFuZGxlTGVuZ3RoID49IG1vdXNlT2Zmc2V0IDogaGFuZGxlT2Zmc2V0IDw9IG1vdXNlT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGRlY3JlYXNlU2Nyb2xsID8gaGFuZGxlT2Zmc2V0IDw9IG1vdXNlT2Zmc2V0IDogaGFuZGxlT2Zmc2V0ICsgaGFuZGxlTGVuZ3RoID49IG1vdXNlT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWRDb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodHJhY2tUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS5zY3JvbGxTdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUaW1lb3V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFjdGlvbkZpbnNpc2hlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVGltZW91dCA9IHNldFRpbWVvdXQoc2Nyb2xsQWN0aW9uLCB0aW1lb3V0RGVsYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxPYmpbeHldID0gKGRlY3JlYXNlU2Nyb2xsID8gJy09JyA6ICcrPScpICsgc2Nyb2xsRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsKHNjcm9sbE9iaiwgZXh0ZW5kRGVlcChhbmltYXRpb25PYmosIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHNjcm9sbER1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXJzdEl0ZXJhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25JbnZlcnRlZFNjYWxlID0gZ2V0SG9zdEVsZW1lbnRJbnZlcnRlZFNjYWxlKClbeHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duT2Zmc2V0ID0gQ09NUEFUSUJJTElUWS5wYWdlKGV2ZW50KVt4eV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zID0gIWdldFByZXBhcmVkU2Nyb2xsYmFyc09wdGlvbihzdHJTbmFwSGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ib2R5RWxlbWVudCwgX2NsYXNzTmFtZURyYWdnaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjcm9sbGJhclZhcnMuX3RyYWNrLCBzdHJBY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLCBzdHJBY3RpdmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2RvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0ck1vdXNlVG91Y2hVcEV2ZW50LCBfc3RyS2V5RG93bkV2ZW50LCBfc3RyS2V5VXBFdmVudCwgX3N0clNlbGVjdFN0YXJ0RXZlbnRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudE1vdXNlVG91Y2hVcCwgZG9jdW1lbnRLZXlEb3duLCBkb2N1bWVudEtleVVwLCBkb2N1bWVudE9uU2VsZWN0U3RhcnRdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uVHJhY2tNb3VzZVRvdWNoRW50ZXIoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgYm90aCBzY3JvbGxiYXJzIHdpbGwgc3RheSB2aXNpYmxlIGlmIG9uZSBzY3JvbGxiYXIgaXMgaG92ZXJlZCBpZiBhdXRvSGlkZSBpcyBcInNjcm9sbFwiIG9yIFwibW92ZVwiLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0hhbmRsZUhvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uVHJhY2tNb3VzZVRvdWNoTGVhdmUoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNIYW5kbGVIb3ZlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsIHx8IF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uU2Nyb2xsYmFyTW91c2VUb3VjaERvd24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKHNjcm9sbGJhclZhcnMuX2hhbmRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1vdXNlVG91Y2hEb3duRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlTW91c2VUb3VjaERvd24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKHNjcm9sbGJhclZhcnMuX3RyYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbX3N0ck1vdXNlVG91Y2hEb3duRXZlbnQsIF9zdHJNb3VzZUVudGVyLCBfc3RyTW91c2VMZWF2ZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtvblRyYWNrTW91c2VUb3VjaERvd24sIG9uVHJhY2tNb3VzZVRvdWNoRW50ZXIsIG9uVHJhY2tNb3VzZVRvdWNoTGVhdmVdKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihzY3JvbGxiYXJWYXJzLl9zY3JvbGxiYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbGJhck1vdXNlVG91Y2hEb3duKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0VHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihzY3JvbGxiYXJWYXJzLl9zY3JvbGxiYXIsIF9zdHJUcmFuc2l0aW9uRW5kRXZlbnQsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVMZW5ndGgoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2hvd3Mgb3IgaGlkZXMgdGhlIGdpdmVuIHNjcm9sbGJhciBhbmQgYXBwbGllZCBhIGNsYXNzIG5hbWUgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBzY3JvbGxiYXIgaXMgc2Nyb2xsYWJsZSBvciBub3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNIb3Jpem9udGFsIFRydWUgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIGlzIHRoZSB0YXJnZXQsIGZhbHNlIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzaGFsbEJlVmlzaWJsZSBUcnVlIGlmIHRoZSBzY3JvbGxiYXIgc2hhbGwgYmUgc2hvd24sIGZhbHNlIGlmIGhpZGRlbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjYW5TY3JvbGwgVHJ1ZSBpZiB0aGUgc2Nyb2xsYmFyIGlzIHNjcm9sbGFibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGJhckFwcGVhcmFuY2UoaXNIb3Jpem9udGFsLCBzaGFsbEJlVmlzaWJsZSwgY2FuU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhckhpZGRlbkNsYXNzTmFtZSA9IGlzSG9yaXpvbnRhbCA/IF9jbGFzc05hbWVIb3N0U2Nyb2xsYmFySG9yaXpvbnRhbEhpZGRlbiA6IF9jbGFzc05hbWVIb3N0U2Nyb2xsYmFyVmVydGljYWxIaWRkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhckVsZW1lbnQgPSBpc0hvcml6b250YWwgPyBfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQgOiBfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIHNjcm9sbGJhckhpZGRlbkNsYXNzTmFtZSwgIXNoYWxsQmVWaXNpYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhzY3JvbGxiYXJFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyVW51c2FibGUsICFjYW5TY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQXV0b3Nob3dzIC8gYXV0b2hpZGVzIGJvdGggc2Nyb2xsYmFycyB3aXRoLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHNoYWxsQmVWaXNpYmxlIFRydWUgaWYgdGhlIHNjcm9sbGJhcnMgc2hhbGwgYmUgYXV0b3Nob3duIChvbmx5IHRoZSBjYXNlIGlmIHRoZXkgYXJlIGhpZGRlbiBieSBhIGF1dG9oaWRlKSwgZmFsc2UgaWYgdGhlIHNoYWxsIGJlIGF1dG8gaGlkZGVuLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlbGF5ZnJlZSBUcnVlIGlmIHRoZSBzY3JvbGxiYXJzIHNoYWxsIGJlIGhpZGRlbiB3aXRob3V0IGEgZGVsYXksIGZhbHNlIG9yIHVuZGVmaW5lZCBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoc2hhbGxCZVZpc2libGUsIGRlbGF5ZnJlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfc2Nyb2xsYmFyc0F1dG9IaWRlVGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhbGxCZVZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZihfaGFzT3ZlcmZsb3dDYWNoZS54ICYmIF9oaWRlT3ZlcmZsb3dDYWNoZS54cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYoX2hhc092ZXJmbG93Q2FjaGUueSAmJiBfaGlkZU92ZXJmbG93Q2FjaGUueXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnlBY3RpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJBY3RpdmUgPSAnYWN0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9zY3JvbGxiYXJzSGFuZGxlSG92ZXJlZCAmJiAhX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueUFjdGl2ZSA9IF9zY3JvbGxiYXJIb3Jpem9udGFsSGFuZGxlRWxlbWVudC5oYXNDbGFzcyhzdHJBY3RpdmUpIHx8IF9zY3JvbGxiYXJWZXJ0aWNhbEhhbmRsZUVsZW1lbnQuaGFzQ2xhc3Moc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFueUFjdGl2ZSAmJiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFueUFjdGl2ZSAmJiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlRGVsYXkgPiAwICYmIGRlbGF5ZnJlZSAhPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGhpZGUsIF9zY3JvbGxiYXJzQXV0b0hpZGVEZWxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZyZXNoZXMgdGhlIGhhbmRsZSBsZW5ndGggb2YgdGhlIGdpdmVuIHNjcm9sbGJhci5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgVHJ1ZSBpZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaGFuZGxlIHNoYWxsIGJlIHJlZnJlc2hlZCwgZmFsc2UgaWYgdGhlIHZlcnRpY2FsIG9uZSBzaGFsbCBiZSByZWZyZXNoZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVMZW5ndGgoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUNTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW5mbyA9IHNjcm9sbGJhclZhcnMuX2luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZ2l0ID0gMTAwMDAwMDtcclxuICAgICAgICAgICAgICAgICAgICAvL2dldCBhbmQgYXBwbHkgaW50ZW5kZWQgaGFuZGxlIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVSYXRpbyA9IE1BVEgubWluKDEsIF92aWV3cG9ydFNpemVbc2Nyb2xsYmFyVmFycy5fd19oXSAvIF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlW3Njcm9sbGJhclZhcnMuX3dfaF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNTU1tzY3JvbGxiYXJWYXJzLl93aWR0aF9oZWlnaHRdID0gKE1BVEguZmxvb3IoaGFuZGxlUmF0aW8gKiAxMDAgKiBkaWdpdCkgLyBkaWdpdCkgKyAnJSc7IC8vdGhlIGxhc3QgKiBkaWdpdCAvIGRpZ2l0IGlzIGZvciBmbG9vcmluZyB0byB0aGUgNHRoIGRpZ2l0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFycy5faGFuZGxlLmNzcyhoYW5kbGVDU1MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgdGhlIGhhbmRsZSBsZW5ndGggdG8gcmVzcGVjdCBtaW4gJiBtYXggbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aCA9IHNjcm9sbGJhclZhcnMuX2hhbmRsZVswXVsnb2Zmc2V0JyArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aFJhdGlvID0gaGFuZGxlUmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZyZXNoZXMgdGhlIGhhbmRsZSBvZmZzZXQgb2YgdGhlIGdpdmVuIHNjcm9sbGJhci5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgVHJ1ZSBpZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaGFuZGxlIHNoYWxsIGJlIHJlZnJlc2hlZCwgZmFsc2UgaWYgdGhlIHZlcnRpY2FsIG9uZSBzaGFsbCBiZSByZWZyZXNoZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2Nyb2xsT3JUcmFuc2l0aW9uIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGdpdmVuIHNjcm9sbGJhciBheGlzIHRvIHdoaWNoIHRoZSBoYW5kbGUgc2hhbGwgYmUgbW92ZWQgb3IgYSBib29sZWFuIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIGEgdHJhbnNpdGlvbiBzaGFsbCBiZSBhcHBsaWVkLiBJZiB1bmRlZmluZWQgb3IgYm9vbGVhbiBpZiB0aGUgY3VycmVudCBzY3JvbGwtb2Zmc2V0IGlzIHRha2VuLiAoaWYgaXNIb3Jpem9udGFsID8gc2Nyb2xsTGVmdCA6IHNjcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwsIHNjcm9sbE9yVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gdHlwZShzY3JvbGxPclRyYW5zaXRpb24pID09IFRZUEVTLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSVExpc0hvcml6b250YWwgPSBfaXNSVEwgJiYgaXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW5mbyA9IHNjcm9sbGJhclZhcnMuX2luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clRyYW5zbGF0ZUJyYWNlID0gJ3RyYW5zbGF0ZSgnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJUcmFuc2Zvcm0gPSBWRU5ET1JTLl9jc3NQcm9wZXJ0eSgndHJhbnNmb3JtJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clRyYW5zaXRpb24gPSBWRU5ET1JTLl9jc3NQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVTY3JvbGwgPSBpc0hvcml6b250YWwgPyBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgpIDogX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsT3JUcmFuc2l0aW9uID09PSB1bmRlZmluZWQgfHwgdHJhbnNpdGlvbiA/IG5hdGl2ZVNjcm9sbCA6IHNjcm9sbE9yVHJhbnNpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIHRoZSBoYW5kbGUgbGVuZ3RoIHRvIHJlc3BlY3QgbWluICYgbWF4IGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVMZW5ndGggPSBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja0xlbmd0aCA9IHNjcm9sbGJhclZhcnMuX3RyYWNrWzBdWydvZmZzZXQnICsgc2Nyb2xsYmFyVmFycy5fV2lkdGhfSGVpZ2h0XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlVHJhY2tEaWZmID0gdHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUNTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1PZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0RPTlQgdXNlIHRoZSB2YXJpYWJsZSAnX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGVbc2Nyb2xsYmFyVmFycy5fd19oXScgaW5zdGVhZCBvZiAnX3ZpZXdwb3J0RWxlbWVudFswXVsnc2Nyb2xsJyArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF0nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYSBiaXQgYmVoaW5kIGR1cmluZyB0aGUgc21hbGwgZGVsYXkgd2hlbiBjb250ZW50IHNpemUgdXBkYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vKGRlbGF5ID0gbXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWcsIGlmIGl0cyAwIHRoZW4gdGhpcyB2YXIgY291bGQgYmUgdXNlZClcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4U2Nyb2xsID0gKF92aWV3cG9ydEVsZW1lbnROYXRpdmVbX3N0clNjcm9sbCArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF0gLSBfdmlld3BvcnRFbGVtZW50TmF0aXZlWydjbGllbnQnICsgc2Nyb2xsYmFyVmFycy5fV2lkdGhfSGVpZ2h0XSkgKiAoX3J0bFNjcm9sbEJlaGF2aW9yLm4gJiYgaXNSVExpc0hvcml6b250YWwgPyAtMSA6IDEpOyAvLyogLTEgaWYgcnRsIHNjcm9sbCBtYXggaXMgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0U2Nyb2xsUmF0aW8gPSBmdW5jdGlvbiAoYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNOYU4oYmFzZSAvIG1heFNjcm9sbCkgPyAwIDogTUFUSC5tYXgoMCwgTUFUSC5taW4oMSwgYmFzZSAvIG1heFNjcm9sbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldEhhbmRsZU9mZnNldCA9IGZ1bmN0aW9uIChzY3JvbGxSYXRpbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaGFuZGxlVHJhY2tEaWZmICogc2Nyb2xsUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGlzTmFOKG9mZnNldCkgPyAwIDogb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAoaXNSVExpc0hvcml6b250YWwgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5pKSA/ICh0cmFja0xlbmd0aCAtIGhhbmRsZUxlbmd0aCAtIG9mZnNldCkgOiBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IE1BVEgubWF4KDAsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUmF0aW8gPSBnZXRTY3JvbGxSYXRpbyhuYXRpdmVTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bnNuYXBwZWRTY3JvbGxSYXRpbyA9IGdldFNjcm9sbFJhdGlvKGN1cnJlbnRTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVPZmZzZXQgPSBnZXRIYW5kbGVPZmZzZXQodW5zbmFwcGVkU2Nyb2xsUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwcGVkSGFuZGxlT2Zmc2V0ID0gZ2V0SGFuZGxlT2Zmc2V0KHNjcm9sbFJhdGlvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX21heFNjcm9sbCA9IG1heFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5fY3VycmVudFNjcm9sbCA9IG5hdGl2ZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5fY3VycmVudFNjcm9sbFJhdGlvID0gc2Nyb2xsUmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PZmZzZXQgPSBpc1JUTGlzSG9yaXpvbnRhbCA/IC0odHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGggLSBoYW5kbGVPZmZzZXQpIDogaGFuZGxlT2Zmc2V0OyAvL2luIHB4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJhbnNmb3JtT2Zmc2V0ID0gKHRyYW5zZm9ybU9mZnNldCAvIHRyYWNrTGVuZ3RoICogMTAwKSAqICh0cmFja0xlbmd0aCAvIGhhbmRsZUxlbmd0aCk7IC8vaW4gJVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVWYWx1ZSA9IGlzSG9yaXpvbnRhbCA/IHN0clRyYW5zbGF0ZUJyYWNlICsgdHJhbnNmb3JtT2Zmc2V0ICsgJ3B4LCAwKScgOiBzdHJUcmFuc2xhdGVCcmFjZSArICcwLCAnICsgdHJhbnNmb3JtT2Zmc2V0ICsgJ3B4KSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVDU1Nbc3RyVHJhbnNmb3JtXSA9IHRyYW5zbGF0ZVZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBvciBjbGVhciB1cCB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVDU1Nbc3RyVHJhbnNpdGlvbl0gPSB0cmFuc2l0aW9uICYmIE1BVEguYWJzKGhhbmRsZU9mZnNldCAtIHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVPZmZzZXQpID4gMSA/IGdldENTU1RyYW5zaXRpb25TdHJpbmcoc2Nyb2xsYmFyVmFycy5faGFuZGxlKSArICcsICcgKyAoc3RyVHJhbnNmb3JtICsgX3N0clNwYWNlICsgdHJhbnNpdGlvbkR1cmF0aW9uICsgJ21zJykgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ1NTW3Njcm9sbGJhclZhcnMuX2xlZnRfdG9wXSA9IGhhbmRsZU9mZnNldDtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vb25seSBhcHBseSBjc3MgaWYgb2Zmc2V0IGhhcyBjaGFuZ2VkIGFuZCBvdmVyZmxvdyBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnMuX2hhbmRsZS5jc3MoaGFuZGxlQ1NTKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2xlYXIgdXAgdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRUcmFuc2Zvcm0gJiYgX3N1cHBvcnRUcmFuc2l0aW9uICYmIHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnMuX2hhbmRsZS5vbmUoX3N0clRyYW5zaXRpb25FbmRFdmVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFycy5faGFuZGxlLmNzcyhzdHJUcmFuc2l0aW9uLCBfc3RyRW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVPZmZzZXQgPSBoYW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX3NuYXBwZWRIYW5kbGVPZmZzZXQgPSBzbmFwcGVkSGFuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl90cmFja0xlbmd0aCA9IHRyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmcmVzaGVzIHRoZSBpbnRlcmFjdGl2aXR5IG9mIHRoZSBnaXZlbiBzY3JvbGxiYXIgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc1RyYWNrIFRydWUgaWYgdGhlIHRyYWNrIGVsZW1lbnQgaXMgdGhlIHRhcmdldCwgZmFsc2UgaWYgdGhlIGhhbmRsZSBlbGVtZW50IGlzIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVHJ1ZSBmb3IgaW50ZXJhY3Rpdml0eSBmYWxzZSBmb3Igbm8gaW50ZXJhY3Rpdml0eS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGJhcnNJbnRlcmFjdGl2ZShpc1RyYWNrLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSB2YWx1ZSA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50MSA9IGlzVHJhY2sgPyBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudCA6IF9zY3JvbGxiYXJIb3Jpem9udGFsSGFuZGxlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudDIgPSBpc1RyYWNrID8gX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gaXNUcmFjayA/IF9jbGFzc05hbWVTY3JvbGxiYXJUcmFja09mZiA6IF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGVPZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQxW2FjdGlvbl0oY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50MlthY3Rpb25dKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgb2JqZWN0IHdoaWNoIGlzIHVzZWQgZm9yIGZhc3QgYWNjZXNzIGZvciBzcGVjaWZpYyB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNIb3Jpem9udGFsIFRydWUgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIHZhcnMgc2hhbGwgYmUgYWNjZXNzZWQsIGZhbHNlIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgdmFycyBzaGFsbCBiZSBhY2Nlc3NlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7d2g6IHN0cmluZywgV0g6IHN0cmluZywgbHQ6IHN0cmluZywgX3doOiBzdHJpbmcsIF9sdDogc3RyaW5nLCB0OiAqLCBoOiAqLCBjOiB7fSwgczogKn19XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3dpZHRoX2hlaWdodDogaXNIb3Jpem9udGFsID8gX3N0cldpZHRoIDogX3N0ckhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1dpZHRoX0hlaWdodDogaXNIb3Jpem9udGFsID8gJ1dpZHRoJyA6ICdIZWlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGVmdF90b3A6IGlzSG9yaXpvbnRhbCA/IF9zdHJMZWZ0IDogX3N0clRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX0xlZnRfVG9wOiBpc0hvcml6b250YWwgPyAnTGVmdCcgOiAnVG9wJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3hfeTogaXNIb3Jpem9udGFsID8gX3N0clggOiBfc3RyWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1hfWTogaXNIb3Jpem9udGFsID8gJ1gnIDogJ1knLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfd19oOiBpc0hvcml6b250YWwgPyAndycgOiAnaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sX3Q6IGlzSG9yaXpvbnRhbCA/ICdsJyA6ICd0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RyYWNrOiBpc0hvcml6b250YWwgPyBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudCA6IF9zY3JvbGxiYXJWZXJ0aWNhbFRyYWNrRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hhbmRsZTogaXNIb3Jpem9udGFsID8gX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcjogaXNIb3Jpem9udGFsID8gX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2luZm86IGlzSG9yaXpvbnRhbCA/IF9zY3JvbGxIb3Jpem9udGFsSW5mbyA6IF9zY3JvbGxWZXJ0aWNhbEluZm9cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gU2Nyb2xsYmFyIENvcm5lciA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEJ1aWxkcyBvciBkZXN0cm95cyB0aGUgc2Nyb2xsYmFyIGNvcm5lciBET00gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBET00gc2hhbGwgYmUgYnVpbGQgb3IgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFNjcm9sbGJhckNvcm5lckRPTShkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckNvcm5lckVsZW1lbnQgPSBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCB8fCBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50LmFwcGVuZChfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzICYmIF9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQucmVtb3ZlQXR0cihMRVhJQ09OLnMpLCBfY2xhc3NOYW1lc0R5bmFtaWNEZXN0cm95KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhbGwgc2Nyb2xsYmFyIGNvcm5lciBpbnRlcmFjdGl2aXR5IGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTY3JvbGxiYXJDb3JuZXJFdmVudHMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc2lkZUlGcmFtZSA9IF93aW5kb3dFbGVtZW50TmF0aXZlLnRvcCAhPT0gX3dpbmRvd0VsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93blBvc2l0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93blNpemUgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvbm5lY3RNdXRhdGlvbk9ic2VydmVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudERyYWdNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldENvb3JkaW5hdGVzKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXNpemVIb3Jpem9udGFsIHx8IF9yZXNpemVCb3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSAobW91c2VEb3duU2l6ZS53ICsgKHBhZ2VPZmZzZXQueCAtIG1vdXNlRG93blBvc2l0aW9uLngpICogbW91c2VEb3duSW52ZXJ0ZWRTY2FsZS54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzaXplVmVydGljYWwgfHwgX3Jlc2l6ZUJvdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSAobW91c2VEb3duU2l6ZS5oICsgKHBhZ2VPZmZzZXQueSAtIG1vdXNlRG93blBvc2l0aW9uLnkpICogbW91c2VEb3duSW52ZXJ0ZWRTY2FsZS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC5jc3MoaG9zdEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TW91c2VUb3VjaFVwKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudE1vdXNlVG91Y2hVcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRJc1RydXN0ZWQgPSBldmVudCAhPT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJTZWxlY3RTdGFydEV2ZW50LCBfc3RyTW91c2VUb3VjaE1vdmVFdmVudCwgX3N0ck1vdXNlVG91Y2hVcEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudE9uU2VsZWN0U3RhcnQsIGRvY3VtZW50RHJhZ01vdmUsIGRvY3VtZW50TW91c2VUb3VjaFVwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2JvZHlFbGVtZW50LCBfY2xhc3NOYW1lRHJhZ2dpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQucmVsZWFzZUNhcHR1cmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudC5yZWxlYXNlQ2FwdHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SXNUcnVzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb25uZWN0TXV0YXRpb25PYnNlcnZlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0TXV0YXRpb25PYnNlcnZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaEV2ZW50ID0gb3JpZ2luYWxFdmVudC50b3VjaGVzICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2xlZXBpbmcgfHwgX2Rlc3Ryb3llZCA/IGZhbHNlIDogQ09NUEFUSUJJTElUWS5tQnRuKGV2ZW50KSA9PT0gMSB8fCBpc1RvdWNoRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfbXNpZVZlcnNpb24gJiYgaW5zaWRlSUZyYW1lID8geyB4OiBldmVudC5zY3JlZW5YLCB5OiBldmVudC5zY3JlZW5ZIH0gOiBDT01QQVRJQklMSVRZLnBhZ2UoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQsIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkgJiYgIV9yZXNpemVOb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0TXV0YXRpb25PYnNlcnZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duUG9zaXRpb24gPSBnZXRDb29yZGluYXRlcyhldmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duU2l6ZS53ID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddIC0gKCFfaXNCb3JkZXJCb3ggPyBfcGFkZGluZ1ggOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNpemUuaCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXSAtICghX2lzQm9yZGVyQm94ID8gX3BhZGRpbmdZIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25JbnZlcnRlZFNjYWxlID0gZ2V0SG9zdEVsZW1lbnRJbnZlcnRlZFNjYWxlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyU2VsZWN0U3RhcnRFdmVudCwgX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQsIF9zdHJNb3VzZVRvdWNoVXBFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50T25TZWxlY3RTdGFydCwgZG9jdW1lbnREcmFnTW92ZSwgZG9jdW1lbnRNb3VzZVRvdWNoVXBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQuc2V0Q2FwdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudC5zZXRDYXB0dXJlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFV0aWxzID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIGdpdmVuIG5hbWUuIFRoZSBDb250ZXh0IG9mIHRoaXMgY2FsbGJhY2sgaXMgYWx3YXlzIF9iYXNlICh0aGlzKS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgd2hpY2ggc2hhbGwgYmUgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3Mgd2l0aCB3aGljaCB0aGUgY2FsbGJhY2sgc2hhbGwgYmUgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlcGVuZGVudCBCb29sZWFuIHdoaWNoIGRlY2lkZXMgd2hldGhlciB0aGUgY2FsbGJhY2sgc2hhbGwgYmUgZmlyZWQsIHVuZGVmaW5lZCBpcyBsaWtlIGEgXCJ0cnVlXCIgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2sobmFtZSwgYXJncywgZGVwZW5kZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVudCA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLmNhbGxiYWNrc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbk9uTmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uT25OYW1lLnN1YnN0cigwLCAyKSA9PT0gJ29uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbk9uTmFtZSA9IGV4dGVuc2lvbk9uTmFtZS5zdWJzdHIoMiwgMSkudG9Mb3dlckNhc2UoKSArIGV4dGVuc2lvbk9uTmFtZS5zdWJzdHIoMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShjYWxsYmFjaykgPT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoX2Jhc2UsIGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChfZXh0ZW5zaW9ucywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGV4dC5vbikgPT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHQub24oZXh0ZW5zaW9uT25OYW1lLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2tzSW5pdFFldWV1ZS5wdXNoKHsgbjogbmFtZSwgYTogYXJncyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgcHJvcGVydGllcywgd2l0aCBhIGdpdmVuIHByZWZpeCwgb2YgdGhlIGdpdmVuIGNzcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0Q1NTT2JqZWN0IFRoZSBjc3Mgb2JqZWN0IHRvIHdoaWNoIHRoZSB2YWx1ZXMgc2hhbGwgYmUgYXBwbGllZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwcmVmaXggVGhlIHByZWZpeCBvZiB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiBjc3MgcHJvcGVydGllcy4gKGV4YW1wbGU6ICdwYWRkaW5nLScgaXMgYSB2YWxpZCBwcmVmaXgpXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWVzIEEgYXJyYXkgb2YgdmFsdWVzIHdoaWNoIHNoYWxsIGJlIGFwcGxpZWQgdG8gdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgLXByb3BlcnRpZXMuIFRoZSBhcnJheSBvcmRlciBpcyBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5cclxuICAgICAgICAgICAgICAgICAqIElmIHRoaXMgYXJndW1lbnQgaXMgdW5kZWZpbmVkIHRoZSB2YWx1ZSAnJyAoZW1wdHkgc3RyaW5nKSB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFRvcFJpZ2h0Qm90dG9tTGVmdCh0YXJnZXRDU1NPYmplY3QsIHByZWZpeCwgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW19zdHJFbXB0eSwgX3N0ckVtcHR5LCBfc3RyRW1wdHksIF9zdHJFbXB0eV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENTU09iamVjdFtwcmVmaXggKyBfc3RyVG9wXSA9IHZhbHVlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDU1NPYmplY3RbcHJlZml4ICsgX3N0clJpZ2h0XSA9IHZhbHVlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDU1NPYmplY3RbcHJlZml4ICsgX3N0ckJvdHRvbV0gPSB2YWx1ZXNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q1NTT2JqZWN0W3ByZWZpeCArIF9zdHJMZWZ0XSA9IHZhbHVlc1szXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgQ1NTIHByb3BlcnRpZXMgb2YgdGhlIENTUyBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBwcmVmaXggZnJvbSB0aGUgaG9zdCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IG9mIHRoZSBcInRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFwiIGNzcyBwcm9wZXJ0aWVzLiAoZXhhbXBsZTogJ3BhZGRpbmctJyBpcyBhIHZhbGlkIHByZWZpeClcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzdWZmaXggVGhlIHN1ZmZpeCBvZiB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiBjc3MgcHJvcGVydGllcy4gKGV4YW1wbGU6ICdib3JkZXItJyBpcyBhIHZhbGlkIHByZWZpeCB3aXRoICctd2lkdGgnIGlzIGEgdmFsaWQgc3VmZml4KVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHplcm9YIFRydWUgaWYgdGhlIHggYXhpcyBzaGFsbCBiZSAwLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHplcm9ZIFRydWUgaWYgdGhlIHkgYXhpcyBzaGFsbCBiZSAwLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t9fSBUaGUgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBudW1iZXJzIG9mIHRoZSByZWFkIENTUyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUb3BSaWdodEJvdHRvbUxlZnRIb3N0KHByZWZpeCwgc3VmZml4LCB6ZXJvWCwgemVyb1kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBzdWZmaXggfHwgX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCB8fCBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDogemVyb1kgPyAwIDogcGFyc2VUb1plcm9Pck51bWJlcihfaG9zdEVsZW1lbnQuY3NzKHByZWZpeCArIF9zdHJUb3AgKyBzdWZmaXgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcjogemVyb1ggPyAwIDogcGFyc2VUb1plcm9Pck51bWJlcihfaG9zdEVsZW1lbnQuY3NzKHByZWZpeCArIF9zdHJSaWdodCArIHN1ZmZpeCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiOiB6ZXJvWSA/IDAgOiBwYXJzZVRvWmVyb09yTnVtYmVyKF9ob3N0RWxlbWVudC5jc3MocHJlZml4ICsgX3N0ckJvdHRvbSArIHN1ZmZpeCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsOiB6ZXJvWCA/IDAgOiBwYXJzZVRvWmVyb09yTnVtYmVyKF9ob3N0RWxlbWVudC5jc3MocHJlZml4ICsgX3N0ckxlZnQgKyBzdWZmaXgpKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBDU1MgdHJhbnNpdGlvbiBzdHJpbmcgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdGhlIHRyYW5zaXRpb24gc3RyaW5nIHNoYWxsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIENTUyB0cmFuc2l0aW9uIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRDU1NUcmFuc2l0aW9uU3RyaW5nKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvblN0ciA9IFZFTkRPUlMuX2Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFzc2VtYmxlZFZhbHVlID0gZWxlbWVudC5jc3ModHJhbnNpdGlvblN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VtYmxlZFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNzZW1ibGVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ0V4cFN0cmluZyA9ICdcXFxccyooJyArICcoW14sKF0rKFxcXFwoLis/XFxcXCkpPykrJyArICcpW1xcXFxzLF0qJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnRXhwTWFpbiA9IG5ldyBSZWdFeHAocmVnRXhwU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnRXhwVmFsaWRhdGUgPSBuZXcgUmVnRXhwKCdeKCcgKyByZWdFeHBTdHJpbmcgKyAnKSskJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSAncHJvcGVydHkgZHVyYXRpb24gdGltaW5nLWZ1bmN0aW9uIGRlbGF5Jy5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgajtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRDc3NTdHlsZUJ5Q29tbWEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0ci5tYXRjaChyZWdFeHBWYWxpZGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLm1hdGNoKHJlZ0V4cE1haW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJSZXN1bHQucHVzaChSZWdFeHAuJDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UocmVnRXhwTWFpbiwgX3N0ckVtcHR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0clJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcHJvcGVydGllc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnJheSA9IHNwbGl0Q3NzU3R5bGVCeUNvbW1hKGVsZW1lbnQuY3NzKHRyYW5zaXRpb25TdHIgKyAnLScgKyBwcm9wZXJ0aWVzW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2YWx1ZUFycmF5W0xFWElDT04ubF07IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXSA9IChyZXN1bHRbal0gPyByZXN1bHRbal0gKyBfc3RyU3BhY2UgOiBfc3RyRW1wdHkpICsgdmFsdWVBcnJheVtqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2VuZXJhdGVzIGEgUmVndWxhciBFeHByZXNzaW9uIHdoaWNoIG1hdGNoZXMgd2l0aCBhIHN0cmluZyB3aGljaCBzdGFydHMgd2l0aCAnb3MtaG9zdCcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhDdXJyQ2xhc3NOYW1lT3B0aW9uIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gYWxzbyBtYXRjaGVzIGlmIHRoZSBzdHJpbmcgaXMgdGhlIGN1cnJlbnQgQ2xhc3NOYW1lIG9wdGlvbiAobXVsdGlwbGUgdmFsdWVzIHNwbGl0dGVkIGJ5IHNwYWNlIHBvc3NpYmxlKS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aE9sZENsYXNzTmFtZU9wdGlvbiBUaGUgUmVndWxhciBFeHByZXNzaW9uIGFsc28gbWF0Y2hlcyBpZiB0aGUgc3RyaW5nIGlzIHRoZSBvbGQgQ2xhc3NOYW1lIG9wdGlvbiAobXVsdGlwbGUgdmFsdWVzIHNwbGl0dGVkIGJ5IHNwYWNlIHBvc3NpYmxlKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlSG9zdENsYXNzTmFtZVJlZ0V4cCh3aXRoQ3VyckNsYXNzTmFtZU9wdGlvbiwgd2l0aE9sZENsYXNzTmFtZU9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXBwZW5kaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGVuZENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NlcywgY29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZGl4ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24gJiYgdHlwZW9mIGNsYXNzZXMgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSBjbGFzc2VzLnNwbGl0KF9zdHJTcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BsaXRbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZGl4ICs9ICd8JyArIHNwbGl0W2ldICsgJyQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXRbaV0ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSBmb3IgZXNjYXBpbmcgcmVnZXggY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBlbmRpeDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyheJyArIF9jbGFzc05hbWVIb3N0RWxlbWVudCArICcoWy1fXS4rfCkkKScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRDbGFzc2VzKF9jbGFzc05hbWVDYWNoZSwgd2l0aEN1cnJDbGFzc05hbWVPcHRpb24pICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2xhc3Nlcyhfb2xkQ2xhc3NOYW1lLCB3aXRoT2xkQ2xhc3NOYW1lT3B0aW9uKSwgJ2cnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGhvc3QtZWxlbWVudHMgaW52ZXJ0ZWQgc2NhbGUuIChpbnZlcnRlZFNjYWxlID0gMSAvIHNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFRoZSBzY2FsZSBvZiB0aGUgaG9zdC1lbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRIb3N0RWxlbWVudEludmVydGVkU2NhbGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5iQ1JdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogX3N1cHBvcnRUcmFuc2Zvcm0gPyAxIC8gKE1BVEgucm91bmQocmVjdC53aWR0aCkgLyBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5vV10pIHx8IDEgOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBfc3VwcG9ydFRyYW5zZm9ybSA/IDEgLyAoTUFUSC5yb3VuZChyZWN0LmhlaWdodCkgLyBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF0pIHx8IDEgOiAxXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBIVE1MRWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvIFRoZSBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgY2hlY2tlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBIVE1MRWxlbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3duZXJEb2N1bWVudCA9ICdvd25lckRvY3VtZW50JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RySFRNTEVsZW1lbnQgPSAnSFRNTEVsZW1lbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3bmQgPSBvICYmIG9bc3RyT3duZXJEb2N1bWVudF0gPyAob1tzdHJPd25lckRvY3VtZW50XS5wYXJlbnRXaW5kb3cgfHwgd2luZG93KSA6IHdpbmRvdztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd25kW3N0ckhUTUxFbGVtZW50XSA9PSBUWVBFUy5vID8gbyBpbnN0YW5jZW9mIHduZFtzdHJIVE1MRWxlbWVudF0gOiAvL0RPTTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gJiYgdHlwZW9mIG8gPT0gVFlQRVMubyAmJiBvICE9PSBudWxsICYmIG8ubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT0gVFlQRVMuc1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb21wYXJlcyAyIGFycmF5cyBhbmQgcmV0dXJucyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIGFzIGEgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYTEgVGhlIGZpcnN0IGFycmF5IHdoaWNoIHNoYWxsIGJlIGNvbXBhcmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGEyIFRoZSBzZWNvbmQgYXJyYXkgd2hpY2ggc2hhbGwgYmUgY29tcGFyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRBcnJheURpZmZlcmVuY2VzKGExLCBhMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYTEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbYTFbaV1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYTIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbYTJbaV1dKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFbYTJbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2EyW2ldXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiBhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmLnB1c2goayk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIFplcm8gb3IgdGhlIG51bWJlciB0byB3aGljaCB0aGUgdmFsdWUgY2FuIGJlIHBhcnNlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggc2hhbGwgYmUgcGFyc2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHRvRmxvYXQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG51bWJlciBzaGFsbCBiZSBwYXJzZWQgdG8gYSBmbG9hdC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VUb1plcm9Pck51bWJlcih2YWx1ZSwgdG9GbG9hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSB0b0Zsb2F0ID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc05hTihudW0pID8gMCA6IG51bTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgc2V2ZXJhbCBpbmZvcm1hdGlvbiBvZiB0aGUgdGV4dGFyZWEgYW5kIHJldHVybnMgdGhlbSBhcyBhIG9iamVjdCBvciB1bmRlZmluZWQgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGl0LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3tjdXJzb3JSb3c6IE51bWJlciwgY3Vyc29yQ29sLCByb3dzOiBOdW1iZXIsIGNvbHM6IG51bWJlciwgd1JvdzogbnVtYmVyLCBwb3M6IG51bWJlciwgbWF4IDogbnVtYmVyfX0gb3IgdW5kZWZpbmVkIGlmIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRleHRhcmVhSW5mbygpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlYWQgbmVlZGVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUN1cnNvclBvc2l0aW9uID0gX3RhcmdldEVsZW1lbnROYXRpdmUuc2VsZWN0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRhcmVhQ3Vyc29yUG9zaXRpb24gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFWYWx1ZSA9IF90YXJnZXRFbGVtZW50LnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUxlbmd0aCA9IHRleHRhcmVhVmFsdWVbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFSb3dTcGxpdCA9IHRleHRhcmVhVmFsdWUuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUxhc3RSb3cgPSB0ZXh0YXJlYVJvd1NwbGl0W0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQ3VycmVudEN1cnNvclJvd1NwbGl0ID0gdGV4dGFyZWFWYWx1ZS5zdWJzdHIoMCwgdGV4dGFyZWFDdXJzb3JQb3NpdGlvbikuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWRlc3RSb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUxhc3RDb2wgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JSb3cgPSB0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdFtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JDb2wgPSB0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdFt0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdFtMRVhJQ09OLmxdIC0gMV1bTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93Q29scztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgd2lkZXN0IFJvdyBhbmQgdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0YXJlYVJvd1NwbGl0W0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb2xzID0gdGV4dGFyZWFSb3dTcGxpdFtpXVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Q29scyA+IHRleHRhcmVhTGFzdENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZXN0Um93ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYUxhc3RDb2wgPSByb3dDb2xzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yUm93OiBjdXJzb3JSb3csIC8vY3Vyc29yUm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JDb2x1bW46IGN1cnNvckNvbCwgLy9jdXJzb3JDb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Jvd3M6IHRleHRhcmVhTGFzdFJvdywgLy9yb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb2x1bW5zOiB0ZXh0YXJlYUxhc3RDb2wsIC8vY29sc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfd2lkZXN0Um93OiB3aWRlc3RSb3csIC8vd1Jvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yUG9zaXRpb246IHRleHRhcmVhQ3Vyc29yUG9zaXRpb24sIC8vcG9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JNYXg6IHRleHRhcmVhTGVuZ3RoIC8vbWF4XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBuYXRpdmUgb3ZlcmxheSBzY3JvbGxiYXJzIGFyZSBhY3RpdmUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBuYXRpdmUgb3ZlcmxheSBzY3JvbGxiYXJzIGFyZSBhY3RpdmUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NhY2hlICYmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGVsZW1lbnQgd2hpY2ggaXMgdXNlZCB0byBtZWFzdXJlIHRoZSBjb250ZW50IHNpemUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGV4dGFyZWFDb3ZlciBpZiB0YXJnZXQgZWxlbWVudCBpcyB0ZXh0YXJlYSBlbHNlIHRoZSBDb250ZW50RWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGVudE1lYXN1cmVFbGVtZW50KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaXNUZXh0YXJlYSA/IF90ZXh0YXJlYUNvdmVyRWxlbWVudFswXSA6IF9jb250ZW50RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdlbmVyYXRlcyBhIHN0cmluZyB3aGljaCByZXByZXNlbnRzIGEgSFRNTCBkaXYgd2l0aCB0aGUgZ2l2ZW4gY2xhc3NlcyBvciBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNsYXNzZXNPckF0dHJzIFRoZSBjbGFzcyBvZiB0aGUgZGl2IGFzIHN0cmluZyBvciBhIG9iamVjdCB3aGljaCByZXByZXNlbnRzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBkaXYuIChUaGUgY2xhc3MgYXR0cmlidXRlIGNhbiBhbHNvIGJlIHdyaXR0ZW4gYXMgXCJjbGFzc05hbWVcIi4pXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCBvZiB0aGUgZGl2IGFzIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb25jYXRlZCBzdHJpbmcgd2hpY2ggcmVwcmVzZW50cyBhIEhUTUwgZGl2IGFuZCBpdHMgY29udGVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVEaXYoY2xhc3Nlc09yQXR0cnMsIGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgJyArIChjbGFzc2VzT3JBdHRycyA/IHR5cGUoY2xhc3Nlc09yQXR0cnMpID09IFRZUEVTLnMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3M9XCInICsgY2xhc3Nlc09yQXR0cnMgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRlJBTUVXT1JLLmlzUGxhaW5PYmplY3QoY2xhc3Nlc09yQXR0cnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gY2xhc3Nlc09yQXR0cnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzICs9IChrZXkgPT09ICdjJyA/ICdjbGFzcycgOiBrZXkpICsgJz1cIicgKyBjbGFzc2VzT3JBdHRyc1trZXldICsgJ1wiICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyRW1wdHkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnQgfHwgX3N0ckVtcHR5KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2VsZWN0cyBvciBnZW5lcmF0ZXMgYSBkaXYgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZXMgKGRpdmlkZWQgYnkgc3BhY2VzKSBvZiB0aGUgZGl2IHdoaWNoIHNoYWxsIGJlIHNlbGVjdGVkIG9yIGdlbmVyYXRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzZWxlY3RQYXJlbnRPck9ubHlDaGlsZHJlbiBUaGUgcGFyZW50IGVsZW1lbnQgZnJvbSB3aGljaCBvZiB0aGUgZWxlbWVudCBzaGFsbCBiZSBzZWxlY3RlZC4gKGlmIHVuZGVmaW5lZCBvciBib29sZWFuIGl0cyBob3N0RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAqIElmIGl0cyBhIGJvb2xlYW4gaXQgZGVjaWRlcyB3aGV0aGVyIG9ubHkgdGhlIGNoaWxkcmVuIG9mIHRoZSBob3N0IGVsZW1lbnQgc2hhbGwgYmUgc2VsZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIGdlbmVyYXRlZCBvciBzZWxlY3RlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhjbGFzc05hbWUsIHNlbGVjdFBhcmVudE9yT25seUNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ubHlDaGlsZHJlbiA9IHR5cGUoc2VsZWN0UGFyZW50T3JPbmx5Q2hpbGRyZW4pID09IFRZUEVTLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdFBhcmVudCA9IG9ubHlDaGlsZHJlbiA/IF9ob3N0RWxlbWVudCA6IChzZWxlY3RQYXJlbnRPck9ubHlDaGlsZHJlbiB8fCBfaG9zdEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9kb21FeGlzdHMgJiYgIXNlbGVjdFBhcmVudFtMRVhJQ09OLmxdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfZG9tRXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdFBhcmVudFtvbmx5Q2hpbGRyZW4gPyAnY2hpbGRyZW4nIDogJ2ZpbmQnXShfc3RyRG90ICsgY2xhc3NOYW1lLnJlcGxhY2UoL1xccy9nLCBfc3RyRG90KSkuZXEoMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogRlJBTUVXT1JLKGdlbmVyYXRlRGl2KGNsYXNzTmFtZSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnR5IHZhbHVlIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwcm9wZXJ0eSBvZiB3aGljaCB0aGUgdmFsdWUgc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzZWFyY2hlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWQgb2YgdGhlIHByb3BlcnR5IHdhc24ndCBmb3VuZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0T2JqZWN0UHJvcFZhbChvYmosIHBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRzID0gcGF0aC5zcGxpdChfc3RyRG90KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHNwbGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtMRVhJQ09OLmhPUF0oc3BsaXRzW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gb2JqW3NwbGl0c1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgc3BsaXRzLmxlbmd0aCAmJiB0eXBlKHZhbCkgPT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydHkgdmFsdWUgc2hhbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHBhdGggVGhlIHByb3BlcnR5IG9mIHdoaWNoIHRoZSB2YWx1ZSBzaGFsbCBiZSBzZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2hpY2ggc2hhbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRPYmplY3RQcm9wVmFsKG9iaiwgcGF0aCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0cyA9IHBhdGguc3BsaXQoX3N0ckRvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0c0xlbmd0aCA9IHNwbGl0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRlbmRPYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kT2JqUm9vdCA9IGV4dGVuZE9iajtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHNwbGl0c0xlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRPYmogPSBleHRlbmRPYmpbc3BsaXRzW2ldXSA9IGkgKyAxIDwgc3BsaXRzTGVuZ3RoID8ge30gOiB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmV4dGVuZChvYmosIGV4dGVuZE9ialJvb3QsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlx0XHJcbiAgICAgICAgICAgICAgICAgKiBSdW5zIGEgYWN0aW9uIGZvciBlYWNoIHNlbGVjdG9yIGluc2lkZSB0aGUgdXBkYXRlT25Mb2FkIG9wdGlvbi5cdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIFRoZSBhY3Rpb24gZm9yIGVhY2ggdXBkYXRlT25Mb2FkIHNlbGVjdG9yLCB0aGUgYXJndW1lbnRzIHRoZSBmdW5jdGlvbiB0YWtlcyBpcyB0aGUgaW5kZXggYW5kIHRoZSB2YWx1ZSAodGhlIHNlbGVjdG9yKS5cdFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoVXBkYXRlT25Mb2FkKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVPbkxvYWQgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy51cGRhdGVPbkxvYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlT25Mb2FkID0gdHlwZSh1cGRhdGVPbkxvYWQpID09IFRZUEVTLnMgPyB1cGRhdGVPbkxvYWQuc3BsaXQoX3N0clNwYWNlKSA6IHVwZGF0ZU9uTG9hZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKHVwZGF0ZU9uTG9hZCkgJiYgIV9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCh1cGRhdGVPbkxvYWQsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gVXRpbHMgQ2FjaGUgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIG9yIG9iamVjdHMgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGV5IGFyZW4ndCBlcXVhbC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjdXJyZW50IFRoZSBmaXJzdCB2YWx1ZSBvciBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgY29tcGFyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY2FjaGUgVGhlIHNlY29uZCB2YWx1ZSBvciBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgY29tcGFyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZm9yY2UgSWYgdHJ1ZSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYWx3YXlzIHRydWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBib3RoIHZhbHVlcyBvciBvYmplY3RzIGFyZW4ndCBlcXVhbCBvciBmb3JjZSBpcyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2FjaGUoY3VycmVudCwgY2FjaGUsIGZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoY3VycmVudCkgPT0gVFlQRVMubyAmJiB0eXBlKGNhY2hlKSA9PSBUWVBFUy5vKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgIT09ICdjJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50W0xFWElDT04uaE9QXShwcm9wKSAmJiBjYWNoZVtMRVhJQ09OLmhPUF0ocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQ2FjaGUoY3VycmVudFtwcm9wXSwgY2FjaGVbcHJvcF0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50ICE9PSBjYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gU2hvcnRjdXRzID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogalF1ZXJ5IGV4dGVuZCBtZXRob2Qgc2hvcnRjdXQgd2l0aCBhIGFwcGVuZGVkIFwidHJ1ZVwiIGFzIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBleHRlbmREZWVwKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGUkFNRVdPUksuZXh0ZW5kLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBqUXVlcnkgYWRkQ2xhc3MgbWV0aG9kIHNob3J0Y3V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWV3b3JrUHJvdG8uYWRkQ2xhc3MuY2FsbChlbCwgY2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBqUXVlcnkgcmVtb3ZlQ2xhc3MgbWV0aG9kIHNob3J0Y3V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWV3b3JrUHJvdG8ucmVtb3ZlQ2xhc3MuY2FsbChlbCwgY2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgdGhlIGdpdmVuIGNsYXNzZXMgZGVwZW5kZW50IG9uIHRoZSBib29sZWFuIHZhbHVlLiBUcnVlIGZvciBhZGQsIGZhbHNlIGZvciByZW1vdmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJlbW92ZUNsYXNzKGVsLCBjbGFzc2VzLCBkb0FkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb0FkZCA/IGFkZENsYXNzKGVsLCBjbGFzc2VzKSA6IHJlbW92ZUNsYXNzKGVsLCBjbGFzc2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIGpRdWVyeSByZW1vdmUgbWV0aG9kIHNob3J0Y3V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1ld29ya1Byb3RvLnJlbW92ZS5jYWxsKGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpbmRzIHRoZSBmaXJzdCBjaGlsZCBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGVsIFRoZSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgc2VsZWN0b3Igc2hhbGwgYmUgdmFsaWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIG9mIHRoZSBzZWFyY2hlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFRoZSBmaXJzdCBlbGVtZW50IHdoaWNoIGlzIGEgY2hpbGQgb2YgdGhlIGdpdmVuIGVsZW1lbnQgYW5kIG1hdGNoZXMgdGhlIGdpdmVucyBzZWxlY3Rvci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluZEZpcnN0KGVsLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWV3b3JrUHJvdG8uZmluZC5jYWxsKGVsLCBzZWxlY3RvcikuZXEoMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBBUEkgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQdXRzIHRoZSBpbnN0YW5jZSB0byBzbGVlcC4gSXQgd29udCByZXNwb25kIHRvIGFueSBjaGFuZ2VzIGluIHRoZSBET00gYW5kIHdvbid0IHVwZGF0ZS4gU2Nyb2xsYmFyIEludGVyYWN0aXZpdHkgaXMgYWxzbyBkaXNhYmxlZCBhcyB3ZWxsIGFzIHRoZSByZXNpemUgaGFuZGxlLlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBiZWhhdmlvciBjYW4gYmUgcmVzZXQgYnkgY2FsbGluZyB0aGUgdXBkYXRlIG1ldGhvZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2Uuc2xlZXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NsZWVwaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBwbHVnaW4gYW5kIERPTSB0byB0aGUgY3VycmVudCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIGEgdXBkYXRlIGlzIDEwMCUgcmVxdWlyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZm9yY2UgVHJ1ZSBpZiBldmVyeSBwcm9wZXJ0eSBzaGFsbCBiZSB1cGRhdGVkIGFuZCB0aGUgY2FjaGUgc2hhbGwgYmUgaWdub3JlZC5cclxuICAgICAgICAgICAgICAgICAqICFJTlRFUk5BTCBVU0FHRSEgOiBmb3JjZSBjYW4gYmUgYSBzdHJpbmcgXCJhdXRvXCIsIFwic3luY1wiIG9yIFwiem9vbVwiIHRvb1xyXG4gICAgICAgICAgICAgICAgICogaWYgXCJhdXRvXCIgdGhlbiBiZWZvcmUgYSByZWFsIHVwZGF0ZSB0aGUgY29udGVudCBzaXplIGFuZCBob3N0IGVsZW1lbnQgYXR0cmlidXRlcyBnZXRzIGNoZWNrZWQsIGFuZCBpZiB0aGV5IGNoYW5nZWQgb25seSB0aGVuIHRoZSB1cGRhdGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogaWYgXCJzeW5jXCIgdGhlbiB0aGUgYXN5bmMgdXBkYXRlIHByb2Nlc3MgKE11dGF0aW9uT2JzZXJ2ZXIgb3IgVXBkYXRlTG9vcCkgZ2V0cyBzeW5jaHJvbml6ZWQgYW5kIGEgY29ycmVzcG9uZGluZyB1cGRhdGUgdGFrZXMgcGxhY2UgaWYgb25lIHdhcyBuZWVkZWQgZHVlIHRvIHBlbmRpbmcgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqIGlmIFwiem9vbVwiIHRoZW4gYSB1cGRhdGUgdGFrZXMgcGxhY2Ugd2hlcmUgaXQncyBhc3N1bWVkIHRoYXQgY29udGVudCBhbmQgaG9zdCBzaXplIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gXHJcbiAgICAgICAgICAgICAgICAgKiBJZiBmb3JjZSBpcyBcInN5bmNcIiB0aGVuIGEgYm9vbGVhbiBpcyByZXR1cm5lZCB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciBhIHVwZGF0ZSB3YXMgbmVlZGVkIGR1ZSB0byBwZW5kaW5nIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBJZiBmb3JjZSBpcyBcImF1dG9cIiB0aGVuIGEgYm9vbGVhbiBpcyByZXR1cm5lZCB3aGV0aGVyIGEgdXBkYXRlIHdhcyBuZWVkZWQgZHVlIHRvIGF0dHJpYnV0ZSBvciBzaXplIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKiB1bmRlZmluZWQgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnNDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50U2l6ZUM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZShmb3JjZSkgPT0gVFlQRVMucztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9VcGRhdGVBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRIb3N0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlID09PSBfc3RyQXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gbWVhbmluZ2Z1bEF0dHJzQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFNpemVDID0gdXBkYXRlQXV0b0NvbnRlbnRTaXplQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGVBdXRvID0gYXR0cnNDaGFuZ2VkIHx8IGNvbnRlbnRTaXplQztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1VwZGF0ZUF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudFNpemVDaGFuZ2VkOiBjb250ZW50U2l6ZUMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jaGFuZ2VkT3B0aW9uczogX2luaXRpYWxpemVkID8gdW5kZWZpbmVkIDogX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JjZSA9PT0gX3N0clN5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRIb3N0ID0gX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2soX211dGF0aW9uT2JzZXJ2ZXJIb3N0LnRha2VSZWNvcmRzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dENvbnRlbnQgPSBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjayhfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQudGFrZVJlY29yZHMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRIb3N0ID0gX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JjZSA9PT0gJ3pvb20nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0U2l6ZUNoYW5nZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRTaXplQ2hhbmdlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlID0gX3NsZWVwaW5nIHx8IGZvcmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2xlZXBpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfYmFzZS51cGRhdGUoX3N0clN5bmMpIHx8IGZvcmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHsgX2ZvcmNlOiBmb3JjZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnRzT25Mb2FkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1VwZGF0ZUF1dG8gfHwgbXV0SG9zdCB8fCBtdXRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgb3B0aW9ucy4gVGhlIHVwZGF0ZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBpZiBuZXcgb3B0aW9ucyB3ZXJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuZXdPcHRpb25zIElmIG5ldyBvcHRpb25zIGFyZSBnaXZlbiwgdGhlbiB0aGUgbmV3IG9wdGlvbnMgd2lsbCBiZSBzZXQsIGlmIG5ldyBvcHRpb25zIGFyZW4ndCBnaXZlbiAodW5kZWZpbmVkIG9yIGEgbm90IGEgcGxhaW4gb2JqZWN0KSB0aGVuIHRoZSBjdXJyZW50IG9wdGlvbnMgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSBJZiBuZXcgb3B0aW9ucyBpcyBhIHByb3BlcnR5IHBhdGggc3RyaW5nLCB0aGVuIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIHRvIHNldCB0aGUgb3B0aW9uIHRvIHdoaWNoIHRoZSBwcm9wZXJ0eSBwYXRoIHN0cmluZyBsZWFkcy5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5vcHRpb25zID0gZnVuY3Rpb24gKG5ld09wdGlvbnMsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkT3BzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBjdXJyZW50IG9wdGlvbnMgaWYgbmV3T3B0aW9ucyBhcmUgdW5kZWZpbmVkIG9yIGVtcHR5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZSQU1FV09SSy5pc0VtcHR5T2JqZWN0KG5ld09wdGlvbnMpIHx8ICFGUkFNRVdPUksuaXNQbGFpbk9iamVjdChuZXdPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShuZXdPcHRpb25zKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRPYmplY3RQcm9wVmFsKG9wdGlvbiwgbmV3T3B0aW9ucywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRPcHMgPSBzZXRPcHRpb25zKG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE9iamVjdFByb3BWYWwoX2N1cnJlbnRPcHRpb25zLCBuZXdPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZE9wcyA9IHNldE9wdGlvbnMobmV3T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUZSQU1FV09SSy5pc0VtcHR5T2JqZWN0KGNoYW5nZWRPcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7IF9jaGFuZ2VkT3B0aW9uczogY2hhbmdlZE9wcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzdG9yZSB0aGUgRE9NLCBkaXNjb25uZWN0cyBhbGwgb2JzZXJ2ZXJzLCByZW1vdmUgYWxsIHJlc2l6ZSBvYnNlcnZlcnMgYW5kIHB1dCB0aGUgaW5zdGFuY2UgdG8gc2xlZXAuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhpcyBpbnN0YW5jZSBmcm9tIGF1dG8gdXBkYXRlIGxvb3BcclxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlTG9vcC5yZW1vdmUoX2Jhc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Rpc2Nvbm5lY3QgYWxsIG11dGF0aW9uIG9ic2VydmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgcmVzaXplIG9ic2VydmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVPYnNlcnZlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBleHROYW1lIGluIF9leHRlbnNpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS5yZW1vdmVFeHQoZXh0TmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCAnZGVzdHJveScgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKF9kZXN0cm95RXZlbnRzW0xFWElDT04ubF0gPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVzdHJveUV2ZW50cy5wb3AoKSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgZXZlbnRzIGZyb20gaG9zdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBIb3N0TW91c2VUb3VjaEV2ZW50cyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIGhlbHBlciAvIGRldGVjdGlvbiBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29udGVudEdsdWVFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX2NvbnRlbnRHbHVlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZW50QXJyYW5nZUVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfY29udGVudEFycmFuZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCBnZW5lcmF0ZWQgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJzRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyQ29ybmVyRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU3RydWN0dXJlRE9NKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgZ2VuZXJhdGVkIGltYWdlIGxvYWQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdXBkYXRlT25Mb2FkRWxtc1tMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSyhfdXBkYXRlT25Mb2FkRWxtc1tpXSkub2ZmKF91cGRhdGVPbkxvYWRFdmVudE5hbWUsIHVwZGF0ZU9uTG9hZENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICBfdXBkYXRlT25Mb2FkRWxtcyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NsZWVwaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhpcyBpbnN0YW5jZSBmcm9tIHRoZSBpbnN0YW5jZXMgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIElOU1RBTkNFUyhwbHVnaW5UYXJnZXRFbGVtZW50LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkRlc3Ryb3llZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZm9yICh2YXIgcHJvcGVydHkgaW4gX2Jhc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgZGVsZXRlIF9iYXNlW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICAvL19iYXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNjcm9sbHMgdG8gYSBnaXZlbiBwb3NpdGlvbiBvciBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgICAgICAgKiAxLiBDYW4gYmUgXCJjb29yZGluYXRlc1wiIHdoaWNoIGxvb2tzIGxpa2U6XHJcbiAgICAgICAgICAgICAgICAgKiAgICB7IHggOiA/LCB5IDogPyB9IE9SICAgICAgICAgIE9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICogICAgeyBsZWZ0IDogPywgdG9wIDogPyB9IE9SICAgICBPYmplY3Qgd2l0aCBsZWZ0IGFuZCB0b3AgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICogICAgeyBsIDogPywgdCA6ID8gfSBPUiAgICAgICAgICBPYmplY3Qgd2l0aCBsIGFuZCB0IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAqICAgIFsgPywgPyBdIE9SICAgICAgICAgICAgICAgICAgQXJyYXkgd2hlcmUgdGhlIGZpcnN0IHR3byBlbGVtZW50IGFyZSB0aGUgY29vcmRpbmF0ZXMgKGZpcnN0IGlzIHgsIHNlY29uZCBpcyB5KVxyXG4gICAgICAgICAgICAgICAgICogICAgPyAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHNpbmdsZSB2YWx1ZSB3aGljaCBzdGF5cyBmb3IgYm90aCBheGlzXHJcbiAgICAgICAgICAgICAgICAgKiAgICBBIHZhbHVlIGNhbiBiZSBhIG51bWJlciwgYSBzdHJpbmcgb3IgYSBjYWxjdWxhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBPcGVyYXRvcnM6XHJcbiAgICAgICAgICAgICAgICAgKiAgICBbTk9ORV0gIFRoZSBjdXJyZW50IHNjcm9sbCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqICAgICcrPScgICAgVGhlIHZhbHVlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICogICAgJy09JyAgICBUaGUgdmFsdWUgd2lsbCBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICogICAgJyo9JyAgICBUaGUgY3VycmVudCBzY3JvbGwgd2lsIGJlIG11bHRpcGxpY2F0ZWQgYnkgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogICAgJy89JyAgICBUaGUgY3VycmVudCBzY3JvbGwgd2lsIGJlIGRpdmlkZWQgYnkgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIFVuaXRzOlxyXG4gICAgICAgICAgICAgICAgICogICAgW05PTkVdICBUaGUgdmFsdWUgaXMgdGhlIGZpbmFsIHNjcm9sbCBhbW91bnQuICAgICAgICAgICAgICAgICAgIGZpbmFsID0gKHZhbHVlICogMSlcclxuICAgICAgICAgICAgICAgICAqICAgICdweCcgICAgU2FtZSBhcyBub25lXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnJScgICAgIFRoZSB2YWx1ZSBpcyBkZXBlbmRlbnQgb24gdGhlIGN1cnJlbnQgc2Nyb2xsIHZhbHVlLiAgICAgZmluYWwgPSAoKGN1cnJlbnRTY3JvbGxWYWx1ZSAvIDEwMCkgKiB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAqICAgICd2dycgICAgVGhlIHZhbHVlIGlzIG11bHRpcGxpY2F0ZWQgYnkgdGhlIHZpZXdwb3J0IHdpZHRoLiAgICAgICBmaW5hbCA9ICh2YWx1ZSAqIHZpZXdwb3J0V2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgKiAgICAndmgnICAgIFRoZSB2YWx1ZSBpcyBtdWx0aXBsaWNhdGVkIGJ5IHRoZSB2aWV3cG9ydCBoZWlnaHQuICAgICAgZmluYWwgPSAodmFsdWUgKiB2aWV3cG9ydEhlaWdodClcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBleGFtcGxlIGZpbmFsIHZhbHVlczpcclxuICAgICAgICAgICAgICAgICAqICAgIDIwMCwgJzIwMHB4JywgJzUwJScsICcxdncnLCAnMXZoJywgJys9MjAwJywgJy89MXZ3JywgJyo9MnB4JywgJy09NXZoJywgJys9MzMlJywgJys9IDUwJSAtIDJweCcsICctPSAxdncgLSA1MCUnXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogMi4gQ2FuIGJlIGEgSFRNTCBvciBqUXVlcnkgZWxlbWVudDpcclxuICAgICAgICAgICAgICAgICAqICAgIFRoZSBmaW5hbCBzY3JvbGwgb2Zmc2V0IGlzIHRoZSBvZmZzZXQgKHdpdGhvdXQgbWFyZ2luKSBvZiB0aGUgZ2l2ZW4gSFRNTCAvIGpRdWVyeSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIDMuIENhbiBiZSBhIG9iamVjdCB3aXRoIGEgSFRNTCBvciBqUXVlcnkgZWxlbWVudCB3aXRoIGFkZGl0aW9uYWwgc2V0dGluZ3M6XHJcbiAgICAgICAgICAgICAgICAgKiAgICB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIGVsIDogW0hUTUxFbGVtZW50LCBqUXVlcnkgZWxlbWVudF0sICAgICAgICAgICAgIE1VU1QgYmUgc3BlY2lmaWVkLCBlbHNlIHRoaXMgb2JqZWN0IGlzbid0IHZhbGlkLlxyXG4gICAgICAgICAgICAgICAgICogICAgICBzY3JvbGwgOiBbc3RyaW5nLCBhcnJheSwgb2JqZWN0XSwgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzICdhbHdheXMnLlxyXG4gICAgICAgICAgICAgICAgICogICAgICBibG9jayA6IFtzdHJpbmcsIGFycmF5LCBvYmplY3RdLCAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzICdiZWdpbicuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIG1hcmdpbiA6IFtudW1iZXIsIGJvb2xlYW4sIGFycmF5LCBvYmplY3RdICAgICAgIERlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXHJcbiAgICAgICAgICAgICAgICAgKiAgICB9XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgUG9zc2libGUgc2Nyb2xsIHNldHRpbmdzIGFyZTpcclxuICAgICAgICAgICAgICAgICAqICAgICdhbHdheXMnICAgICAgU2Nyb2xscyBhbHdheXMuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnaWZuZWVkZWQnICAgIFNjcm9sbHMgb25seSBpZiB0aGUgZWxlbWVudCBpc250IGZ1bGx5IGluIHZpZXcuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnbmV2ZXInICAgICAgIFNjcm9sbHMgbmV2ZXIuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgUG9zc2libGUgYmxvY2sgc2V0dGluZ3MgYXJlOlxyXG4gICAgICAgICAgICAgICAgICogICAgJ2JlZ2luJyAgIEJvdGggYXhpcyBzaGFsbCBiZSBkb2NrZWQgdG8gdGhlIFwiYmVnaW5cIiBlZGdlLiAtIFRoZSBlbGVtZW50IHdpbGwgYmUgZG9ja2VkIHRvIHRoZSB0b3AgYW5kIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnZW5kJyAgICAgQm90aCBheGlzIHNoYWxsIGJlIGRvY2tlZCB0byB0aGUgXCJlbmRcIiBlZGdlLiAtIFRoZSBlbGVtZW50IHdpbGwgYmUgZG9ja2VkIHRvIHRoZSBib3R0b20gYW5kIHJpZ2h0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0LiAoSWYgZGlyZWN0aW9uIGlzIFJUTCB0byB0aGUgYm90dG9tIGFuZCBsZWZ0IGVkZ2UuKVxyXG4gICAgICAgICAgICAgICAgICogICAgJ2NlbnRlcicgIEJvdGggYXhpcyBzaGFsbCBiZSBkb2NrZWQgdG8gXCJjZW50ZXJcIi4gLSBUaGUgZWxlbWVudCB3aWxsIGJlIGNlbnRlcmVkIGluIHRoZSB2aWV3cG9ydC5cclxuICAgICAgICAgICAgICAgICAqICAgICduZWFyZXN0JyBUaGUgZWxlbWVudCB3aWxsIGJlIGRvY2tlZCB0byB0aGUgbmVhcmVzdCBlZGdlKHMpLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIFBvc3NpYmxlIG1hcmdpbiBzZXR0aW5ncyBhcmU6IC0tIFRoZSBhY3R1YWwgbWFyZ2luIG9mIHRoZSBlbGVtZW50IHdvbnQgYmUgYWZmZWN0LCB0aGlzIG9wdGlvbiBhZmZlY3RzIG9ubHkgdGhlIGZpbmFsIHNjcm9sbCBvZmZzZXQuXHJcbiAgICAgICAgICAgICAgICAgKiAgICBbQk9PTEVBTl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgdGhlIGNzcyBtYXJnaW4gb2YgdGhlIGVsZW1lbnQgd2lsbCBiZSB1c2VkLCBpZiBmYWxzZSBubyBtYXJnaW4gd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgICogICAgW05VTUJFUl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbWFyZ2luIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGVkZ2VzLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBhbmltYXRpb24sIE9SIGEgalF1ZXJ5IGFuaW1hdGlvbiBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlYXNpbmcgVGhlIGFuaW1hdGlvbiBlYXNpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29tcGxldGUgVGhlIGFuaW1hdGlvbiBjb21wbGV0ZSBjYWxsYmFjay5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7XHJcbiAgICAgICAgICAgICAgICAgKiAgIHBvc2l0aW9uOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICByYXRpbzoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgbWF4OiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICBoYW5kbGVPZmZzZXQ6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sXHJcbiAgICAgICAgICAgICAgICAgKiAgIGhhbmRsZUxlbmd0aDoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgaGFuZGxlTGVuZ3RoUmF0aW86IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sIHRcclxuICAgICAgICAgICAgICAgICAqICAgcmFja0xlbmd0aDoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgaXNSVEw6IGJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICAgKiAgIGlzUlRMTm9ybWFsaXplZDogYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICogIH19XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb29yZGluYXRlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvWCA9IF9zY3JvbGxIb3Jpem9udGFsSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm9ZID0gX3Njcm9sbFZlcnRpY2FsSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZUludmVydCA9IF9ub3JtYWxpemVSVExDYWNoZSAmJiBfaXNSVEwgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVOZWdhdGUgPSBfbm9ybWFsaXplUlRMQ2FjaGUgJiYgX2lzUlRMICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWCA9IGluZm9YLl9jdXJyZW50U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWFJhdGlvID0gaW5mb1guX2N1cnJlbnRTY3JvbGxSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFNjcm9sbFggPSBpbmZvWC5fbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYUmF0aW8gPSBub3JtYWxpemVJbnZlcnQgPyAxIC0gc2Nyb2xsWFJhdGlvIDogc2Nyb2xsWFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYID0gbm9ybWFsaXplSW52ZXJ0ID8gbWF4U2Nyb2xsWCAtIHNjcm9sbFggOiBzY3JvbGxYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYICo9IG5vcm1hbGl6ZU5lZ2F0ZSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U2Nyb2xsWCAqPSBub3JtYWxpemVOZWdhdGUgPyAtMSA6IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9jdXJyZW50U2Nyb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW86IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzY3JvbGxYUmF0aW8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2N1cnJlbnRTY3JvbGxSYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1heFNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX21heFNjcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9mZnNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZm9YLl9oYW5kbGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2hhbmRsZU9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUxlbmd0aDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZm9YLl9oYW5kbGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2hhbmRsZUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUxlbmd0aFJhdGlvOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5mb1guX2hhbmRsZUxlbmd0aFJhdGlvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9oYW5kbGVMZW5ndGhSYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrTGVuZ3RoOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5mb1guX3RyYWNrTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl90cmFja0xlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBwZWRIYW5kbGVPZmZzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbmZvWC5fc25hcHBlZEhhbmRsZU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5fc25hcHBlZEhhbmRsZU9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUlRMOiBfaXNSVEwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JUTE5vcm1hbGl6ZWQ6IF9ub3JtYWxpemVSVExDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJTeW5jKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZVJUTCA9IF9ub3JtYWxpemVSVExDYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXNYQXhpc1Byb3BzID0gW19zdHJYLCBfc3RyTGVmdCwgJ2wnXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXNZQXhpc1Byb3BzID0gW19zdHJZLCBfc3RyVG9wLCAndCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlc09wZXJhdG9ycyA9IFsnKz0nLCAnLT0nLCAnKj0nLCAnLz0nXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb25Jc09iamVjdCA9IHR5cGUoZHVyYXRpb24pID09IFRZUEVTLm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlQ2FsbGJhY2sgPSBkdXJhdGlvbklzT2JqZWN0ID8gZHVyYXRpb24uY29tcGxldGUgOiBjb21wbGV0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxTY3JvbGwgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BlY2lhbEVhc2luZyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb1Njcm9sbExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvU2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJFbmQgPSAnZW5kJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQmVnaW4gPSAnYmVnaW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJDZW50ZXIgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyTmVhcmVzdCA9ICduZWFyZXN0JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQWx3YXlzID0gJ2Fsd2F5cyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck5ldmVyID0gJ25ldmVyJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RySWZOZWVkZWQgPSAnaWZuZWVkZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJMZW5ndGggPSBMRVhJQ09OLmw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzQXhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3NTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzQmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzTWFyZ2luO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRPYmpTZXR0aW5nc0F4aXNWYWx1ZXMgPSBbX3N0clgsIF9zdHJZLCAneHknLCAneXgnXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9ialNldHRpbmdzQmxvY2tWYWx1ZXMgPSBbc3RyQmVnaW4sIHN0ckVuZCwgc3RyQ2VudGVyLCBzdHJOZWFyZXN0XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9ialNldHRpbmdzU2Nyb2xsVmFsdWVzID0gW3N0ckFsd2F5cywgc3RyTmV2ZXIsIHN0cklmTmVlZGVkXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPSBjb29yZGluYXRlc1tMRVhJQ09OLmhPUF0oJ2VsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlRWxlbWVudCA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMuZWwgOiBjb29yZGluYXRlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVFbGVtZW50SXNKUXVlcnkgPSBwb3NzaWJsZUVsZW1lbnQgaW5zdGFuY2VvZiBGUkFNRVdPUksgfHwgSlFVRVJZID8gcG9zc2libGVFbGVtZW50IGluc3RhbmNlb2YgSlFVRVJZIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlRWxlbWVudElzSFRNTEVsZW1lbnQgPSBwb3NzaWJsZUVsZW1lbnRJc0pRdWVyeSA/IGZhbHNlIDogaXNIVE1MRWxlbWVudChwb3NzaWJsZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVTY3JvbGxiYXJJbmZvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2Nyb2xsTGVmdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1Njcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3h5Q29tcGxldGVDYWxsYmFjayA9IHR5cGUoY29tcGxldGVDYWxsYmFjaykgIT0gVFlQRVMuZiA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2Nyb2xsYmFySW5mb3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tTZXR0aW5nc1N0cmluZ1ZhbHVlKGN1cnJWYWx1ZSwgYWxsb3dlZFZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsb3dlZFZhbHVlc1tzdHJMZW5ndGhdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVmFsdWUgPT09IGFsbG93ZWRWYWx1ZXNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRSYXdTY3JvbGwoaXNYLCBjb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZVByb3BzID0gaXNYID8gY29vcmRpbmF0ZXNYQXhpc1Byb3BzIDogY29vcmRpbmF0ZXNZQXhpc1Byb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IHR5cGUoY29vcmRpbmF0ZXMpID09IFRZUEVTLnMgfHwgdHlwZShjb29yZGluYXRlcykgPT0gVFlQRVMubiA/IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdIDogY29vcmRpbmF0ZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EoY29vcmRpbmF0ZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzWCA/IGNvb3JkaW5hdGVzWzBdIDogY29vcmRpbmF0ZXNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUoY29vcmRpbmF0ZXMpID09IFRZUEVTLm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVjaWRlcyBSVEwgbm9ybWFsaXphdGlvbiBcImhhY2tcIiB3aXRoIC5uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vcm1hbGl6ZVJUTCA9IHR5cGUoY29vcmRpbmF0ZXMubikgPT0gVFlQRVMuYiA/IGNvb3JkaW5hdGVzLm4gOiBub3JtYWxpemVSVEw7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3JkaW5hdGVQcm9wc1tzdHJMZW5ndGhdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVQcm9wc1tpXSBpbiBjb29yZGluYXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVQcm9wc1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RmluYWxTY3JvbGwoaXNYLCByYXdTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZShyYXdTY3JvbGwpID09IFRZUEVTLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEluZm8gPSBpc1ggPyBfc2Nyb2xsSG9yaXpvbnRhbEluZm8gOiBfc2Nyb2xsVmVydGljYWxJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclNjcm9sbCA9IHNjcm9sbEluZm8uX2N1cnJlbnRTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhTY3JvbGwgPSBzY3JvbGxJbmZvLl9tYXhTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0ID0gJyAqICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNSVExpc1ggPSBfaXNSVEwgJiYgaXNYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplU2hvcnRjdXRzID0gaXNSVExpc1ggJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm4gJiYgIW5vcm1hbGl6ZVJUTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0clJlcGxhY2UgPSAncmVwbGFjZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmFsRnVuYyA9IGV2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZU9wZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdTY3JvbGxbc3RyTGVuZ3RoXSA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZU9wZXJhdG9yID0gcmF3U2Nyb2xsLnN1YnN0cigwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShwb3NzaWJsZU9wZXJhdG9yLCBjb29yZGluYXRlc09wZXJhdG9ycykgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBwb3NzaWJsZU9wZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHVuaXRzIGFuZCBzaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1Njcm9sbCA9IG9wZXJhdG9yID8gcmF3U2Nyb2xsLnN1YnN0cigyKSA6IHJhd1Njcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1Njcm9sbCA9IHJhd1Njcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC9taW4vZywgMCkgLy8nbWluJyA9IDAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oLzwvZywgMCkgICAvLyc8JyAgID0gMCVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvbWF4L2csIChub3JtYWxpemVTaG9ydGN1dHMgPyAnLScgOiBfc3RyRW1wdHkpICsgX3N0ckh1bmRyZWRQZXJjZW50KSAgICAvLydtYXgnID0gMTAwJVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC8+L2csIChub3JtYWxpemVTaG9ydGN1dHMgPyAnLScgOiBfc3RyRW1wdHkpICsgX3N0ckh1bmRyZWRQZXJjZW50KSAgICAgIC8vJz4nICAgPSAxMDAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL3B4L2csIF9zdHJFbXB0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvJS9nLCBtdWx0ICsgKG1heFNjcm9sbCAqIChpc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IC0xIDogMSkgLyAxMDAuMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL3Z3L2csIG11bHQgKyBfdmlld3BvcnRTaXplLncpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL3ZoL2csIG11bHQgKyBfdmlld3BvcnRTaXplLmgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gcGFyc2VUb1plcm9Pck51bWJlcihpc05hTihyYXdTY3JvbGwpID8gcGFyc2VUb1plcm9Pck51bWJlcihldmFsRnVuYyhyYXdTY3JvbGwpLCB0cnVlKS50b0ZpeGVkKCkgOiByYXdTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gcmF3U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1vdW50ICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKGFtb3VudCkgJiYgdHlwZShhbW91bnQpID09IFRZUEVTLm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVJc1JUTGlzWCA9IG5vcm1hbGl6ZVJUTCAmJiBpc1JUTGlzWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvckN1cnJTY3JvbGwgPSBjdXJyU2Nyb2xsICogKG5vcm1hbGl6ZUlzUlRMaXNYICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnZlcnQgPSBub3JtYWxpemVJc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZWdhdGUgPSBub3JtYWxpemVJc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yQ3VyclNjcm9sbCA9IGludmVydCA/IChtYXhTY3JvbGwgLSBvcGVyYXRvckN1cnJTY3JvbGwpIDogb3BlcmF0b3JDdXJyU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJys9JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG9wZXJhdG9yQ3VyclNjcm9sbCArIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLT0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gb3BlcmF0b3JDdXJyU2Nyb2xsIC0gYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqPSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBvcGVyYXRvckN1cnJTY3JvbGwgKiBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy89JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG9wZXJhdG9yQ3VyclNjcm9sbCAvIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gaW52ZXJ0ID8gbWF4U2Nyb2xsIC0gZmluYWxWYWx1ZSA6IGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlICo9IG5lZ2F0ZSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBpc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IE1BVEgubWluKDAsIE1BVEgubWF4KG1heFNjcm9sbCwgZmluYWxWYWx1ZSkpIDogTUFUSC5tYXgoMCwgTUFUSC5taW4obWF4U2Nyb2xsLCBmaW5hbFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsVmFsdWUgPT09IGN1cnJTY3JvbGwgPyB1bmRlZmluZWQgOiBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRQZXJBeGlzVmFsdWUodmFsdWUsIHZhbHVlSW50ZXJuYWxUeXBlLCBkZWZhdWx0VmFsdWUsIGFsbG93ZWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdERlZmF1bHQgPSBbZGVmYXVsdFZhbHVlLCBkZWZhdWx0VmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVUeXBlID0gdHlwZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUFyckxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlQXJySXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgY2FuIGJlIFsgc3RyaW5nLCBvciBhcnJheSBvZiB0d28gc3RyaW5ncyBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT0gdmFsdWVJbnRlcm5hbFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlLCB2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVUeXBlID09IFRZUEVTLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXJyTGVuZ3RoID0gdmFsdWVbc3RyTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFyckxlbmd0aCA+IDIgfHwgdmFsdWVBcnJMZW5ndGggPCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0RGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFyckxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlQXJyTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnJJdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKHZhbHVlQXJySXRlbSkgIT0gdmFsdWVJbnRlcm5hbFR5cGUgfHwgIWNoZWNrU2V0dGluZ3NTdHJpbmdWYWx1ZSh2YWx1ZUFyckl0ZW0sIGFsbG93ZWRWYWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVR5cGUgPT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlW19zdHJYXSB8fCBkZWZhdWx0VmFsdWUsIHZhbHVlW19zdHJZXSB8fCBkZWZhdWx0VmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHZhbHVlWzBdLCB5OiB2YWx1ZVsxXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZU1hcmdpbihtYXJnaW5Ub3BSaWdodEJvdHRvbUxlZnRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVmFsdWVUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVEaXJlY3Rpb25zID0gW19zdHJUb3AsIF9zdHJSaWdodCwgX3N0ckJvdHRvbSwgX3N0ckxlZnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWFyZ2luVG9wUmlnaHRCb3R0b21MZWZ0QXJyYXlbc3RyTGVuZ3RoXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdmFsdWVEaXJlY3Rpb25zW3N0ckxlbmd0aF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVmFsdWUgPSBtYXJnaW5Ub3BSaWdodEJvdHRvbUxlZnRBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJWYWx1ZVR5cGUgPSB0eXBlKGN1cnJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyclZhbHVlVHlwZSA9PSBUWVBFUy5iKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJWYWx1ZSA/IHBhcnNlVG9aZXJvT3JOdW1iZXIoZmluYWxFbGVtZW50LmNzcyhfc3RyTWFyZ2luTWludXMgKyB2YWx1ZURpcmVjdGlvbnNbaV0pKSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJWYWx1ZVR5cGUgPT0gVFlQRVMubiA/IGN1cnJWYWx1ZSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVFbGVtZW50SXNKUXVlcnkgfHwgcG9zc2libGVFbGVtZW50SXNIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPyBjb29yZGluYXRlcy5tYXJnaW4gOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMuYXhpcyA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGwgPSBjb29yZGluYXRlc0lzRWxlbWVudE9iaiA/IGNvb3JkaW5hdGVzLnNjcm9sbCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMuYmxvY2sgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luRGVmYXVsdCA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpblR5cGUgPSB0eXBlKG1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW5MZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsRWxlbWVudCA9IHBvc3NpYmxlRWxlbWVudElzSlF1ZXJ5ID8gcG9zc2libGVFbGVtZW50IDogRlJBTUVXT1JLKHBvc3NpYmxlRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxFbGVtZW50W3N0ckxlbmd0aF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21hcmdpbiBjYW4gYmUgWyBib29sZWFuLCBudW1iZXIsIGFycmF5IG9mIDIsIGFycmF5IG9mIDQsIG9iamVjdCBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2luVHlwZSA9PSBUWVBFUy5uIHx8IG1hcmdpblR5cGUgPT0gVFlQRVMuYilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBnZW5lcmF0ZU1hcmdpbihbbWFyZ2luLCBtYXJnaW4sIG1hcmdpbiwgbWFyZ2luXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXJnaW5UeXBlID09IFRZUEVTLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZW5ndGggPSBtYXJnaW5bc3RyTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2luTGVuZ3RoID09PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBnZW5lcmF0ZU1hcmdpbihbbWFyZ2luWzBdLCBtYXJnaW5bMV0sIG1hcmdpblswXSwgbWFyZ2luWzFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFyZ2luTGVuZ3RoID49IDQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IGdlbmVyYXRlTWFyZ2luKG1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBtYXJnaW5EZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFyZ2luVHlwZSA9PSBUWVBFUy5vKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IGdlbmVyYXRlTWFyZ2luKFttYXJnaW5bX3N0clRvcF0sIG1hcmdpbltfc3RyUmlnaHRdLCBtYXJnaW5bX3N0ckJvdHRvbV0sIG1hcmdpbltfc3RyTGVmdF1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBtYXJnaW5EZWZhdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmxvY2sgPSB0eXBlKGJsb2NrKSA9PT0gVFlQRVMuYiA/IGJsb2NrID8gWyBzdHJOZWFyZXN0LCBzdHJCZWdpbiBdIDogWyBzdHJOZWFyZXN0LCBzdHJFbmQgXSA6IGJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NBeGlzID0gY2hlY2tTZXR0aW5nc1N0cmluZ1ZhbHVlKGF4aXMsIGVsZW1lbnRPYmpTZXR0aW5nc0F4aXNWYWx1ZXMpID8gYXhpcyA6ICd4eSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1Njcm9sbCA9IGdldFBlckF4aXNWYWx1ZShzY3JvbGwsIFRZUEVTLnMsIHN0ckFsd2F5cywgZWxlbWVudE9ialNldHRpbmdzU2Nyb2xsVmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQmxvY2sgPSBnZXRQZXJBeGlzVmFsdWUoYmxvY2ssIFRZUEVTLnMsIHN0ckJlZ2luLCBlbGVtZW50T2JqU2V0dGluZ3NCbG9ja1ZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc01hcmdpbiA9IG1hcmdpbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRTY3JvbGwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDogX3Njcm9sbEhvcml6b250YWxJbmZvLl9jdXJyZW50U2Nyb2xsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6IF9zY3JvbGxWZXJ0aWNhbEluZm8uX2N1cnJlbnRTY3JvbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcGFkZGluZyBlbGVtZW50IGluc3RlYWQgb2Ygdmlld3BvcnQgZWxlbWVudCBiZWNhdXNlIHBhZGRpbmcgZWxlbWVudCBoYXMgbmV2ZXIgcGFkZGluZywgbWFyZ2luIG9yIHBvc2l0aW9uIGFwcGxpZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRPZmZzZXQgPSBfcGFkZGluZ0VsZW1lbnQub2Zmc2V0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gZmluYWxFbGVtZW50Lm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvTm90U2Nyb2xsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNldHRpbmdzU2Nyb2xsLnggPT0gc3RyTmV2ZXIgfHwgc2V0dGluZ3NBeGlzID09IF9zdHJZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNldHRpbmdzU2Nyb2xsLnkgPT0gc3RyTmV2ZXIgfHwgc2V0dGluZ3NBeGlzID09IF9zdHJYXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE9mZnNldFtfc3RyVG9wXSAtPSBzZXR0aW5nc01hcmdpblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdIC09IHNldHRpbmdzTWFyZ2luWzNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBNQVRILnJvdW5kKGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdIC0gdmlld3BvcnRPZmZzZXRbX3N0ckxlZnRdICsgdmlld3BvcnRTY3JvbGwubCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogTUFUSC5yb3VuZChlbGVtZW50T2Zmc2V0W19zdHJUb3BdIC0gdmlld3BvcnRPZmZzZXRbX3N0clRvcF0gKyB2aWV3cG9ydFNjcm9sbC50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9ydGxTY3JvbGxCZWhhdmlvci5uICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IuaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLnggPSBNQVRILnJvdW5kKHZpZXdwb3J0T2Zmc2V0W19zdHJMZWZ0XSAtIGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdICsgdmlld3BvcnRTY3JvbGwubCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ydGxTY3JvbGxCZWhhdmlvci5uICYmIG5vcm1hbGl6ZVJUTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLnggKj0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ydGxTY3JvbGxCZWhhdmlvci5pICYmIG5vcm1hbGl6ZVJUTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLnggPSBNQVRILnJvdW5kKHZpZXdwb3J0T2Zmc2V0W19zdHJMZWZ0XSAtIGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdICsgKF9zY3JvbGxIb3Jpem9udGFsSW5mby5fbWF4U2Nyb2xsIC0gdmlld3BvcnRTY3JvbGwubCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyaW5nIGlzIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NCbG9jay54ICE9IHN0ckJlZ2luIHx8IHNldHRpbmdzQmxvY2sueSAhPSBzdHJCZWdpbiB8fCBzZXR0aW5nc1Njcm9sbC54ID09IHN0cklmTmVlZGVkIHx8IHNldHRpbmdzU2Nyb2xsLnkgPT0gc3RySWZOZWVkZWQgfHwgX2lzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lYXN1cmluZ0VsbSA9IGZpbmFsRWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3RWxlbWVudFNpemUgPSBfc3VwcG9ydFRyYW5zZm9ybSA/IG1lYXN1cmluZ0VsbVtMRVhJQ09OLmJDUl0oKSA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1lYXN1cmluZ0VsbVtMRVhJQ09OLm9XXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtZWFzdXJpbmdFbG1bTEVYSUNPTi5vSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50U2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogcmF3RWxlbWVudFNpemVbX3N0cldpZHRoXSArIHNldHRpbmdzTWFyZ2luWzNdICsgc2V0dGluZ3NNYXJnaW5bMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IHJhd0VsZW1lbnRTaXplW19zdHJIZWlnaHRdICsgc2V0dGluZ3NNYXJnaW5bMF0gKyBzZXR0aW5nc01hcmdpblsyXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsaXplQmxvY2sgPSBmdW5jdGlvbiAoaXNYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc1gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2ggPSB2YXJzLl93X2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsdCA9IHZhcnMuX2xlZnRfdG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHkgPSB2YXJzLl94X3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0lzRW5kID0gc2V0dGluZ3NCbG9ja1t4eV0gPT0gKGlzWCA/IF9pc1JUTCA/IHN0ckJlZ2luIDogc3RyRW5kIDogc3RyRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrSXNDZW50ZXIgPSBzZXR0aW5nc0Jsb2NrW3h5XSA9PSBzdHJDZW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0lzTmVhcmVzdCA9IHNldHRpbmdzQmxvY2tbeHldID09IHN0ck5lYXJlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxOZXZlciA9IHNldHRpbmdzU2Nyb2xsW3h5XSA9PSBzdHJOZXZlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbElmTmVlZGVkID0gc2V0dGluZ3NTY3JvbGxbeHldID09IHN0cklmTmVlZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnBTaXplID0gX3ZpZXdwb3J0U2l6ZVt3aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2cE9mZnNldCA9IHZpZXdwb3J0T2Zmc2V0W2x0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsU2l6ZSA9IGVsZW1lbnRTaXplW3doXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsT2Zmc2V0ID0gZWxlbWVudE9mZnNldFtsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXZpZGUgPSBibG9ja0lzQ2VudGVyID8gMiA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50Q2VudGVyT2Zmc2V0ID0gZWxPZmZzZXQgKyAoZWxTaXplIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydENlbnRlck9mZnNldCA9IHZwT2Zmc2V0ICsgKHZwU2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJblZpZXcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxTaXplIDw9IHZwU2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZWxPZmZzZXQgPj0gdnBPZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGVsT2Zmc2V0ICsgZWxTaXplIDw9IHZwT2Zmc2V0ICsgdnBTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbE5ldmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9Ob3RTY3JvbGxbeHldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvTm90U2Nyb2xsW3h5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrSXNOZWFyZXN0IHx8IHNjcm9sbElmTmVlZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9Ob3RTY3JvbGxbeHldID0gc2Nyb2xsSWZOZWVkZWQgPyBpc0luVmlldyA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrSXNFbmQgPSBlbFNpemUgPCB2cFNpemUgPyBlbGVtZW50Q2VudGVyT2Zmc2V0ID4gdmlld3BvcnRDZW50ZXJPZmZzZXQgOiBlbGVtZW50Q2VudGVyT2Zmc2V0IDwgdmlld3BvcnRDZW50ZXJPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXNbeHldIC09IGJsb2NrSXNFbmQgfHwgYmxvY2tJc0NlbnRlciA/ICgodnBTaXplIC8gZGl2aWRlKSAtIChlbFNpemUgLyBkaXZpZGUpKSAqIChpc1ggJiYgX2lzUlRMICYmIG5vcm1hbGl6ZVJUTCA/IC0xIDogMSkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZUJsb2NrKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplQmxvY2soZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb05vdFNjcm9sbC55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb05vdFNjcm9sbC54KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMueDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTY3JvbGxbX3N0clNjcm9sbExlZnRdID0gZ2V0RmluYWxTY3JvbGwodHJ1ZSwgZ2V0UmF3U2Nyb2xsKHRydWUsIGNvb3JkaW5hdGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTY3JvbGxbX3N0clNjcm9sbFRvcF0gPSBnZXRGaW5hbFNjcm9sbChmYWxzZSwgZ2V0UmF3U2Nyb2xsKGZhbHNlLCBjb29yZGluYXRlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2Nyb2xsTGVmdCA9IGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxMZWZ0XSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2Nyb2xsVG9wID0gZmluYWxTY3JvbGxbX3N0clNjcm9sbFRvcF0gIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkb1Njcm9sbExlZnQgfHwgZG9TY3JvbGxUb3ApICYmIChkdXJhdGlvbiA+IDAgfHwgZHVyYXRpb25Jc09iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uSXNPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uLmNvbXBsZXRlID0gcHJveHlDb21wbGV0ZUNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5hbmltYXRlKGZpbmFsU2Nyb2xsLCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogcHJveHlDb21wbGV0ZUNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKGVhc2luZykgfHwgRlJBTUVXT1JLLmlzUGxhaW5PYmplY3QoZWFzaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbX3N0clNjcm9sbExlZnRdID0gZWFzaW5nWzBdIHx8IGVhc2luZy54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbX3N0clNjcm9sbFRvcF0gPSBlYXNpbmdbMV0gfHwgZWFzaW5nLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy5zcGVjaWFsRWFzaW5nID0gc3BlY2lhbEVhc2luZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMuZWFzaW5nID0gZWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5hbmltYXRlKGZpbmFsU2Nyb2xsLCBhbmltYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2Nyb2xsTGVmdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxMZWZ0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1Njcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oZmluYWxTY3JvbGxbX3N0clNjcm9sbFRvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTY3JvbGxiYXJJbmZvcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTdG9wcyBhbGwgc2Nyb2xsIGFuaW1hdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIGN1cnJlbnQgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UgKGZvciBjaGFpbmluZykuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbFN0b3AgPSBmdW5jdGlvbiAocGFyYW0xLCBwYXJhbTIsIHBhcmFtMykge1xyXG4gICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuc3RvcChwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhbGwgcmVsZXZhbnQgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZWxlbWVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgd2hpY2ggc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3RhcmdldDogKiwgaG9zdDogKiwgcGFkZGluZzogKiwgdmlld3BvcnQ6ICosIGNvbnRlbnQ6ICosIHNjcm9sbGJhckhvcml6b250YWw6IHtzY3JvbGxiYXI6ICosIHRyYWNrOiAqLCBoYW5kbGU6ICp9LCBzY3JvbGxiYXJWZXJ0aWNhbDoge3Njcm9sbGJhcjogKiwgdHJhY2s6ICosIGhhbmRsZTogKn0sIHNjcm9sbGJhckNvcm5lcjogKn0gfCAqfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogX3RhcmdldEVsZW1lbnROYXRpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IF9ob3N0RWxlbWVudE5hdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogX3BhZGRpbmdFbGVtZW50TmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydDogX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogX2NvbnRlbnRFbGVtZW50TmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJIb3Jpem9udGFsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXI6IF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrOiBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZTogX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50WzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXI6IF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjazogX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50WzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckNvcm5lcjogX3Njcm9sbGJhckNvcm5lckVsZW1lbnRbMF1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlKGVsZW1lbnROYW1lKSA9PSBUWVBFUy5zID8gZ2V0T2JqZWN0UHJvcFZhbChvYmosIGVsZW1lbnROYW1lKSA6IG9iajtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgb2JqZWN0IHdoaWNoIGRlc2NyaWJlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHN0YXRlUHJvcGVydHkgQSBzcGVjaWZpYyBwcm9wZXJ0eSBmcm9tIHRoZSBzdGF0ZSBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3dpZHRoQXV0bywgaGVpZ2h0QXV0bywgb3ZlcmZsb3dBbW91bnQsIGhpZGVPdmVyZmxvdywgaGFzT3ZlcmZsb3csIGNvbnRlbnRTY3JvbGxTaXplLCB2aWV3cG9ydFNpemUsIGhvc3RTaXplLCBhdXRvVXBkYXRlfSB8ICp9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmdldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUZSQU1FV09SSy5pc1BsYWluT2JqZWN0KG9iaikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kZWQgPSBleHRlbmREZWVwKHt9LCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWRbTEVYSUNPTi5oT1BdKGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRbdG9dID0gZXh0ZW5kZWRbZnJvbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV4dGVuZGVkW2Zyb21dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VQcm9wZXJ0eU5hbWUoJ3cnLCBfc3RyV2lkdGgpOyAvL2NoYW5nZSB3IHRvIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVByb3BlcnR5TmFtZSgnaCcsIF9zdHJIZWlnaHQpOyAvL2NoYW5nZSBoIHRvIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXh0ZW5kZWQuYzsgLy9kZWxldGUgYyAodGhlICdjaGFuZ2VkJyBwcm9wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZWQ6ICEhcHJlcGFyZShfZGVzdHJveWVkKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xlZXBpbmc6ICEhcHJlcGFyZShfc2xlZXBpbmcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlOiBwcmVwYXJlKCFfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aEF1dG86IHByZXBhcmUoX3dpZHRoQXV0b0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0QXV0bzogcHJlcGFyZShfaGVpZ2h0QXV0b0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcHJlcGFyZShfY3NzUGFkZGluZ0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dBbW91bnQ6IHByZXBhcmUoX292ZXJmbG93QW1vdW50Q2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcmZsb3c6IHByZXBhcmUoX2hpZGVPdmVyZmxvd0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3c6IHByZXBhcmUoX2hhc092ZXJmbG93Q2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U2Nyb2xsU2l6ZTogcHJlcGFyZShfY29udGVudFNjcm9sbFNpemVDYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0U2l6ZTogcHJlcGFyZShfdmlld3BvcnRTaXplKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFNpemU6IHByZXBhcmUoX2hvc3RTaXplQ2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1peGVkOiBwcmVwYXJlKF9kb2N1bWVudE1peGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUoc3RhdGVQcm9wZXJ0eSkgPT0gVFlQRVMucyA/IGdldE9iamVjdFByb3BWYWwob2JqLCBzdGF0ZVByb3BlcnR5KSA6IG9iajtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIGFsbCBvciBzcGVjaWZpYyBleHRlbnNpb24gaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIGZyb20gd2hpY2ggdGhlIGluc3RhbmNlIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7fX0gVGhlIGluc3RhbmNlIG9mIHRoZSBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciB1bmRlZmluZWQgaWYgdGhlIGluc3RhbmNlIGNvdWxkbid0IGJlIGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5leHQgPSBmdW5jdGlvbiAoZXh0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaXZhdGVNZXRob2RzID0gX2V4dGVuc2lvbnNQcml2YXRlTWV0aG9kcy5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShleHROYW1lKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZXh0ZW5zaW9uc1tMRVhJQ09OLmhPUF0oZXh0TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4dGVuZERlZXAoe30sIF9leHRlbnNpb25zW2V4dE5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcHJpdmF0ZU1ldGhvZHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtwcml2YXRlTWV0aG9kc1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gX2V4dGVuc2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBleHRlbmREZWVwKHt9LCBfYmFzZS5leHQoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSBleHRlbnNpb24gdG8gdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHROYW1lIFRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gd2hpY2ggc2hhbGwgYmUgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uT3B0aW9ucyBUaGUgZXh0ZW5zaW9uIG9wdGlvbnMgd2hpY2ggc2hhbGwgYmUgdXNlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7fX0gVGhlIGluc3RhbmNlIG9mIHRoZSBhZGRlZCBleHRlbnNpb24gb3IgdW5kZWZpbmVkIGlmIHRoZSBleHRlbnNpb24gY291bGRuJ3QgYmUgYWRkZWQgcHJvcGVybHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmFkZEV4dCA9IGZ1bmN0aW9uIChleHROYW1lLCBleHRlbnNpb25PcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWRFeHRlbnNpb25PYmogPSBfcGx1Z2luLmV4dGVuc2lvbihleHROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQWRkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQ29udHJhY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyYWN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cmFjdEZ1bGZpbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRFeHRlbnNpb25PYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXh0ZW5zaW9uc1tMRVhJQ09OLmhPUF0oZXh0TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcmVnaXN0ZXJlZEV4dGVuc2lvbk9iai5leHRlbnNpb25GYWN0b3J5LmNhbGwoX2Jhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kRGVlcCh7fSwgcmVnaXN0ZXJlZEV4dGVuc2lvbk9iai5kZWZhdWx0T3B0aW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlQ29udHJhY3QgPSBpbnN0YW5jZS5jb250cmFjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShpbnN0YW5jZUNvbnRyYWN0KSA9PSBUWVBFUy5mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0UmVzdWx0ID0gaW5zdGFuY2VDb250cmFjdCh3aW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEZ1bGZpbGxlZCA9IHR5cGUoY29udHJhY3RSZXN1bHQpID09IFRZUEVTLmIgPyBjb250cmFjdFJlc3VsdCA6IGNvbnRyYWN0RnVsZmlsbGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJhY3RGdWxmaWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuc2lvbnNbZXh0TmFtZV0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VBZGRlZCA9IGluc3RhbmNlLmFkZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShpbnN0YW5jZUFkZGVkKSA9PSBUWVBFUy5mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VBZGRlZChleHRlbnNpb25PcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZS5leHQoZXh0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZS5leHQoZXh0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSBleHRlbnNpb24gd2l0aCB0aGUgbmFtZSBcXFwiXCIgKyBleHROYW1lICsgXCJcXFwiIGlzbid0IHJlZ2lzdGVyZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYSBleHRlbnNpb24gZnJvbSB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4dGVuc2lvbiB3aGljaCBzaGFsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4dGVuc2lvbiB3YXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlIGUuZy4gaWYgdGhlIGV4dGVuc2lvbiB3YXNuJ3QgYWRkZWQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5yZW1vdmVFeHQgPSBmdW5jdGlvbiAoZXh0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IF9leHRlbnNpb25zW2V4dE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZVJlbW92ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfZXh0ZW5zaW9uc1tleHROYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlUmVtb3ZlZCA9IGluc3RhbmNlLnJlbW92ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGluc3RhbmNlUmVtb3ZlZCkgPT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlUmVtb3ZlZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIHRoZSBwbHVnaW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgcGx1Z2luIHNoYWxsIGJlIGFwcGxpZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5pdGlhbCBvcHRpb25zIG9mIHRoZSBwbHVnaW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9uKHMpIHdoaWNoIHNoYWxsIGJlIGFkZGVkIHJpZ2h0IGFmdGVyIHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwbHVnaW4gd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3QodGFyZ2V0RWxlbWVudCwgb3B0aW9ucywgZXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0T3B0aW9ucyA9IGdsb2JhbHMuZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcgPSBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhclN0eWxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclNpemUgPSBleHRlbmREZWVwKHt9LCBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhclNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkID0gZXh0ZW5kRGVlcCh7fSwgZ2xvYmFscy5uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkKTtcclxuICAgICAgICAgICAgICAgICAgICBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZSA9IGV4dGVuZERlZXAoe30sIGdsb2JhbHMub3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3J0bFNjcm9sbEJlaGF2aW9yID0gZXh0ZW5kRGVlcCh7fSwgZ2xvYmFscy5ydGxTY3JvbGxCZWhhdmlvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGFyc2UgJiBzZXQgb3B0aW9ucyBidXQgZG9uJ3QgdXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9ucyhleHRlbmREZWVwKHt9LCBfZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc0NhbGMgPSBnbG9iYWxzLmNzc0NhbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgX21zaWVWZXJzaW9uID0gZ2xvYmFscy5tc2llO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hdXRvVXBkYXRlUmVjb21tZW5kZWQgPSBnbG9iYWxzLmF1dG9VcGRhdGVSZWNvbW1lbmRlZDtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwcG9ydFRyYW5zaXRpb24gPSBnbG9iYWxzLnN1cHBvcnRUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0VHJhbnNmb3JtID0gZ2xvYmFscy5zdXBwb3J0VHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0UGFzc2l2ZUV2ZW50cyA9IGdsb2JhbHMuc3VwcG9ydFBhc3NpdmVFdmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cHBvcnRSZXNpemVPYnNlcnZlciA9IGdsb2JhbHMuc3VwcG9ydFJlc2l6ZU9ic2VydmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0TXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbHMuc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3RyaWN0ZWRNZWFzdXJpbmcgPSBnbG9iYWxzLnJlc3RyaWN0ZWRNZWFzdXJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50RWxlbWVudCA9IEZSQU1FV09SSyh0YXJnZXRFbGVtZW50Lm93bmVyRG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudEVsZW1lbnROYXRpdmUgPSBfZG9jdW1lbnRFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIF93aW5kb3dFbGVtZW50ID0gRlJBTUVXT1JLKF9kb2N1bWVudEVsZW1lbnROYXRpdmUuZGVmYXVsdFZpZXcgfHwgX2RvY3VtZW50RWxlbWVudE5hdGl2ZS5wYXJlbnRXaW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIF93aW5kb3dFbGVtZW50TmF0aXZlID0gX3dpbmRvd0VsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgX2h0bWxFbGVtZW50ID0gZmluZEZpcnN0KF9kb2N1bWVudEVsZW1lbnQsICdodG1sJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2JvZHlFbGVtZW50ID0gZmluZEZpcnN0KF9odG1sRWxlbWVudCwgJ2JvZHknKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudCA9IEZSQU1FV09SSyh0YXJnZXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudE5hdGl2ZSA9IF90YXJnZXRFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pc1RleHRhcmVhID0gX3RhcmdldEVsZW1lbnQuaXMoJ3RleHRhcmVhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2lzQm9keSA9IF90YXJnZXRFbGVtZW50LmlzKCdib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50TWl4ZWQgPSBfZG9jdW1lbnRFbGVtZW50TmF0aXZlICE9PSBkb2N1bWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogT24gYSBkaXYgRWxlbWVudCBUaGUgaWYgY2hlY2tzIG9ubHkgd2hldGhlcjpcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIHRoZSB0YXJnZXRFbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJvcy1ob3N0XCJcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIHRoZSB0YXJnZXRFbGVtZW50IGhhcyBhIGEgY2hpbGQgd2l0aCB0aGUgY2xhc3MgXCJvcy1wYWRkaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGF0J3MgdGhlIGNhc2UsIGl0cyBhc3N1bWVkIHRoZSBET00gaGFzIGFscmVhZHkgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XHJcbiAgICAgICAgICAgICAgICAgICAgICogKFRoZSBcIi5vcy1ob3N0XCIgZWxlbWVudCBpcyB0aGUgdGFyZ2V0RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICA8ZGl2IGNsYXNzPVwib3MtaG9zdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0XCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3MtcGFkZGluZ1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy12aWV3cG9ydFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3MtY29udGVudFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci1ob3Jpem9udGFsIFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItdHJhY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci1oYW5kbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhciBvcy1zY3JvbGxiYXItdmVydGljYWxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLXRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItaGFuZGxlXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItY29ybmVyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIE9uIGEgVGV4dGFyZWEgRWxlbWVudCBUaGUgaWYgY2hlY2tzIG9ubHkgd2hldGhlcjpcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIHRoZSB0YXJnZXRFbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJvcy10ZXh0YXJlYVwiIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gdGhlIHRhcmdldEVsZW1lbnQgaXMgaW5zaWRlIGEgZWxlbWVudCB3aXRoIHRoZSBjbGFzcyBcIm9zLWNvbnRlbnRcIiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGF0J3MgdGhlIGNhc2UsIGl0cyBhc3N1bWVkIHRoZSBET00gaGFzIGFscmVhZHkgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XHJcbiAgICAgICAgICAgICAgICAgICAgICogKFRoZSBcIi5vcy10ZXh0YXJlYVwiICh0ZXh0YXJlYSkgZWxlbWVudCBpcyB0aGUgdGFyZ2V0RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICA8ZGl2IGNsYXNzPVwib3MtaG9zdC10ZXh0YXJlYVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0XCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3MtcGFkZGluZyBvcy10ZXh0LWluaGVyaXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtdmlld3BvcnQgb3MtdGV4dC1pbmhlcml0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1jb250ZW50IG9zLXRleHQtaW5oZXJpdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXRleHRhcmVhLWNvdmVyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJvcy10ZXh0YXJlYSBvcy10ZXh0LWluaGVyaXRcIj48L3RleHRhcmVhPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhciBvcy1zY3JvbGxiYXItaG9yaXpvbnRhbCBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLXRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItaGFuZGxlXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXIgb3Mtc2Nyb2xsYmFyLXZlcnRpY2FsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci10cmFja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWhhbmRsZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWNvcm5lclwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBfZG9tRXhpc3RzID0gX2lzVGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfdGFyZ2V0RWxlbWVudC5oYXNDbGFzcyhfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50KSAmJiBfdGFyZ2V0RWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcyhfY2xhc3NOYW1lQ29udGVudEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3RhcmdldEVsZW1lbnQuaGFzQ2xhc3MoX2NsYXNzTmFtZUhvc3RFbGVtZW50KSAmJiBfdGFyZ2V0RWxlbWVudC5jaGlsZHJlbihfc3RyRG90ICsgX2NsYXNzTmFtZVBhZGRpbmdFbGVtZW50KVtMRVhJQ09OLmxdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdEJvZHlTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlNb3VzZVRvdWNoRG93bkxpc3RlbmVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBwbHVnaW4gaGFzbid0IHRvIGJlIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSAmJiAhX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMubmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLmluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25Jbml0aWFsaXphdGlvbldpdGhkcmF3bicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdHJ1Y3R1cmVET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhcnNET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckNvcm5lckRPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zbGVlcGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Qm9keVNjcm9sbCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Qm9keVNjcm9sbC5sID0gTUFUSC5tYXgoX3RhcmdldEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKCksIF9odG1sRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oKSwgX3dpbmRvd0VsZW1lbnRbX3N0clNjcm9sbExlZnRdKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Qm9keVNjcm9sbC50ID0gTUFUSC5tYXgoX3RhcmdldEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oKSwgX2h0bWxFbGVtZW50W19zdHJTY3JvbGxUb3BdKCksIF93aW5kb3dFbGVtZW50W19zdHJTY3JvbGxUb3BdKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1vdXNlVG91Y2hEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LnJlbW92ZUF0dHIoTEVYSUNPTi50aSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF92aWV3cG9ydEVsZW1lbnQsIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LCBib2R5TW91c2VUb3VjaERvd25MaXN0ZW5lciwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYnVpbGQgT3ZlcmxheVNjcm9sbGJhcnMgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTdHJ1Y3R1cmVET00oKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhcnNET00oKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckNvcm5lckRPTSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSBPdmVybGF5U2Nyb2xsYmFycyBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFN0cnVjdHVyZUV2ZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyRXZlbnRzKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyRXZlbnRzKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckNvcm5lckV2ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSBtdXRhdGlvbiBvYnNlcnZlcnNcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVNdXRhdGlvbk9ic2VydmVycygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2J1aWxkIHJlc2l6ZSBvYnNlcnZlciBmb3IgdGhlIGhvc3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVPYnNlcnZlckVsZW1lbnQsIGhvc3RPblJlc2l6ZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IHRoZSBib2R5IHNjcm9sbCB0byBoYW5kbGUgaXQgcmlnaHQgaW4gdGhlIHVwZGF0ZSBtZXRob2RcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oaW5pdEJvZHlTY3JvbGwubClbX3N0clNjcm9sbFRvcF0oaW5pdEJvZHlTY3JvbGwudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCB0aGUgZm9jdXMgb24gdGhlIHZpZXdwb3J0IGVsZW1lbnQgc28geW91IGRvbnQgaGF2ZSB0byBjbGljayBvbiB0aGUgcGFnZSB0byB1c2Uga2V5Ym9hcmQga2V5cyAodXAgLyBkb3duIC8gc3BhY2UpIGZvciBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gdGFyZ2V0RWxlbWVudCAmJiBfdmlld3BvcnRFbGVtZW50TmF0aXZlLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NldCBhIHRhYmluZGV4IHRvIG1ha2UgdGhlIHZpZXdwb3J0RWxlbWVudCBmb2N1c2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuYXR0cihMRVhJQ09OLnRpLCAnLTEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnROYXRpdmUuZm9jdXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiB0aGUgdGFiaW5kZXggaGFzIHRvIGJlIHJlbW92ZWQgZHVlIHRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgeW91IHNldCB0aGUgdGFiaW5kZXggYXR0cmlidXRlIG9uIGFuIDxkaXY+LCB0aGVuIGl0cyBjaGlsZCBjb250ZW50IGNhbm5vdCBiZSBzY3JvbGxlZCB3aXRoIHRoZSBhcnJvdyBrZXlzIHVubGVzcyB5b3Ugc2V0IHRhYmluZGV4IG9uIHRoZSBjb250ZW50LCB0b29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfdmlld3BvcnRFbGVtZW50LCBfc3RyTW91c2VUb3VjaERvd25FdmVudCwgYm9keU1vdXNlVG91Y2hEb3duTGlzdGVuZXIsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgZm9yIHRoZSBmaXJzdCB0aW1lICYgaW5pdGlhbGl6ZSBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIHBsdWdpbiBpcyBpbml0aWFsaXplZCBub3chXHJcbiAgICAgICAgICAgICAgICAgICAgX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkluaXRpYWxpemVkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2FsbCBhbGwgY2FsbGJhY2tzIHdoaWNoIHdvdWxkIGZpcmUgYmVmb3JlIHRoZSBpbml0aWFsaXplZCB3YXMgY29tcGxldGVcclxuICAgICAgICAgICAgICAgICAgICBlYWNoKF9jYWxsYmFja3NJbml0UWV1ZXVlLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7IGRpc3BhdGNoQ2FsbGJhY2sodmFsdWUubiwgdmFsdWUuYSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFja3NJbml0UWV1ZXVlID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShleHRlbnNpb25zKSA9PSBUWVBFUy5zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zID0gW2V4dGVuc2lvbnNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmlzQShleHRlbnNpb25zKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChleHRlbnNpb25zLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7IF9iYXNlLmFkZEV4dCh2YWx1ZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEZSQU1FV09SSy5pc1BsYWluT2JqZWN0KGV4dGVuc2lvbnMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGV4dGVuc2lvbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7IF9iYXNlLmFkZEV4dChrZXksIHZhbHVlKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSB0cmFuc2l0aW9uIGNsYXNzIGZvciB0cmFuc2l0aW9ucyBBRlRFUiB0aGUgZmlyc3QgdXBkYXRlICYgQUZURVIgdGhlIGFwcGxpZWQgZXh0ZW5zaW9ucyAoZm9yIHByZXZlbnRpbmcgdW53YW50ZWQgdHJhbnNpdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zaXRpb24gJiYgIV9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0VHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMzMzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9iYXNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfcGx1Z2luLnZhbGlkKGNvbnN0cnVjdChwbHVnaW5UYXJnZXRFbGVtZW50LCBvcHRpb25zLCBleHRlbnNpb25zKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBJTlNUQU5DRVMocGx1Z2luVGFyZ2V0RWxlbWVudCwgX2Jhc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3IE92ZXJsYXlTY3JvbGxiYXJzSW5zdGFuY2Ugb2JqZWN0IG9yIGNoYW5nZXMgb3B0aW9ucyBpZiBhbHJlYWR5IGluaXRpYWxpemVkIG9yIHJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBwbHVnaW5UYXJnZXRFbGVtZW50cyBUaGUgZWxlbWVudHMgdG8gd2hpY2ggdGhlIFBsdWdpbiBzaGFsbCBiZSBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGN1c3RvbSBvcHRpb25zIHdpdGggd2hpY2ggdGhlIHBsdWdpbiBzaGFsbCBiZSBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbihzKSB3aGljaCBzaGFsbCBiZSBhZGRlZCByaWdodCBhZnRlciBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfcGx1Z2luID0gd2luZG93W1BMVUdJTk5BTUVdID0gZnVuY3Rpb24gKHBsdWdpblRhcmdldEVsZW1lbnRzLCBvcHRpb25zLCBleHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW0xFWElDT04ubF0gPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdHNJc1BsYWluT2JqID0gRlJBTUVXT1JLLmlzUGxhaW5PYmplY3Qob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdDtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9wbHVnaW5UYXJnZXRFbGVtZW50cyBpcyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFwbHVnaW5UYXJnZXRFbGVtZW50cylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0c0lzUGxhaW5PYmogfHwgIW9wdGlvbnMgPyByZXN1bHQgOiBhcnI7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgIHBsdWdpblRhcmdldEVsZW1lbnRzIHdpbGwgYmUgY29udmVydGVkIHRvOlxyXG4gICAgICAgICAgICAgICAgICAgMS4gQSBqUXVlcnlFbGVtZW50IEFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAyLiBBIEhUTUxFbGVtZW50IEFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAzLiBBIEFycmF5IHdpdGggYSBzaW5nbGUgSFRNTCBFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICBzbyBwbHVnaW5UYXJnZXRFbGVtZW50cyBpcyBhbHdheXMgYSBhcnJheS5cclxuICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5UYXJnZXRFbGVtZW50cyA9IHBsdWdpblRhcmdldEVsZW1lbnRzW0xFWElDT04ubF0gIT0gdW5kZWZpbmVkID8gcGx1Z2luVGFyZ2V0RWxlbWVudHMgOiBbcGx1Z2luVGFyZ2V0RWxlbWVudHNbMF0gfHwgcGx1Z2luVGFyZ2V0RWxlbWVudHNdO1xyXG4gICAgICAgICAgICAgICAgaW5pdE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5UYXJnZXRFbGVtZW50c1tMRVhJQ09OLmxdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzSXNQbGFpbk9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZWFjaChwbHVnaW5UYXJnZXRFbGVtZW50cywgZnVuY3Rpb24gKGksIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3QgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3QgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChPdmVybGF5U2Nyb2xsYmFyc0luc3RhbmNlKGluc3QsIG9wdGlvbnMsIGV4dGVuc2lvbnMsIF9wbHVnaW5zR2xvYmFscywgX3BsdWdpbnNBdXRvVXBkYXRlTG9vcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5lYWNoKHBsdWdpblRhcmdldEVsZW1lbnRzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCA9IElOU1RBTkNFUyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gJyEnICYmIF9wbHVnaW4udmFsaWQoaW5zdCkpIHx8IChDT01QQVRJQklMSVRZLnR5cGUob3B0aW9ucykgPT0gVFlQRVMuZiAmJiBvcHRpb25zKHYsIGluc3QpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpbnN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpbnN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFycltMRVhJQ09OLmxdID09PSAxID8gYXJyWzBdIDogYXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGx1Z2luIGFuZCBlYWNoIGluc3RhbmNlIG9mIGl0LlxyXG4gICAgICAgICAgICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIGp1c3QgYSBjb3B5LCB0aGF0IG1lYW5zIHRoYXQgY2hhbmdlcyB0byB0aGUgcmV0dXJuZWQgb2JqZWN0IHdvbid0IGhhdmUgYW55IGVmZmVjdCB0byB0aGUgb3JpZ2luYWwgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3BsdWdpbi5nbG9iYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljcygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdsb2JhbHMgPSBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBfcGx1Z2luc0dsb2JhbHMpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbHNbJ21zaWUnXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3IgU2V0cyB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBlYWNoIG5ldyBwbHVnaW4gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBuZXdEZWZhdWx0T3B0aW9ucyBUaGUgb2JqZWN0IHdpdGggd2hpY2ggdGhlIGRlZmF1bHQgb3B0aW9ucyBzaGFsbCBiZSBleHRlbmRlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9wbHVnaW4uZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAobmV3RGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGluaXRPdmVybGF5U2Nyb2xsYmFyc1N0YXRpY3MoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyRGVmYXVsdE9wdGlvbnMgPSBfcGx1Z2luc0dsb2JhbHMuZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RGVmYXVsdE9wdGlvbnMgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgY3VyckRlZmF1bHRPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NldCB0aGUgbmV3IGRlZmF1bHQgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgX3BsdWdpbnNHbG9iYWxzLmRlZmF1bHRPcHRpb25zID0gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgY3VyckRlZmF1bHRPcHRpb25zLCBfcGx1Z2luc09wdGlvbnMuX3ZhbGlkYXRlKG5ld0RlZmF1bHRPcHRpb25zLCBfcGx1Z2luc09wdGlvbnMuX3RlbXBsYXRlLCB0cnVlLCBjdXJyRGVmYXVsdE9wdGlvbnMpLl9kZWZhdWx0KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgcGFzc2VkIGluc3RhbmNlIGlzIGEgbm9uLWRlc3Ryb3llZCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIG9zSW5zdGFuY2UgVGhlIHBvdGVudGlhbCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgbm9uLWRlc3Ryb3llZCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3BsdWdpbi52YWxpZCA9IGZ1bmN0aW9uIChvc0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3NJbnN0YW5jZSBpbnN0YW5jZW9mIF9wbHVnaW4gJiYgIW9zSW5zdGFuY2UuZ2V0U3RhdGUoKS5kZXN0cm95ZWQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVnaXN0ZXJzLCBVbnJlZ2lzdGVycyBvciByZXR1cm5zIGEgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcjogUGFzcyB0aGUgbmFtZSBhbmQgdGhlIGV4dGVuc2lvbi4gKGRlZmF1bHRPcHRpb25zIGlzIG9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgKiBVbnJlZ2lzdGVyOiBQYXNzIHRoZSBuYW1lIGFuZCBhbnl0aGluZyBleGNlcHQgYSBmdW5jdGlvbiBhcyBleHRlbnNpb24gcGFyYW1ldGVyLlxyXG4gICAgICAgICAgICAgKiBHZXQgZXh0ZW5zaW9uOiBQYXNzIHRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gd2hpY2ggc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgKiBHZXQgYWxsIGV4dGVuc2lvbnM6IFBhc3Mgbm8gYXJndW1lbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uTmFtZSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIHdoaWNoIHNoYWxsIGJlIHJlZ2lzdGVyZWQsIHVucmVnaXN0ZXJlZCBvciByZXR1cm5lZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbiBBIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGV4dGVuc2lvbiBvciBhbnl0aGluZyBvdGhlciB0byByZW1vdmUgYSBhbHJlYWR5IHJlZ2lzdGVyZWQgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGVmYXVsdE9wdGlvbnMgVGhlIGRlZmF1bHQgb3B0aW9ucyB3aGljaCBzaGFsbCBiZSB1c2VkIGZvciB0aGUgcmVnaXN0ZXJlZCBleHRlbnNpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfcGx1Z2luLmV4dGVuc2lvbiA9IGZ1bmN0aW9uIChleHRlbnNpb25OYW1lLCBleHRlbnNpb24sIGRlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXh0TmFtZVR5cGVTdHJpbmcgPSBDT01QQVRJQklMSVRZLnR5cGUoZXh0ZW5zaW9uTmFtZSkgPT0gVFlQRVMucztcclxuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmd1bWVudHNbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPCAxIHx8ICFleHROYW1lVHlwZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGEgY29weSBvZiBhbGwgZXh0ZW5zaW9uIG9iamVjdHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7IGxlbmd0aDogX3BsdWdpbnNFeHRlbnNpb25zW0xFWElDT04ubF0gfSwgX3BsdWdpbnNFeHRlbnNpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dE5hbWVUeXBlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkudHlwZShleHRlbnNpb24pID09IFRZUEVTLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWdpc3RlciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3BsdWdpbnNFeHRlbnNpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbkZhY3Rvcnk6IGV4dGVuc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgX3BsdWdpbnNFeHRlbnNpb25zW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9wbHVnaW5zRXh0ZW5zaW9uc1tpXS5uYW1lID09PSBleHRlbnNpb25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wbHVnaW5zRXh0ZW5zaW9ucy5zcGxpY2UoaSwgMSk7IC8vcmVtb3ZlIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIF9wbHVnaW5zRXh0ZW5zaW9uc1tpXSk7IC8vcmV0dXJuIGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX3BsdWdpbjtcclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICBpZiAoSlFVRVJZICYmIEpRVUVSWS5mbikge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGpRdWVyeSBpbml0aWFsaXphdGlvbiBpbnRlcmZhY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbml0aWFsIG9wdGlvbnMgZm9yIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIHBsdWdpbi4gVG8gaW5pdGlhbGl6ZSB0aGUgcGx1Z2luLCB0aGlzIG9wdGlvbiBoYXMgdG8gYmUgYSBvYmplY3QhIElmIGl0IGlzbid0IGEgb2JqZWN0LCB0aGUgaW5zdGFuY2UocykgYXJlIHJldHVybmVkIGFuZCB0aGUgcGx1Z2luIHdvbnQgYmUgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb24ocykgd2hpY2ggc2hhbGwgYmUgYWRkZWQgcmlnaHQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBBZnRlciBpbml0aWFsaXphdGlvbiBpdCByZXR1cm5zIHRoZSBqUXVlcnkgZWxlbWVudCBhcnJheSwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnN0YW5jZShzKSBvZiB0aGUgZWxlbWVudHMgd2hpY2ggYXJlIHNlbGVjdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSlFVRVJZLmZuLm92ZXJsYXlTY3JvbGxiYXJzID0gZnVuY3Rpb24gKG9wdGlvbnMsIGV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKEpRVUVSWS5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgSlFVRVJZLmVhY2goX2VsZW1lbnRzLCBmdW5jdGlvbiAoKSB7IFBMVUdJTih0aGlzLCBvcHRpb25zLCBleHRlbnNpb25zKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbGVtZW50cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUExVR0lOKF9lbGVtZW50cywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQTFVHSU47XHJcbiAgICB9XHJcbikpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDJcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9jcmVhdGVTdXBlciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlU3VwZXJcIjtcbnZhciBfZXhjbHVkZWQgPSBbXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiLCBcInN0eWxlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJkZWZhdWx0T3BlblwiLCBcIm9wZW5cIiwgXCJwcmVmaXhDbHNcIiwgXCJwbGFjZW1lbnRcIiwgXCJsZXZlbFwiLCBcImxldmVsTW92ZVwiLCBcImVhc2VcIiwgXCJkdXJhdGlvblwiLCBcImdldENvbnRhaW5lclwiLCBcImhhbmRsZXJcIiwgXCJvbkNoYW5nZVwiLCBcImFmdGVyVmlzaWJsZUNoYW5nZVwiLCBcInNob3dNYXNrXCIsIFwibWFza0Nsb3NhYmxlXCIsIFwibWFza1N0eWxlXCIsIFwib25DbG9zZVwiLCBcIm9uSGFuZGxlQ2xpY2tcIiwgXCJrZXlib2FyZFwiLCBcImdldE9wZW5Db3VudFwiLCBcInNjcm9sbExvY2tlclwiLCBcImNvbnRlbnRXcmFwcGVyU3R5bGVcIl07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBnZXRTY3JvbGxCYXJTaXplIGZyb20gXCJyYy11dGlsL2VzL2dldFNjcm9sbEJhclNpemVcIjtcbmltcG9ydCBLZXlDb2RlIGZyb20gXCJyYy11dGlsL2VzL0tleUNvZGVcIjtcbmltcG9ydCBvbWl0IGZyb20gXCJyYy11dGlsL2VzL29taXRcIjtcbmltcG9ydCB7IGFkZEV2ZW50TGlzdGVuZXIsIGRhdGFUb0FycmF5LCBnZXRUb3VjaFBhcmVudFNjcm9sbCwgaXNOdW1lcmljLCByZW1vdmVFdmVudExpc3RlbmVyLCB0cmFuc2Zvcm1Bcmd1bWVudHMsIHRyYW5zaXRpb25FbmQsIHRyYW5zaXRpb25TdHIsIHdpbmRvd0lzVW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscyc7XG52YXIgY3VycmVudERyYXdlciA9IHt9O1xuXG52YXIgRHJhd2VyQ2hpbGQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERyYXdlckNoaWxkLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERyYXdlckNoaWxkKTtcblxuICBmdW5jdGlvbiBEcmF3ZXJDaGlsZChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmF3ZXJDaGlsZCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICBfdGhpcy5sZXZlbERvbSA9IHZvaWQgMDtcbiAgICBfdGhpcy5kb20gPSB2b2lkIDA7XG4gICAgX3RoaXMuY29udGVudFdyYXBwZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuY29udGVudERvbSA9IHZvaWQgMDtcbiAgICBfdGhpcy5tYXNrRG9tID0gdm9pZCAwO1xuICAgIF90aGlzLmhhbmRsZXJEb20gPSB2b2lkIDA7XG4gICAgX3RoaXMuZHJhd2VySWQgPSB2b2lkIDA7XG4gICAgX3RoaXMudGltZW91dCA9IHZvaWQgMDtcbiAgICBfdGhpcy5wYXNzaXZlID0gdm9pZCAwO1xuICAgIF90aGlzLnN0YXJ0UG9zID0gdm9pZCAwO1xuXG4gICAgX3RoaXMuZG9tRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuZG9tKSB7XG4gICAgICAgIF90aGlzLmRvbS5mb2N1cygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5yZW1vdmVTdGFydEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhcnRQb3MgPSB7XG4gICAgICAgIHg6IGUudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICB5OiBlLnRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVtb3ZlTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgdmFyIGRpZmZlclggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFggLSBfdGhpcy5zdGFydFBvcy54O1xuICAgICAgdmFyIGRpZmZlclkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkgLSBfdGhpcy5zdGFydFBvcy55O1xuXG4gICAgICBpZiAoKGN1cnJlbnRUYXJnZXQgPT09IF90aGlzLm1hc2tEb20gfHwgY3VycmVudFRhcmdldCA9PT0gX3RoaXMuaGFuZGxlckRvbSB8fCBjdXJyZW50VGFyZ2V0ID09PSBfdGhpcy5jb250ZW50RG9tICYmIGdldFRvdWNoUGFyZW50U2Nyb2xsKGN1cnJlbnRUYXJnZXQsIGUudGFyZ2V0LCBkaWZmZXJYLCBkaWZmZXJZKSkgJiYgZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMudHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZG9tID0gZS50YXJnZXQ7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGRvbSwgdHJhbnNpdGlvbkVuZCwgX3RoaXMudHJhbnNpdGlvbkVuZCk7XG4gICAgICBkb20uc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS2V5Q29kZS5FU0MpIHtcbiAgICAgICAgdmFyIG9uQ2xvc2UgPSBfdGhpcy5wcm9wcy5vbkNsb3NlO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgICAgb25DbG9zZShlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbldyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG9wZW4gPSBfdGhpcyRwcm9wcy5vcGVuLFxuICAgICAgICAgIGFmdGVyVmlzaWJsZUNoYW5nZSA9IF90aGlzJHByb3BzLmFmdGVyVmlzaWJsZUNoYW5nZTtcblxuICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy5jb250ZW50V3JhcHBlciAmJiBlLnByb3BlcnR5TmFtZS5tYXRjaCgvdHJhbnNmb3JtJC8pKSB7XG4gICAgICAgIF90aGlzLmRvbS5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG5cbiAgICAgICAgaWYgKCFvcGVuICYmIF90aGlzLmdldEN1cnJlbnREcmF3ZXJTb21lKCkpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WCA9ICcnO1xuXG4gICAgICAgICAgaWYgKF90aGlzLm1hc2tEb20pIHtcbiAgICAgICAgICAgIF90aGlzLm1hc2tEb20uc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICAgICAgX3RoaXMubWFza0RvbS5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZnRlclZpc2libGVDaGFuZ2UpIHtcbiAgICAgICAgICBhZnRlclZpc2libGVDaGFuZ2UoISFvcGVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vcGVuTGV2ZWxUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG9wZW4gPSBfdGhpcyRwcm9wczIub3BlbixcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzMi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczIuaGVpZ2h0O1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0SG9yaXpvbnRhbEJvID0gX3RoaXMuZ2V0SG9yaXpvbnRhbEJvb2xBbmRQbGFjZW1lbnROYW1lKCksXG4gICAgICAgICAgaXNIb3Jpem9udGFsID0gX3RoaXMkZ2V0SG9yaXpvbnRhbEJvLmlzSG9yaXpvbnRhbCxcbiAgICAgICAgICBwbGFjZW1lbnROYW1lID0gX3RoaXMkZ2V0SG9yaXpvbnRhbEJvLnBsYWNlbWVudE5hbWU7XG5cbiAgICAgIHZhciBjb250ZW50VmFsdWUgPSBfdGhpcy5jb250ZW50RG9tID8gX3RoaXMuY29udGVudERvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtpc0hvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMDtcbiAgICAgIHZhciB2YWx1ZSA9IChpc0hvcml6b250YWwgPyB3aWR0aCA6IGhlaWdodCkgfHwgY29udGVudFZhbHVlO1xuXG4gICAgICBfdGhpcy5zZXRMZXZlbEFuZFNjcm9sbGluZyhvcGVuLCBwbGFjZW1lbnROYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLnNldExldmVsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG9wZW4sIHBsYWNlbWVudE5hbWUsIHZhbHVlLCByaWdodCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIHBsYWNlbWVudCA9IF90aGlzJHByb3BzMy5wbGFjZW1lbnQsXG4gICAgICAgICAgbGV2ZWxNb3ZlID0gX3RoaXMkcHJvcHMzLmxldmVsTW92ZSxcbiAgICAgICAgICBkdXJhdGlvbiA9IF90aGlzJHByb3BzMy5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlID0gX3RoaXMkcHJvcHMzLmVhc2UsXG4gICAgICAgICAgc2hvd01hc2sgPSBfdGhpcyRwcm9wczMuc2hvd01hc2s7IC8vIHJvdXRlciDliIfmjaLml7blj6/og73kvJrlr7zoh7PpobXpnaLlpLHljrvmu5rliqjmnaHvvIzmiYDku6XpnIDopoHml7bml7bojrflj5bjgIJcblxuICAgICAgX3RoaXMubGV2ZWxEb20uZm9yRWFjaChmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgIGRvbS5zdHlsZS50cmFuc2l0aW9uID0gXCJ0cmFuc2Zvcm0gXCIuY29uY2F0KGR1cmF0aW9uLCBcIiBcIikuY29uY2F0KGVhc2UpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGRvbSwgdHJhbnNpdGlvbkVuZCwgX3RoaXMudHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIHZhciBsZXZlbFZhbHVlID0gb3BlbiA/IHZhbHVlIDogMDtcblxuICAgICAgICBpZiAobGV2ZWxNb3ZlKSB7XG4gICAgICAgICAgdmFyICRsZXZlbE1vdmUgPSB0cmFuc2Zvcm1Bcmd1bWVudHMobGV2ZWxNb3ZlLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IGRvbSxcbiAgICAgICAgICAgIG9wZW46IG9wZW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXZlbFZhbHVlID0gb3BlbiA/ICRsZXZlbE1vdmVbMF0gOiAkbGV2ZWxNb3ZlWzFdIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgJHZhbHVlID0gdHlwZW9mIGxldmVsVmFsdWUgPT09ICdudW1iZXInID8gXCJcIi5jb25jYXQobGV2ZWxWYWx1ZSwgXCJweFwiKSA6IGxldmVsVmFsdWU7XG4gICAgICAgIHZhciBwbGFjZW1lbnRQb3MgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyB8fCBwbGFjZW1lbnQgPT09ICd0b3AnID8gJHZhbHVlIDogXCItXCIuY29uY2F0KCR2YWx1ZSk7XG4gICAgICAgIHBsYWNlbWVudFBvcyA9IHNob3dNYXNrICYmIHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiByaWdodCA/IFwiY2FsYyhcIi5jb25jYXQocGxhY2VtZW50UG9zLCBcIiArIFwiKS5jb25jYXQocmlnaHQsIFwicHgpXCIpIDogcGxhY2VtZW50UG9zO1xuICAgICAgICBkb20uc3R5bGUudHJhbnNmb3JtID0gbGV2ZWxWYWx1ZSA/IFwiXCIuY29uY2F0KHBsYWNlbWVudE5hbWUsIFwiKFwiKS5jb25jYXQocGxhY2VtZW50UG9zLCBcIilcIikgOiAnJztcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRMZXZlbEFuZFNjcm9sbGluZyA9IGZ1bmN0aW9uIChvcGVuLCBwbGFjZW1lbnROYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG9uQ2hhbmdlID0gX3RoaXMucHJvcHMub25DaGFuZ2U7XG5cbiAgICAgIGlmICghd2luZG93SXNVbmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCA/IGdldFNjcm9sbEJhclNpemUodHJ1ZSkgOiAwO1xuXG4gICAgICAgIF90aGlzLnNldExldmVsVHJhbnNmb3JtKG9wZW4sIHBsYWNlbWVudE5hbWUsIHZhbHVlLCByaWdodCk7XG5cbiAgICAgICAgX3RoaXMudG9nZ2xlU2Nyb2xsaW5nVG9EcmF3ZXJBbmRCb2R5KHJpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgIG9uQ2hhbmdlKG9wZW4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy50b2dnbGVTY3JvbGxpbmdUb0RyYXdlckFuZEJvZHkgPSBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBnZXRDb250YWluZXIgPSBfdGhpcyRwcm9wczQuZ2V0Q29udGFpbmVyLFxuICAgICAgICAgIHNob3dNYXNrID0gX3RoaXMkcHJvcHM0LnNob3dNYXNrLFxuICAgICAgICAgIG9wZW4gPSBfdGhpcyRwcm9wczQub3BlbjtcbiAgICAgIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIgJiYgZ2V0Q29udGFpbmVyKCk7IC8vIOWkhOeQhiBib2R5IOa7muWKqFxuXG4gICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5wYXJlbnROb2RlID09PSBkb2N1bWVudC5ib2R5ICYmIHNob3dNYXNrKSB7XG4gICAgICAgIHZhciBldmVudEFycmF5ID0gWyd0b3VjaHN0YXJ0J107XG4gICAgICAgIHZhciBkb21BcnJheSA9IFtkb2N1bWVudC5ib2R5LCBfdGhpcy5tYXNrRG9tLCBfdGhpcy5oYW5kbGVyRG9tLCBfdGhpcy5jb250ZW50RG9tXTtcblxuICAgICAgICBpZiAob3BlbiAmJiBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgX3RoaXMuYWRkU2Nyb2xsaW5nRWZmZWN0KHJpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnOyAvLyDmiYvmnLrnpoHmu5pcblxuICAgICAgICAgIGRvbUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoaXRlbSwgZXZlbnRBcnJheVtpXSB8fCAndG91Y2htb3ZlJywgaSA/IF90aGlzLnJlbW92ZU1vdmVIYW5kbGVyIDogX3RoaXMucmVtb3ZlU3RhcnRIYW5kbGVyLCBfdGhpcy5wYXNzaXZlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5nZXRDdXJyZW50RHJhd2VyU29tZSgpKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3VjaEFjdGlvbiA9ICcnO1xuXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1TY3JvbGxpbmdFZmZlY3QocmlnaHQpO1xuICAgICAgICAgIH0gLy8g5oGi5aSN5LqL5Lu2XG5cblxuICAgICAgICAgIGRvbUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbSwgZXZlbnRBcnJheVtpXSB8fCAndG91Y2htb3ZlJywgaSA/IF90aGlzLnJlbW92ZU1vdmVIYW5kbGVyIDogX3RoaXMucmVtb3ZlU3RhcnRIYW5kbGVyLCBfdGhpcy5wYXNzaXZlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5hZGRTY3JvbGxpbmdFZmZlY3QgPSBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBwbGFjZW1lbnQgPSBfdGhpcyRwcm9wczUucGxhY2VtZW50LFxuICAgICAgICAgIGR1cmF0aW9uID0gX3RoaXMkcHJvcHM1LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2UgPSBfdGhpcyRwcm9wczUuZWFzZTtcbiAgICAgIHZhciB3aWR0aFRyYW5zaXRpb24gPSBcIndpZHRoIFwiLmNvbmNhdChkdXJhdGlvbiwgXCIgXCIpLmNvbmNhdChlYXNlKTtcbiAgICAgIHZhciB0cmFuc2Zvcm1UcmFuc2l0aW9uID0gXCJ0cmFuc2Zvcm0gXCIuY29uY2F0KGR1cmF0aW9uLCBcIiBcIikuY29uY2F0KGVhc2UpO1xuICAgICAgX3RoaXMuZG9tLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG5cbiAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBfdGhpcy5kb20uc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVYKC1cIi5jb25jYXQocmlnaHQsIFwicHgpXCIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgX3RoaXMuZG9tLnN0eWxlLndpZHRoID0gXCJjYWxjKDEwMCUgLSBcIi5jb25jYXQocmlnaHQsIFwicHgpXCIpO1xuICAgICAgICAgIF90aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuZG9tKSB7XG4gICAgICAgICAgX3RoaXMuZG9tLnN0eWxlLnRyYW5zaXRpb24gPSBcIlwiLmNvbmNhdCh0cmFuc2Zvcm1UcmFuc2l0aW9uLCBcIixcIikuY29uY2F0KHdpZHRoVHJhbnNpdGlvbik7XG4gICAgICAgICAgX3RoaXMuZG9tLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgICAgX3RoaXMuZG9tLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVtU2Nyb2xsaW5nRWZmZWN0ID0gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgcGxhY2VtZW50ID0gX3RoaXMkcHJvcHM2LnBsYWNlbWVudCxcbiAgICAgICAgICBkdXJhdGlvbiA9IF90aGlzJHByb3BzNi5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlID0gX3RoaXMkcHJvcHM2LmVhc2U7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uU3RyKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3dYID0gJ2hpZGRlbic7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRvbS5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgICAgdmFyIGhlaWdodFRyYW5zaXRpb247XG4gICAgICB2YXIgd2lkdGhUcmFuc2l0aW9uID0gXCJ3aWR0aCBcIi5jb25jYXQoZHVyYXRpb24sIFwiIFwiKS5jb25jYXQoZWFzZSk7XG4gICAgICB2YXIgdHJhbnNmb3JtVHJhbnNpdGlvbiA9IFwidHJhbnNmb3JtIFwiLmNvbmNhdChkdXJhdGlvbiwgXCIgXCIpLmNvbmNhdChlYXNlKTtcblxuICAgICAgc3dpdGNoIChwbGFjZW1lbnQpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuZG9tLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgd2lkdGhUcmFuc2l0aW9uID0gXCJ3aWR0aCAwcyBcIi5jb25jYXQoZWFzZSwgXCIgXCIpLmNvbmNhdChkdXJhdGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHJpZ2h0LCBcInB4KVwiKTtcbiAgICAgICAgICAgIF90aGlzLmRvbS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHdpZHRoVHJhbnNpdGlvbiA9IFwid2lkdGggMHMgXCIuY29uY2F0KGVhc2UsIFwiIFwiKS5jb25jYXQoZHVyYXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMubWFza0RvbSkge1xuICAgICAgICAgICAgICBfdGhpcy5tYXNrRG9tLnN0eWxlLmxlZnQgPSBcIi1cIi5jb25jYXQocmlnaHQsIFwicHhcIik7XG4gICAgICAgICAgICAgIF90aGlzLm1hc2tEb20uc3R5bGUud2lkdGggPSBcImNhbGMoMTAwJSArIFwiLmNvbmNhdChyaWdodCwgXCJweClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmRvbS5zdHlsZS53aWR0aCA9IFwiY2FsYygxMDAlICsgXCIuY29uY2F0KHJpZ2h0LCBcInB4KVwiKTtcbiAgICAgICAgICAgIF90aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICBfdGhpcy5kb20uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICAgICAgaGVpZ2h0VHJhbnNpdGlvbiA9IFwiaGVpZ2h0IDBzIFwiLmNvbmNhdChlYXNlLCBcIiBcIikuY29uY2F0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5kb20pIHtcbiAgICAgICAgICBfdGhpcy5kb20uc3R5bGUudHJhbnNpdGlvbiA9IFwiXCIuY29uY2F0KHRyYW5zZm9ybVRyYW5zaXRpb24sIFwiLFwiKS5jb25jYXQoaGVpZ2h0VHJhbnNpdGlvbiA/IFwiXCIuY29uY2F0KGhlaWdodFRyYW5zaXRpb24sIFwiLFwiKSA6ICcnKS5jb25jYXQod2lkdGhUcmFuc2l0aW9uKTtcbiAgICAgICAgICBfdGhpcy5kb20uc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgICAgICAgX3RoaXMuZG9tLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgICAgX3RoaXMuZG9tLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Q3VycmVudERyYXdlclNvbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIU9iamVjdC5rZXlzKGN1cnJlbnREcmF3ZXIpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY3VycmVudERyYXdlcltrZXldO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmdldExldmVsRG9tID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBsZXZlbCA9IF9yZWYubGV2ZWwsXG4gICAgICAgICAgZ2V0Q29udGFpbmVyID0gX3JlZi5nZXRDb250YWluZXI7XG5cbiAgICAgIGlmICh3aW5kb3dJc1VuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIgJiYgZ2V0Q29udGFpbmVyKCk7XG4gICAgICB2YXIgcGFyZW50ID0gY29udGFpbmVyID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBudWxsO1xuICAgICAgX3RoaXMubGV2ZWxEb20gPSBbXTtcblxuICAgICAgaWYgKGxldmVsID09PSAnYWxsJykge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXJlbnQuY2hpbGRyZW4pIDogW107XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLm5vZGVOYW1lICE9PSAnU0NSSVBUJyAmJiBjaGlsZC5ub2RlTmFtZSAhPT0gJ1NUWUxFJyAmJiBjaGlsZC5ub2RlTmFtZSAhPT0gJ0xJTksnICYmIGNoaWxkICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIF90aGlzLmxldmVsRG9tLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGxldmVsKSB7XG4gICAgICAgIGRhdGFUb0FycmF5KGxldmVsKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGtleSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgX3RoaXMubGV2ZWxEb20ucHVzaChpdGVtKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldEhvcml6b250YWxCb29sQW5kUGxhY2VtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwbGFjZW1lbnQgPSBfdGhpcy5wcm9wcy5wbGFjZW1lbnQ7XG4gICAgICB2YXIgaXNIb3Jpem9udGFsID0gcGxhY2VtZW50ID09PSAnbGVmdCcgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnO1xuICAgICAgdmFyIHBsYWNlbWVudE5hbWUgPSBcInRyYW5zbGF0ZVwiLmNvbmNhdChpc0hvcml6b250YWwgPyAnWCcgOiAnWScpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNIb3Jpem9udGFsOiBpc0hvcml6b250YWwsXG4gICAgICAgIHBsYWNlbWVudE5hbWU6IHBsYWNlbWVudE5hbWVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgX3NlbGY6IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJhd2VyQ2hpbGQsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghd2luZG93SXNVbmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgdGhpcy5wYXNzaXZlID0gcGFzc2l2ZVN1cHBvcnRlZCA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczcgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIG9wZW4gPSBfdGhpcyRwcm9wczcub3BlbixcbiAgICAgICAgICBnZXRDb250YWluZXIgPSBfdGhpcyRwcm9wczcuZ2V0Q29udGFpbmVyLFxuICAgICAgICAgIHNob3dNYXNrID0gX3RoaXMkcHJvcHM3LnNob3dNYXNrLFxuICAgICAgICAgIGF1dG9Gb2N1cyA9IF90aGlzJHByb3BzNy5hdXRvRm9jdXM7XG4gICAgICB2YXIgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyICYmIGdldENvbnRhaW5lcigpO1xuICAgICAgdGhpcy5kcmF3ZXJJZCA9IFwiZHJhd2VyX2lkX1wiLmNvbmNhdChOdW1iZXIoKERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpLnJlcGxhY2UoJy4nLCBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiA5KS50b1N0cmluZygpKSkudG9TdHJpbmcoMTYpKTtcbiAgICAgIHRoaXMuZ2V0TGV2ZWxEb20odGhpcy5wcm9wcyk7XG5cbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICBjdXJyZW50RHJhd2VyW3RoaXMuZHJhd2VySWRdID0gb3BlbjtcbiAgICAgICAgfSAvLyDpu5jorqTmiZPlvIDnirbmgIHml7bmjqjlh7ogbGV2ZWw7XG5cblxuICAgICAgICB0aGlzLm9wZW5MZXZlbFRyYW5zaXRpb24oKTtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgICAgICAgX3RoaXMyLmRvbUZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2hvd01hc2spIHtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMkc2Nyb2xsTG9jO1xuXG4gICAgICAgICAgKF90aGlzJHByb3BzJHNjcm9sbExvYyA9IHRoaXMucHJvcHMuc2Nyb2xsTG9ja2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRzY3JvbGxMb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJHNjcm9sbExvYy5sb2NrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczggPSB0aGlzLnByb3BzLFxuICAgICAgICAgIG9wZW4gPSBfdGhpcyRwcm9wczgub3BlbixcbiAgICAgICAgICBnZXRDb250YWluZXIgPSBfdGhpcyRwcm9wczguZ2V0Q29udGFpbmVyLFxuICAgICAgICAgIHNjcm9sbExvY2tlciA9IF90aGlzJHByb3BzOC5zY3JvbGxMb2NrZXIsXG4gICAgICAgICAgc2hvd01hc2sgPSBfdGhpcyRwcm9wczguc2hvd01hc2ssXG4gICAgICAgICAgYXV0b0ZvY3VzID0gX3RoaXMkcHJvcHM4LmF1dG9Gb2N1cztcbiAgICAgIHZhciBjb250YWluZXIgPSBnZXRDb250YWluZXIgJiYgZ2V0Q29udGFpbmVyKCk7XG5cbiAgICAgIGlmIChvcGVuICE9PSBwcmV2UHJvcHMub3Blbikge1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5wYXJlbnROb2RlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgY3VycmVudERyYXdlclt0aGlzLmRyYXdlcklkXSA9ICEhb3BlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3BlbkxldmVsVHJhbnNpdGlvbigpO1xuXG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgICAgICAgdGhpcy5kb21Gb2N1cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG93TWFzaykge1xuICAgICAgICAgICAgc2Nyb2xsTG9ja2VyID09PSBudWxsIHx8IHNjcm9sbExvY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Nyb2xsTG9ja2VyLmxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsTG9ja2VyID09PSBudWxsIHx8IHNjcm9sbExvY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Nyb2xsTG9ja2VyLnVuTG9jaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzOSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb3BlbiA9IF90aGlzJHByb3BzOS5vcGVuLFxuICAgICAgICAgIHNjcm9sbExvY2tlciA9IF90aGlzJHByb3BzOS5zY3JvbGxMb2NrZXI7XG4gICAgICBkZWxldGUgY3VycmVudERyYXdlclt0aGlzLmRyYXdlcklkXTtcblxuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgdGhpcy5zZXRMZXZlbFRyYW5zZm9ybShmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudG91Y2hBY3Rpb24gPSAnJztcbiAgICAgIH1cblxuICAgICAgc2Nyb2xsTG9ja2VyID09PSBudWxsIHx8IHNjcm9sbExvY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Nyb2xsTG9ja2VyLnVuTG9jaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1lbWJlci1vcmRlcmluZ1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfY2xhc3NuYW1lcyxcbiAgICAgICAgICBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMxMCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMxMC5jbGFzc05hbWUsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczEwLmNoaWxkcmVuLFxuICAgICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHMxMC5zdHlsZSxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzMTAud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMxMC5oZWlnaHQsXG4gICAgICAgICAgZGVmYXVsdE9wZW4gPSBfdGhpcyRwcm9wczEwLmRlZmF1bHRPcGVuLFxuICAgICAgICAgICRvcGVuID0gX3RoaXMkcHJvcHMxMC5vcGVuLFxuICAgICAgICAgIHByZWZpeENscyA9IF90aGlzJHByb3BzMTAucHJlZml4Q2xzLFxuICAgICAgICAgIHBsYWNlbWVudCA9IF90aGlzJHByb3BzMTAucGxhY2VtZW50LFxuICAgICAgICAgIGxldmVsID0gX3RoaXMkcHJvcHMxMC5sZXZlbCxcbiAgICAgICAgICBsZXZlbE1vdmUgPSBfdGhpcyRwcm9wczEwLmxldmVsTW92ZSxcbiAgICAgICAgICBlYXNlID0gX3RoaXMkcHJvcHMxMC5lYXNlLFxuICAgICAgICAgIGR1cmF0aW9uID0gX3RoaXMkcHJvcHMxMC5kdXJhdGlvbixcbiAgICAgICAgICBnZXRDb250YWluZXIgPSBfdGhpcyRwcm9wczEwLmdldENvbnRhaW5lcixcbiAgICAgICAgICBoYW5kbGVyID0gX3RoaXMkcHJvcHMxMC5oYW5kbGVyLFxuICAgICAgICAgIG9uQ2hhbmdlID0gX3RoaXMkcHJvcHMxMC5vbkNoYW5nZSxcbiAgICAgICAgICBhZnRlclZpc2libGVDaGFuZ2UgPSBfdGhpcyRwcm9wczEwLmFmdGVyVmlzaWJsZUNoYW5nZSxcbiAgICAgICAgICBzaG93TWFzayA9IF90aGlzJHByb3BzMTAuc2hvd01hc2ssXG4gICAgICAgICAgbWFza0Nsb3NhYmxlID0gX3RoaXMkcHJvcHMxMC5tYXNrQ2xvc2FibGUsXG4gICAgICAgICAgbWFza1N0eWxlID0gX3RoaXMkcHJvcHMxMC5tYXNrU3R5bGUsXG4gICAgICAgICAgb25DbG9zZSA9IF90aGlzJHByb3BzMTAub25DbG9zZSxcbiAgICAgICAgICBvbkhhbmRsZUNsaWNrID0gX3RoaXMkcHJvcHMxMC5vbkhhbmRsZUNsaWNrLFxuICAgICAgICAgIGtleWJvYXJkID0gX3RoaXMkcHJvcHMxMC5rZXlib2FyZCxcbiAgICAgICAgICBnZXRPcGVuQ291bnQgPSBfdGhpcyRwcm9wczEwLmdldE9wZW5Db3VudCxcbiAgICAgICAgICBzY3JvbGxMb2NrZXIgPSBfdGhpcyRwcm9wczEwLnNjcm9sbExvY2tlcixcbiAgICAgICAgICBjb250ZW50V3JhcHBlclN0eWxlID0gX3RoaXMkcHJvcHMxMC5jb250ZW50V3JhcHBlclN0eWxlLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMTAsIF9leGNsdWRlZCk7IC8vIOmmluasoea4suafk+mDveWwhuaYr+WFs+mXreeKtuaAgeOAglxuXG5cbiAgICAgIHZhciBvcGVuID0gdGhpcy5kb20gPyAkb3BlbiA6IGZhbHNlO1xuICAgICAgdmFyIHdyYXBwZXJDbGFzc05hbWUgPSBjbGFzc25hbWVzKHByZWZpeENscywgKF9jbGFzc25hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1cIikuY29uY2F0KHBsYWNlbWVudCksIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzbmFtZXMsIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItb3BlblwiKSwgb3BlbiksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgY2xhc3NOYW1lIHx8ICcnLCAhIWNsYXNzTmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NuYW1lcywgJ25vLW1hc2snLCAhc2hvd01hc2spLCBfY2xhc3NuYW1lcykpO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0SG9yaXpvbnRhbEJvMiA9IHRoaXMuZ2V0SG9yaXpvbnRhbEJvb2xBbmRQbGFjZW1lbnROYW1lKCksXG4gICAgICAgICAgcGxhY2VtZW50TmFtZSA9IF90aGlzJGdldEhvcml6b250YWxCbzIucGxhY2VtZW50TmFtZTsgLy8g55m+5YiG5q+U5LiO5YOP57Sg5Yqo55S75LiN5ZCM5q2l77yM56ys5LiA5qyh5omT55So5ZCO5YWo55So5YOP57Sg5Yqo55S744CCXG4gICAgICAvLyBjb25zdCBkZWZhdWx0VmFsdWUgPSAhdGhpcy5jb250ZW50RG9tIHx8ICFsZXZlbCA/ICcxMDAlJyA6IGAke3ZhbHVlfXB4YDtcblxuXG4gICAgICB2YXIgcGxhY2VtZW50UG9zID0gcGxhY2VtZW50ID09PSAnbGVmdCcgfHwgcGxhY2VtZW50ID09PSAndG9wJyA/ICctMTAwJScgOiAnMTAwJSc7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gb3BlbiA/ICcnIDogXCJcIi5jb25jYXQocGxhY2VtZW50TmFtZSwgXCIoXCIpLmNvbmNhdChwbGFjZW1lbnRQb3MsIFwiKVwiKTtcbiAgICAgIHZhciBoYW5kbGVyQ2hpbGRyZW4gPSBoYW5kbGVyICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoaGFuZGxlciwge1xuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlci5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgICAgICBoYW5kbGVyLnByb3BzLm9uQ2xpY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25IYW5kbGVDbGljaykge1xuICAgICAgICAgICAgb25IYW5kbGVDbGljayhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGMpIHtcbiAgICAgICAgICBfdGhpczMuaGFuZGxlckRvbSA9IGM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBvbWl0KHByb3BzLCBbJ3N3aXRjaFNjcm9sbGluZ0VmZmVjdCddKSwge1xuICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgIGNsYXNzTmFtZTogd3JhcHBlckNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihjKSB7XG4gICAgICAgICAgX3RoaXMzLmRvbSA9IGM7XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bjogb3BlbiAmJiBrZXlib2FyZCA/IHRoaXMub25LZXlEb3duIDogdW5kZWZpbmVkLFxuICAgICAgICBvblRyYW5zaXRpb25FbmQ6IHRoaXMub25XcmFwcGVyVHJhbnNpdGlvbkVuZFxuICAgICAgfSksIHNob3dNYXNrICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChwcmVmaXhDbHMsIFwiLW1hc2tcIiksXG4gICAgICAgIG9uQ2xpY2s6IG1hc2tDbG9zYWJsZSA/IG9uQ2xvc2UgOiB1bmRlZmluZWQsXG4gICAgICAgIHN0eWxlOiBtYXNrU3R5bGUsXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGMpIHtcbiAgICAgICAgICBfdGhpczMubWFza0RvbSA9IGM7XG4gICAgICAgIH1cbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1jb250ZW50LXdyYXBwZXJcIiksXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICBtc1RyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgIHdpZHRoOiBpc051bWVyaWMod2lkdGgpID8gXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikgOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGlzTnVtZXJpYyhoZWlnaHQpID8gXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpIDogaGVpZ2h0XG4gICAgICAgIH0sIGNvbnRlbnRXcmFwcGVyU3R5bGUpLFxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihjKSB7XG4gICAgICAgICAgX3RoaXMzLmNvbnRlbnRXcmFwcGVyID0gYztcbiAgICAgICAgfVxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItY29udGVudFwiKSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoYykge1xuICAgICAgICAgIF90aGlzMy5jb250ZW50RG9tID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiBvcGVuICYmIHNob3dNYXNrID8gdGhpcy5yZW1vdmVTdGFydEhhbmRsZXIgOiB1bmRlZmluZWQgLy8g6LeR55So5L6L55SoXG4gICAgICAgICxcbiAgICAgICAgb25Ub3VjaE1vdmU6IG9wZW4gJiYgc2hvd01hc2sgPyB0aGlzLnJlbW92ZU1vdmVIYW5kbGVyIDogdW5kZWZpbmVkIC8vIOi3keeUqOS+i+eUqFxuXG4gICAgICB9LCBjaGlsZHJlbiksIGhhbmRsZXJDaGlsZHJlbikpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgICB2YXIgcHJldlByb3BzID0gX3JlZjIucHJldlByb3BzLFxuICAgICAgICAgIF9zZWxmID0gX3JlZjIuX3NlbGY7XG4gICAgICB2YXIgbmV4dFN0YXRlID0ge1xuICAgICAgICBwcmV2UHJvcHM6IHByb3BzXG4gICAgICB9O1xuXG4gICAgICBpZiAocHJldlByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IHByb3BzLnBsYWNlbWVudCxcbiAgICAgICAgICAgIGxldmVsID0gcHJvcHMubGV2ZWw7XG5cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcHJldlByb3BzLnBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIHRlc3Qg55qEIGJ1Zywg5pyJ5Yqo55S76L+H5Zy677yM5Yig6ZmkIGRvbVxuICAgICAgICAgIF9zZWxmLmNvbnRlbnREb20gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldmVsICE9PSBwcmV2UHJvcHMubGV2ZWwpIHtcbiAgICAgICAgICBfc2VsZi5nZXRMZXZlbERvbShwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJhd2VyQ2hpbGQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IERyYXdlckNoaWxkOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfY3JlYXRlU3VwZXIgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZVN1cGVyXCI7XG52YXIgX2V4Y2x1ZGVkID0gW1wiZGVmYXVsdE9wZW5cIiwgXCJnZXRDb250YWluZXJcIiwgXCJ3cmFwcGVyQ2xhc3NOYW1lXCIsIFwiZm9yY2VSZW5kZXJcIiwgXCJoYW5kbGVyXCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJ2aXNpYmxlXCIsIFwiYWZ0ZXJDbG9zZVwiXTtcbmltcG9ydCBQb3J0YWwgZnJvbSBcInJjLXV0aWwvZXMvUG9ydGFsV3JhcHBlclwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IENoaWxkIGZyb20gJy4vRHJhd2VyQ2hpbGQnO1xuXG52YXIgRHJhd2VyV3JhcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRHJhd2VyV3JhcHBlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEcmF3ZXJXcmFwcGVyKTtcblxuICBmdW5jdGlvbiBEcmF3ZXJXcmFwcGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYXdlcldyYXBwZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgX3RoaXMuZG9tID0gdm9pZCAwO1xuXG4gICAgX3RoaXMub25IYW5kbGVDbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBvbkhhbmRsZUNsaWNrID0gX3RoaXMkcHJvcHMub25IYW5kbGVDbGljayxcbiAgICAgICAgICAkb3BlbiA9IF90aGlzJHByb3BzLm9wZW47XG5cbiAgICAgIGlmIChvbkhhbmRsZUNsaWNrKSB7XG4gICAgICAgIG9uSGFuZGxlQ2xpY2soZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgJG9wZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBvcGVuID0gX3RoaXMuc3RhdGUub3BlbjtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgb3BlbjogIW9wZW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG9uQ2xvc2UgPSBfdGhpcyRwcm9wczIub25DbG9zZSxcbiAgICAgICAgICBvcGVuID0gX3RoaXMkcHJvcHMyLm9wZW47XG5cbiAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgIG9uQ2xvc2UoZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3BlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIG9wZW46IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX29wZW4gPSB0eXBlb2YgcHJvcHMub3BlbiAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5vcGVuIDogISFwcm9wcy5kZWZhdWx0T3BlbjtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgb3BlbjogX29wZW5cbiAgICB9O1xuXG4gICAgaWYgKCdvbk1hc2tDbGljaycgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnNvbGUud2FybignYG9uTWFza0NsaWNrYCBhcmUgcmVtb3ZlZCwgcGxlYXNlIHVzZSBgb25DbG9zZWAgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJhd2VyV3JhcHBlciwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptZW1iZXItb3JkZXJpbmdcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGVmYXVsdE9wZW4gPSBfdGhpcyRwcm9wczMuZGVmYXVsdE9wZW4sXG4gICAgICAgICAgZ2V0Q29udGFpbmVyID0gX3RoaXMkcHJvcHMzLmdldENvbnRhaW5lcixcbiAgICAgICAgICB3cmFwcGVyQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMzLndyYXBwZXJDbGFzc05hbWUsXG4gICAgICAgICAgZm9yY2VSZW5kZXIgPSBfdGhpcyRwcm9wczMuZm9yY2VSZW5kZXIsXG4gICAgICAgICAgaGFuZGxlciA9IF90aGlzJHByb3BzMy5oYW5kbGVyLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzMywgX2V4Y2x1ZGVkKTtcblxuICAgICAgdmFyIG9wZW4gPSB0aGlzLnN0YXRlLm9wZW47IC8vIOa4suafk+WcqOW9k+WJjSBkb20g6YeM77ybXG5cbiAgICAgIGlmICghZ2V0Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiB3cmFwcGVyQ2xhc3NOYW1lLFxuICAgICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGMpIHtcbiAgICAgICAgICAgIF90aGlzMi5kb20gPSBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpbGQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICBnZXRDb250YWluZXI6IGZ1bmN0aW9uIGdldENvbnRhaW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuZG9tO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25DbG9zZTogdGhpcy5vbkNsb3NlLFxuICAgICAgICAgIG9uSGFuZGxlQ2xpY2s6IHRoaXMub25IYW5kbGVDbGlja1xuICAgICAgICB9KSkpO1xuICAgICAgfSAvLyDlpoLmnpzmnIkgaGFuZGxlciDkuLrlhoXnva7lvLrliLbmuLLmn5PvvJtcblxuXG4gICAgICB2YXIgJGZvcmNlUmVuZGVyID0gISFoYW5kbGVyIHx8IGZvcmNlUmVuZGVyO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwge1xuICAgICAgICB2aXNpYmxlOiBvcGVuLFxuICAgICAgICBmb3JjZVJlbmRlcjogJGZvcmNlUmVuZGVyLFxuICAgICAgICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgICAgICAgd3JhcHBlckNsYXNzTmFtZTogd3JhcHBlckNsYXNzTmFtZVxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHZpc2libGUgPSBfcmVmLnZpc2libGUsXG4gICAgICAgICAgICBhZnRlckNsb3NlID0gX3JlZi5hZnRlckNsb3NlLFxuICAgICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQyKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAvLyByZWFjdCAxNe+8jGNvbXBvbmVudFdpbGxVbm1vdW50IOaXtiBQb3J0YWwg6L+U5ZueIGFmdGVyQ2xvc2UsIHZpc2libGUuXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDaGlsZCwgX2V4dGVuZHMoe30sIHByb3BzLCByZXN0LCB7XG4gICAgICAgICAgICBvcGVuOiB2aXNpYmxlICE9PSB1bmRlZmluZWQgPyB2aXNpYmxlIDogb3BlbixcbiAgICAgICAgICAgIGFmdGVyVmlzaWJsZUNoYW5nZTogYWZ0ZXJDbG9zZSAhPT0gdW5kZWZpbmVkID8gYWZ0ZXJDbG9zZSA6IHByb3BzLmFmdGVyVmlzaWJsZUNoYW5nZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBvbkNsb3NlOiBfdGhpczIub25DbG9zZSxcbiAgICAgICAgICAgIG9uSGFuZGxlQ2xpY2s6IF90aGlzMi5vbkhhbmRsZUNsaWNrXG4gICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBfcmVmMikge1xuICAgICAgdmFyIHByZXZQcm9wcyA9IF9yZWYyLnByZXZQcm9wcztcbiAgICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgICAgcHJldlByb3BzOiBwcm9wc1xuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiBwcmV2UHJvcHMgIT09ICd1bmRlZmluZWQnICYmIHByb3BzLm9wZW4gIT09IHByZXZQcm9wcy5vcGVuKSB7XG4gICAgICAgIG5ld1N0YXRlLm9wZW4gPSBwcm9wcy5vcGVuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERyYXdlcldyYXBwZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkRyYXdlcldyYXBwZXIuZGVmYXVsdFByb3BzID0ge1xuICBwcmVmaXhDbHM6ICdkcmF3ZXInLFxuICBwbGFjZW1lbnQ6ICdsZWZ0JyxcbiAgZ2V0Q29udGFpbmVyOiAnYm9keScsXG4gIGRlZmF1bHRPcGVuOiBmYWxzZSxcbiAgbGV2ZWw6ICdhbGwnLFxuICBkdXJhdGlvbjogJy4zcycsXG4gIGVhc2U6ICdjdWJpYy1iZXppZXIoMC43OCwgMC4xNCwgMC4xNSwgMC44NiknLFxuICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7fSxcbiAgYWZ0ZXJWaXNpYmxlQ2hhbmdlOiBmdW5jdGlvbiBhZnRlclZpc2libGVDaGFuZ2UoKSB7fSxcbiAgaGFuZGxlcjogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJkcmF3ZXItaGFuZGxlXCJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpXCIsIHtcbiAgICBjbGFzc05hbWU6IFwiZHJhd2VyLWhhbmRsZS1pY29uXCJcbiAgfSkpLFxuICBzaG93TWFzazogdHJ1ZSxcbiAgbWFza0Nsb3NhYmxlOiB0cnVlLFxuICBtYXNrU3R5bGU6IHt9LFxuICB3cmFwcGVyQ2xhc3NOYW1lOiAnJyxcbiAgY2xhc3NOYW1lOiAnJyxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIGZvcmNlUmVuZGVyOiBmYWxzZSxcbiAgYXV0b0ZvY3VzOiB0cnVlXG59O1xuZXhwb3J0IGRlZmF1bHQgRHJhd2VyV3JhcHBlcjsiLCIvLyBleHBvcnQgdGhpcyBwYWNrYWdlJ3MgYXBpXG5pbXBvcnQgRHJhd2VyIGZyb20gJy4vRHJhd2VyV3JhcHBlcic7XG5leHBvcnQgZGVmYXVsdCBEcmF3ZXI7IiwiZXhwb3J0IGZ1bmN0aW9uIGRhdGFUb0FycmF5KHZhcnMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFycykpIHtcbiAgICByZXR1cm4gdmFycztcbiAgfVxuXG4gIHJldHVybiBbdmFyc107XG59XG52YXIgdHJhbnNpdGlvbkVuZE9iamVjdCA9IHtcbiAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gIE1velRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCdcbn07XG5leHBvcnQgdmFyIHRyYW5zaXRpb25TdHIgPSBPYmplY3Qua2V5cyh0cmFuc2l0aW9uRW5kT2JqZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBodG1sID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2h0bWwnKVswXTtcbiAgcmV0dXJuIGtleSBpbiAoaHRtbCA/IGh0bWwuc3R5bGUgOiB7fSk7XG59KVswXTtcbmV4cG9ydCB2YXIgdHJhbnNpdGlvbkVuZCA9IHRyYW5zaXRpb25FbmRPYmplY3RbdHJhbnNpdGlvblN0cl07XG5leHBvcnQgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgIHRhcmdldC5hdHRhY2hFdmVudChcIm9uXCIuY29uY2F0KGV2ZW50VHlwZSksIGNhbGxiYWNrKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgaWYgKHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgIHRhcmdldC5kZXRhY2hFdmVudChcIm9uXCIuY29uY2F0KGV2ZW50VHlwZSksIGNhbGxiYWNrKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQXJndW1lbnRzKGFyZywgY2IpIHtcbiAgdmFyIHJlc3VsdCA9IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBhcmcoY2IpIDogYXJnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Jlc3VsdFswXSwgcmVzdWx0WzFdXTtcbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0XTtcbn1cbmV4cG9ydCB2YXIgaXNOdW1lcmljID0gZnVuY3Rpb24gaXNOdW1lcmljKHZhbHVlKSB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpICYmIGlzRmluaXRlKHZhbHVlKTtcbn07XG5leHBvcnQgdmFyIHdpbmRvd0lzVW5kZWZpbmVkID0gISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuZXhwb3J0IHZhciBnZXRUb3VjaFBhcmVudFNjcm9sbCA9IGZ1bmN0aW9uIGdldFRvdWNoUGFyZW50U2Nyb2xsKHJvb3QsIGN1cnJlbnRUYXJnZXQsIGRpZmZlclgsIGRpZmZlclkpIHtcbiAgaWYgKCFjdXJyZW50VGFyZ2V0IHx8IGN1cnJlbnRUYXJnZXQgPT09IGRvY3VtZW50IHx8IGN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyByb290IOS4uiBkcmF3ZXItY29udGVudCDorr7lrprkuoYgb3ZlcmZsb3csIOWIpOaWreS4uiByb290IOeahCBwYXJlbnQg5pe257uT5p2f5rua5Yqo77ybXG5cblxuICBpZiAoY3VycmVudFRhcmdldCA9PT0gcm9vdC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaXNZID0gTWF0aC5tYXgoTWF0aC5hYnMoZGlmZmVyWCksIE1hdGguYWJzKGRpZmZlclkpKSA9PT0gTWF0aC5hYnMoZGlmZmVyWSk7XG4gIHZhciBpc1ggPSBNYXRoLm1heChNYXRoLmFicyhkaWZmZXJYKSwgTWF0aC5hYnMoZGlmZmVyWSkpID09PSBNYXRoLmFicyhkaWZmZXJYKTtcbiAgdmFyIHNjcm9sbFkgPSBjdXJyZW50VGFyZ2V0LnNjcm9sbEhlaWdodCAtIGN1cnJlbnRUYXJnZXQuY2xpZW50SGVpZ2h0O1xuICB2YXIgc2Nyb2xsWCA9IGN1cnJlbnRUYXJnZXQuc2Nyb2xsV2lkdGggLSBjdXJyZW50VGFyZ2V0LmNsaWVudFdpZHRoO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRUYXJnZXQpO1xuICB2YXIgb3ZlcmZsb3dZID0gc3R5bGUub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgc3R5bGUub3ZlcmZsb3dZID09PSAnc2Nyb2xsJztcbiAgdmFyIG92ZXJmbG93WCA9IHN0eWxlLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IHN0eWxlLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCc7XG4gIHZhciB5ID0gc2Nyb2xsWSAmJiBvdmVyZmxvd1k7XG4gIHZhciB4ID0gc2Nyb2xsWCAmJiBvdmVyZmxvd1g7XG5cbiAgaWYgKGlzWSAmJiAoIXkgfHwgeSAmJiAoY3VycmVudFRhcmdldC5zY3JvbGxUb3AgPj0gc2Nyb2xsWSAmJiBkaWZmZXJZIDwgMCB8fCBjdXJyZW50VGFyZ2V0LnNjcm9sbFRvcCA8PSAwICYmIGRpZmZlclkgPiAwKSkgfHwgaXNYICYmICgheCB8fCB4ICYmIChjdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQgPj0gc2Nyb2xsWCAmJiBkaWZmZXJYIDwgMCB8fCBjdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQgPD0gMCAmJiBkaWZmZXJYID4gMCkpKSB7XG4gICAgcmV0dXJuIGdldFRvdWNoUGFyZW50U2Nyb2xsKHJvb3QsIGN1cnJlbnRUYXJnZXQucGFyZW50Tm9kZSwgZGlmZmVyWCwgZGlmZmVyWSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhblVzZURvbSgpIHtcbiAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG59IiwiaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgZ2V0U2Nyb2xsQmFyU2l6ZSBmcm9tICcuLi9nZXRTY3JvbGxCYXJTaXplJztcbmltcG9ydCBzZXRTdHlsZSBmcm9tICcuLi9zZXRTdHlsZSc7XG52YXIgbG9ja3MgPSBbXTtcbnZhciBzY3JvbGxpbmdFZmZlY3RDbGFzc05hbWUgPSAnYW50LXNjcm9sbGluZy1lZmZlY3QnO1xudmFyIHNjcm9sbGluZ0VmZmVjdENsYXNzTmFtZVJlZyA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoc2Nyb2xsaW5nRWZmZWN0Q2xhc3NOYW1lKSwgJ2cnKTtcbnZhciB1dWlkID0gMDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi9pc3N1ZXMvMTkzNDBcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24vaXNzdWVzLzE5MzMyXG5cbnZhciBjYWNoZVN0eWxlID0gbmV3IE1hcCgpO1xuXG52YXIgU2Nyb2xsTG9ja2VyID0gZnVuY3Rpb24gU2Nyb2xsTG9ja2VyKF9vcHRpb25zKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjcm9sbExvY2tlcik7XG5cbiAgdGhpcy5sb2NrVGFyZ2V0ID0gdm9pZCAwO1xuICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG5cbiAgdGhpcy5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnM7XG5cbiAgICByZXR1cm4gKF90aGlzJG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zLmNvbnRhaW5lcjtcbiAgfTtcblxuICB0aGlzLnJlTG9jayA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGZpbmRMb2NrID0gbG9ja3MuZmluZChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHRhcmdldCA9IF9yZWYudGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldCA9PT0gX3RoaXMubG9ja1RhcmdldDtcbiAgICB9KTtcblxuICAgIGlmIChmaW5kTG9jaykge1xuICAgICAgX3RoaXMudW5Mb2NrKCk7XG4gICAgfVxuXG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBpZiAoZmluZExvY2spIHtcbiAgICAgIGZpbmRMb2NrLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICBfdGhpcy5sb2NrKCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9uczM7XG5cbiAgICAvLyBJZiBsb2NrVGFyZ2V0IGV4aXN0IHJldHVyblxuICAgIGlmIChsb2Nrcy5zb21lKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIHRhcmdldCA9IF9yZWYyLnRhcmdldDtcbiAgICAgIHJldHVybiB0YXJnZXQgPT09IF90aGlzLmxvY2tUYXJnZXQ7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHNhbWUgY29udGFpbmVyIGVmZmVjdCwgcmV0dXJuXG5cblxuICAgIGlmIChsb2Nrcy5zb21lKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMyO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnM7XG4gICAgICByZXR1cm4gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250YWluZXIpID09PSAoKF90aGlzJG9wdGlvbnMyID0gX3RoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX3RoaXMkb3B0aW9uczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMyLmNvbnRhaW5lcik7XG4gICAgfSkpIHtcbiAgICAgIGxvY2tzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb2NrcyksIFt7XG4gICAgICAgIHRhcmdldDogX3RoaXMubG9ja1RhcmdldCxcbiAgICAgICAgb3B0aW9uczogX3RoaXMub3B0aW9uc1xuICAgICAgfV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxCYXJTaXplID0gMDtcbiAgICB2YXIgY29udGFpbmVyID0gKChfdGhpcyRvcHRpb25zMyA9IF90aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF90aGlzJG9wdGlvbnMzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zMy5jb250YWluZXIpIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICBpZiAoY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5ICYmIHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID4gMCB8fCBjb250YWluZXIuc2Nyb2xsSGVpZ2h0ID4gY29udGFpbmVyLmNsaWVudEhlaWdodCkge1xuICAgICAgc2Nyb2xsQmFyU2l6ZSA9IGdldFNjcm9sbEJhclNpemUoKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyQ2xhc3NOYW1lID0gY29udGFpbmVyLmNsYXNzTmFtZTtcblxuICAgIGlmIChsb2Nrcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9uczQ7XG5cbiAgICAgIHZhciBvcHRpb25zID0gX3JlZjQub3B0aW9ucztcbiAgICAgIHJldHVybiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRhaW5lcikgPT09ICgoX3RoaXMkb3B0aW9uczQgPSBfdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRpb25zNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uczQuY29udGFpbmVyKTtcbiAgICB9KS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhY2hlU3R5bGUuc2V0KGNvbnRhaW5lciwgc2V0U3R5bGUoe1xuICAgICAgICB3aWR0aDogc2Nyb2xsQmFyU2l6ZSAhPT0gMCA/IFwiY2FsYygxMDAlIC0gXCIuY29uY2F0KHNjcm9sbEJhclNpemUsIFwicHgpXCIpIDogdW5kZWZpbmVkLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXG4gICAgICAgIG92ZXJmbG93WTogJ2hpZGRlbidcbiAgICAgIH0sIHtcbiAgICAgICAgZWxlbWVudDogY29udGFpbmVyXG4gICAgICB9KSk7XG4gICAgfSAvLyBodHRwczovL2dpdGh1Yi5jb20vYW50LWRlc2lnbi9hbnQtZGVzaWduL2lzc3Vlcy8xOTcyOVxuXG5cbiAgICBpZiAoIXNjcm9sbGluZ0VmZmVjdENsYXNzTmFtZVJlZy50ZXN0KGNvbnRhaW5lckNsYXNzTmFtZSkpIHtcbiAgICAgIHZhciBhZGRDbGFzc05hbWUgPSBcIlwiLmNvbmNhdChjb250YWluZXJDbGFzc05hbWUsIFwiIFwiKS5jb25jYXQoc2Nyb2xsaW5nRWZmZWN0Q2xhc3NOYW1lKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBhZGRDbGFzc05hbWUudHJpbSgpO1xuICAgIH1cblxuICAgIGxvY2tzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb2NrcyksIFt7XG4gICAgICB0YXJnZXQ6IF90aGlzLmxvY2tUYXJnZXQsXG4gICAgICBvcHRpb25zOiBfdGhpcy5vcHRpb25zXG4gICAgfV0pO1xuICB9O1xuXG4gIHRoaXMudW5Mb2NrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyRvcHRpb25zNTtcblxuICAgIHZhciBmaW5kTG9jayA9IGxvY2tzLmZpbmQoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gX3JlZjUudGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldCA9PT0gX3RoaXMubG9ja1RhcmdldDtcbiAgICB9KTtcbiAgICBsb2NrcyA9IGxvY2tzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBfcmVmNi50YXJnZXQ7XG4gICAgICByZXR1cm4gdGFyZ2V0ICE9PSBfdGhpcy5sb2NrVGFyZ2V0O1xuICAgIH0pO1xuXG4gICAgaWYgKCFmaW5kTG9jayB8fCBsb2Nrcy5zb21lKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgdmFyIF9maW5kTG9jayRvcHRpb25zO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IF9yZWY3Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250YWluZXIpID09PSAoKF9maW5kTG9jayRvcHRpb25zID0gZmluZExvY2sub3B0aW9ucykgPT09IG51bGwgfHwgX2ZpbmRMb2NrJG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9maW5kTG9jayRvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFJlbW92ZSBFZmZlY3RcblxuXG4gICAgdmFyIGNvbnRhaW5lciA9ICgoX3RoaXMkb3B0aW9uczUgPSBfdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRpb25zNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uczUuY29udGFpbmVyKSB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBjb250YWluZXJDbGFzc05hbWUgPSBjb250YWluZXIuY2xhc3NOYW1lO1xuICAgIGlmICghc2Nyb2xsaW5nRWZmZWN0Q2xhc3NOYW1lUmVnLnRlc3QoY29udGFpbmVyQ2xhc3NOYW1lKSkgcmV0dXJuO1xuICAgIHNldFN0eWxlKGNhY2hlU3R5bGUuZ2V0KGNvbnRhaW5lciksIHtcbiAgICAgIGVsZW1lbnQ6IGNvbnRhaW5lclxuICAgIH0pO1xuICAgIGNhY2hlU3R5bGUuZGVsZXRlKGNvbnRhaW5lcik7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGNvbnRhaW5lci5jbGFzc05hbWUucmVwbGFjZShzY3JvbGxpbmdFZmZlY3RDbGFzc05hbWVSZWcsICcnKS50cmltKCk7XG4gIH07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBsdXNwbHVzXG4gIHRoaXMubG9ja1RhcmdldCA9IHV1aWQrKztcbiAgdGhpcy5vcHRpb25zID0gX29wdGlvbnM7XG59O1xuXG5leHBvcnQgeyBTY3JvbGxMb2NrZXIgYXMgZGVmYXVsdCB9OyIsIi8qKlxuICogQGlnbm9yZVxuICogc29tZSBrZXktY29kZXMgZGVmaW5pdGlvbiBhbmQgdXRpbHMgZnJvbSBjbG9zdXJlLWxpYnJhcnlcbiAqIEBhdXRob3IgeWltaW5naGVAZ21haWwuY29tXG4gKi9cbnZhciBLZXlDb2RlID0ge1xuICAvKipcbiAgICogTUFDX0VOVEVSXG4gICAqL1xuICBNQUNfRU5URVI6IDMsXG5cbiAgLyoqXG4gICAqIEJBQ0tTUEFDRVxuICAgKi9cbiAgQkFDS1NQQUNFOiA4LFxuXG4gIC8qKlxuICAgKiBUQUJcbiAgICovXG4gIFRBQjogOSxcblxuICAvKipcbiAgICogTlVNTE9DSyBvbiBGRi9TYWZhcmkgTWFjXG4gICAqL1xuICBOVU1fQ0VOVEVSOiAxMixcblxuICAvKipcbiAgICogRU5URVJcbiAgICovXG4gIEVOVEVSOiAxMyxcblxuICAvKipcbiAgICogU0hJRlRcbiAgICovXG4gIFNISUZUOiAxNixcblxuICAvKipcbiAgICogQ1RSTFxuICAgKi9cbiAgQ1RSTDogMTcsXG5cbiAgLyoqXG4gICAqIEFMVFxuICAgKi9cbiAgQUxUOiAxOCxcblxuICAvKipcbiAgICogUEFVU0VcbiAgICovXG4gIFBBVVNFOiAxOSxcblxuICAvKipcbiAgICogQ0FQU19MT0NLXG4gICAqL1xuICBDQVBTX0xPQ0s6IDIwLFxuXG4gIC8qKlxuICAgKiBFU0NcbiAgICovXG4gIEVTQzogMjcsXG5cbiAgLyoqXG4gICAqIFNQQUNFXG4gICAqL1xuICBTUEFDRTogMzIsXG5cbiAgLyoqXG4gICAqIFBBR0VfVVBcbiAgICovXG4gIFBBR0VfVVA6IDMzLFxuXG4gIC8qKlxuICAgKiBQQUdFX0RPV05cbiAgICovXG4gIFBBR0VfRE9XTjogMzQsXG5cbiAgLyoqXG4gICAqIEVORFxuICAgKi9cbiAgRU5EOiAzNSxcblxuICAvKipcbiAgICogSE9NRVxuICAgKi9cbiAgSE9NRTogMzYsXG5cbiAgLyoqXG4gICAqIExFRlRcbiAgICovXG4gIExFRlQ6IDM3LFxuXG4gIC8qKlxuICAgKiBVUFxuICAgKi9cbiAgVVA6IDM4LFxuXG4gIC8qKlxuICAgKiBSSUdIVFxuICAgKi9cbiAgUklHSFQ6IDM5LFxuXG4gIC8qKlxuICAgKiBET1dOXG4gICAqL1xuICBET1dOOiA0MCxcblxuICAvKipcbiAgICogUFJJTlRfU0NSRUVOXG4gICAqL1xuICBQUklOVF9TQ1JFRU46IDQ0LFxuXG4gIC8qKlxuICAgKiBJTlNFUlRcbiAgICovXG4gIElOU0VSVDogNDUsXG5cbiAgLyoqXG4gICAqIERFTEVURVxuICAgKi9cbiAgREVMRVRFOiA0NixcblxuICAvKipcbiAgICogWkVST1xuICAgKi9cbiAgWkVSTzogNDgsXG5cbiAgLyoqXG4gICAqIE9ORVxuICAgKi9cbiAgT05FOiA0OSxcblxuICAvKipcbiAgICogVFdPXG4gICAqL1xuICBUV086IDUwLFxuXG4gIC8qKlxuICAgKiBUSFJFRVxuICAgKi9cbiAgVEhSRUU6IDUxLFxuXG4gIC8qKlxuICAgKiBGT1VSXG4gICAqL1xuICBGT1VSOiA1MixcblxuICAvKipcbiAgICogRklWRVxuICAgKi9cbiAgRklWRTogNTMsXG5cbiAgLyoqXG4gICAqIFNJWFxuICAgKi9cbiAgU0lYOiA1NCxcblxuICAvKipcbiAgICogU0VWRU5cbiAgICovXG4gIFNFVkVOOiA1NSxcblxuICAvKipcbiAgICogRUlHSFRcbiAgICovXG4gIEVJR0hUOiA1NixcblxuICAvKipcbiAgICogTklORVxuICAgKi9cbiAgTklORTogNTcsXG5cbiAgLyoqXG4gICAqIFFVRVNUSU9OX01BUktcbiAgICovXG4gIFFVRVNUSU9OX01BUks6IDYzLFxuXG4gIC8qKlxuICAgKiBBXG4gICAqL1xuICBBOiA2NSxcblxuICAvKipcbiAgICogQlxuICAgKi9cbiAgQjogNjYsXG5cbiAgLyoqXG4gICAqIENcbiAgICovXG4gIEM6IDY3LFxuXG4gIC8qKlxuICAgKiBEXG4gICAqL1xuICBEOiA2OCxcblxuICAvKipcbiAgICogRVxuICAgKi9cbiAgRTogNjksXG5cbiAgLyoqXG4gICAqIEZcbiAgICovXG4gIEY6IDcwLFxuXG4gIC8qKlxuICAgKiBHXG4gICAqL1xuICBHOiA3MSxcblxuICAvKipcbiAgICogSFxuICAgKi9cbiAgSDogNzIsXG5cbiAgLyoqXG4gICAqIElcbiAgICovXG4gIEk6IDczLFxuXG4gIC8qKlxuICAgKiBKXG4gICAqL1xuICBKOiA3NCxcblxuICAvKipcbiAgICogS1xuICAgKi9cbiAgSzogNzUsXG5cbiAgLyoqXG4gICAqIExcbiAgICovXG4gIEw6IDc2LFxuXG4gIC8qKlxuICAgKiBNXG4gICAqL1xuICBNOiA3NyxcblxuICAvKipcbiAgICogTlxuICAgKi9cbiAgTjogNzgsXG5cbiAgLyoqXG4gICAqIE9cbiAgICovXG4gIE86IDc5LFxuXG4gIC8qKlxuICAgKiBQXG4gICAqL1xuICBQOiA4MCxcblxuICAvKipcbiAgICogUVxuICAgKi9cbiAgUTogODEsXG5cbiAgLyoqXG4gICAqIFJcbiAgICovXG4gIFI6IDgyLFxuXG4gIC8qKlxuICAgKiBTXG4gICAqL1xuICBTOiA4MyxcblxuICAvKipcbiAgICogVFxuICAgKi9cbiAgVDogODQsXG5cbiAgLyoqXG4gICAqIFVcbiAgICovXG4gIFU6IDg1LFxuXG4gIC8qKlxuICAgKiBWXG4gICAqL1xuICBWOiA4NixcblxuICAvKipcbiAgICogV1xuICAgKi9cbiAgVzogODcsXG5cbiAgLyoqXG4gICAqIFhcbiAgICovXG4gIFg6IDg4LFxuXG4gIC8qKlxuICAgKiBZXG4gICAqL1xuICBZOiA4OSxcblxuICAvKipcbiAgICogWlxuICAgKi9cbiAgWjogOTAsXG5cbiAgLyoqXG4gICAqIE1FVEFcbiAgICovXG4gIE1FVEE6IDkxLFxuXG4gIC8qKlxuICAgKiBXSU5fS0VZX1JJR0hUXG4gICAqL1xuICBXSU5fS0VZX1JJR0hUOiA5MixcblxuICAvKipcbiAgICogQ09OVEVYVF9NRU5VXG4gICAqL1xuICBDT05URVhUX01FTlU6IDkzLFxuXG4gIC8qKlxuICAgKiBOVU1fWkVST1xuICAgKi9cbiAgTlVNX1pFUk86IDk2LFxuXG4gIC8qKlxuICAgKiBOVU1fT05FXG4gICAqL1xuICBOVU1fT05FOiA5NyxcblxuICAvKipcbiAgICogTlVNX1RXT1xuICAgKi9cbiAgTlVNX1RXTzogOTgsXG5cbiAgLyoqXG4gICAqIE5VTV9USFJFRVxuICAgKi9cbiAgTlVNX1RIUkVFOiA5OSxcblxuICAvKipcbiAgICogTlVNX0ZPVVJcbiAgICovXG4gIE5VTV9GT1VSOiAxMDAsXG5cbiAgLyoqXG4gICAqIE5VTV9GSVZFXG4gICAqL1xuICBOVU1fRklWRTogMTAxLFxuXG4gIC8qKlxuICAgKiBOVU1fU0lYXG4gICAqL1xuICBOVU1fU0lYOiAxMDIsXG5cbiAgLyoqXG4gICAqIE5VTV9TRVZFTlxuICAgKi9cbiAgTlVNX1NFVkVOOiAxMDMsXG5cbiAgLyoqXG4gICAqIE5VTV9FSUdIVFxuICAgKi9cbiAgTlVNX0VJR0hUOiAxMDQsXG5cbiAgLyoqXG4gICAqIE5VTV9OSU5FXG4gICAqL1xuICBOVU1fTklORTogMTA1LFxuXG4gIC8qKlxuICAgKiBOVU1fTVVMVElQTFlcbiAgICovXG4gIE5VTV9NVUxUSVBMWTogMTA2LFxuXG4gIC8qKlxuICAgKiBOVU1fUExVU1xuICAgKi9cbiAgTlVNX1BMVVM6IDEwNyxcblxuICAvKipcbiAgICogTlVNX01JTlVTXG4gICAqL1xuICBOVU1fTUlOVVM6IDEwOSxcblxuICAvKipcbiAgICogTlVNX1BFUklPRFxuICAgKi9cbiAgTlVNX1BFUklPRDogMTEwLFxuXG4gIC8qKlxuICAgKiBOVU1fRElWSVNJT05cbiAgICovXG4gIE5VTV9ESVZJU0lPTjogMTExLFxuXG4gIC8qKlxuICAgKiBGMVxuICAgKi9cbiAgRjE6IDExMixcblxuICAvKipcbiAgICogRjJcbiAgICovXG4gIEYyOiAxMTMsXG5cbiAgLyoqXG4gICAqIEYzXG4gICAqL1xuICBGMzogMTE0LFxuXG4gIC8qKlxuICAgKiBGNFxuICAgKi9cbiAgRjQ6IDExNSxcblxuICAvKipcbiAgICogRjVcbiAgICovXG4gIEY1OiAxMTYsXG5cbiAgLyoqXG4gICAqIEY2XG4gICAqL1xuICBGNjogMTE3LFxuXG4gIC8qKlxuICAgKiBGN1xuICAgKi9cbiAgRjc6IDExOCxcblxuICAvKipcbiAgICogRjhcbiAgICovXG4gIEY4OiAxMTksXG5cbiAgLyoqXG4gICAqIEY5XG4gICAqL1xuICBGOTogMTIwLFxuXG4gIC8qKlxuICAgKiBGMTBcbiAgICovXG4gIEYxMDogMTIxLFxuXG4gIC8qKlxuICAgKiBGMTFcbiAgICovXG4gIEYxMTogMTIyLFxuXG4gIC8qKlxuICAgKiBGMTJcbiAgICovXG4gIEYxMjogMTIzLFxuXG4gIC8qKlxuICAgKiBOVU1MT0NLXG4gICAqL1xuICBOVU1MT0NLOiAxNDQsXG5cbiAgLyoqXG4gICAqIFNFTUlDT0xPTlxuICAgKi9cbiAgU0VNSUNPTE9OOiAxODYsXG5cbiAgLyoqXG4gICAqIERBU0hcbiAgICovXG4gIERBU0g6IDE4OSxcblxuICAvKipcbiAgICogRVFVQUxTXG4gICAqL1xuICBFUVVBTFM6IDE4NyxcblxuICAvKipcbiAgICogQ09NTUFcbiAgICovXG4gIENPTU1BOiAxODgsXG5cbiAgLyoqXG4gICAqIFBFUklPRFxuICAgKi9cbiAgUEVSSU9EOiAxOTAsXG5cbiAgLyoqXG4gICAqIFNMQVNIXG4gICAqL1xuICBTTEFTSDogMTkxLFxuXG4gIC8qKlxuICAgKiBBUE9TVFJPUEhFXG4gICAqL1xuICBBUE9TVFJPUEhFOiAxOTIsXG5cbiAgLyoqXG4gICAqIFNJTkdMRV9RVU9URVxuICAgKi9cbiAgU0lOR0xFX1FVT1RFOiAyMjIsXG5cbiAgLyoqXG4gICAqIE9QRU5fU1FVQVJFX0JSQUNLRVRcbiAgICovXG4gIE9QRU5fU1FVQVJFX0JSQUNLRVQ6IDIxOSxcblxuICAvKipcbiAgICogQkFDS1NMQVNIXG4gICAqL1xuICBCQUNLU0xBU0g6IDIyMCxcblxuICAvKipcbiAgICogQ0xPU0VfU1FVQVJFX0JSQUNLRVRcbiAgICovXG4gIENMT1NFX1NRVUFSRV9CUkFDS0VUOiAyMjEsXG5cbiAgLyoqXG4gICAqIFdJTl9LRVlcbiAgICovXG4gIFdJTl9LRVk6IDIyNCxcblxuICAvKipcbiAgICogTUFDX0ZGX01FVEFcbiAgICovXG4gIE1BQ19GRl9NRVRBOiAyMjQsXG5cbiAgLyoqXG4gICAqIFdJTl9JTUVcbiAgICovXG4gIFdJTl9JTUU6IDIyOSxcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09IEZ1bmN0aW9uID09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiB3aGV0aGVyIHRleHQgYW5kIG1vZGlmaWVkIGtleSBpcyBlbnRlcmVkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqL1xuICBpc1RleHRNb2RpZnlpbmdLZXlFdmVudDogZnVuY3Rpb24gaXNUZXh0TW9kaWZ5aW5nS2V5RXZlbnQoZSkge1xuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuXG4gICAgaWYgKGUuYWx0S2V5ICYmICFlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IC8vIEZ1bmN0aW9uIGtleXMgZG9uJ3QgZ2VuZXJhdGUgdGV4dFxuICAgIGtleUNvZGUgPj0gS2V5Q29kZS5GMSAmJiBrZXlDb2RlIDw9IEtleUNvZGUuRjEyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBUaGUgZm9sbG93aW5nIGtleXMgYXJlIHF1aXRlIGhhcm1sZXNzLCBldmVuIGluIGNvbWJpbmF0aW9uIHdpdGhcbiAgICAvLyBDVFJMLCBBTFQgb3IgU0hJRlQuXG5cblxuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSBLZXlDb2RlLkFMVDpcbiAgICAgIGNhc2UgS2V5Q29kZS5DQVBTX0xPQ0s6XG4gICAgICBjYXNlIEtleUNvZGUuQ09OVEVYVF9NRU5VOlxuICAgICAgY2FzZSBLZXlDb2RlLkNUUkw6XG4gICAgICBjYXNlIEtleUNvZGUuRE9XTjpcbiAgICAgIGNhc2UgS2V5Q29kZS5FTkQ6XG4gICAgICBjYXNlIEtleUNvZGUuRVNDOlxuICAgICAgY2FzZSBLZXlDb2RlLkhPTUU6XG4gICAgICBjYXNlIEtleUNvZGUuSU5TRVJUOlxuICAgICAgY2FzZSBLZXlDb2RlLkxFRlQ6XG4gICAgICBjYXNlIEtleUNvZGUuTUFDX0ZGX01FVEE6XG4gICAgICBjYXNlIEtleUNvZGUuTUVUQTpcbiAgICAgIGNhc2UgS2V5Q29kZS5OVU1MT0NLOlxuICAgICAgY2FzZSBLZXlDb2RlLk5VTV9DRU5URVI6XG4gICAgICBjYXNlIEtleUNvZGUuUEFHRV9ET1dOOlxuICAgICAgY2FzZSBLZXlDb2RlLlBBR0VfVVA6XG4gICAgICBjYXNlIEtleUNvZGUuUEFVU0U6XG4gICAgICBjYXNlIEtleUNvZGUuUFJJTlRfU0NSRUVOOlxuICAgICAgY2FzZSBLZXlDb2RlLlJJR0hUOlxuICAgICAgY2FzZSBLZXlDb2RlLlNISUZUOlxuICAgICAgY2FzZSBLZXlDb2RlLlVQOlxuICAgICAgY2FzZSBLZXlDb2RlLldJTl9LRVk6XG4gICAgICBjYXNlIEtleUNvZGUuV0lOX0tFWV9SSUdIVDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIHdoZXRoZXIgY2hhcmFjdGVyIGlzIGVudGVyZWQuXG4gICAqL1xuICBpc0NoYXJhY3RlcktleTogZnVuY3Rpb24gaXNDaGFyYWN0ZXJLZXkoa2V5Q29kZSkge1xuICAgIGlmIChrZXlDb2RlID49IEtleUNvZGUuWkVSTyAmJiBrZXlDb2RlIDw9IEtleUNvZGUuTklORSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGtleUNvZGUgPj0gS2V5Q29kZS5OVU1fWkVSTyAmJiBrZXlDb2RlIDw9IEtleUNvZGUuTlVNX01VTFRJUExZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoa2V5Q29kZSA+PSBLZXlDb2RlLkEgJiYga2V5Q29kZSA8PSBLZXlDb2RlLlopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gU2FmYXJpIHNlbmRzIHplcm8ga2V5IGNvZGUgZm9yIG5vbi1sYXRpbiBjaGFyYWN0ZXJzLlxuXG5cbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignV2ViS2l0JykgIT09IC0xICYmIGtleUNvZGUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSBLZXlDb2RlLlNQQUNFOlxuICAgICAgY2FzZSBLZXlDb2RlLlFVRVNUSU9OX01BUks6XG4gICAgICBjYXNlIEtleUNvZGUuTlVNX1BMVVM6XG4gICAgICBjYXNlIEtleUNvZGUuTlVNX01JTlVTOlxuICAgICAgY2FzZSBLZXlDb2RlLk5VTV9QRVJJT0Q6XG4gICAgICBjYXNlIEtleUNvZGUuTlVNX0RJVklTSU9OOlxuICAgICAgY2FzZSBLZXlDb2RlLlNFTUlDT0xPTjpcbiAgICAgIGNhc2UgS2V5Q29kZS5EQVNIOlxuICAgICAgY2FzZSBLZXlDb2RlLkVRVUFMUzpcbiAgICAgIGNhc2UgS2V5Q29kZS5DT01NQTpcbiAgICAgIGNhc2UgS2V5Q29kZS5QRVJJT0Q6XG4gICAgICBjYXNlIEtleUNvZGUuU0xBU0g6XG4gICAgICBjYXNlIEtleUNvZGUuQVBPU1RST1BIRTpcbiAgICAgIGNhc2UgS2V5Q29kZS5TSU5HTEVfUVVPVEU6XG4gICAgICBjYXNlIEtleUNvZGUuT1BFTl9TUVVBUkVfQlJBQ0tFVDpcbiAgICAgIGNhc2UgS2V5Q29kZS5CQUNLU0xBU0g6XG4gICAgICBjYXNlIEtleUNvZGUuQ0xPU0VfU1FVQVJFX0JSQUNLRVQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgS2V5Q29kZTsiLCJpbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNhblVzZURvbSBmcm9tICcuL0RvbS9jYW5Vc2VEb20nO1xudmFyIFBvcnRhbCA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBkaWRVcGRhdGUgPSBwcm9wcy5kaWRVcGRhdGUsXG4gICAgICBnZXRDb250YWluZXIgPSBwcm9wcy5nZXRDb250YWluZXIsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICB2YXIgY29udGFpbmVyUmVmID0gdXNlUmVmKCk7IC8vIFJlZiByZXR1cm4gbm90aGluZywgb25seSBmb3Igd3JhcHBlciBjaGVjayBleGlzdFxuXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KTsgLy8gQ3JlYXRlIGNvbnRhaW5lciBpbiBjbGllbnQgc2lkZSB3aXRoIHN5bmMgdG8gYXZvaWQgdXNlRWZmZWN0IG5vdCBnZXQgcmVmXG5cbiAgdmFyIGluaXRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIGlmICghaW5pdFJlZi5jdXJyZW50ICYmIGNhblVzZURvbSgpKSB7XG4gICAgY29udGFpbmVyUmVmLmN1cnJlbnQgPSBnZXRDb250YWluZXIoKTtcbiAgICBpbml0UmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9IC8vIFtMZWdhY3ldIFVzZWQgYnkgYHJjLXRyaWdnZXJgXG5cblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGRpZFVwZGF0ZSA9PT0gbnVsbCB8fCBkaWRVcGRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpZFVwZGF0ZShwcm9wcyk7XG4gIH0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NvbnRhaW5lclJlZiRjdXJyZW50LCBfY29udGFpbmVyUmVmJGN1cnJlbnQyO1xuXG4gICAgICAvLyBbTGVnYWN5XSBUaGlzIHNob3VsZCBub3QgYmUgaGFuZGxlIGJ5IFBvcnRhbCBidXQgcGFyZW50IFBvcnRhbFdyYXBwZXIgaW5zdGVhZC5cbiAgICAgIC8vIFNpbmNlIHNvbWUgY29tcG9uZW50IHVzZSBgUG9ydGFsYCBkaXJlY3RseSwgd2UgaGF2ZSB0byBrZWVwIHRoZSBsb2dpYyBoZXJlLlxuICAgICAgKF9jb250YWluZXJSZWYkY3VycmVudCA9IGNvbnRhaW5lclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfY29udGFpbmVyUmVmJGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29udGFpbmVyUmVmJGN1cnJlbnQyID0gX2NvbnRhaW5lclJlZiRjdXJyZW50LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9jb250YWluZXJSZWYkY3VycmVudDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb250YWluZXJSZWYkY3VycmVudDIucmVtb3ZlQ2hpbGQoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGNvbnRhaW5lclJlZi5jdXJyZW50ID8gLyojX19QVVJFX18qL1JlYWN0RE9NLmNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyUmVmLmN1cnJlbnQpIDogbnVsbDtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgUG9ydGFsOyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfY3JlYXRlU3VwZXIgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZVN1cGVyXCI7XG5pbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLHJlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wcyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHJhZiBmcm9tICcuL3JhZic7XG5pbXBvcnQgUG9ydGFsIGZyb20gJy4vUG9ydGFsJztcbmltcG9ydCBjYW5Vc2VEb20gZnJvbSAnLi9Eb20vY2FuVXNlRG9tJztcbmltcG9ydCBzd2l0Y2hTY3JvbGxpbmdFZmZlY3QgZnJvbSAnLi9zd2l0Y2hTY3JvbGxpbmdFZmZlY3QnO1xuaW1wb3J0IHNldFN0eWxlIGZyb20gJy4vc2V0U3R5bGUnO1xuaW1wb3J0IFNjcm9sbExvY2tlciBmcm9tICcuL0RvbS9zY3JvbGxMb2NrZXInO1xudmFyIG9wZW5Db3VudCA9IDA7XG52YXIgc3VwcG9ydERvbSA9IGNhblVzZURvbSgpO1xuLyoqIEBwcml2YXRlIFRlc3QgdXNhZ2Ugb25seSAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlbkNvdW50KCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JyA/IG9wZW5Db3VudCA6IDA7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24vaXNzdWVzLzE5MzQwXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW50LWRlc2lnbi9hbnQtZGVzaWduL2lzc3Vlcy8xOTMzMlxuXG52YXIgY2FjaGVPdmVyZmxvdyA9IHt9O1xuXG52YXIgZ2V0UGFyZW50ID0gZnVuY3Rpb24gZ2V0UGFyZW50KGdldENvbnRhaW5lcikge1xuICBpZiAoIXN1cHBvcnREb20pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChnZXRDb250YWluZXIpIHtcbiAgICBpZiAodHlwZW9mIGdldENvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGdldENvbnRhaW5lcilbMF07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnZXRDb250YWluZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRDb250YWluZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihnZXRDb250YWluZXIpID09PSAnb2JqZWN0JyAmJiBnZXRDb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRDb250YWluZXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG59O1xuXG52YXIgUG9ydGFsV3JhcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUG9ydGFsV3JhcHBlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQb3J0YWxXcmFwcGVyKTtcblxuICBmdW5jdGlvbiBQb3J0YWxXcmFwcGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcnRhbFdyYXBwZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgX3RoaXMuY29udGFpbmVyID0gdm9pZCAwO1xuICAgIF90aGlzLmNvbXBvbmVudFJlZiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKTtcbiAgICBfdGhpcy5yYWZJZCA9IHZvaWQgMDtcbiAgICBfdGhpcy5zY3JvbGxMb2NrZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMucmVuZGVyQ29tcG9uZW50ID0gdm9pZCAwO1xuXG4gICAgX3RoaXMudXBkYXRlU2Nyb2xsTG9ja2VyID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgdmFyIF9yZWYgPSBwcmV2UHJvcHMgfHwge30sXG4gICAgICAgICAgcHJldlZpc2libGUgPSBfcmVmLnZpc2libGU7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGdldENvbnRhaW5lciA9IF90aGlzJHByb3BzLmdldENvbnRhaW5lcixcbiAgICAgICAgICB2aXNpYmxlID0gX3RoaXMkcHJvcHMudmlzaWJsZTtcblxuICAgICAgaWYgKHZpc2libGUgJiYgdmlzaWJsZSAhPT0gcHJldlZpc2libGUgJiYgc3VwcG9ydERvbSAmJiBnZXRQYXJlbnQoZ2V0Q29udGFpbmVyKSAhPT0gX3RoaXMuc2Nyb2xsTG9ja2VyLmdldENvbnRhaW5lcigpKSB7XG4gICAgICAgIF90aGlzLnNjcm9sbExvY2tlci5yZUxvY2soe1xuICAgICAgICAgIGNvbnRhaW5lcjogZ2V0UGFyZW50KGdldENvbnRhaW5lcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnVwZGF0ZU9wZW5Db3VudCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBfcmVmMiA9IHByZXZQcm9wcyB8fCB7fSxcbiAgICAgICAgICBwcmV2VmlzaWJsZSA9IF9yZWYyLnZpc2libGUsXG4gICAgICAgICAgcHJldkdldENvbnRhaW5lciA9IF9yZWYyLmdldENvbnRhaW5lcjtcblxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIHZpc2libGUgPSBfdGhpcyRwcm9wczIudmlzaWJsZSxcbiAgICAgICAgICBnZXRDb250YWluZXIgPSBfdGhpcyRwcm9wczIuZ2V0Q29udGFpbmVyOyAvLyBVcGRhdGUgY291bnRcblxuICAgICAgaWYgKHZpc2libGUgIT09IHByZXZWaXNpYmxlICYmIHN1cHBvcnREb20gJiYgZ2V0UGFyZW50KGdldENvbnRhaW5lcikgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgaWYgKHZpc2libGUgJiYgIXByZXZWaXNpYmxlKSB7XG4gICAgICAgICAgb3BlbkNvdW50ICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldlByb3BzKSB7XG4gICAgICAgICAgb3BlbkNvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2xlYW4gdXAgY29udGFpbmVyIGlmIG5lZWRlZFxuXG5cbiAgICAgIHZhciBnZXRDb250YWluZXJJc0Z1bmMgPSB0eXBlb2YgZ2V0Q29udGFpbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwcmV2R2V0Q29udGFpbmVyID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICBpZiAoZ2V0Q29udGFpbmVySXNGdW5jID8gZ2V0Q29udGFpbmVyLnRvU3RyaW5nKCkgIT09IHByZXZHZXRDb250YWluZXIudG9TdHJpbmcoKSA6IGdldENvbnRhaW5lciAhPT0gcHJldkdldENvbnRhaW5lcikge1xuICAgICAgICBfdGhpcy5yZW1vdmVDdXJyZW50Q29udGFpbmVyKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmF0dGFjaFRvUGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKGZvcmNlIHx8IF90aGlzLmNvbnRhaW5lciAmJiAhX3RoaXMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChfdGhpcy5wcm9wcy5nZXRDb250YWluZXIpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIF90aGlzLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3VwcG9ydERvbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgX3RoaXMuYXR0YWNoVG9QYXJlbnQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFdyYXBwZXJDbGFzc05hbWUoKTtcblxuICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcjtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0V3JhcHBlckNsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB3cmFwcGVyQ2xhc3NOYW1lID0gX3RoaXMucHJvcHMud3JhcHBlckNsYXNzTmFtZTtcblxuICAgICAgaWYgKF90aGlzLmNvbnRhaW5lciAmJiB3cmFwcGVyQ2xhc3NOYW1lICYmIHdyYXBwZXJDbGFzc05hbWUgIT09IF90aGlzLmNvbnRhaW5lci5jbGFzc05hbWUpIHtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHdyYXBwZXJDbGFzc05hbWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnJlbW92ZUN1cnJlbnRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkY29udGFpbmVyLCBfdGhpcyRjb250YWluZXIkcGFyZW47XG5cbiAgICAgIC8vIFBvcnRhbCB3aWxsIHJlbW92ZSBmcm9tIGBwYXJlbnROb2RlYC5cbiAgICAgIC8vIExldCdzIGhhbmRsZSB0aGlzIGFnYWluIHRvIGF2b2lkIHJlZmFjdG9yIGlzc3VlLlxuICAgICAgKF90aGlzJGNvbnRhaW5lciA9IF90aGlzLmNvbnRhaW5lcikgPT09IG51bGwgfHwgX3RoaXMkY29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXMkY29udGFpbmVyJHBhcmVuID0gX3RoaXMkY29udGFpbmVyLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF90aGlzJGNvbnRhaW5lciRwYXJlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkY29udGFpbmVyJHBhcmVuLnJlbW92ZUNoaWxkKF90aGlzLmNvbnRhaW5lcik7XG4gICAgfTtcblxuICAgIF90aGlzLnN3aXRjaFNjcm9sbGluZ0VmZmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvcGVuQ291bnQgPT09IDEgJiYgIU9iamVjdC5rZXlzKGNhY2hlT3ZlcmZsb3cpLmxlbmd0aCkge1xuICAgICAgICBzd2l0Y2hTY3JvbGxpbmdFZmZlY3QoKTsgLy8gTXVzdCBiZSBzZXQgYWZ0ZXIgc3dpdGNoU2Nyb2xsaW5nRWZmZWN0XG5cbiAgICAgICAgY2FjaGVPdmVyZmxvdyA9IHNldFN0eWxlKHtcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcbiAgICAgICAgICBvdmVyZmxvd1k6ICdoaWRkZW4nXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghb3BlbkNvdW50KSB7XG4gICAgICAgIHNldFN0eWxlKGNhY2hlT3ZlcmZsb3cpO1xuICAgICAgICBjYWNoZU92ZXJmbG93ID0ge307XG4gICAgICAgIHN3aXRjaFNjcm9sbGluZ0VmZmVjdCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuc2Nyb2xsTG9ja2VyID0gbmV3IFNjcm9sbExvY2tlcih7XG4gICAgICBjb250YWluZXI6IGdldFBhcmVudChwcm9wcy5nZXRDb250YWluZXIpXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvcnRhbFdyYXBwZXIsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMudXBkYXRlT3BlbkNvdW50KCk7XG5cbiAgICAgIGlmICghdGhpcy5hdHRhY2hUb1BhcmVudCgpKSB7XG4gICAgICAgIHRoaXMucmFmSWQgPSByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHRoaXMudXBkYXRlT3BlbkNvdW50KHByZXZQcm9wcyk7XG4gICAgICB0aGlzLnVwZGF0ZVNjcm9sbExvY2tlcihwcmV2UHJvcHMpO1xuICAgICAgdGhpcy5zZXRXcmFwcGVyQ2xhc3NOYW1lKCk7XG4gICAgICB0aGlzLmF0dGFjaFRvUGFyZW50KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgdmlzaWJsZSA9IF90aGlzJHByb3BzMy52aXNpYmxlLFxuICAgICAgICAgIGdldENvbnRhaW5lciA9IF90aGlzJHByb3BzMy5nZXRDb250YWluZXI7XG5cbiAgICAgIGlmIChzdXBwb3J0RG9tICYmIGdldFBhcmVudChnZXRDb250YWluZXIpID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIOemu+W8gOaXtuS4jeS8miByZW5kZXLvvIwg5a+85Yiw56a75byA5pe25pWw5YC85LiN5Y+Y77yM5pS555SoIGZ1bmMg44CC44CCXG4gICAgICAgIG9wZW5Db3VudCA9IHZpc2libGUgJiYgb3BlbkNvdW50ID8gb3BlbkNvdW50IC0gMSA6IG9wZW5Db3VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW1vdmVDdXJyZW50Q29udGFpbmVyKCk7XG4gICAgICByYWYuY2FuY2VsKHRoaXMucmFmSWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczQuY2hpbGRyZW4sXG4gICAgICAgICAgZm9yY2VSZW5kZXIgPSBfdGhpcyRwcm9wczQuZm9yY2VSZW5kZXIsXG4gICAgICAgICAgdmlzaWJsZSA9IF90aGlzJHByb3BzNC52aXNpYmxlO1xuICAgICAgdmFyIHBvcnRhbCA9IG51bGw7XG4gICAgICB2YXIgY2hpbGRQcm9wcyA9IHtcbiAgICAgICAgZ2V0T3BlbkNvdW50OiBmdW5jdGlvbiBnZXRPcGVuQ291bnQoKSB7XG4gICAgICAgICAgcmV0dXJuIG9wZW5Db3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29udGFpbmVyOiB0aGlzLmdldENvbnRhaW5lcixcbiAgICAgICAgc3dpdGNoU2Nyb2xsaW5nRWZmZWN0OiB0aGlzLnN3aXRjaFNjcm9sbGluZ0VmZmVjdCxcbiAgICAgICAgc2Nyb2xsTG9ja2VyOiB0aGlzLnNjcm9sbExvY2tlclxuICAgICAgfTtcblxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHZpc2libGUgfHwgdGhpcy5jb21wb25lbnRSZWYuY3VycmVudCkge1xuICAgICAgICBwb3J0YWwgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWwsIHtcbiAgICAgICAgICBnZXRDb250YWluZXI6IHRoaXMuZ2V0Q29udGFpbmVyLFxuICAgICAgICAgIHJlZjogdGhpcy5jb21wb25lbnRSZWZcbiAgICAgICAgfSwgY2hpbGRyZW4oY2hpbGRQcm9wcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9ydGFsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3J0YWxXcmFwcGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBQb3J0YWxXcmFwcGVyOyIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG52YXIgY2FjaGVkO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsQmFyU2l6ZShmcmVzaCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGZyZXNoIHx8IGNhY2hlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JztcbiAgICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgb3V0ZXJTdHlsZSA9IG91dGVyLnN0eWxlO1xuICAgIG91dGVyU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIG91dGVyU3R5bGUudG9wID0gJzAnO1xuICAgIG91dGVyU3R5bGUubGVmdCA9ICcwJztcbiAgICBvdXRlclN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgb3V0ZXJTdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgb3V0ZXJTdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gICAgb3V0ZXJTdHlsZS5oZWlnaHQgPSAnMTUwcHgnO1xuICAgIG91dGVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG4gICAgdmFyIHdpZHRoQ29udGFpbmVkID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICB2YXIgd2lkdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRXaWR0aDtcblxuICAgIGlmICh3aWR0aENvbnRhaW5lZCA9PT0gd2lkdGhTY3JvbGwpIHtcbiAgICAgIHdpZHRoU2Nyb2xsID0gb3V0ZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG4gICAgY2FjaGVkID0gd2lkdGhDb250YWluZWQgLSB3aWR0aFNjcm9sbDtcbiAgfVxuXG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNpemUoc3RyKSB7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXiguKilweCQvKTtcbiAgdmFyIHZhbHVlID0gTnVtYmVyKG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaFsxXSk7XG4gIHJldHVybiBOdW1iZXIuaXNOYU4odmFsdWUpID8gZ2V0U2Nyb2xsQmFyU2l6ZSgpIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUYXJnZXRTY3JvbGxCYXJTaXplKHRhcmdldCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhdGFyZ2V0IHx8ICEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsICc6Oi13ZWJraXQtc2Nyb2xsYmFyJyksXG4gICAgICB3aWR0aCA9IF9nZXRDb21wdXRlZFN0eWxlLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUuaGVpZ2h0O1xuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGVuc3VyZVNpemUod2lkdGgpLFxuICAgIGhlaWdodDogZW5zdXJlU2l6ZShoZWlnaHQpXG4gIH07XG59IiwiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDJcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9taXQob2JqLCBmaWVsZHMpIHtcbiAgdmFyIGNsb25lID0gX29iamVjdFNwcmVhZCh7fSwgb2JqKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVsZXRlIGNsb25lW2tleV07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59IiwidmFyIHJhZiA9IGZ1bmN0aW9uIHJhZihjYWxsYmFjaykge1xuICByZXR1cm4gK3NldFRpbWVvdXQoY2FsbGJhY2ssIDE2KTtcbn07XG5cbnZhciBjYWYgPSBmdW5jdGlvbiBjYWYobnVtKSB7XG4gIHJldHVybiBjbGVhclRpbWVvdXQobnVtKTtcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBpbiB3aW5kb3cpIHtcbiAgcmFmID0gZnVuY3Rpb24gcmFmKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICB9O1xuXG4gIGNhZiA9IGZ1bmN0aW9uIGNhZihoYW5kbGUpIHtcbiAgICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gIH07XG59XG5cbnZhciByYWZVVUlEID0gMDtcbnZhciByYWZJZHMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGNsZWFudXAoaWQpIHtcbiAgcmFmSWRzLmRlbGV0ZShpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdyYXBwZXJSYWYoY2FsbGJhY2spIHtcbiAgdmFyIHRpbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICByYWZVVUlEICs9IDE7XG4gIHZhciBpZCA9IHJhZlVVSUQ7XG5cbiAgZnVuY3Rpb24gY2FsbFJlZihsZWZ0VGltZXMpIHtcbiAgICBpZiAobGVmdFRpbWVzID09PSAwKSB7XG4gICAgICAvLyBDbGVhbiB1cFxuICAgICAgY2xlYW51cChpZCk7IC8vIFRyaWdnZXJcblxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmV4dCByYWZcbiAgICAgIHZhciByZWFsSWQgPSByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsUmVmKGxlZnRUaW1lcyAtIDEpO1xuICAgICAgfSk7IC8vIEJpbmQgcmVhbCByYWYgaWRcblxuICAgICAgcmFmSWRzLnNldChpZCwgcmVhbElkKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUmVmKHRpbWVzKTtcbiAgcmV0dXJuIGlkO1xufVxuXG53cmFwcGVyUmFmLmNhbmNlbCA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgcmVhbElkID0gcmFmSWRzLmdldChpZCk7XG4gIGNsZWFudXAocmVhbElkKTtcbiAgcmV0dXJuIGNhZihyZWFsSWQpO1xufTsiLCIvKipcbiAqIEVhc3kgdG8gc2V0IGVsZW1lbnQgc3R5bGUsIHJldHVybiBwcmV2aW91cyBzdHlsZVxuICogSUUgYnJvd3NlciBjb21wYXRpYmxlKElFIGJyb3dzZXIgZG9lc24ndCBtZXJnZSBvdmVyZmxvdyBzdHlsZSwgbmVlZCB0byBzZXQgaXQgc2VwYXJhdGVseSlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24vaXNzdWVzLzE5MzkzXG4gKlxuICovXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgZWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/IGRvY3VtZW50LmJvZHkgOiBfb3B0aW9ucyRlbGVtZW50O1xuICB2YXIgb2xkU3R5bGUgPSB7fTtcbiAgdmFyIHN0eWxlS2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlKTsgLy8gSUUgYnJvd3NlciBjb21wYXRpYmxlXG5cbiAgc3R5bGVLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIG9sZFN0eWxlW2tleV0gPSBlbGVtZW50LnN0eWxlW2tleV07XG4gIH0pO1xuICBzdHlsZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgfSk7XG4gIHJldHVybiBvbGRTdHlsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0U3R5bGU7IiwiaW1wb3J0IGdldFNjcm9sbEJhclNpemUgZnJvbSAnLi9nZXRTY3JvbGxCYXJTaXplJztcbmltcG9ydCBzZXRTdHlsZSBmcm9tICcuL3NldFN0eWxlJztcblxuZnVuY3Rpb24gaXNCb2R5T3ZlcmZsb3dpbmcoKSB7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiYgd2luZG93LmlubmVyV2lkdGggPiBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xufVxuXG52YXIgY2FjaGVTdHlsZSA9IHt9O1xuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIChjbG9zZSkge1xuICBpZiAoIWlzQm9keU92ZXJmbG93aW5nKCkgJiYgIWNsb3NlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24vaXNzdWVzLzE5NzI5XG5cblxuICB2YXIgc2Nyb2xsaW5nRWZmZWN0Q2xhc3NOYW1lID0gJ2FudC1zY3JvbGxpbmctZWZmZWN0JztcbiAgdmFyIHNjcm9sbGluZ0VmZmVjdENsYXNzTmFtZVJlZyA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoc2Nyb2xsaW5nRWZmZWN0Q2xhc3NOYW1lKSwgJ2cnKTtcbiAgdmFyIGJvZHlDbGFzc05hbWUgPSBkb2N1bWVudC5ib2R5LmNsYXNzTmFtZTtcblxuICBpZiAoY2xvc2UpIHtcbiAgICBpZiAoIXNjcm9sbGluZ0VmZmVjdENsYXNzTmFtZVJlZy50ZXN0KGJvZHlDbGFzc05hbWUpKSByZXR1cm47XG4gICAgc2V0U3R5bGUoY2FjaGVTdHlsZSk7XG4gICAgY2FjaGVTdHlsZSA9IHt9O1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lID0gYm9keUNsYXNzTmFtZS5yZXBsYWNlKHNjcm9sbGluZ0VmZmVjdENsYXNzTmFtZVJlZywgJycpLnRyaW0oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2Nyb2xsQmFyU2l6ZSA9IGdldFNjcm9sbEJhclNpemUoKTtcblxuICBpZiAoc2Nyb2xsQmFyU2l6ZSkge1xuICAgIGNhY2hlU3R5bGUgPSBzZXRTdHlsZSh7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiBcImNhbGMoMTAwJSAtIFwiLmNvbmNhdChzY3JvbGxCYXJTaXplLCBcInB4KVwiKVxuICAgIH0pO1xuXG4gICAgaWYgKCFzY3JvbGxpbmdFZmZlY3RDbGFzc05hbWVSZWcudGVzdChib2R5Q2xhc3NOYW1lKSkge1xuICAgICAgdmFyIGFkZENsYXNzTmFtZSA9IFwiXCIuY29uY2F0KGJvZHlDbGFzc05hbWUsIFwiIFwiKS5jb25jYXQoc2Nyb2xsaW5nRWZmZWN0Q2xhc3NOYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lID0gYWRkQ2xhc3NOYW1lLnRyaW0oKTtcbiAgICB9XG4gIH1cbn0pOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcmVzaXplcl8xID0gcmVxdWlyZShcIi4vcmVzaXplclwiKTtcbnZhciBmYXN0X21lbW9pemVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZmFzdC1tZW1vaXplXCIpKTtcbnZhciBERUZBVUxUX1NJWkUgPSB7XG4gICAgd2lkdGg6ICdhdXRvJyxcbiAgICBoZWlnaHQ6ICdhdXRvJyxcbn07XG52YXIgY2xhbXAgPSBmYXN0X21lbW9pemVfMS5kZWZhdWx0KGZ1bmN0aW9uIChuLCBtaW4sIG1heCkgeyByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obiwgbWF4KSwgbWluKTsgfSk7XG52YXIgc25hcCA9IGZhc3RfbWVtb2l6ZV8xLmRlZmF1bHQoZnVuY3Rpb24gKG4sIHNpemUpIHsgcmV0dXJuIE1hdGgucm91bmQobiAvIHNpemUpICogc2l6ZTsgfSk7XG52YXIgaGFzRGlyZWN0aW9uID0gZmFzdF9tZW1vaXplXzEuZGVmYXVsdChmdW5jdGlvbiAoZGlyLCB0YXJnZXQpIHsgcmV0dXJuIG5ldyBSZWdFeHAoZGlyLCAnaScpLnRlc3QodGFyZ2V0KTsgfSk7XG52YXIgZmluZENsb3Nlc3RTbmFwID0gZmFzdF9tZW1vaXplXzEuZGVmYXVsdChmdW5jdGlvbiAobiwgc25hcEFycmF5LCBzbmFwR2FwKSB7XG4gICAgaWYgKHNuYXBHYXAgPT09IHZvaWQgMCkgeyBzbmFwR2FwID0gMDsgfVxuICAgIHZhciBjbG9zZXN0R2FwSW5kZXggPSBzbmFwQXJyYXkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpbmRleCkgeyByZXR1cm4gKE1hdGguYWJzKGN1cnIgLSBuKSA8IE1hdGguYWJzKHNuYXBBcnJheVtwcmV2XSAtIG4pID8gaW5kZXggOiBwcmV2KTsgfSwgMCk7XG4gICAgdmFyIGdhcCA9IE1hdGguYWJzKHNuYXBBcnJheVtjbG9zZXN0R2FwSW5kZXhdIC0gbik7XG4gICAgcmV0dXJuIHNuYXBHYXAgPT09IDAgfHwgZ2FwIDwgc25hcEdhcCA/IHNuYXBBcnJheVtjbG9zZXN0R2FwSW5kZXhdIDogbjtcbn0pO1xudmFyIGVuZHNXaXRoID0gZmFzdF9tZW1vaXplXzEuZGVmYXVsdChmdW5jdGlvbiAoc3RyLCBzZWFyY2hTdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cihzdHIubGVuZ3RoIC0gc2VhcmNoU3RyLmxlbmd0aCwgc2VhcmNoU3RyLmxlbmd0aCkgPT09IHNlYXJjaFN0cjtcbn0pO1xudmFyIGdldFN0cmluZ1NpemUgPSBmYXN0X21lbW9pemVfMS5kZWZhdWx0KGZ1bmN0aW9uIChuKSB7XG4gICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICBpZiAobiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBpZiAoZW5kc1dpdGgobiwgJ3B4JykpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGlmIChlbmRzV2l0aChuLCAnJScpKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBpZiAoZW5kc1dpdGgobiwgJ3ZoJykpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGlmIChlbmRzV2l0aChuLCAndncnKSkge1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgaWYgKGVuZHNXaXRoKG4sICd2bWF4JykpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGlmIChlbmRzV2l0aChuLCAndm1pbicpKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICByZXR1cm4gbiArIFwicHhcIjtcbn0pO1xudmFyIGNhbGN1bGF0ZU5ld01heCA9IGZhc3RfbWVtb2l6ZV8xLmRlZmF1bHQoZnVuY3Rpb24gKHBhcmVudFNpemUsIG1heFdpZHRoLCBtYXhIZWlnaHQsIG1pbldpZHRoLCBtaW5IZWlnaHQpIHtcbiAgICBpZiAobWF4V2lkdGggJiYgdHlwZW9mIG1heFdpZHRoID09PSAnc3RyaW5nJyAmJiBlbmRzV2l0aChtYXhXaWR0aCwgJyUnKSkge1xuICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIobWF4V2lkdGgucmVwbGFjZSgnJScsICcnKSkgLyAxMDA7XG4gICAgICAgIG1heFdpZHRoID0gcGFyZW50U2l6ZS53aWR0aCAqIHJhdGlvO1xuICAgIH1cbiAgICBpZiAobWF4SGVpZ2h0ICYmIHR5cGVvZiBtYXhIZWlnaHQgPT09ICdzdHJpbmcnICYmIGVuZHNXaXRoKG1heEhlaWdodCwgJyUnKSkge1xuICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIobWF4SGVpZ2h0LnJlcGxhY2UoJyUnLCAnJykpIC8gMTAwO1xuICAgICAgICBtYXhIZWlnaHQgPSBwYXJlbnRTaXplLmhlaWdodCAqIHJhdGlvO1xuICAgIH1cbiAgICBpZiAobWluV2lkdGggJiYgdHlwZW9mIG1pbldpZHRoID09PSAnc3RyaW5nJyAmJiBlbmRzV2l0aChtaW5XaWR0aCwgJyUnKSkge1xuICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIobWluV2lkdGgucmVwbGFjZSgnJScsICcnKSkgLyAxMDA7XG4gICAgICAgIG1pbldpZHRoID0gcGFyZW50U2l6ZS53aWR0aCAqIHJhdGlvO1xuICAgIH1cbiAgICBpZiAobWluSGVpZ2h0ICYmIHR5cGVvZiBtaW5IZWlnaHQgPT09ICdzdHJpbmcnICYmIGVuZHNXaXRoKG1pbkhlaWdodCwgJyUnKSkge1xuICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIobWluSGVpZ2h0LnJlcGxhY2UoJyUnLCAnJykpIC8gMTAwO1xuICAgICAgICBtaW5IZWlnaHQgPSBwYXJlbnRTaXplLmhlaWdodCAqIHJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXhXaWR0aDogdHlwZW9mIG1heFdpZHRoID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE51bWJlcihtYXhXaWR0aCksXG4gICAgICAgIG1heEhlaWdodDogdHlwZW9mIG1heEhlaWdodCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBOdW1iZXIobWF4SGVpZ2h0KSxcbiAgICAgICAgbWluV2lkdGg6IHR5cGVvZiBtaW5XaWR0aCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBOdW1iZXIobWluV2lkdGgpLFxuICAgICAgICBtaW5IZWlnaHQ6IHR5cGVvZiBtaW5IZWlnaHQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTnVtYmVyKG1pbkhlaWdodCksXG4gICAgfTtcbn0pO1xudmFyIGRlZmluZWRQcm9wcyA9IFtcbiAgICAnc3R5bGUnLFxuICAgICdjbGFzc05hbWUnLFxuICAgICdncmlkJyxcbiAgICAnc25hcCcsXG4gICAgJ2JvdW5kcycsXG4gICAgJ3NpemUnLFxuICAgICdkZWZhdWx0U2l6ZScsXG4gICAgJ21pbldpZHRoJyxcbiAgICAnbWluSGVpZ2h0JyxcbiAgICAnbWF4V2lkdGgnLFxuICAgICdtYXhIZWlnaHQnLFxuICAgICdsb2NrQXNwZWN0UmF0aW8nLFxuICAgICdsb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoJyxcbiAgICAnbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQnLFxuICAgICdlbmFibGUnLFxuICAgICdoYW5kbGVTdHlsZXMnLFxuICAgICdoYW5kbGVDbGFzc2VzJyxcbiAgICAnaGFuZGxlV3JhcHBlclN0eWxlJyxcbiAgICAnaGFuZGxlV3JhcHBlckNsYXNzJyxcbiAgICAnY2hpbGRyZW4nLFxuICAgICdvblJlc2l6ZVN0YXJ0JyxcbiAgICAnb25SZXNpemUnLFxuICAgICdvblJlc2l6ZVN0b3AnLFxuICAgICdoYW5kbGVDb21wb25lbnQnLFxuICAgICdzY2FsZScsXG4gICAgJ3Jlc2l6ZVJhdGlvJyxcbiAgICAnc25hcEdhcCcsXG5dO1xuLy8gSEFDSzogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSAlIHNpemUuXG52YXIgYmFzZUNsYXNzTmFtZSA9ICdfX3Jlc2l6YWJsZV9iYXNlX18nO1xudmFyIFJlc2l6YWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaXphYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc2l6YWJsZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmF0aW8gPSAxO1xuICAgICAgICBfdGhpcy5yZXNpemFibGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5leHRlbmRzUHJvcHMgPSB7fTtcbiAgICAgICAgLy8gRm9yIHBhcmVudCBib3VuZGFyeVxuICAgICAgICBfdGhpcy5wYXJlbnRMZWZ0ID0gMDtcbiAgICAgICAgX3RoaXMucGFyZW50VG9wID0gMDtcbiAgICAgICAgLy8gRm9yIGJvdW5kYXJ5XG4gICAgICAgIF90aGlzLnJlc2l6YWJsZUxlZnQgPSAwO1xuICAgICAgICBfdGhpcy5yZXNpemFibGVUb3AgPSAwO1xuICAgICAgICAvLyBGb3IgdGFyZ2V0IGJvdW5kYXJ5XG4gICAgICAgIF90aGlzLnRhcmdldExlZnQgPSAwO1xuICAgICAgICBfdGhpcy50YXJnZXRUb3AgPSAwO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzUmVzaXppbmc6IGZhbHNlLFxuICAgICAgICAgICAgcmVzaXplQ3Vyc29yOiAnYXV0bycsXG4gICAgICAgICAgICB3aWR0aDogdHlwZW9mIChfdGhpcy5wcm9wc1NpemUgJiYgX3RoaXMucHJvcHNTaXplLndpZHRoKSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/ICdhdXRvJ1xuICAgICAgICAgICAgICAgIDogX3RoaXMucHJvcHNTaXplICYmIF90aGlzLnByb3BzU2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdHlwZW9mIChfdGhpcy5wcm9wc1NpemUgJiYgX3RoaXMucHJvcHNTaXplLmhlaWdodCkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyAnYXV0bydcbiAgICAgICAgICAgICAgICA6IF90aGlzLnByb3BzU2l6ZSAmJiBfdGhpcy5wcm9wc1NpemUuaGVpZ2h0LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudXBkYXRlRXh0ZW5kc1Byb3BzKHByb3BzKTtcbiAgICAgICAgX3RoaXMub25SZXNpemVTdGFydCA9IF90aGlzLm9uUmVzaXplU3RhcnQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uTW91c2VNb3ZlID0gX3RoaXMub25Nb3VzZU1vdmUuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uTW91c2VVcCA9IF90aGlzLm9uTW91c2VVcC5iaW5kKF90aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLm9uTW91c2VVcCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBfdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF90aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzaXphYmxlLnByb3RvdHlwZSwgXCJwYXJlbnROb2RlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNpemFibGUucGFyZW50Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc2l6YWJsZS5wcm90b3R5cGUsIFwicHJvcHNTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zaXplIHx8IHRoaXMucHJvcHMuZGVmYXVsdFNpemUgfHwgREVGQVVMVF9TSVpFO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzaXphYmxlLnByb3RvdHlwZSwgXCJiYXNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbChwYXJlbnQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGlsZHJlbl8xID0gY2hpbGRyZW47IF9pIDwgY2hpbGRyZW5fMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGNoaWxkcmVuXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4uY2xhc3NMaXN0LmNvbnRhaW5zKGJhc2VDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNpemFibGUucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdXaWR0aCA9IHRoaXMucmVzaXphYmxlLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBvcmdIZWlnaHQgPSB0aGlzLnJlc2l6YWJsZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzogU2V0IHBvc2l0aW9uIGByZWxhdGl2ZWAgdG8gZ2V0IHBhcmVudCBzaXplLlxuICAgICAgICAgICAgICAgIC8vICAgICAgIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHJlLXJlc2l6YWJsZSBzZXQgYGFic29sdXRlYCwgSSBjYW4gbm90IGdldCBiYXNlIHdpZHRoIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YXIgb3JnUG9zaXRpb24gPSB0aGlzLnJlc2l6YWJsZS5zdHlsZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAob3JnUG9zaXRpb24gIT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemFibGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJTkZPOiBVc2Ugb3JpZ2luYWwgd2lkdGggb3IgaGVpZ2h0IGlmIHNldCBhdXRvLlxuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5yZXNpemFibGUuc3R5bGUud2lkdGggIT09ICdhdXRvJyA/IHRoaXMucmVzaXphYmxlLm9mZnNldFdpZHRoIDogb3JnV2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5yZXNpemFibGUuc3R5bGUuaGVpZ2h0ICE9PSAnYXV0bycgPyB0aGlzLnJlc2l6YWJsZS5vZmZzZXRIZWlnaHQgOiBvcmdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXphYmxlLnN0eWxlLnBvc2l0aW9uID0gb3JnUG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNpemFibGUucHJvdG90eXBlLCBcInNpemVTdHlsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5wcm9wcy5zaXplO1xuICAgICAgICAgICAgdmFyIGdldFNpemUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5zdGF0ZVtrZXldID09PSAndW5kZWZpbmVkJyB8fCBfdGhpcy5zdGF0ZVtrZXldID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhdXRvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzU2l6ZSAmJiBfdGhpcy5wcm9wc1NpemVba2V5XSAmJiBlbmRzV2l0aChfdGhpcy5wcm9wc1NpemVba2V5XS50b1N0cmluZygpLCAnJScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aChfdGhpcy5zdGF0ZVtrZXldLnRvU3RyaW5nKCksICclJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdGF0ZVtrZXldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFNpemUgPSBfdGhpcy5nZXRQYXJlbnRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihfdGhpcy5zdGF0ZVtrZXldLnRvU3RyaW5nKCkucmVwbGFjZSgncHgnLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9ICh2YWx1ZSAvIHBhcmVudFNpemVba2V5XSkgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwZXJjZW50ICsgXCIlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdHJpbmdTaXplKF90aGlzLnN0YXRlW2tleV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNpemUgJiYgdHlwZW9mIHNpemUud2lkdGggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0YXRlLmlzUmVzaXppbmdcbiAgICAgICAgICAgICAgICA/IGdldFN0cmluZ1NpemUoc2l6ZS53aWR0aClcbiAgICAgICAgICAgICAgICA6IGdldFNpemUoJ3dpZHRoJyk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2l6ZSAmJiB0eXBlb2Ygc2l6ZS5oZWlnaHQgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0YXRlLmlzUmVzaXppbmdcbiAgICAgICAgICAgICAgICA/IGdldFN0cmluZ1NpemUoc2l6ZS5oZWlnaHQpXG4gICAgICAgICAgICAgICAgOiBnZXRTaXplKCdoZWlnaHQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS51cGRhdGVFeHRlbmRzUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdGhpcy5leHRlbmRzUHJvcHMgPSBPYmplY3Qua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgaWYgKGRlZmluZWRQcm9wcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUuZ2V0UGFyZW50U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJhc2UgfHwgIXRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLCBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIElORk86IFRvIGNhbGN1bGF0ZSBwYXJlbnQgd2lkdGggd2l0aCBmbGV4IGxheW91dFxuICAgICAgICB2YXIgd3JhcENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHdyYXAgPSB0aGlzLnBhcmVudE5vZGUuc3R5bGUuZmxleFdyYXA7XG4gICAgICAgIHZhciBtaW5XaWR0aCA9IHRoaXMuYmFzZS5zdHlsZS5taW5XaWR0aDtcbiAgICAgICAgaWYgKHdyYXAgIT09ICd3cmFwJykge1xuICAgICAgICAgICAgd3JhcENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnN0eWxlLmZsZXhXcmFwID0gJ3dyYXAnO1xuICAgICAgICAgICAgLy8gSEFDSzogVXNlIHJlbGF0aXZlIHRvIGdldCBwYXJlbnQgcGFkZGluZyBzaXplXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXNlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgdGhpcy5iYXNlLnN0eWxlLm1pbldpZHRoID0gJzEwMCUnO1xuICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmJhc2Uub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYmFzZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFzZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGlmICh3cmFwQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnN0eWxlLmZsZXhXcmFwID0gd3JhcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhc2Uuc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnN0YXRlLndpZHRoIHx8IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHQgfHwgdGhpcy5zaXplLmhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDAsIDApJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmZsZXggPSAnMCc7XG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGJhc2VDbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gYmFzZUNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVuZHNQcm9wcyhuZXh0KTtcbiAgICB9O1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5iYXNlIHx8ICFwYXJlbnRfMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHBhcmVudF8xIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8ICEodGhpcy5iYXNlIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRfMS5yZW1vdmVDaGlsZCh0aGlzLmJhc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLmNyZWF0ZVNpemVGb3JDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdTaXplLCBraW5kKSB7XG4gICAgICAgIHZhciBwcm9wc1NpemUgPSB0aGlzLnByb3BzU2l6ZSAmJiB0aGlzLnByb3BzU2l6ZVtraW5kXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVba2luZF0gPT09ICdhdXRvJyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vcmlnaW5hbFtraW5kXSA9PT0gbmV3U2l6ZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBwcm9wc1NpemUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzU2l6ZSA9PT0gJ2F1dG8nKVxuICAgICAgICAgICAgPyAnYXV0bydcbiAgICAgICAgICAgIDogbmV3U2l6ZTtcbiAgICB9O1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUuY2FsY3VsYXRlTmV3TWF4RnJvbUJvdW5kYXJ5ID0gZnVuY3Rpb24gKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSAncGFyZW50Jykge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8yID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudF8yIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRXaWR0aCA9IHBhcmVudF8yLm9mZnNldFdpZHRoICsgKHRoaXMucGFyZW50TGVmdCAtIHRoaXMucmVzaXphYmxlTGVmdCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kSGVpZ2h0ID0gcGFyZW50XzIub2Zmc2V0SGVpZ2h0ICsgKHRoaXMucGFyZW50VG9wIC0gdGhpcy5yZXNpemFibGVUb3ApO1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gbWF4V2lkdGggJiYgbWF4V2lkdGggPCBib3VuZFdpZHRoID8gbWF4V2lkdGggOiBib3VuZFdpZHRoO1xuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IG1heEhlaWdodCAmJiBtYXhIZWlnaHQgPCBib3VuZEhlaWdodCA/IG1heEhlaWdodCA6IGJvdW5kSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIHRoaXMucmVzaXphYmxlTGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZVRvcDtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IG1heFdpZHRoICYmIG1heFdpZHRoIDwgYm91bmRXaWR0aCA/IG1heFdpZHRoIDogYm91bmRXaWR0aDtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBtYXhIZWlnaHQgJiYgbWF4SGVpZ2h0IDwgYm91bmRIZWlnaHQgPyBtYXhIZWlnaHQgOiBib3VuZEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYm91bmRXaWR0aCA9IHRoaXMucHJvcHMuYm91bmRzLm9mZnNldFdpZHRoICsgKHRoaXMudGFyZ2V0TGVmdCAtIHRoaXMucmVzaXphYmxlTGVmdCk7XG4gICAgICAgICAgICB2YXIgYm91bmRIZWlnaHQgPSB0aGlzLnByb3BzLmJvdW5kcy5vZmZzZXRIZWlnaHQgKyAodGhpcy50YXJnZXRUb3AgLSB0aGlzLnJlc2l6YWJsZVRvcCk7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IG1heFdpZHRoICYmIG1heFdpZHRoIDwgYm91bmRXaWR0aCA/IG1heFdpZHRoIDogYm91bmRXaWR0aDtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IG1heEhlaWdodCAmJiBtYXhIZWlnaHQgPCBib3VuZEhlaWdodCA/IG1heEhlaWdodCA6IGJvdW5kSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfTtcbiAgICB9O1xuICAgIFJlc2l6YWJsZS5wcm90b3R5cGUuY2FsY3VsYXRlTmV3U2l6ZUZyb21EaXJlY3Rpb24gPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlIHx8IDE7XG4gICAgICAgIHZhciByZXNpemVSYXRpbyA9IHRoaXMucHJvcHMucmVzaXplUmF0aW8gfHwgMTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uLCBvcmlnaW5hbCA9IF9hLm9yaWdpbmFsO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCBsb2NrQXNwZWN0UmF0aW8gPSBfYi5sb2NrQXNwZWN0UmF0aW8sIGxvY2tBc3BlY3RSYXRpb0V4dHJhSGVpZ2h0ID0gX2IubG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQsIGxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGggPSBfYi5sb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoO1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBvcmlnaW5hbC53aWR0aDtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IG9yaWdpbmFsLmhlaWdodDtcbiAgICAgICAgdmFyIGV4dHJhSGVpZ2h0ID0gbG9ja0FzcGVjdFJhdGlvRXh0cmFIZWlnaHQgfHwgMDtcbiAgICAgICAgdmFyIGV4dHJhV2lkdGggPSBsb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoIHx8IDA7XG4gICAgICAgIGlmIChoYXNEaXJlY3Rpb24oJ3JpZ2h0JywgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgbmV3V2lkdGggPSBvcmlnaW5hbC53aWR0aCArICgoY2xpZW50WCAtIG9yaWdpbmFsLngpICogcmVzaXplUmF0aW8pIC8gc2NhbGU7XG4gICAgICAgICAgICBpZiAobG9ja0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gKG5ld1dpZHRoIC0gZXh0cmFXaWR0aCkgLyB0aGlzLnJhdGlvICsgZXh0cmFIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RpcmVjdGlvbignbGVmdCcsIGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gb3JpZ2luYWwud2lkdGggLSAoKGNsaWVudFggLSBvcmlnaW5hbC54KSAqIHJlc2l6ZVJhdGlvKSAvIHNjYWxlO1xuICAgICAgICAgICAgaWYgKGxvY2tBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IChuZXdXaWR0aCAtIGV4dHJhV2lkdGgpIC8gdGhpcy5yYXRpbyArIGV4dHJhSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEaXJlY3Rpb24oJ2JvdHRvbScsIGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IG9yaWdpbmFsLmhlaWdodCArICgoY2xpZW50WSAtIG9yaWdpbmFsLnkpICogcmVzaXplUmF0aW8pIC8gc2NhbGU7XG4gICAgICAgICAgICBpZiAobG9ja0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSAobmV3SGVpZ2h0IC0gZXh0cmFIZWlnaHQpICogdGhpcy5yYXRpbyArIGV4dHJhV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RpcmVjdGlvbigndG9wJywgZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gb3JpZ2luYWwuaGVpZ2h0IC0gKChjbGllbnRZIC0gb3JpZ2luYWwueSkgKiByZXNpemVSYXRpbykgLyBzY2FsZTtcbiAgICAgICAgICAgIGlmIChsb2NrQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCA9IChuZXdIZWlnaHQgLSBleHRyYUhlaWdodCkgKiB0aGlzLnJhdGlvICsgZXh0cmFXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBuZXdXaWR0aDogbmV3V2lkdGgsIG5ld0hlaWdodDogbmV3SGVpZ2h0IH07XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLmNhbGN1bGF0ZU5ld1NpemVGcm9tQXNwZWN0UmF0aW8gPSBmdW5jdGlvbiAobmV3V2lkdGgsIG5ld0hlaWdodCwgbWF4LCBtaW4pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbG9ja0FzcGVjdFJhdGlvID0gX2EubG9ja0FzcGVjdFJhdGlvLCBsb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodCA9IF9hLmxvY2tBc3BlY3RSYXRpb0V4dHJhSGVpZ2h0LCBsb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoID0gX2EubG9ja0FzcGVjdFJhdGlvRXh0cmFXaWR0aDtcbiAgICAgICAgdmFyIGNvbXB1dGVkTWluV2lkdGggPSB0eXBlb2YgbWluLndpZHRoID09PSAndW5kZWZpbmVkJyA/IDEwIDogbWluLndpZHRoO1xuICAgICAgICB2YXIgY29tcHV0ZWRNYXhXaWR0aCA9IHR5cGVvZiBtYXgud2lkdGggPT09ICd1bmRlZmluZWQnIHx8IG1heC53aWR0aCA8IDAgPyBuZXdXaWR0aCA6IG1heC53aWR0aDtcbiAgICAgICAgdmFyIGNvbXB1dGVkTWluSGVpZ2h0ID0gdHlwZW9mIG1pbi5oZWlnaHQgPT09ICd1bmRlZmluZWQnID8gMTAgOiBtaW4uaGVpZ2h0O1xuICAgICAgICB2YXIgY29tcHV0ZWRNYXhIZWlnaHQgPSB0eXBlb2YgbWF4LmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWF4LmhlaWdodCA8IDAgPyBuZXdIZWlnaHQgOiBtYXguaGVpZ2h0O1xuICAgICAgICB2YXIgZXh0cmFIZWlnaHQgPSBsb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodCB8fCAwO1xuICAgICAgICB2YXIgZXh0cmFXaWR0aCA9IGxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGggfHwgMDtcbiAgICAgICAgaWYgKGxvY2tBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgdmFyIGV4dHJhTWluV2lkdGggPSAoY29tcHV0ZWRNaW5IZWlnaHQgLSBleHRyYUhlaWdodCkgKiB0aGlzLnJhdGlvICsgZXh0cmFXaWR0aDtcbiAgICAgICAgICAgIHZhciBleHRyYU1heFdpZHRoID0gKGNvbXB1dGVkTWF4SGVpZ2h0IC0gZXh0cmFIZWlnaHQpICogdGhpcy5yYXRpbyArIGV4dHJhV2lkdGg7XG4gICAgICAgICAgICB2YXIgZXh0cmFNaW5IZWlnaHQgPSAoY29tcHV0ZWRNaW5XaWR0aCAtIGV4dHJhV2lkdGgpIC8gdGhpcy5yYXRpbyArIGV4dHJhSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGV4dHJhTWF4SGVpZ2h0ID0gKGNvbXB1dGVkTWF4V2lkdGggLSBleHRyYVdpZHRoKSAvIHRoaXMucmF0aW8gKyBleHRyYUhlaWdodDtcbiAgICAgICAgICAgIHZhciBsb2NrZWRNaW5XaWR0aCA9IE1hdGgubWF4KGNvbXB1dGVkTWluV2lkdGgsIGV4dHJhTWluV2lkdGgpO1xuICAgICAgICAgICAgdmFyIGxvY2tlZE1heFdpZHRoID0gTWF0aC5taW4oY29tcHV0ZWRNYXhXaWR0aCwgZXh0cmFNYXhXaWR0aCk7XG4gICAgICAgICAgICB2YXIgbG9ja2VkTWluSGVpZ2h0ID0gTWF0aC5tYXgoY29tcHV0ZWRNaW5IZWlnaHQsIGV4dHJhTWluSGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBsb2NrZWRNYXhIZWlnaHQgPSBNYXRoLm1pbihjb21wdXRlZE1heEhlaWdodCwgZXh0cmFNYXhIZWlnaHQpO1xuICAgICAgICAgICAgbmV3V2lkdGggPSBjbGFtcChuZXdXaWR0aCwgbG9ja2VkTWluV2lkdGgsIGxvY2tlZE1heFdpZHRoKTtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IGNsYW1wKG5ld0hlaWdodCwgbG9ja2VkTWluSGVpZ2h0LCBsb2NrZWRNYXhIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3V2lkdGggPSBjbGFtcChuZXdXaWR0aCwgY29tcHV0ZWRNaW5XaWR0aCwgY29tcHV0ZWRNYXhXaWR0aCk7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBjbGFtcChuZXdIZWlnaHQsIGNvbXB1dGVkTWluSGVpZ2h0LCBjb21wdXRlZE1heEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbmV3V2lkdGg6IG5ld1dpZHRoLCBuZXdIZWlnaHQ6IG5ld0hlaWdodCB9O1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5zZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZvciBwYXJlbnQgYm91bmRhcnlcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzID09PSAncGFyZW50Jykge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8zID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudF8zIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHBhcmVudF8zLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TGVmdCA9IHBhcmVudFJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvcCA9IHBhcmVudFJlY3QudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZvciB0YXJnZXQoaHRtbCBlbGVtZW50KSBib3VuZGFyeVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFJlY3QgPSB0aGlzLnByb3BzLmJvdW5kcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0TGVmdCA9IHRhcmdldFJlY3QubGVmdDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0VG9wID0gdGFyZ2V0UmVjdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGJvdW5kYXJ5XG4gICAgICAgIGlmICh0aGlzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5yZXNpemFibGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYS5sZWZ0LCB0b3BfMSA9IF9hLnRvcDtcbiAgICAgICAgICAgIHRoaXMucmVzaXphYmxlTGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJlc2l6YWJsZVRvcCA9IHRvcF8xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLm9uUmVzaXplU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgY2xpZW50WCA9IDA7XG4gICAgICAgIHZhciBjbGllbnRZID0gMDtcbiAgICAgICAgaWYgKGV2ZW50Lm5hdGl2ZUV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgICAgICAgY2xpZW50WCA9IGV2ZW50Lm5hdGl2ZUV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICBjbGllbnRZID0gZXZlbnQubmF0aXZlRXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgIC8vIFdoZW4gdXNlciBjbGljayB3aXRoIHJpZ2h0IGJ1dHRvbiB0aGUgcmVzaXplIGlzIHN0dWNrIGluIHJlc2l6aW5nIG1vZGVcbiAgICAgICAgICAgIC8vIHVudGlsIHVzZXJzIGNsaWNrcyBhZ2FpbiwgZG9udCBjb250aW51ZSBpZiByaWdodCBjbGljayBpcyB1c2VkLlxuICAgICAgICAgICAgLy8gSEFDSzogTW91c2VFdmVudCBkb2VzIG5vdCBoYXZlIGB3aGljaGAgZnJvbSBmbG93LWJpbiB2MC42OC5cbiAgICAgICAgICAgIGlmIChldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5uYXRpdmVFdmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGNsaWVudFggPSBldmVudC5uYXRpdmVFdmVudC50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICBjbGllbnRZID0gZXZlbnQubmF0aXZlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uUmVzaXplU3RhcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdGFydChldmVudCwgZGlyZWN0aW9uLCB0aGlzLnJlc2l6YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRml4ICMxNjhcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLnNpemUuaGVpZ2h0ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLnByb3BzLnNpemUuaGVpZ2h0ICE9PSB0aGlzLnN0YXRlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoZWlnaHQ6IHRoaXMucHJvcHMuc2l6ZS5oZWlnaHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuc2l6ZS53aWR0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5wcm9wcy5zaXplLndpZHRoICE9PSB0aGlzLnN0YXRlLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiB0aGlzLnByb3BzLnNpemUud2lkdGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGxvY2tBc3BlY3RSYXRpbyBjYXNlXG4gICAgICAgIHRoaXMucmF0aW8gPVxuICAgICAgICAgICAgdHlwZW9mIHRoaXMucHJvcHMubG9ja0FzcGVjdFJhdGlvID09PSAnbnVtYmVyJyA/IHRoaXMucHJvcHMubG9ja0FzcGVjdFJhdGlvIDogdGhpcy5zaXplLndpZHRoIC8gdGhpcy5zaXplLmhlaWdodDtcbiAgICAgICAgLy8gRm9yIGJvdW5kYXJ5XG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGNsaWVudFksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZXNpemluZzogdHJ1ZSxcbiAgICAgICAgICAgIHJlc2l6ZUN1cnNvcjogd2luZG93LmdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3IgfHwgJ2F1dG8nLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaXNSZXNpemluZyB8fCAhdGhpcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBtYXhXaWR0aCA9IF9hLm1heFdpZHRoLCBtYXhIZWlnaHQgPSBfYS5tYXhIZWlnaHQsIG1pbldpZHRoID0gX2EubWluV2lkdGgsIG1pbkhlaWdodCA9IF9hLm1pbkhlaWdodDtcbiAgICAgICAgdmFyIGNsaWVudFggPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB2YXIgY2xpZW50WSA9IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCA/IGV2ZW50LmNsaWVudFkgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuc3RhdGUsIGRpcmVjdGlvbiA9IF9iLmRpcmVjdGlvbiwgb3JpZ2luYWwgPSBfYi5vcmlnaW5hbCwgd2lkdGggPSBfYi53aWR0aCwgaGVpZ2h0ID0gX2IuaGVpZ2h0O1xuICAgICAgICB2YXIgcGFyZW50U2l6ZSA9IHRoaXMuZ2V0UGFyZW50U2l6ZSgpO1xuICAgICAgICB2YXIgbWF4ID0gY2FsY3VsYXRlTmV3TWF4KHBhcmVudFNpemUsIG1heFdpZHRoLCBtYXhIZWlnaHQsIG1pbldpZHRoLCBtaW5IZWlnaHQpO1xuICAgICAgICBtYXhXaWR0aCA9IG1heC5tYXhXaWR0aDtcbiAgICAgICAgbWF4SGVpZ2h0ID0gbWF4Lm1heEhlaWdodDtcbiAgICAgICAgbWluV2lkdGggPSBtYXgubWluV2lkdGg7XG4gICAgICAgIG1pbkhlaWdodCA9IG1heC5taW5IZWlnaHQ7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc2l6ZVxuICAgICAgICB2YXIgX2MgPSB0aGlzLmNhbGN1bGF0ZU5ld1NpemVGcm9tRGlyZWN0aW9uKGNsaWVudFgsIGNsaWVudFkpLCBuZXdIZWlnaHQgPSBfYy5uZXdIZWlnaHQsIG5ld1dpZHRoID0gX2MubmV3V2lkdGg7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXggc2l6ZSBmcm9tIGJvdW5kYXJ5IHNldHRpbmdzXG4gICAgICAgIHZhciBib3VuZGFyeU1heCA9IHRoaXMuY2FsY3VsYXRlTmV3TWF4RnJvbUJvdW5kYXJ5KG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHNpemUgZnJvbSBhc3BlY3QgcmF0aW9cbiAgICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLmNhbGN1bGF0ZU5ld1NpemVGcm9tQXNwZWN0UmF0aW8obmV3V2lkdGgsIG5ld0hlaWdodCwgeyB3aWR0aDogYm91bmRhcnlNYXgubWF4V2lkdGgsIGhlaWdodDogYm91bmRhcnlNYXgubWF4SGVpZ2h0IH0sIHsgd2lkdGg6IG1pbldpZHRoLCBoZWlnaHQ6IG1pbkhlaWdodCB9KTtcbiAgICAgICAgbmV3V2lkdGggPSBuZXdTaXplLm5ld1dpZHRoO1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdTaXplLm5ld0hlaWdodDtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZ3JpZCkge1xuICAgICAgICAgICAgdmFyIG5ld0dyaWRXaWR0aCA9IHNuYXAobmV3V2lkdGgsIHRoaXMucHJvcHMuZ3JpZFswXSk7XG4gICAgICAgICAgICB2YXIgbmV3R3JpZEhlaWdodCA9IHNuYXAobmV3SGVpZ2h0LCB0aGlzLnByb3BzLmdyaWRbMV0pO1xuICAgICAgICAgICAgdmFyIGdhcCA9IHRoaXMucHJvcHMuc25hcEdhcCB8fCAwO1xuICAgICAgICAgICAgbmV3V2lkdGggPSBnYXAgPT09IDAgfHwgTWF0aC5hYnMobmV3R3JpZFdpZHRoIC0gbmV3V2lkdGgpIDw9IGdhcCA/IG5ld0dyaWRXaWR0aCA6IG5ld1dpZHRoO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gZ2FwID09PSAwIHx8IE1hdGguYWJzKG5ld0dyaWRIZWlnaHQgLSBuZXdIZWlnaHQpIDw9IGdhcCA/IG5ld0dyaWRIZWlnaHQgOiBuZXdIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc25hcCAmJiB0aGlzLnByb3BzLnNuYXAueCkge1xuICAgICAgICAgICAgbmV3V2lkdGggPSBmaW5kQ2xvc2VzdFNuYXAobmV3V2lkdGgsIHRoaXMucHJvcHMuc25hcC54LCB0aGlzLnByb3BzLnNuYXBHYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNuYXAgJiYgdGhpcy5wcm9wcy5zbmFwLnkpIHtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IGZpbmRDbG9zZXN0U25hcChuZXdIZWlnaHQsIHRoaXMucHJvcHMuc25hcC55LCB0aGlzLnByb3BzLnNuYXBHYXApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCAtIG9yaWdpbmFsLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQgLSBvcmlnaW5hbC5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh3aWR0aCAmJiB0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGgod2lkdGgsICclJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IChuZXdXaWR0aCAvIHBhcmVudFNpemUud2lkdGgpICogMTAwO1xuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gcGVyY2VudCArIFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kc1dpdGgod2lkdGgsICd2dycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZ3ID0gKG5ld1dpZHRoIC8gd2luZG93LmlubmVyV2lkdGgpICogMTAwO1xuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gdncgKyBcInZ3XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRzV2l0aCh3aWR0aCwgJ3ZoJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmggPSAobmV3V2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQpICogMTAwO1xuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gdmggKyBcInZoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCAmJiB0eXBlb2YgaGVpZ2h0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuZHNXaXRoKGhlaWdodCwgJyUnKSkge1xuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gKG5ld0hlaWdodCAvIHBhcmVudFNpemUuaGVpZ2h0KSAqIDEwMDtcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBwZXJjZW50ICsgXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmRzV2l0aChoZWlnaHQsICd2dycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZ3ID0gKG5ld0hlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDEwMDtcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB2dyArIFwidndcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZHNXaXRoKGhlaWdodCwgJ3ZoJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmggPSAobmV3SGVpZ2h0IC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDEwMDtcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB2aCArIFwidmhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNyZWF0ZVNpemVGb3JDc3NQcm9wZXJ0eShuZXdXaWR0aCwgJ3dpZHRoJyksXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY3JlYXRlU2l6ZUZvckNzc1Byb3BlcnR5KG5ld0hlaWdodCwgJ2hlaWdodCcpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25SZXNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemUoZXZlbnQsIGRpcmVjdGlvbiwgdGhpcy5yZXNpemFibGUsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgaXNSZXNpemluZyA9IF9hLmlzUmVzaXppbmcsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbiwgb3JpZ2luYWwgPSBfYS5vcmlnaW5hbDtcbiAgICAgICAgaWYgKCFpc1Jlc2l6aW5nIHx8ICF0aGlzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGggLSBvcmlnaW5hbC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5zaXplLmhlaWdodCAtIG9yaWdpbmFsLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25SZXNpemVTdG9wKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplU3RvcChldmVudCwgZGlyZWN0aW9uLCB0aGlzLnJlc2l6YWJsZSwgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5wcm9wcy5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNSZXNpemluZzogZmFsc2UsIHJlc2l6ZUN1cnNvcjogJ2F1dG8nIH0pO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiBzaXplLndpZHRoLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IH0pO1xuICAgIH07XG4gICAgUmVzaXphYmxlLnByb3RvdHlwZS5yZW5kZXJSZXNpemVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBlbmFibGUgPSBfYS5lbmFibGUsIGhhbmRsZVN0eWxlcyA9IF9hLmhhbmRsZVN0eWxlcywgaGFuZGxlQ2xhc3NlcyA9IF9hLmhhbmRsZUNsYXNzZXMsIGhhbmRsZVdyYXBwZXJTdHlsZSA9IF9hLmhhbmRsZVdyYXBwZXJTdHlsZSwgaGFuZGxlV3JhcHBlckNsYXNzID0gX2EuaGFuZGxlV3JhcHBlckNsYXNzLCBoYW5kbGVDb21wb25lbnQgPSBfYS5oYW5kbGVDb21wb25lbnQ7XG4gICAgICAgIGlmICghZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzaXplcnMgPSBPYmplY3Qua2V5cyhlbmFibGUpLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlW2Rpcl0gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KHJlc2l6ZXJfMS5SZXNpemVyLCB7IGtleTogZGlyLCBkaXJlY3Rpb246IGRpciwgb25SZXNpemVTdGFydDogX3RoaXMub25SZXNpemVTdGFydCwgcmVwbGFjZVN0eWxlczogaGFuZGxlU3R5bGVzICYmIGhhbmRsZVN0eWxlc1tkaXJdLCBjbGFzc05hbWU6IGhhbmRsZUNsYXNzZXMgJiYgaGFuZGxlQ2xhc3Nlc1tkaXJdIH0sIGhhbmRsZUNvbXBvbmVudCAmJiBoYW5kbGVDb21wb25lbnRbZGlyXSA/IGhhbmRsZUNvbXBvbmVudFtkaXJdIDogbnVsbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAjOTMgV3JhcCB0aGUgcmVzaXplIGJveCBpbiBzcGFuICh3aWxsIG5vdCBicmVhayAxMDAlIHdpZHRoL2hlaWdodClcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogaGFuZGxlV3JhcHBlckNsYXNzLCBzdHlsZTogaGFuZGxlV3JhcHBlclN0eWxlIH0sIHJlc2l6ZXJzKSk7XG4gICAgfTtcbiAgICBSZXNpemFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHsgcmVmOiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6YWJsZSA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgc3R5bGU6IF9fYXNzaWduKHsgcG9zaXRpb246ICdyZWxhdGl2ZScsIHVzZXJTZWxlY3Q6IHRoaXMuc3RhdGUuaXNSZXNpemluZyA/ICdub25lJyA6ICdhdXRvJyB9LCB0aGlzLnByb3BzLnN0eWxlLCB0aGlzLnNpemVTdHlsZSwgeyBtYXhXaWR0aDogdGhpcy5wcm9wcy5tYXhXaWR0aCwgbWF4SGVpZ2h0OiB0aGlzLnByb3BzLm1heEhlaWdodCwgbWluV2lkdGg6IHRoaXMucHJvcHMubWluV2lkdGgsIG1pbkhlaWdodDogdGhpcy5wcm9wcy5taW5IZWlnaHQsIGJveFNpemluZzogJ2JvcmRlci1ib3gnIH0pLCBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lIH0sIHRoaXMuZXh0ZW5kc1Byb3BzKSxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaXNSZXNpemluZyAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcIlwiICsgKHRoaXMuc3RhdGUucmVzaXplQ3Vyc29yIHx8ICdhdXRvJyksXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDk5OTksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJzAnLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogJzAnLFxuICAgICAgICAgICAgICAgIH0gfSkpLFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUmVzaXplcigpKSk7XG4gICAgfTtcbiAgICBSZXNpemFibGUuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBvblJlc2l6ZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIG9uUmVzaXplU3RvcDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBlbmFibGU6IHtcbiAgICAgICAgICAgIHRvcDogdHJ1ZSxcbiAgICAgICAgICAgIHJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgYm90dG9tOiB0cnVlLFxuICAgICAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgICAgIHRvcFJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgYm90dG9tUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICBib3R0b21MZWZ0OiB0cnVlLFxuICAgICAgICAgICAgdG9wTGVmdDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHt9LFxuICAgICAgICBncmlkOiBbMSwgMV0sXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpb0V4dHJhV2lkdGg6IDAsXG4gICAgICAgIGxvY2tBc3BlY3RSYXRpb0V4dHJhSGVpZ2h0OiAwLFxuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgcmVzaXplUmF0aW86IDEsXG4gICAgICAgIHNuYXBHYXA6IDAsXG4gICAgfTtcbiAgICByZXR1cm4gUmVzaXphYmxlO1xufShSZWFjdC5Db21wb25lbnQpKTtcbmV4cG9ydHMuUmVzaXphYmxlID0gUmVzaXphYmxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgc3R5bGVzID0ge1xuICAgIHRvcDoge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMHB4JyxcbiAgICAgICAgdG9wOiAnLTVweCcsXG4gICAgICAgIGxlZnQ6ICcwcHgnLFxuICAgICAgICBjdXJzb3I6ICdyb3ctcmVzaXplJyxcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICAgIHdpZHRoOiAnMTBweCcsXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICB0b3A6ICcwcHgnLFxuICAgICAgICByaWdodDogJy01cHgnLFxuICAgICAgICBjdXJzb3I6ICdjb2wtcmVzaXplJyxcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMHB4JyxcbiAgICAgICAgYm90dG9tOiAnLTVweCcsXG4gICAgICAgIGxlZnQ6ICcwcHgnLFxuICAgICAgICBjdXJzb3I6ICdyb3ctcmVzaXplJyxcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgICAgd2lkdGg6ICcxMHB4JyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIHRvcDogJzBweCcsXG4gICAgICAgIGxlZnQ6ICctNXB4JyxcbiAgICAgICAgY3Vyc29yOiAnY29sLXJlc2l6ZScsXG4gICAgfSxcbiAgICB0b3BSaWdodDoge1xuICAgICAgICB3aWR0aDogJzIwcHgnLFxuICAgICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAnLTEwcHgnLFxuICAgICAgICB0b3A6ICctMTBweCcsXG4gICAgICAgIGN1cnNvcjogJ25lLXJlc2l6ZScsXG4gICAgfSxcbiAgICBib3R0b21SaWdodDoge1xuICAgICAgICB3aWR0aDogJzIwcHgnLFxuICAgICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAnLTEwcHgnLFxuICAgICAgICBib3R0b206ICctMTBweCcsXG4gICAgICAgIGN1cnNvcjogJ3NlLXJlc2l6ZScsXG4gICAgfSxcbiAgICBib3R0b21MZWZ0OiB7XG4gICAgICAgIHdpZHRoOiAnMjBweCcsXG4gICAgICAgIGhlaWdodDogJzIwcHgnLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogJy0xMHB4JyxcbiAgICAgICAgYm90dG9tOiAnLTEwcHgnLFxuICAgICAgICBjdXJzb3I6ICdzdy1yZXNpemUnLFxuICAgIH0sXG4gICAgdG9wTGVmdDoge1xuICAgICAgICB3aWR0aDogJzIwcHgnLFxuICAgICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGxlZnQ6ICctMTBweCcsXG4gICAgICAgIHRvcDogJy0xMHB4JyxcbiAgICAgICAgY3Vyc29yOiAnbnctcmVzaXplJyxcbiAgICB9LFxufTtcbmZ1bmN0aW9uIFJlc2l6ZXIocHJvcHMpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSB8fCAnJywgc3R5bGU6IF9fYXNzaWduKHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHVzZXJTZWxlY3Q6ICdub25lJyB9LCBzdHlsZXNbcHJvcHMuZGlyZWN0aW9uXSwgKHByb3BzLnJlcGxhY2VTdHlsZXMgfHwge30pKSwgb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBwcm9wcy5vblJlc2l6ZVN0YXJ0KGUsIHByb3BzLmRpcmVjdGlvbik7XG4gICAgICAgIH0sIG9uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHByb3BzLm9uUmVzaXplU3RhcnQoZSwgcHJvcHMuZGlyZWN0aW9uKTtcbiAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxuZXhwb3J0cy5SZXNpemVyID0gUmVzaXplcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQoUmVhY3QpO1xuXG52YXIgVUFQYXJzZXIgPSByZXF1aXJlKCd1YS1wYXJzZXItanMvZGlzdC91YS1wYXJzZXIubWluJyk7XG5cbnZhciBVQSA9IG5ldyBVQVBhcnNlcigpO1xudmFyIGJyb3dzZXIgPSBVQS5nZXRCcm93c2VyKCk7XG52YXIgY3B1ID0gVUEuZ2V0Q1BVKCk7XG52YXIgZGV2aWNlID0gVUEuZ2V0RGV2aWNlKCk7XG52YXIgZW5naW5lID0gVUEuZ2V0RW5naW5lKCk7XG52YXIgb3MgPSBVQS5nZXRPUygpO1xudmFyIHVhID0gVUEuZ2V0VUEoKTtcblxudmFyIHNldERlZmF1bHRzID0gZnVuY3Rpb24gc2V0RGVmYXVsdHMocCkge1xuICB2YXIgZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ25vbmUnO1xuICByZXR1cm4gcCA/IHAgOiBkO1xufTtcbnZhciBnZXROYXZpZ2F0b3JJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldE5hdmlnYXRvckluc3RhbmNlKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAod2luZG93Lm5hdmlnYXRvciB8fCBuYXZpZ2F0b3IpIHtcbiAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yIHx8IG5hdmlnYXRvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzSU9TMTNDaGVjayA9IGZ1bmN0aW9uIGlzSU9TMTNDaGVjayh0eXBlKSB7XG4gIHZhciBuYXYgPSBnZXROYXZpZ2F0b3JJbnN0YW5jZSgpO1xuICByZXR1cm4gbmF2ICYmIG5hdi5wbGF0Zm9ybSAmJiAobmF2LnBsYXRmb3JtLmluZGV4T2YodHlwZSkgIT09IC0xIHx8IG5hdi5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiBuYXYubWF4VG91Y2hQb2ludHMgPiAxICYmICF3aW5kb3cuTVNTdHJlYW0pO1xufTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxudmFyIERFVklDRV9UWVBFUyA9IHtcbiAgTU9CSUxFOiAnbW9iaWxlJyxcbiAgVEFCTEVUOiAndGFibGV0JyxcbiAgU01BUlRfVFY6ICdzbWFydHR2JyxcbiAgQ09OU09MRTogJ2NvbnNvbGUnLFxuICBXRUFSQUJMRTogJ3dlYXJhYmxlJyxcbiAgQlJPV1NFUjogdW5kZWZpbmVkXG59O1xudmFyIEJST1dTRVJfVFlQRVMgPSB7XG4gIENIUk9NRTogJ0Nocm9tZScsXG4gIEZJUkVGT1g6IFwiRmlyZWZveFwiLFxuICBPUEVSQTogXCJPcGVyYVwiLFxuICBZQU5ERVg6IFwiWWFuZGV4XCIsXG4gIFNBRkFSSTogXCJTYWZhcmlcIixcbiAgSU5URVJORVRfRVhQTE9SRVI6IFwiSW50ZXJuZXQgRXhwbG9yZXJcIixcbiAgRURHRTogXCJFZGdlXCIsXG4gIENIUk9NSVVNOiBcIkNocm9taXVtXCIsXG4gIElFOiAnSUUnLFxuICBNT0JJTEVfU0FGQVJJOiBcIk1vYmlsZSBTYWZhcmlcIixcbiAgRURHRV9DSFJPTUlVTTogXCJFZGdlIENocm9taXVtXCIsXG4gIE1JVUk6IFwiTUlVSSBCcm93c2VyXCJcbn07XG52YXIgT1NfVFlQRVMgPSB7XG4gIElPUzogJ2lPUycsXG4gIEFORFJPSUQ6IFwiQW5kcm9pZFwiLFxuICBXSU5ET1dTX1BIT05FOiBcIldpbmRvd3MgUGhvbmVcIixcbiAgV0lORE9XUzogJ1dpbmRvd3MnLFxuICBNQUNfT1M6ICdNYWMgT1MnXG59O1xudmFyIGluaXRpYWxEYXRhID0ge1xuICBpc01vYmlsZTogZmFsc2UsXG4gIGlzVGFibGV0OiBmYWxzZSxcbiAgaXNCcm93c2VyOiBmYWxzZSxcbiAgaXNTbWFydFRWOiBmYWxzZSxcbiAgaXNDb25zb2xlOiBmYWxzZSxcbiAgaXNXZWFyYWJsZTogZmFsc2Vcbn07XG52YXIgY2hlY2tUeXBlID0gZnVuY3Rpb24gY2hlY2tUeXBlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBERVZJQ0VfVFlQRVMuTU9CSUxFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNb2JpbGU6IHRydWVcbiAgICAgIH07XG5cbiAgICBjYXNlIERFVklDRV9UWVBFUy5UQUJMRVQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1RhYmxldDogdHJ1ZVxuICAgICAgfTtcblxuICAgIGNhc2UgREVWSUNFX1RZUEVTLlNNQVJUX1RWOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTbWFydFRWOiB0cnVlXG4gICAgICB9O1xuXG4gICAgY2FzZSBERVZJQ0VfVFlQRVMuQ09OU09MRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQ29uc29sZTogdHJ1ZVxuICAgICAgfTtcblxuICAgIGNhc2UgREVWSUNFX1RZUEVTLldFQVJBQkxFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNXZWFyYWJsZTogdHJ1ZVxuICAgICAgfTtcblxuICAgIGNhc2UgREVWSUNFX1RZUEVTLkJST1dTRVI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0Jyb3dzZXI6IHRydWVcbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGluaXRpYWxEYXRhO1xuICB9XG59O1xudmFyIGJyb1BheWxvYWQgPSBmdW5jdGlvbiBicm9QYXlsb2FkKGlzQnJvd3NlciwgYnJvd3NlciwgZW5naW5lLCBvcywgdWEpIHtcbiAgcmV0dXJuIHtcbiAgICBpc0Jyb3dzZXI6IGlzQnJvd3NlcixcbiAgICBicm93c2VyTWFqb3JWZXJzaW9uOiBzZXREZWZhdWx0cyhicm93c2VyLm1ham9yKSxcbiAgICBicm93c2VyRnVsbFZlcnNpb246IHNldERlZmF1bHRzKGJyb3dzZXIudmVyc2lvbiksXG4gICAgYnJvd3Nlck5hbWU6IHNldERlZmF1bHRzKGJyb3dzZXIubmFtZSksXG4gICAgZW5naW5lTmFtZTogc2V0RGVmYXVsdHMoZW5naW5lLm5hbWUpLFxuICAgIGVuZ2luZVZlcnNpb246IHNldERlZmF1bHRzKGVuZ2luZS52ZXJzaW9uKSxcbiAgICBvc05hbWU6IHNldERlZmF1bHRzKG9zLm5hbWUpLFxuICAgIG9zVmVyc2lvbjogc2V0RGVmYXVsdHMob3MudmVyc2lvbiksXG4gICAgdXNlckFnZW50OiBzZXREZWZhdWx0cyh1YSlcbiAgfTtcbn07XG52YXIgbW9iaWxlUGF5bG9hZCA9IGZ1bmN0aW9uIG1vYmlsZVBheWxvYWQodHlwZSwgZGV2aWNlLCBvcywgdWEpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCB0eXBlLCB7XG4gICAgdmVuZG9yOiBzZXREZWZhdWx0cyhkZXZpY2UudmVuZG9yKSxcbiAgICBtb2RlbDogc2V0RGVmYXVsdHMoZGV2aWNlLm1vZGVsKSxcbiAgICBvczogc2V0RGVmYXVsdHMob3MubmFtZSksXG4gICAgb3NWZXJzaW9uOiBzZXREZWZhdWx0cyhvcy52ZXJzaW9uKSxcbiAgICB1YTogc2V0RGVmYXVsdHModWEpXG4gIH0pO1xufTtcbnZhciBzdHZQYXlsb2FkID0gZnVuY3Rpb24gc3R2UGF5bG9hZChpc1NtYXJ0VFYsIGVuZ2luZSwgb3MsIHVhKSB7XG4gIHJldHVybiB7XG4gICAgaXNTbWFydFRWOiBpc1NtYXJ0VFYsXG4gICAgZW5naW5lTmFtZTogc2V0RGVmYXVsdHMoZW5naW5lLm5hbWUpLFxuICAgIGVuZ2luZVZlcnNpb246IHNldERlZmF1bHRzKGVuZ2luZS52ZXJzaW9uKSxcbiAgICBvc05hbWU6IHNldERlZmF1bHRzKG9zLm5hbWUpLFxuICAgIG9zVmVyc2lvbjogc2V0RGVmYXVsdHMob3MudmVyc2lvbiksXG4gICAgdXNlckFnZW50OiBzZXREZWZhdWx0cyh1YSlcbiAgfTtcbn07XG52YXIgY29uc29sZVBheWxvYWQgPSBmdW5jdGlvbiBjb25zb2xlUGF5bG9hZChpc0NvbnNvbGUsIGVuZ2luZSwgb3MsIHVhKSB7XG4gIHJldHVybiB7XG4gICAgaXNDb25zb2xlOiBpc0NvbnNvbGUsXG4gICAgZW5naW5lTmFtZTogc2V0RGVmYXVsdHMoZW5naW5lLm5hbWUpLFxuICAgIGVuZ2luZVZlcnNpb246IHNldERlZmF1bHRzKGVuZ2luZS52ZXJzaW9uKSxcbiAgICBvc05hbWU6IHNldERlZmF1bHRzKG9zLm5hbWUpLFxuICAgIG9zVmVyc2lvbjogc2V0RGVmYXVsdHMob3MudmVyc2lvbiksXG4gICAgdXNlckFnZW50OiBzZXREZWZhdWx0cyh1YSlcbiAgfTtcbn07XG52YXIgd2VhclBheWxvYWQgPSBmdW5jdGlvbiB3ZWFyUGF5bG9hZChpc1dlYXJhYmxlLCBlbmdpbmUsIG9zLCB1YSkge1xuICByZXR1cm4ge1xuICAgIGlzV2VhcmFibGU6IGlzV2VhcmFibGUsXG4gICAgZW5naW5lTmFtZTogc2V0RGVmYXVsdHMoZW5naW5lLm5hbWUpLFxuICAgIGVuZ2luZVZlcnNpb246IHNldERlZmF1bHRzKGVuZ2luZS52ZXJzaW9uKSxcbiAgICBvc05hbWU6IHNldERlZmF1bHRzKG9zLm5hbWUpLFxuICAgIG9zVmVyc2lvbjogc2V0RGVmYXVsdHMob3MudmVyc2lvbiksXG4gICAgdXNlckFnZW50OiBzZXREZWZhdWx0cyh1YSlcbiAgfTtcbn07XG5cbnZhciB0eXBlID0gY2hlY2tUeXBlKGRldmljZS50eXBlKTtcblxuZnVuY3Rpb24gZGV2aWNlRGV0ZWN0KCkge1xuICB2YXIgaXNCcm93c2VyID0gdHlwZS5pc0Jyb3dzZXIsXG4gICAgICBpc01vYmlsZSA9IHR5cGUuaXNNb2JpbGUsXG4gICAgICBpc1RhYmxldCA9IHR5cGUuaXNUYWJsZXQsXG4gICAgICBpc1NtYXJ0VFYgPSB0eXBlLmlzU21hcnRUVixcbiAgICAgIGlzQ29uc29sZSA9IHR5cGUuaXNDb25zb2xlLFxuICAgICAgaXNXZWFyYWJsZSA9IHR5cGUuaXNXZWFyYWJsZTtcblxuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIGJyb1BheWxvYWQoaXNCcm93c2VyLCBicm93c2VyLCBlbmdpbmUsIG9zLCB1YSk7XG4gIH1cblxuICBpZiAoaXNTbWFydFRWKSB7XG4gICAgcmV0dXJuIHN0dlBheWxvYWQoaXNTbWFydFRWLCBlbmdpbmUsIG9zLCB1YSk7XG4gIH1cblxuICBpZiAoaXNDb25zb2xlKSB7XG4gICAgcmV0dXJuIGNvbnNvbGVQYXlsb2FkKGlzQ29uc29sZSwgZW5naW5lLCBvcywgdWEpO1xuICB9XG5cbiAgaWYgKGlzTW9iaWxlKSB7XG4gICAgcmV0dXJuIG1vYmlsZVBheWxvYWQodHlwZSwgZGV2aWNlLCBvcywgdWEpO1xuICB9XG5cbiAgaWYgKGlzVGFibGV0KSB7XG4gICAgcmV0dXJuIG1vYmlsZVBheWxvYWQodHlwZSwgZGV2aWNlLCBvcywgdWEpO1xuICB9XG5cbiAgaWYgKGlzV2VhcmFibGUpIHtcbiAgICByZXR1cm4gd2VhclBheWxvYWQoaXNXZWFyYWJsZSwgZW5naW5lLCBvcywgdWEpO1xuICB9XG59XG5cbnZhciBpc01vYmlsZVR5cGUgPSBmdW5jdGlvbiBpc01vYmlsZVR5cGUoKSB7XG4gIHJldHVybiBkZXZpY2UudHlwZSA9PT0gREVWSUNFX1RZUEVTLk1PQklMRTtcbn07XG5cbnZhciBpc1RhYmxldFR5cGUgPSBmdW5jdGlvbiBpc1RhYmxldFR5cGUoKSB7XG4gIHJldHVybiBkZXZpY2UudHlwZSA9PT0gREVWSUNFX1RZUEVTLlRBQkxFVDtcbn07XG5cbnZhciBpc01vYmlsZUFuZFRhYmxldFR5cGUgPSBmdW5jdGlvbiBpc01vYmlsZUFuZFRhYmxldFR5cGUoKSB7XG4gIHN3aXRjaCAoZGV2aWNlLnR5cGUpIHtcbiAgICBjYXNlIERFVklDRV9UWVBFUy5NT0JJTEU6XG4gICAgY2FzZSBERVZJQ0VfVFlQRVMuVEFCTEVUOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNFZGdlQ2hyb21pdW1UeXBlID0gZnVuY3Rpb24gaXNFZGdlQ2hyb21pdW1UeXBlKCkge1xuICByZXR1cm4gdHlwZW9mIHVhID09PSAnc3RyaW5nJyAmJiB1YS5pbmRleE9mKCdFZGcvJykgIT09IC0xO1xufTtcblxudmFyIGlzU21hcnRUVlR5cGUgPSBmdW5jdGlvbiBpc1NtYXJ0VFZUeXBlKCkge1xuICByZXR1cm4gZGV2aWNlLnR5cGUgPT09IERFVklDRV9UWVBFUy5TTUFSVF9UVjtcbn07XG5cbnZhciBpc0Jyb3dzZXJUeXBlID0gZnVuY3Rpb24gaXNCcm93c2VyVHlwZSgpIHtcbiAgcmV0dXJuIGRldmljZS50eXBlID09PSBERVZJQ0VfVFlQRVMuQlJPV1NFUjtcbn07XG5cbnZhciBpc1dlYXJhYmxlVHlwZSA9IGZ1bmN0aW9uIGlzV2VhcmFibGVUeXBlKCkge1xuICByZXR1cm4gZGV2aWNlLnR5cGUgPT09IERFVklDRV9UWVBFUy5XRUFSQUJMRTtcbn07XG5cbnZhciBpc0NvbnNvbGVUeXBlID0gZnVuY3Rpb24gaXNDb25zb2xlVHlwZSgpIHtcbiAgcmV0dXJuIGRldmljZS50eXBlID09PSBERVZJQ0VfVFlQRVMuQ09OU09MRTtcbn07XG5cbnZhciBpc0FuZHJvaWRUeXBlID0gZnVuY3Rpb24gaXNBbmRyb2lkVHlwZSgpIHtcbiAgcmV0dXJuIG9zLm5hbWUgPT09IE9TX1RZUEVTLkFORFJPSUQ7XG59O1xuXG52YXIgaXNXaW5kb3dzVHlwZSA9IGZ1bmN0aW9uIGlzV2luZG93c1R5cGUoKSB7XG4gIHJldHVybiBvcy5uYW1lID09PSBPU19UWVBFUy5XSU5ET1dTO1xufTtcblxudmFyIGlzTWFjT3NUeXBlID0gZnVuY3Rpb24gaXNNYWNPc1R5cGUoKSB7XG4gIHJldHVybiBvcy5uYW1lID09PSBPU19UWVBFUy5NQUNfT1M7XG59O1xuXG52YXIgaXNXaW5QaG9uZVR5cGUgPSBmdW5jdGlvbiBpc1dpblBob25lVHlwZSgpIHtcbiAgcmV0dXJuIG9zLm5hbWUgPT09IE9TX1RZUEVTLldJTkRPV1NfUEhPTkU7XG59O1xuXG52YXIgaXNJT1NUeXBlID0gZnVuY3Rpb24gaXNJT1NUeXBlKCkge1xuICByZXR1cm4gb3MubmFtZSA9PT0gT1NfVFlQRVMuSU9TO1xufTtcblxudmFyIGlzQ2hyb21lVHlwZSA9IGZ1bmN0aW9uIGlzQ2hyb21lVHlwZSgpIHtcbiAgcmV0dXJuIGJyb3dzZXIubmFtZSA9PT0gQlJPV1NFUl9UWVBFUy5DSFJPTUU7XG59O1xuXG52YXIgaXNGaXJlZm94VHlwZSA9IGZ1bmN0aW9uIGlzRmlyZWZveFR5cGUoKSB7XG4gIHJldHVybiBicm93c2VyLm5hbWUgPT09IEJST1dTRVJfVFlQRVMuRklSRUZPWDtcbn07XG5cbnZhciBpc0Nocm9taXVtVHlwZSA9IGZ1bmN0aW9uIGlzQ2hyb21pdW1UeXBlKCkge1xuICByZXR1cm4gYnJvd3Nlci5uYW1lID09PSBCUk9XU0VSX1RZUEVTLkNIUk9NSVVNO1xufTtcblxudmFyIGlzRWRnZVR5cGUgPSBmdW5jdGlvbiBpc0VkZ2VUeXBlKCkge1xuICByZXR1cm4gYnJvd3Nlci5uYW1lID09PSBCUk9XU0VSX1RZUEVTLkVER0U7XG59O1xuXG52YXIgaXNZYW5kZXhUeXBlID0gZnVuY3Rpb24gaXNZYW5kZXhUeXBlKCkge1xuICByZXR1cm4gYnJvd3Nlci5uYW1lID09PSBCUk9XU0VSX1RZUEVTLllBTkRFWDtcbn07XG5cbnZhciBpc1NhZmFyaVR5cGUgPSBmdW5jdGlvbiBpc1NhZmFyaVR5cGUoKSB7XG4gIHJldHVybiBicm93c2VyLm5hbWUgPT09IEJST1dTRVJfVFlQRVMuU0FGQVJJIHx8IGJyb3dzZXIubmFtZSA9PT0gQlJPV1NFUl9UWVBFUy5NT0JJTEVfU0FGQVJJO1xufTtcblxudmFyIGlzTW9iaWxlU2FmYXJpVHlwZSA9IGZ1bmN0aW9uIGlzTW9iaWxlU2FmYXJpVHlwZSgpIHtcbiAgcmV0dXJuIGJyb3dzZXIubmFtZSA9PT0gQlJPV1NFUl9UWVBFUy5NT0JJTEVfU0FGQVJJO1xufTtcblxudmFyIGlzT3BlcmFUeXBlID0gZnVuY3Rpb24gaXNPcGVyYVR5cGUoKSB7XG4gIHJldHVybiBicm93c2VyLm5hbWUgPT09IEJST1dTRVJfVFlQRVMuT1BFUkE7XG59O1xuXG52YXIgaXNJRVR5cGUgPSBmdW5jdGlvbiBpc0lFVHlwZSgpIHtcbiAgcmV0dXJuIGJyb3dzZXIubmFtZSA9PT0gQlJPV1NFUl9UWVBFUy5JTlRFUk5FVF9FWFBMT1JFUiB8fCBicm93c2VyLm5hbWUgPT09IEJST1dTRVJfVFlQRVMuSUU7XG59O1xuXG52YXIgaXNNSVVJVHlwZSA9IGZ1bmN0aW9uIGlzTUlVSVR5cGUoKSB7XG4gIHJldHVybiBicm93c2VyLm5hbWUgPT09IEJST1dTRVJfVFlQRVMuTUlVSTtcbn07XG5cbnZhciBpc0VsZWN0cm9uVHlwZSA9IGZ1bmN0aW9uIGlzRWxlY3Ryb25UeXBlKCkge1xuICB2YXIgbmF2ID0gZ2V0TmF2aWdhdG9ySW5zdGFuY2UoKTtcbiAgdmFyIHVhID0gbmF2ICYmIG5hdi51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHR5cGVvZiB1YSA9PT0gJ3N0cmluZycgPyAvZWxlY3Ryb24vLnRlc3QodWEpIDogZmFsc2U7XG59O1xuXG52YXIgZ2V0SU9TMTMgPSBmdW5jdGlvbiBnZXRJT1MxMygpIHtcbiAgdmFyIG5hdiA9IGdldE5hdmlnYXRvckluc3RhbmNlKCk7XG4gIHJldHVybiBuYXYgJiYgKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdi5wbGF0Zm9ybSkgfHwgbmF2LnBsYXRmb3JtID09PSAnTWFjSW50ZWwnICYmIG5hdi5tYXhUb3VjaFBvaW50cyA+IDEpICYmICF3aW5kb3cuTVNTdHJlYW07XG59O1xuXG52YXIgZ2V0SVBhZDEzID0gZnVuY3Rpb24gZ2V0SVBhZDEzKCkge1xuICByZXR1cm4gaXNJT1MxM0NoZWNrKCdpUGFkJyk7XG59O1xuXG52YXIgZ2V0SXBob25lMTMgPSBmdW5jdGlvbiBnZXRJcGhvbmUxMygpIHtcbiAgcmV0dXJuIGlzSU9TMTNDaGVjaygnaVBob25lJyk7XG59O1xuXG52YXIgZ2V0SVBvZDEzID0gZnVuY3Rpb24gZ2V0SVBvZDEzKCkge1xuICByZXR1cm4gaXNJT1MxM0NoZWNrKCdpUG9kJyk7XG59O1xuXG52YXIgZ2V0QnJvd3NlckZ1bGxWZXJzaW9uID0gZnVuY3Rpb24gZ2V0QnJvd3NlckZ1bGxWZXJzaW9uKCkge1xuICByZXR1cm4gc2V0RGVmYXVsdHMoYnJvd3Nlci52ZXJzaW9uKTtcbn07XG5cbnZhciBnZXRCcm93c2VyVmVyc2lvbiA9IGZ1bmN0aW9uIGdldEJyb3dzZXJWZXJzaW9uKCkge1xuICByZXR1cm4gc2V0RGVmYXVsdHMoYnJvd3Nlci5tYWpvcik7XG59O1xuXG52YXIgZ2V0T3NWZXJzaW9uID0gZnVuY3Rpb24gZ2V0T3NWZXJzaW9uKCkge1xuICByZXR1cm4gc2V0RGVmYXVsdHMob3MudmVyc2lvbik7XG59O1xuXG52YXIgZ2V0T3NOYW1lID0gZnVuY3Rpb24gZ2V0T3NOYW1lKCkge1xuICByZXR1cm4gc2V0RGVmYXVsdHMob3MubmFtZSk7XG59O1xuXG52YXIgZ2V0QnJvd3Nlck5hbWUgPSBmdW5jdGlvbiBnZXRCcm93c2VyTmFtZSgpIHtcbiAgcmV0dXJuIHNldERlZmF1bHRzKGJyb3dzZXIubmFtZSk7XG59O1xuXG52YXIgZ2V0TW9iaWxlVmVuZG9yID0gZnVuY3Rpb24gZ2V0TW9iaWxlVmVuZG9yKCkge1xuICByZXR1cm4gc2V0RGVmYXVsdHMoZGV2aWNlLnZlbmRvcik7XG59O1xuXG52YXIgZ2V0TW9iaWxlTW9kZWwgPSBmdW5jdGlvbiBnZXRNb2JpbGVNb2RlbCgpIHtcbiAgcmV0dXJuIHNldERlZmF1bHRzKGRldmljZS5tb2RlbCk7XG59O1xuXG52YXIgZ2V0RW5naW5lTmFtZSA9IGZ1bmN0aW9uIGdldEVuZ2luZU5hbWUoKSB7XG4gIHJldHVybiBzZXREZWZhdWx0cyhlbmdpbmUubmFtZSk7XG59O1xuXG52YXIgZ2V0RW5naW5lVmVyc2lvbiA9IGZ1bmN0aW9uIGdldEVuZ2luZVZlcnNpb24oKSB7XG4gIHJldHVybiBzZXREZWZhdWx0cyhlbmdpbmUudmVyc2lvbik7XG59O1xuXG52YXIgZ2V0VXNlcmFnZW50ID0gZnVuY3Rpb24gZ2V0VXNlcmFnZW50KCkge1xuICByZXR1cm4gc2V0RGVmYXVsdHModWEpO1xufTtcblxudmFyIGdldERldmljZVR5cGUgPSBmdW5jdGlvbiBnZXREZXZpY2VUeXBlKCkge1xuICByZXR1cm4gc2V0RGVmYXVsdHMoZGV2aWNlLnR5cGUsICdicm93c2VyJyk7XG59O1xuXG52YXIgaXNTbWFydFRWID0gaXNTbWFydFRWVHlwZSgpO1xudmFyIGlzQ29uc29sZSA9IGlzQ29uc29sZVR5cGUoKTtcbnZhciBpc1dlYXJhYmxlID0gaXNXZWFyYWJsZVR5cGUoKTtcbnZhciBpc01vYmlsZVNhZmFyaSA9IGlzTW9iaWxlU2FmYXJpVHlwZSgpIHx8IGdldElQYWQxMygpO1xudmFyIGlzQ2hyb21pdW0gPSBpc0Nocm9taXVtVHlwZSgpO1xudmFyIGlzTW9iaWxlID0gaXNNb2JpbGVBbmRUYWJsZXRUeXBlKCkgfHwgZ2V0SVBhZDEzKCk7XG52YXIgaXNNb2JpbGVPbmx5ID0gaXNNb2JpbGVUeXBlKCk7XG52YXIgaXNUYWJsZXQgPSBpc1RhYmxldFR5cGUoKSB8fCBnZXRJUGFkMTMoKTtcbnZhciBpc0Jyb3dzZXIgPSBpc0Jyb3dzZXJUeXBlKCk7XG52YXIgaXNBbmRyb2lkID0gaXNBbmRyb2lkVHlwZSgpO1xudmFyIGlzV2luUGhvbmUgPSBpc1dpblBob25lVHlwZSgpO1xudmFyIGlzSU9TID0gaXNJT1NUeXBlKCkgfHwgZ2V0SVBhZDEzKCk7XG52YXIgaXNDaHJvbWUgPSBpc0Nocm9tZVR5cGUoKTtcbnZhciBpc0ZpcmVmb3ggPSBpc0ZpcmVmb3hUeXBlKCk7XG52YXIgaXNTYWZhcmkgPSBpc1NhZmFyaVR5cGUoKTtcbnZhciBpc09wZXJhID0gaXNPcGVyYVR5cGUoKTtcbnZhciBpc0lFID0gaXNJRVR5cGUoKTtcbnZhciBvc1ZlcnNpb24gPSBnZXRPc1ZlcnNpb24oKTtcbnZhciBvc05hbWUgPSBnZXRPc05hbWUoKTtcbnZhciBmdWxsQnJvd3NlclZlcnNpb24gPSBnZXRCcm93c2VyRnVsbFZlcnNpb24oKTtcbnZhciBicm93c2VyVmVyc2lvbiA9IGdldEJyb3dzZXJWZXJzaW9uKCk7XG52YXIgYnJvd3Nlck5hbWUgPSBnZXRCcm93c2VyTmFtZSgpO1xudmFyIG1vYmlsZVZlbmRvciA9IGdldE1vYmlsZVZlbmRvcigpO1xudmFyIG1vYmlsZU1vZGVsID0gZ2V0TW9iaWxlTW9kZWwoKTtcbnZhciBlbmdpbmVOYW1lID0gZ2V0RW5naW5lTmFtZSgpO1xudmFyIGVuZ2luZVZlcnNpb24gPSBnZXRFbmdpbmVWZXJzaW9uKCk7XG52YXIgZ2V0VUEgPSBnZXRVc2VyYWdlbnQoKTtcbnZhciBpc0VkZ2UgPSBpc0VkZ2VUeXBlKCkgfHwgaXNFZGdlQ2hyb21pdW1UeXBlKCk7XG52YXIgaXNZYW5kZXggPSBpc1lhbmRleFR5cGUoKTtcbnZhciBkZXZpY2VUeXBlID0gZ2V0RGV2aWNlVHlwZSgpO1xudmFyIGlzSU9TMTMgPSBnZXRJT1MxMygpO1xudmFyIGlzSVBhZDEzID0gZ2V0SVBhZDEzKCk7XG52YXIgaXNJUGhvbmUxMyA9IGdldElwaG9uZTEzKCk7XG52YXIgaXNJUG9kMTMgPSBnZXRJUG9kMTMoKTtcbnZhciBpc0VsZWN0cm9uID0gaXNFbGVjdHJvblR5cGUoKTtcbnZhciBpc0VkZ2VDaHJvbWl1bSA9IGlzRWRnZUNocm9taXVtVHlwZSgpO1xudmFyIGlzTGVnYWN5RWRnZSA9IGlzRWRnZVR5cGUoKSAmJiAhaXNFZGdlQ2hyb21pdW1UeXBlKCk7XG52YXIgaXNXaW5kb3dzID0gaXNXaW5kb3dzVHlwZSgpO1xudmFyIGlzTWFjT3MgPSBpc01hY09zVHlwZSgpO1xudmFyIGlzTUlVSSA9IGlzTUlVSVR5cGUoKTtcblxudmFyIEFuZHJvaWRWaWV3ID0gZnVuY3Rpb24gQW5kcm9pZFZpZXcoX3JlZikge1xuICB2YXIgcmVuZGVyV2l0aEZyYWdtZW50ID0gX3JlZi5yZW5kZXJXaXRoRnJhZ21lbnQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB2aWV3Q2xhc3NOYW1lID0gX3JlZi52aWV3Q2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlO1xuICByZXR1cm4gaXNBbmRyb2lkID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBCcm93c2VyVmlldyA9IGZ1bmN0aW9uIEJyb3dzZXJWaWV3KF9yZWYyKSB7XG4gIHZhciByZW5kZXJXaXRoRnJhZ21lbnQgPSBfcmVmMi5yZW5kZXJXaXRoRnJhZ21lbnQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuLFxuICAgICAgdmlld0NsYXNzTmFtZSA9IF9yZWYyLnZpZXdDbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IF9yZWYyLnN0eWxlO1xuICByZXR1cm4gaXNCcm93c2VyID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBJRVZpZXcgPSBmdW5jdGlvbiBJRVZpZXcoX3JlZjMpIHtcbiAgdmFyIHJlbmRlcldpdGhGcmFnbWVudCA9IF9yZWYzLnJlbmRlcldpdGhGcmFnbWVudCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjMuY2hpbGRyZW4sXG4gICAgICB2aWV3Q2xhc3NOYW1lID0gX3JlZjMudmlld0NsYXNzTmFtZSxcbiAgICAgIHN0eWxlID0gX3JlZjMuc3R5bGU7XG4gIHJldHVybiBpc0lFID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBJT1NWaWV3ID0gZnVuY3Rpb24gSU9TVmlldyhfcmVmNCkge1xuICB2YXIgcmVuZGVyV2l0aEZyYWdtZW50ID0gX3JlZjQucmVuZGVyV2l0aEZyYWdtZW50LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmNC5jaGlsZHJlbixcbiAgICAgIHZpZXdDbGFzc05hbWUgPSBfcmVmNC52aWV3Q2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmNC5zdHlsZTtcbiAgcmV0dXJuIGlzSU9TID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBNb2JpbGVWaWV3ID0gZnVuY3Rpb24gTW9iaWxlVmlldyhfcmVmNSkge1xuICB2YXIgcmVuZGVyV2l0aEZyYWdtZW50ID0gX3JlZjUucmVuZGVyV2l0aEZyYWdtZW50LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmNS5jaGlsZHJlbixcbiAgICAgIHZpZXdDbGFzc05hbWUgPSBfcmVmNS52aWV3Q2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmNS5zdHlsZTtcbiAgcmV0dXJuIGlzTW9iaWxlID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBUYWJsZXRWaWV3ID0gZnVuY3Rpb24gVGFibGV0VmlldyhfcmVmNikge1xuICB2YXIgcmVuZGVyV2l0aEZyYWdtZW50ID0gX3JlZjYucmVuZGVyV2l0aEZyYWdtZW50LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmNi5jaGlsZHJlbixcbiAgICAgIHZpZXdDbGFzc05hbWUgPSBfcmVmNi52aWV3Q2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmNi5zdHlsZTtcbiAgcmV0dXJuIGlzVGFibGV0ID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBXaW5QaG9uZVZpZXcgPSBmdW5jdGlvbiBXaW5QaG9uZVZpZXcoX3JlZjcpIHtcbiAgdmFyIHJlbmRlcldpdGhGcmFnbWVudCA9IF9yZWY3LnJlbmRlcldpdGhGcmFnbWVudCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjcuY2hpbGRyZW4sXG4gICAgICB2aWV3Q2xhc3NOYW1lID0gX3JlZjcudmlld0NsYXNzTmFtZSxcbiAgICAgIHN0eWxlID0gX3JlZjcuc3R5bGU7XG4gIHJldHVybiBpc1dpblBob25lID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBNb2JpbGVPbmx5VmlldyA9IGZ1bmN0aW9uIE1vYmlsZU9ubHlWaWV3KF9yZWY4KSB7XG4gIHZhciByZW5kZXJXaXRoRnJhZ21lbnQgPSBfcmVmOC5yZW5kZXJXaXRoRnJhZ21lbnQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWY4LmNoaWxkcmVuLFxuICAgICAgdmlld0NsYXNzTmFtZSA9IF9yZWY4LnZpZXdDbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IF9yZWY4LnN0eWxlO1xuICByZXR1cm4gaXNNb2JpbGVPbmx5ID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBTbWFydFRWVmlldyA9IGZ1bmN0aW9uIFNtYXJ0VFZWaWV3KF9yZWY5KSB7XG4gIHZhciByZW5kZXJXaXRoRnJhZ21lbnQgPSBfcmVmOS5yZW5kZXJXaXRoRnJhZ21lbnQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWY5LmNoaWxkcmVuLFxuICAgICAgdmlld0NsYXNzTmFtZSA9IF9yZWY5LnZpZXdDbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IF9yZWY5LnN0eWxlO1xuICByZXR1cm4gaXNTbWFydFRWID8gcmVuZGVyV2l0aEZyYWdtZW50ID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pIDogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBjaGlsZHJlbikgOiBudWxsO1xufTtcbnZhciBDb25zb2xlVmlldyA9IGZ1bmN0aW9uIENvbnNvbGVWaWV3KF9yZWYxMCkge1xuICB2YXIgcmVuZGVyV2l0aEZyYWdtZW50ID0gX3JlZjEwLnJlbmRlcldpdGhGcmFnbWVudCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjEwLmNoaWxkcmVuLFxuICAgICAgdmlld0NsYXNzTmFtZSA9IF9yZWYxMC52aWV3Q2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmMTAuc3R5bGU7XG4gIHJldHVybiBpc0NvbnNvbGUgPyByZW5kZXJXaXRoRnJhZ21lbnQgPyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbikgOiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IHZpZXdDbGFzc05hbWUsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIGNoaWxkcmVuKSA6IG51bGw7XG59O1xudmFyIFdlYXJhYmxlVmlldyA9IGZ1bmN0aW9uIFdlYXJhYmxlVmlldyhfcmVmMTEpIHtcbiAgdmFyIHJlbmRlcldpdGhGcmFnbWVudCA9IF9yZWYxMS5yZW5kZXJXaXRoRnJhZ21lbnQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYxMS5jaGlsZHJlbixcbiAgICAgIHZpZXdDbGFzc05hbWUgPSBfcmVmMTEudmlld0NsYXNzTmFtZSxcbiAgICAgIHN0eWxlID0gX3JlZjExLnN0eWxlO1xuICByZXR1cm4gaXNXZWFyYWJsZSA/IHJlbmRlcldpdGhGcmFnbWVudCA/IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKSA6IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogdmlld0NsYXNzTmFtZSxcbiAgICBzdHlsZTogc3R5bGVcbiAgfSwgY2hpbGRyZW4pIDogbnVsbDtcbn07XG52YXIgQ3VzdG9tVmlldyA9IGZ1bmN0aW9uIEN1c3RvbVZpZXcoX3JlZjEyKSB7XG4gIHZhciByZW5kZXJXaXRoRnJhZ21lbnQgPSBfcmVmMTIucmVuZGVyV2l0aEZyYWdtZW50LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmMTIuY2hpbGRyZW4sXG4gICAgICB2aWV3Q2xhc3NOYW1lID0gX3JlZjEyLnZpZXdDbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IF9yZWYxMi5zdHlsZSxcbiAgICAgIGNvbmRpdGlvbiA9IF9yZWYxMi5jb25kaXRpb247XG4gIHJldHVybiBjb25kaXRpb24gPyByZW5kZXJXaXRoRnJhZ21lbnQgPyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbikgOiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IHZpZXdDbGFzc05hbWUsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIGNoaWxkcmVuKSA6IG51bGw7XG59O1xuXG5mdW5jdGlvbiB3aXRoT3JpZW50YXRpb25DaGFuZ2UoV3JhcHBlZENvbXBvbmVudCkge1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKF9jbGFzcywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIF9jbGFzcyhwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2NsYXNzKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgICAgIF90aGlzLmlzRXZlbnRMaXN0ZW5lckFkZGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmhhbmRsZU9yaWVudGF0aW9uQ2hhbmdlID0gX3RoaXMuaGFuZGxlT3JpZW50YXRpb25DaGFuZ2UuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICAgIF90aGlzLm9uT3JpZW50YXRpb25DaGFuZ2UgPSBfdGhpcy5vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5vblBhZ2VMb2FkID0gX3RoaXMub25QYWdlTG9hZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgaXNMYW5kc2NhcGU6IGZhbHNlLFxuICAgICAgICAgIGlzUG9ydHJhaXQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcbiAgICAgICAga2V5OiBcImhhbmRsZU9yaWVudGF0aW9uQ2hhbmdlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVPcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudExpc3RlbmVyQWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNFdmVudExpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHdpbmRvdy5pbm5lcldpZHRoID4gd2luZG93LmlubmVySGVpZ2h0ID8gOTAgOiAwO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNQb3J0cmFpdDogb3JpZW50YXRpb24gPT09IDAsXG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogb3JpZW50YXRpb24gPT09IDkwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm9uT3JpZW50YXRpb25DaGFuZ2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3JpZW50YXRpb25DaGFuZ2UoKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVPcmllbnRhdGlvbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJvblBhZ2VMb2FkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhZ2VMb2FkKCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpICE9PSB1bmRlZmluZWQgJiYgaXNNb2JpbGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0V2ZW50TGlzdGVuZXJBZGRlZCkge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZU9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uUGFnZUxvYWQsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uUGFnZUxvYWQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbk9yaWVudGF0aW9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbk9yaWVudGF0aW9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgICBpc0xhbmRzY2FwZTogdGhpcy5zdGF0ZS5pc0xhbmRzY2FwZSxcbiAgICAgICAgICAgIGlzUG9ydHJhaXQ6IHRoaXMuc3RhdGUuaXNQb3J0cmFpdFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gX2NsYXNzO1xuICAgIH0oUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50KVxuICApO1xufVxuXG5leHBvcnRzLkFuZHJvaWRWaWV3ID0gQW5kcm9pZFZpZXc7XG5leHBvcnRzLkJyb3dzZXJWaWV3ID0gQnJvd3NlclZpZXc7XG5leHBvcnRzLkNvbnNvbGVWaWV3ID0gQ29uc29sZVZpZXc7XG5leHBvcnRzLkN1c3RvbVZpZXcgPSBDdXN0b21WaWV3O1xuZXhwb3J0cy5JRVZpZXcgPSBJRVZpZXc7XG5leHBvcnRzLklPU1ZpZXcgPSBJT1NWaWV3O1xuZXhwb3J0cy5Nb2JpbGVPbmx5VmlldyA9IE1vYmlsZU9ubHlWaWV3O1xuZXhwb3J0cy5Nb2JpbGVWaWV3ID0gTW9iaWxlVmlldztcbmV4cG9ydHMuU21hcnRUVlZpZXcgPSBTbWFydFRWVmlldztcbmV4cG9ydHMuVGFibGV0VmlldyA9IFRhYmxldFZpZXc7XG5leHBvcnRzLldlYXJhYmxlVmlldyA9IFdlYXJhYmxlVmlldztcbmV4cG9ydHMuV2luUGhvbmVWaWV3ID0gV2luUGhvbmVWaWV3O1xuZXhwb3J0cy5icm93c2VyTmFtZSA9IGJyb3dzZXJOYW1lO1xuZXhwb3J0cy5icm93c2VyVmVyc2lvbiA9IGJyb3dzZXJWZXJzaW9uO1xuZXhwb3J0cy5kZXZpY2VEZXRlY3QgPSBkZXZpY2VEZXRlY3Q7XG5leHBvcnRzLmRldmljZVR5cGUgPSBkZXZpY2VUeXBlO1xuZXhwb3J0cy5lbmdpbmVOYW1lID0gZW5naW5lTmFtZTtcbmV4cG9ydHMuZW5naW5lVmVyc2lvbiA9IGVuZ2luZVZlcnNpb247XG5leHBvcnRzLmZ1bGxCcm93c2VyVmVyc2lvbiA9IGZ1bGxCcm93c2VyVmVyc2lvbjtcbmV4cG9ydHMuZ2V0VUEgPSBnZXRVQTtcbmV4cG9ydHMuaXNBbmRyb2lkID0gaXNBbmRyb2lkO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLmlzQ2hyb21lID0gaXNDaHJvbWU7XG5leHBvcnRzLmlzQ2hyb21pdW0gPSBpc0Nocm9taXVtO1xuZXhwb3J0cy5pc0NvbnNvbGUgPSBpc0NvbnNvbGU7XG5leHBvcnRzLmlzRWRnZSA9IGlzRWRnZTtcbmV4cG9ydHMuaXNFZGdlQ2hyb21pdW0gPSBpc0VkZ2VDaHJvbWl1bTtcbmV4cG9ydHMuaXNFbGVjdHJvbiA9IGlzRWxlY3Ryb247XG5leHBvcnRzLmlzRmlyZWZveCA9IGlzRmlyZWZveDtcbmV4cG9ydHMuaXNJRSA9IGlzSUU7XG5leHBvcnRzLmlzSU9TID0gaXNJT1M7XG5leHBvcnRzLmlzSU9TMTMgPSBpc0lPUzEzO1xuZXhwb3J0cy5pc0lQYWQxMyA9IGlzSVBhZDEzO1xuZXhwb3J0cy5pc0lQaG9uZTEzID0gaXNJUGhvbmUxMztcbmV4cG9ydHMuaXNJUG9kMTMgPSBpc0lQb2QxMztcbmV4cG9ydHMuaXNMZWdhY3lFZGdlID0gaXNMZWdhY3lFZGdlO1xuZXhwb3J0cy5pc01JVUkgPSBpc01JVUk7XG5leHBvcnRzLmlzTWFjT3MgPSBpc01hY09zO1xuZXhwb3J0cy5pc01vYmlsZSA9IGlzTW9iaWxlO1xuZXhwb3J0cy5pc01vYmlsZU9ubHkgPSBpc01vYmlsZU9ubHk7XG5leHBvcnRzLmlzTW9iaWxlU2FmYXJpID0gaXNNb2JpbGVTYWZhcmk7XG5leHBvcnRzLmlzT3BlcmEgPSBpc09wZXJhO1xuZXhwb3J0cy5pc1NhZmFyaSA9IGlzU2FmYXJpO1xuZXhwb3J0cy5pc1NtYXJ0VFYgPSBpc1NtYXJ0VFY7XG5leHBvcnRzLmlzVGFibGV0ID0gaXNUYWJsZXQ7XG5leHBvcnRzLmlzV2VhcmFibGUgPSBpc1dlYXJhYmxlO1xuZXhwb3J0cy5pc1dpblBob25lID0gaXNXaW5QaG9uZTtcbmV4cG9ydHMuaXNXaW5kb3dzID0gaXNXaW5kb3dzO1xuZXhwb3J0cy5pc1lhbmRleCA9IGlzWWFuZGV4O1xuZXhwb3J0cy5tb2JpbGVNb2RlbCA9IG1vYmlsZU1vZGVsO1xuZXhwb3J0cy5tb2JpbGVWZW5kb3IgPSBtb2JpbGVWZW5kb3I7XG5leHBvcnRzLm9zTmFtZSA9IG9zTmFtZTtcbmV4cG9ydHMub3NWZXJzaW9uID0gb3NWZXJzaW9uO1xuZXhwb3J0cy53aXRoT3JpZW50YXRpb25DaGFuZ2UgPSB3aXRoT3JpZW50YXRpb25DaGFuZ2U7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgncmVhY3QtZG9tJyksIHJlcXVpcmUoJ3JlYWN0JykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVhY3QtZG9tJywgJ3JlYWN0J10sIGZhY3RvcnkpIDpcblx0KGdsb2JhbC5SZWFjdERyYWdnYWJsZSA9IGZhY3RvcnkoZ2xvYmFsLlJlYWN0RE9NLGdsb2JhbC5SZWFjdCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKFJlYWN0RE9NLFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuXHRSZWFjdERPTSA9IFJlYWN0RE9NICYmIFJlYWN0RE9NLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBSZWFjdERPTVsnZGVmYXVsdCddIDogUmVhY3RET007XG5cdFJlYWN0ID0gUmVhY3QgJiYgUmVhY3QuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IFJlYWN0WydkZWZhdWx0J10gOiBSZWFjdDtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKiBcblx0ICovXG5cblx0ZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBhcmc7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuXHQgKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuXHQgKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuXHQgKi9cblx0dmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZztcblx0fTtcblxuXHR2YXIgZW1wdHlGdW5jdGlvbl8xID0gZW1wdHlGdW5jdGlvbjtcblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG5cdCAqXG5cdCAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG5cdCAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuXHQgKiBleHBlY3RpbmcuXG5cdCAqXG5cdCAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG5cdCAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cblx0ICovXG5cblx0dmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuXHR7XG5cdCAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcblx0ICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuXHQgIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cblx0ICBpZiAoIWNvbmRpdGlvbikge1xuXHQgICAgdmFyIGVycm9yO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcblx0ICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcblx0ICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcblx0ICAgICAgfSkpO1xuXHQgICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuXHQgICAgfVxuXG5cdCAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG5cdCAgICB0aHJvdyBlcnJvcjtcblx0ICB9XG5cdH1cblxuXHR2YXIgaW52YXJpYW50XzEgPSBpbnZhcmlhbnQ7XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cblx0ICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuXHQgKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuXHQgKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cblx0ICovXG5cblx0dmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uXzE7XG5cblx0e1xuXHQgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cblx0ICAgIHZhciBhcmdJbmRleCA9IDA7XG5cdCAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG5cdCAgICB9KTtcblx0ICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cblx0ICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG5cdCAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdCAgICB9IGNhdGNoICh4KSB7fVxuXHQgIH07XG5cblx0ICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcblx0ICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuXHQgICAgfVxuXG5cdCAgICBpZiAoIWNvbmRpdGlvbikge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG5cdCAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXG5cdHZhciB3YXJuaW5nXzEgPSB3YXJuaW5nO1xuXG5cdC8qXG5cdG9iamVjdC1hc3NpZ25cblx0KGMpIFNpbmRyZSBTb3JodXNcblx0QGxpY2Vuc2UgTUlUXG5cdCovXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblx0ZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gT2JqZWN0KHZhbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdFx0dmFyIHRlc3QyID0ge307XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHZhciBvYmplY3RBc3NpZ24gPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgZnJvbTtcblx0XHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHRcdHZhciBzeW1ib2xzO1xuXG5cdFx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICovXG5cblx0dmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxuXHR2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cdHtcblx0ICB2YXIgaW52YXJpYW50JDEgPSBpbnZhcmlhbnRfMTtcblx0ICB2YXIgd2FybmluZyQxID0gd2FybmluZ18xO1xuXHQgIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCQxID0gUmVhY3RQcm9wVHlwZXNTZWNyZXRfMTtcblx0ICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cdH1cblxuXHQvKipcblx0ICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuXHQgKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cblx0ICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcblx0ICB7XG5cdCAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG5cdCAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuXHQgICAgICAgIHZhciBlcnJvcjtcblx0ICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuXHQgICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cblx0ICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuXHQgICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuXHQgICAgICAgICAgaW52YXJpYW50JDEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuXHQgICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0JDEpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICBlcnJvciA9IGV4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB3YXJuaW5nJDEoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG5cdCAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcblx0ICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuXHQgICAgICAgICAgLy8gc2FtZSBlcnJvci5cblx0ICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cblx0ICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG5cdCAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIGNoZWNrUHJvcFR5cGVzXzEgPSBjaGVja1Byb3BUeXBlcztcblxuXHR2YXIgZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuXHQgIC8qIGdsb2JhbCBTeW1ib2wgKi9cblx0ICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cdCAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cblx0ICAvKipcblx0ICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG5cdCAgICpcblx0ICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcblx0ICAgKlxuXHQgICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG5cdCAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG5cdCAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuXHQgICAqICAgICAgIC4uLlxuXHQgICAqICAgICB9XG5cdCAgICpcblx0ICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcblx0ICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG5cdCAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuXHQgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG5cdCAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcblx0ICAgKlxuXHQgICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcblx0ICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgIHByb3BUeXBlczoge1xuXHQgICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cblx0ICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuXHQgICAqXG5cdCAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuXHQgICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcblx0ICAgKlxuXHQgICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuXHQgICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcblx0ICAgKiAgICAgfSxcblx0ICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cblx0ICAgKiAgIH0pO1xuXHQgICAqXG5cdCAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuXHQgICAqXG5cdCAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG5cdCAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG5cdCAgICpcblx0ICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG5cdCAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuXHQgICAqXG5cdCAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgcHJvcFR5cGVzOiB7XG5cdCAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG5cdCAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcblx0ICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG5cdCAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcblx0ICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuXHQgICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcblx0ICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcblx0ICAgKiAgICAgICAgICApO1xuXHQgICAqICAgICAgICB9XG5cdCAgICogICAgICB9XG5cdCAgICogICAgfSxcblx0ICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cblx0ICAgKiAgfSk7XG5cdCAgICpcblx0ICAgKiBAaW50ZXJuYWxcblx0ICAgKi9cblxuXHQgIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cblx0ICAvLyBJbXBvcnRhbnQhXG5cdCAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuXHQgIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcblx0ICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcblx0ICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG5cdCAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcblx0ICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuXHQgICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG5cdCAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcblx0ICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG5cdCAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG5cdCAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG5cdCAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcblx0ICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG5cdCAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuXHQgICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG5cdCAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuXHQgICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuXHQgICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG5cdCAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuXHQgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuXHQgICAqL1xuXHQgIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cblx0ICBmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdCAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG5cdCAgICBpZiAoeCA9PT0geSkge1xuXHQgICAgICAvLyBTdGVwcyAxLTUsIDctMTBcblx0ICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcblx0ICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cblx0ICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cblx0ICAvKipcblx0ICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG5cdCAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcblx0ICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG5cdCAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuXHQgICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcblx0ICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdCAgICB0aGlzLnN0YWNrID0gJyc7XG5cdCAgfVxuXHQgIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cblx0ICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG5cdCAgICB7XG5cdCAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuXHQgICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG5cdCAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcblx0ICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG5cdCAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpIHtcblx0ICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuXHQgICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG5cdCAgICAgICAgICBpbnZhcmlhbnRfMShcblx0ICAgICAgICAgICAgZmFsc2UsXG5cdCAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcblx0ICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG5cdCAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG5cdCAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG5cdCAgICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcblx0ICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG5cdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuXHQgICAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIHdhcm5pbmdfMShcblx0ICAgICAgICAgICAgICBmYWxzZSxcblx0ICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG5cdCAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcblx0ICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuXHQgICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuXHQgICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuXHQgICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcblx0ICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG5cdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG5cdCAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcblx0ICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG5cdCAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG5cdCAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG5cdCAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG5cdCAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuXHQgICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25fMS50aGF0UmV0dXJuc051bGwpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcblx0ICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuXHQgICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcblx0ICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuXHQgICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuXHQgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuXHQgICAgICB3YXJuaW5nXzEoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcblx0ICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25fMS50aGF0UmV0dXJuc051bGw7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuXHQgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuXHQgICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpO1xuXHQgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG5cdCAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcblx0ICAgICAgd2FybmluZ18xKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpO1xuXHQgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbl8xLnRoYXRSZXR1cm5zTnVsbDtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcblx0ICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgd2FybmluZ18xKFxuXHQgICAgICAgICAgZmFsc2UsXG5cdCAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuXHQgICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG5cdCAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG5cdCAgICAgICAgICBpXG5cdCAgICAgICAgKTtcblx0ICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbl8xLnRoYXRSZXR1cm5zTnVsbDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuXHQgICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcblx0ICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcblx0ICAgICAgICBpZiAoIWNoZWNrZXIpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcblx0ICAgICAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cblx0ICAgICAgLy8gcHJvcHMuXG5cdCAgICAgIHZhciBhbGxLZXlzID0gb2JqZWN0QXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuXHQgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuXHQgICAgICAgIGlmICghY2hlY2tlcikge1xuXHQgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuXHQgICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG5cdCAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG5cdCAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSk7XG5cdCAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcblx0ICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuXHQgICAgICBjYXNlICdudW1iZXInOlxuXHQgICAgICBjYXNlICdzdHJpbmcnOlxuXHQgICAgICBjYXNlICd1bmRlZmluZWQnOlxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICBjYXNlICdib29sZWFuJzpcblx0ICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcblx0ICAgICAgY2FzZSAnb2JqZWN0Jzpcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG5cdCAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG5cdCAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcblx0ICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuXHQgICAgICAgICAgdmFyIHN0ZXA7XG5cdCAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcblx0ICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cblx0ICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG5cdCAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcblx0ICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG5cdCAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuXHQgICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuXHQgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuXHQgIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuXHQgICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcblx0ICAgICAgcmV0dXJuICdhcnJheSc7XG5cdCAgICB9XG5cdCAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cblx0ICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG5cdCAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuXHQgICAgICByZXR1cm4gJ29iamVjdCc7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcblx0ICAgICAgcmV0dXJuICdzeW1ib2wnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHByb3BUeXBlO1xuXHQgIH1cblxuXHQgIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cblx0ICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cblx0ICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcblx0ICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuXHQgICAgfVxuXHQgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0ICAgICAgICByZXR1cm4gJ2RhdGUnO1xuXHQgICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHQgICAgICAgIHJldHVybiAncmVnZXhwJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHByb3BUeXBlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cblx0ICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuXHQgIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuXHQgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG5cdCAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgY2FzZSAnYXJyYXknOlxuXHQgICAgICBjYXNlICdvYmplY3QnOlxuXHQgICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG5cdCAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuXHQgICAgICBjYXNlICdkYXRlJzpcblx0ICAgICAgY2FzZSAncmVnZXhwJzpcblx0ICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgcmV0dXJuIHR5cGU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cblx0ICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG5cdCAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcblx0ICAgICAgcmV0dXJuIEFOT05ZTU9VUztcblx0ICAgIH1cblx0ICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcblx0ICB9XG5cblx0ICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzXzE7XG5cdCAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cblx0ICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG5cdH07XG5cblx0dmFyIHByb3BUeXBlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblxuXHR7XG5cdCAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG5cdCAgICBTeW1ib2wuZm9yICYmXG5cdCAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdCAgICAweGVhYzc7XG5cblx0ICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHQgICAgICBvYmplY3QgIT09IG51bGwgJiZcblx0ICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cdCAgfTtcblxuXHQgIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuXHQgIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2Rcblx0ICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5V2l0aFR5cGVDaGVja2Vycyhpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG5cdH1cblx0fSk7XG5cblx0dmFyIGNsYXNzbmFtZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdC8qIVxuXHQgIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxuXHQgIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG5cdCAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuXHQqL1xuXHQvKiBnbG9iYWwgZGVmaW5lICovXG5cblx0KGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRcdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0XHR9XG5cblx0XHRpZiAoJ29iamVjdCcgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdW5kZWZpbmVkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB1bmRlZmluZWQuYW1kID09PSAnb2JqZWN0JyAmJiB1bmRlZmluZWQuYW1kKSB7XG5cdFx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0XHR1bmRlZmluZWQoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdFx0fVxuXHR9KCkpO1xuXHR9KTtcblxuXHQvLyBAY3JlZGl0cyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yb2dvemhuaWtvZmYvYTQzY2ZlZDI3YzQxZTRlNjhjZGNcblx0ZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXkgLyo6IEFycmF5PGFueT4gfCBUb3VjaExpc3QqLywgY2FsbGJhY2sgLyo6IEZ1bmN0aW9uKi8pIC8qOiBhbnkqLyB7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIFthcnJheVtpXSwgaSwgYXJyYXldKSkgcmV0dXJuIGFycmF5W2ldO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYyAvKjogYW55Ki8pIC8qOiBib29sZWFuKi8ge1xuXHQgIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZnVuYykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblxuXHRmdW5jdGlvbiBpc051bShudW0gLyo6IGFueSovKSAvKjogYm9vbGVhbiovIHtcblx0ICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnQoYSAvKjogc3RyaW5nKi8pIC8qOiBudW1iZXIqLyB7XG5cdCAgcmV0dXJuIHBhcnNlSW50KGEsIDEwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRvbnRTZXRNZShwcm9wcyAvKjogT2JqZWN0Ki8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLywgY29tcG9uZW50TmFtZSAvKjogc3RyaW5nKi8pIHtcblx0ICBpZiAocHJvcHNbcHJvcE5hbWVdKSB7XG5cdCAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIHByb3AgJyArIHByb3BOYW1lICsgJyBwYXNzZWQgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnIC0gZG8gbm90IHNldCB0aGlzLCBzZXQgaXQgb24gdGhlIGNoaWxkLicpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBwcmVmaXhlcyA9IFsnTW96JywgJ1dlYmtpdCcsICdPJywgJ21zJ107XG5cdGZ1bmN0aW9uIGdldFByZWZpeCgpIC8qOiBzdHJpbmcqLyB7XG5cdCAgdmFyIHByb3AgLyo6IHN0cmluZyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndHJhbnNmb3JtJztcblxuXHQgIC8vIENoZWNraW5nIHNwZWNpZmljYWxseSBmb3IgJ3dpbmRvdy5kb2N1bWVudCcgaXMgZm9yIHBzZXVkby1icm93c2VyIHNlcnZlci1zaWRlXG5cdCAgLy8gZW52aXJvbm1lbnRzIHRoYXQgZGVmaW5lICd3aW5kb3cnIGFzIHRoZSBnbG9iYWwgY29udGV4dC5cblx0ICAvLyBFLmcuIFJlYWN0LXJhaWxzIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtcmFpbHMvcHVsbC84NClcblx0ICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnJztcblxuXHQgIHZhciBzdHlsZSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cblx0ICBpZiAocHJvcCBpbiBzdHlsZSkgcmV0dXJuICcnO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKGJyb3dzZXJQcmVmaXhUb0tleShwcm9wLCBwcmVmaXhlc1tpXSkgaW4gc3R5bGUpIHJldHVybiBwcmVmaXhlc1tpXTtcblx0ICB9XG5cblx0ICByZXR1cm4gJyc7XG5cdH1cblxuXHRmdW5jdGlvbiBicm93c2VyUHJlZml4VG9LZXkocHJvcCAvKjogc3RyaW5nKi8sIHByZWZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqLyB7XG5cdCAgcmV0dXJuIHByZWZpeCA/ICcnICsgcHJlZml4ICsga2ViYWJUb1RpdGxlQ2FzZShwcm9wKSA6IHByb3A7XG5cdH1cblxuXHRmdW5jdGlvbiBrZWJhYlRvVGl0bGVDYXNlKHN0ciAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqLyB7XG5cdCAgdmFyIG91dCA9ICcnO1xuXHQgIHZhciBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHNob3VsZENhcGl0YWxpemUpIHtcblx0ICAgICAgb3V0ICs9IHN0cltpXS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICBzaG91bGRDYXBpdGFsaXplID0gZmFsc2U7XG5cdCAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gJy0nKSB7XG5cdCAgICAgIHNob3VsZENhcGl0YWxpemUgPSB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb3V0ICs9IHN0cltpXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG91dDtcblx0fVxuXG5cdC8vIERlZmF1bHQgZXhwb3J0IGlzIHRoZSBwcmVmaXggaXRzZWxmLCBsaWtlICdNb3onLCAnV2Via2l0JywgZXRjXG5cdC8vIE5vdGUgdGhhdCB5b3UgbWF5IGhhdmUgdG8gcmUtdGVzdCBmb3IgY2VydGFpbiB0aGluZ3M7IGZvciBpbnN0YW5jZSwgQ2hyb21lIDUwXG5cdC8vIGNhbiBoYW5kbGUgdW5wcmVmaXhlZCBgdHJhbnNmb3JtYCwgYnV0IG5vdCB1bnByZWZpeGVkIGB1c2VyLXNlbGVjdGBcblx0dmFyIGJyb3dzZXJQcmVmaXggPSBnZXRQcmVmaXgoKTtcblxuXHR2YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG5cdCAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcblx0ICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuXHQgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdCAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuXHQgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblx0ICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuXHQgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuXHQgIH07XG5cdH0oKTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG5cdCAgaWYgKGtleSBpbiBvYmopIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuXHQgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgd3JpdGFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvYmpba2V5XSA9IHZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBvYmo7XG5cdH07XG5cblx0dmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcblx0ICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcblx0ICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHR2YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcblx0ICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcblx0ICB9XG5cblx0ICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcblx0ICAgIGNvbnN0cnVjdG9yOiB7XG5cdCAgICAgIHZhbHVlOiBzdWJDbGFzcyxcblx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH1cblx0ICB9KTtcblx0ICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG5cdH07XG5cblx0dmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuXHQgIGlmICghc2VsZikge1xuXHQgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xuXHR9O1xuXG5cdHZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG5cdCAgICB2YXIgX2FyciA9IFtdO1xuXHQgICAgdmFyIF9uID0gdHJ1ZTtcblx0ICAgIHZhciBfZCA9IGZhbHNlO1xuXHQgICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG5cdCAgICB0cnkge1xuXHQgICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG5cdCAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuXHQgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgIF9kID0gdHJ1ZTtcblx0ICAgICAgX2UgPSBlcnI7XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX2Fycjtcblx0ICB9XG5cblx0ICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuXHQgICAgICByZXR1cm4gYXJyO1xuXHQgICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcblx0ICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuXHQgICAgfVxuXHQgIH07XG5cdH0oKTtcblxuXHQvKjo6IGltcG9ydCB0eXBlIHtDb250cm9sUG9zaXRpb24sIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG5cblxuXHR2YXIgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICcnO1xuXHRmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoZWwgLyo6IE5vZGUqLywgc2VsZWN0b3IgLyo6IHN0cmluZyovKSAvKjogYm9vbGVhbiovIHtcblx0ICBpZiAoIW1hdGNoZXNTZWxlY3RvckZ1bmMpIHtcblx0ICAgIG1hdGNoZXNTZWxlY3RvckZ1bmMgPSBmaW5kSW5BcnJheShbJ21hdGNoZXMnLCAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJywgJ21vek1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdvTWF0Y2hlc1NlbGVjdG9yJ10sIGZ1bmN0aW9uIChtZXRob2QpIHtcblx0ICAgICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuXHQgICAgICByZXR1cm4gaXNGdW5jdGlvbihlbFttZXRob2RdKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIC8vIE1pZ2h0IG5vdCBiZSBmb3VuZCBlbnRpcmVseSAobm90IGFuIEVsZW1lbnQ/KSAtIGluIHRoYXQgY2FzZSwgYmFpbFxuXHQgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcblx0ICBpZiAoIWlzRnVuY3Rpb24oZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10pKSByZXR1cm4gZmFsc2U7XG5cblx0ICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG5cdCAgcmV0dXJuIGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdKHNlbGVjdG9yKTtcblx0fVxuXG5cdC8vIFdvcmtzIHVwIHRoZSB0cmVlIHRvIHRoZSBkcmFnZ2FibGUgaXRzZWxmIGF0dGVtcHRpbmcgdG8gbWF0Y2ggc2VsZWN0b3IuXG5cdGZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyhlbCAvKjogTm9kZSovLCBzZWxlY3RvciAvKjogc3RyaW5nKi8sIGJhc2VOb2RlIC8qOiBOb2RlKi8pIC8qOiBib29sZWFuKi8ge1xuXHQgIHZhciBub2RlID0gZWw7XG5cdCAgZG8ge1xuXHQgICAgaWYgKG1hdGNoZXNTZWxlY3Rvcihub2RlLCBzZWxlY3RvcikpIHJldHVybiB0cnVlO1xuXHQgICAgaWYgKG5vZGUgPT09IGJhc2VOb2RlKSByZXR1cm4gZmFsc2U7XG5cdCAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHQgIH0gd2hpbGUgKG5vZGUpO1xuXG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLykgLyo6IHZvaWQqLyB7XG5cdCAgaWYgKCFlbCkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcblx0ICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG5cdCAgfSBlbHNlIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuXHQgICAgZWxbJ29uJyArIGV2ZW50XSA9IGhhbmRsZXI7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLykgLyo6IHZvaWQqLyB7XG5cdCAgaWYgKCFlbCkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcblx0ICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG5cdCAgfSBlbHNlIGlmIChlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdCAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuXHQgICAgZWxbJ29uJyArIGV2ZW50XSA9IG51bGw7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gb3V0ZXJIZWlnaHQobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciovIHtcblx0ICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcblx0ICAvLyBvZmZzZXRUb3Agd2hpY2ggaXMgaW5jbHVkaW5nIG1hcmdpbi4gU2VlIGdldEJvdW5kUG9zaXRpb25cblx0ICB2YXIgaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG5cdCAgdmFyIGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0ICBoZWlnaHQgKz0gaW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuXHQgIGhlaWdodCArPSBpbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG5cdCAgcmV0dXJuIGhlaWdodDtcblx0fVxuXG5cdGZ1bmN0aW9uIG91dGVyV2lkdGgobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciovIHtcblx0ICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcblx0ICAvLyBvZmZzZXRMZWZ0IHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG5cdCAgdmFyIHdpZHRoID0gbm9kZS5jbGllbnRXaWR0aDtcblx0ICB2YXIgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHQgIHdpZHRoICs9IGludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCk7XG5cdCAgd2lkdGggKz0gaW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG5cdCAgcmV0dXJuIHdpZHRoO1xuXHR9XG5cdGZ1bmN0aW9uIGlubmVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqLyB7XG5cdCAgdmFyIGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuXHQgIHZhciBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdCAgaGVpZ2h0IC09IGludChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApO1xuXHQgIGhlaWdodCAtPSBpbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKTtcblx0ICByZXR1cm4gaGVpZ2h0O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5uZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi8ge1xuXHQgIHZhciB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG5cdCAgdmFyIGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0ICB3aWR0aCAtPSBpbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCk7XG5cdCAgd2lkdGggLT0gaW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KTtcblx0ICByZXR1cm4gd2lkdGg7XG5cdH1cblxuXHQvLyBHZXQgZnJvbSBvZmZzZXRQYXJlbnRcblx0ZnVuY3Rpb24gb2Zmc2V0WFlGcm9tUGFyZW50KGV2dCAvKjoge2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfSovLCBvZmZzZXRQYXJlbnQgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBDb250cm9sUG9zaXRpb24qLyB7XG5cdCAgdmFyIGlzQm9keSA9IG9mZnNldFBhcmVudCA9PT0gb2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcblx0ICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGlzQm9keSA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0ICB2YXIgeCA9IGV2dC5jbGllbnRYICsgb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQgLSBvZmZzZXRQYXJlbnRSZWN0LmxlZnQ7XG5cdCAgdmFyIHkgPSBldnQuY2xpZW50WSArIG9mZnNldFBhcmVudC5zY3JvbGxUb3AgLSBvZmZzZXRQYXJlbnRSZWN0LnRvcDtcblxuXHQgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNTU1RyYW5zZm9ybShjb250cm9sUG9zIC8qOiBDb250cm9sUG9zaXRpb24qLywgcG9zaXRpb25PZmZzZXQgLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi8pIC8qOiBPYmplY3QqLyB7XG5cdCAgdmFyIHRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb24oY29udHJvbFBvcywgcG9zaXRpb25PZmZzZXQsICdweCcpO1xuXHQgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgYnJvd3NlclByZWZpeFRvS2V5KCd0cmFuc2Zvcm0nLCBicm93c2VyUHJlZml4KSwgdHJhbnNsYXRpb24pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlU1ZHVHJhbnNmb3JtKGNvbnRyb2xQb3MgLyo6IENvbnRyb2xQb3NpdGlvbiovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLykgLyo6IHN0cmluZyovIHtcblx0ICB2YXIgdHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbihjb250cm9sUG9zLCBwb3NpdGlvbk9mZnNldCwgJycpO1xuXHQgIHJldHVybiB0cmFuc2xhdGlvbjtcblx0fVxuXHRmdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihfcmVmMiwgcG9zaXRpb25PZmZzZXQgLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi8sIHVuaXRTdWZmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi8ge1xuXHQgIHZhciB4ID0gX3JlZjIueCxcblx0ICAgICAgeSA9IF9yZWYyLnk7XG5cblx0ICB2YXIgdHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCcgKyB4ICsgdW5pdFN1ZmZpeCArICcsJyArIHkgKyB1bml0U3VmZml4ICsgJyknO1xuXHQgIGlmIChwb3NpdGlvbk9mZnNldCkge1xuXHQgICAgdmFyIGRlZmF1bHRYID0gJycgKyAodHlwZW9mIHBvc2l0aW9uT2Zmc2V0LnggPT09ICdzdHJpbmcnID8gcG9zaXRpb25PZmZzZXQueCA6IHBvc2l0aW9uT2Zmc2V0LnggKyB1bml0U3VmZml4KTtcblx0ICAgIHZhciBkZWZhdWx0WSA9ICcnICsgKHR5cGVvZiBwb3NpdGlvbk9mZnNldC55ID09PSAnc3RyaW5nJyA/IHBvc2l0aW9uT2Zmc2V0LnkgOiBwb3NpdGlvbk9mZnNldC55ICsgdW5pdFN1ZmZpeCk7XG5cdCAgICB0cmFuc2xhdGlvbiA9ICd0cmFuc2xhdGUoJyArIGRlZmF1bHRYICsgJywgJyArIGRlZmF1bHRZICsgJyknICsgdHJhbnNsYXRpb247XG5cdCAgfVxuXHQgIHJldHVybiB0cmFuc2xhdGlvbjtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRvdWNoKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovLCBpZGVudGlmaWVyIC8qOiBudW1iZXIqLykgLyo6ID97Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9Ki8ge1xuXHQgIHJldHVybiBlLnRhcmdldFRvdWNoZXMgJiYgZmluZEluQXJyYXkoZS50YXJnZXRUb3VjaGVzLCBmdW5jdGlvbiAodCkge1xuXHQgICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IHQuaWRlbnRpZmllcjtcblx0ICB9KSB8fCBlLmNoYW5nZWRUb3VjaGVzICYmIGZpbmRJbkFycmF5KGUuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0KSB7XG5cdCAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gdC5pZGVudGlmaWVyO1xuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VG91Y2hJZGVudGlmaWVyKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovKSAvKjogP251bWJlciovIHtcblx0ICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlc1swXSkgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyO1xuXHQgIGlmIChlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXNbMF0pIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG5cdH1cblxuXHQvLyBVc2VyLXNlbGVjdCBIYWNrczpcblx0Ly9cblx0Ly8gVXNlZnVsIGZvciBwcmV2ZW50aW5nIGJsdWUgaGlnaGxpZ2h0cyBhbGwgb3ZlciBldmVyeXRoaW5nIHdoZW4gZHJhZ2dpbmcuXG5cblx0Ly8gTm90ZSB3ZSdyZSBwYXNzaW5nIGBkb2N1bWVudGAgYi9jIHdlIGNvdWxkIGJlIGlmcmFtZWRcblx0ZnVuY3Rpb24gYWRkVXNlclNlbGVjdFN0eWxlcyhkb2MgLyo6ID9Eb2N1bWVudCovKSB7XG5cdCAgaWYgKCFkb2MpIHJldHVybjtcblx0ICB2YXIgc3R5bGVFbCA9IGRvYy5nZXRFbGVtZW50QnlJZCgncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJyk7XG5cdCAgaWYgKCFzdHlsZUVsKSB7XG5cdCAgICBzdHlsZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICBzdHlsZUVsLnR5cGUgPSAndGV4dC9jc3MnO1xuXHQgICAgc3R5bGVFbC5pZCA9ICdyZWFjdC1kcmFnZ2FibGUtc3R5bGUtZWwnO1xuXHQgICAgc3R5bGVFbC5pbm5lckhUTUwgPSAnLnJlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24gKjo6LW1vei1zZWxlY3Rpb24ge2JhY2tncm91bmQ6IHRyYW5zcGFyZW50O31cXG4nO1xuXHQgICAgc3R5bGVFbC5pbm5lckhUTUwgKz0gJy5yZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7fVxcbic7XG5cdCAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsKTtcblx0ICB9XG5cdCAgaWYgKGRvYy5ib2R5KSBhZGRDbGFzc05hbWUoZG9jLmJvZHksICdyZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uJyk7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmVVc2VyU2VsZWN0U3R5bGVzKGRvYyAvKjogP0RvY3VtZW50Ki8pIHtcblx0ICB0cnkge1xuXHQgICAgaWYgKGRvYyAmJiBkb2MuYm9keSkgcmVtb3ZlQ2xhc3NOYW1lKGRvYy5ib2R5LCAncmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbicpO1xuXHQgICAgLy8gJEZsb3dJZ25vcmU6IElFXG5cdCAgICBpZiAoZG9jLnNlbGVjdGlvbikge1xuXHQgICAgICAvLyAkRmxvd0lnbm9yZTogSUVcblx0ICAgICAgZG9jLnNlbGVjdGlvbi5lbXB0eSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpOyAvLyByZW1vdmUgc2VsZWN0aW9uIGNhdXNlZCBieSBzY3JvbGxcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICAvLyBwcm9iYWJseSBJRVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHN0eWxlSGFja3MoKSAvKjogT2JqZWN0Ki8ge1xuXHQgIHZhciBjaGlsZFN0eWxlIC8qOiBPYmplY3QqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblx0ICAvLyBXb3JrYXJvdW5kIElFIHBvaW50ZXIgZXZlbnRzOyBzZWUgIzUxXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvcmVhY3QtZHJhZ2dhYmxlL2lzc3Vlcy81MSNpc3N1ZWNvbW1lbnQtMTAzNDg4Mjc4XG5cdCAgcmV0dXJuIF9leHRlbmRzKHtcblx0ICAgIHRvdWNoQWN0aW9uOiAnbm9uZSdcblx0ICB9LCBjaGlsZFN0eWxlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZENsYXNzTmFtZShlbCAvKjogSFRNTEVsZW1lbnQqLywgY2xhc3NOYW1lIC8qOiBzdHJpbmcqLykge1xuXHQgIGlmIChlbC5jbGFzc0xpc3QpIHtcblx0ICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKCFlbC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cCgnKD86XnxcXFxccyknICsgY2xhc3NOYW1lICsgJyg/IVxcXFxTKScpKSkge1xuXHQgICAgICBlbC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZShlbCAvKjogSFRNTEVsZW1lbnQqLywgY2xhc3NOYW1lIC8qOiBzdHJpbmcqLykge1xuXHQgIGlmIChlbC5jbGFzc0xpc3QpIHtcblx0ICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnKD86XnxcXFxccyknICsgY2xhc3NOYW1lICsgJyg/IVxcXFxTKScsICdnJyksICcnKTtcblx0ICB9XG5cdH1cblxuXHQvKjo6IGltcG9ydCB0eXBlIERyYWdnYWJsZSBmcm9tICcuLi9EcmFnZ2FibGUnOyovXG5cdC8qOjogaW1wb3J0IHR5cGUge0JvdW5kcywgQ29udHJvbFBvc2l0aW9uLCBEcmFnZ2FibGVEYXRhLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG5cdC8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZSBmcm9tICcuLi9EcmFnZ2FibGVDb3JlJzsqL1xuXG5cblx0ZnVuY3Rpb24gZ2V0Qm91bmRQb3NpdGlvbihkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi8ge1xuXHQgIC8vIElmIG5vIGJvdW5kcywgc2hvcnQtY2lyY3VpdCBhbmQgbW92ZSBvblxuXHQgIGlmICghZHJhZ2dhYmxlLnByb3BzLmJvdW5kcykgcmV0dXJuIFt4LCB5XTtcblxuXHQgIC8vIENsb25lIG5ldyBib3VuZHNcblx0ICB2YXIgYm91bmRzID0gZHJhZ2dhYmxlLnByb3BzLmJvdW5kcztcblxuXHQgIGJvdW5kcyA9IHR5cGVvZiBib3VuZHMgPT09ICdzdHJpbmcnID8gYm91bmRzIDogY2xvbmVCb3VuZHMoYm91bmRzKTtcblx0ICB2YXIgbm9kZSA9IGZpbmRET01Ob2RlKGRyYWdnYWJsZSk7XG5cblx0ICBpZiAodHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuXG5cdCAgICB2YXIgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHQgICAgdmFyIGJvdW5kTm9kZSA9IHZvaWQgMDtcblx0ICAgIGlmIChib3VuZHMgPT09ICdwYXJlbnQnKSB7XG5cdCAgICAgIGJvdW5kTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGJvdW5kTm9kZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3Rvcihib3VuZHMpO1xuXHQgICAgfVxuXHQgICAgaWYgKCEoYm91bmROb2RlIGluc3RhbmNlb2Ygb3duZXJXaW5kb3cuSFRNTEVsZW1lbnQpKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignQm91bmRzIHNlbGVjdG9yIFwiJyArIGJvdW5kcyArICdcIiBjb3VsZCBub3QgZmluZCBhbiBlbGVtZW50LicpO1xuXHQgICAgfVxuXHQgICAgdmFyIG5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdCAgICB2YXIgYm91bmROb2RlU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJvdW5kTm9kZSk7XG5cdCAgICAvLyBDb21wdXRlIGJvdW5kcy4gVGhpcyBpcyBhIHBhaW4gd2l0aCBwYWRkaW5nIGFuZCBvZmZzZXRzIGJ1dCB0aGlzIGdldHMgaXQgZXhhY3RseSByaWdodC5cblx0ICAgIGJvdW5kcyA9IHtcblx0ICAgICAgbGVmdDogLW5vZGUub2Zmc2V0TGVmdCArIGludChib3VuZE5vZGVTdHlsZS5wYWRkaW5nTGVmdCkgKyBpbnQobm9kZVN0eWxlLm1hcmdpbkxlZnQpLFxuXHQgICAgICB0b3A6IC1ub2RlLm9mZnNldFRvcCArIGludChib3VuZE5vZGVTdHlsZS5wYWRkaW5nVG9wKSArIGludChub2RlU3R5bGUubWFyZ2luVG9wKSxcblx0ICAgICAgcmlnaHQ6IGlubmVyV2lkdGgoYm91bmROb2RlKSAtIG91dGVyV2lkdGgobm9kZSkgLSBub2RlLm9mZnNldExlZnQgKyBpbnQoYm91bmROb2RlU3R5bGUucGFkZGluZ1JpZ2h0KSAtIGludChub2RlU3R5bGUubWFyZ2luUmlnaHQpLFxuXHQgICAgICBib3R0b206IGlubmVySGVpZ2h0KGJvdW5kTm9kZSkgLSBvdXRlckhlaWdodChub2RlKSAtIG5vZGUub2Zmc2V0VG9wICsgaW50KGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdCb3R0b20pIC0gaW50KG5vZGVTdHlsZS5tYXJnaW5Cb3R0b20pXG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIC8vIEtlZXAgeCBhbmQgeSBiZWxvdyByaWdodCBhbmQgYm90dG9tIGxpbWl0cy4uLlxuXHQgIGlmIChpc051bShib3VuZHMucmlnaHQpKSB4ID0gTWF0aC5taW4oeCwgYm91bmRzLnJpZ2h0KTtcblx0ICBpZiAoaXNOdW0oYm91bmRzLmJvdHRvbSkpIHkgPSBNYXRoLm1pbih5LCBib3VuZHMuYm90dG9tKTtcblxuXHQgIC8vIEJ1dCBhYm92ZSBsZWZ0IGFuZCB0b3AgbGltaXRzLlxuXHQgIGlmIChpc051bShib3VuZHMubGVmdCkpIHggPSBNYXRoLm1heCh4LCBib3VuZHMubGVmdCk7XG5cdCAgaWYgKGlzTnVtKGJvdW5kcy50b3ApKSB5ID0gTWF0aC5tYXgoeSwgYm91bmRzLnRvcCk7XG5cblx0ICByZXR1cm4gW3gsIHldO1xuXHR9XG5cblx0ZnVuY3Rpb24gc25hcFRvR3JpZChncmlkIC8qOiBbbnVtYmVyLCBudW1iZXJdKi8sIHBlbmRpbmdYIC8qOiBudW1iZXIqLywgcGVuZGluZ1kgLyo6IG51bWJlciovKSAvKjogW251bWJlciwgbnVtYmVyXSovIHtcblx0ICB2YXIgeCA9IE1hdGgucm91bmQocGVuZGluZ1ggLyBncmlkWzBdKSAqIGdyaWRbMF07XG5cdCAgdmFyIHkgPSBNYXRoLnJvdW5kKHBlbmRpbmdZIC8gZ3JpZFsxXSkgKiBncmlkWzFdO1xuXHQgIHJldHVybiBbeCwgeV07XG5cdH1cblxuXHRmdW5jdGlvbiBjYW5EcmFnWChkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovKSAvKjogYm9vbGVhbiovIHtcblx0ICByZXR1cm4gZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICdib3RoJyB8fCBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ3gnO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FuRHJhZ1koZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLykgLyo6IGJvb2xlYW4qLyB7XG5cdCAgcmV0dXJuIGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICd5Jztcblx0fVxuXG5cdC8vIEdldCB7eCwgeX0gcG9zaXRpb25zIGZyb20gZXZlbnQuXG5cdGZ1bmN0aW9uIGdldENvbnRyb2xQb3NpdGlvbihlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLywgdG91Y2hJZGVudGlmaWVyIC8qOiA/bnVtYmVyKi8sIGRyYWdnYWJsZUNvcmUgLyo6IERyYWdnYWJsZUNvcmUqLykgLyo6ID9Db250cm9sUG9zaXRpb24qLyB7XG5cdCAgdmFyIHRvdWNoT2JqID0gdHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgPyBnZXRUb3VjaChlLCB0b3VjaElkZW50aWZpZXIpIDogbnVsbDtcblx0ICBpZiAodHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgJiYgIXRvdWNoT2JqKSByZXR1cm4gbnVsbDsgLy8gbm90IHRoZSByaWdodCB0b3VjaFxuXHQgIHZhciBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlQ29yZSk7XG5cdCAgLy8gVXNlciBjYW4gcHJvdmlkZSBhbiBvZmZzZXRQYXJlbnQgaWYgZGVzaXJlZC5cblx0ICB2YXIgb2Zmc2V0UGFyZW50ID0gZHJhZ2dhYmxlQ29yZS5wcm9wcy5vZmZzZXRQYXJlbnQgfHwgbm9kZS5vZmZzZXRQYXJlbnQgfHwgbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG5cdCAgcmV0dXJuIG9mZnNldFhZRnJvbVBhcmVudCh0b3VjaE9iaiB8fCBlLCBvZmZzZXRQYXJlbnQpO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGFuIGRhdGEgb2JqZWN0IGV4cG9zZWQgYnkgPERyYWdnYWJsZUNvcmU+J3MgZXZlbnRzXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvcmVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlQ29yZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi8ge1xuXHQgIHZhciBzdGF0ZSA9IGRyYWdnYWJsZS5zdGF0ZTtcblx0ICB2YXIgaXNTdGFydCA9ICFpc051bShzdGF0ZS5sYXN0WCk7XG5cdCAgdmFyIG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGUpO1xuXG5cdCAgaWYgKGlzU3RhcnQpIHtcblx0ICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IG1vdmUsIHVzZSB0aGUgeCBhbmQgeSBhcyBsYXN0IGNvb3Jkcy5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIG5vZGU6IG5vZGUsXG5cdCAgICAgIGRlbHRhWDogMCwgZGVsdGFZOiAwLFxuXHQgICAgICBsYXN0WDogeCwgbGFzdFk6IHksXG5cdCAgICAgIHg6IHgsIHk6IHlcblx0ICAgIH07XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcHJvcGVyIHZhbHVlcy5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIG5vZGU6IG5vZGUsXG5cdCAgICAgIGRlbHRhWDogeCAtIHN0YXRlLmxhc3RYLCBkZWx0YVk6IHkgLSBzdGF0ZS5sYXN0WSxcblx0ICAgICAgbGFzdFg6IHN0YXRlLmxhc3RYLCBsYXN0WTogc3RhdGUubGFzdFksXG5cdCAgICAgIHg6IHgsIHk6IHlcblx0ICAgIH07XG5cdCAgfVxuXHR9XG5cblx0Ly8gQ3JlYXRlIGFuIGRhdGEgZXhwb3NlZCBieSA8RHJhZ2dhYmxlPidzIGV2ZW50c1xuXHRmdW5jdGlvbiBjcmVhdGVEcmFnZ2FibGVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8sIGNvcmVEYXRhIC8qOiBEcmFnZ2FibGVEYXRhKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi8ge1xuXHQgIHZhciBzY2FsZSA9IGRyYWdnYWJsZS5wcm9wcy5zY2FsZTtcblx0ICByZXR1cm4ge1xuXHQgICAgbm9kZTogY29yZURhdGEubm9kZSxcblx0ICAgIHg6IGRyYWdnYWJsZS5zdGF0ZS54ICsgY29yZURhdGEuZGVsdGFYIC8gc2NhbGUsXG5cdCAgICB5OiBkcmFnZ2FibGUuc3RhdGUueSArIGNvcmVEYXRhLmRlbHRhWSAvIHNjYWxlLFxuXHQgICAgZGVsdGFYOiBjb3JlRGF0YS5kZWx0YVggLyBzY2FsZSxcblx0ICAgIGRlbHRhWTogY29yZURhdGEuZGVsdGFZIC8gc2NhbGUsXG5cdCAgICBsYXN0WDogZHJhZ2dhYmxlLnN0YXRlLngsXG5cdCAgICBsYXN0WTogZHJhZ2dhYmxlLnN0YXRlLnlcblx0ICB9O1xuXHR9XG5cblx0Ly8gQSBsb3QgZmFzdGVyIHRoYW4gc3RyaW5naWZ5L3BhcnNlXG5cdGZ1bmN0aW9uIGNsb25lQm91bmRzKGJvdW5kcyAvKjogQm91bmRzKi8pIC8qOiBCb3VuZHMqLyB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGxlZnQ6IGJvdW5kcy5sZWZ0LFxuXHQgICAgdG9wOiBib3VuZHMudG9wLFxuXHQgICAgcmlnaHQ6IGJvdW5kcy5yaWdodCxcblx0ICAgIGJvdHRvbTogYm91bmRzLmJvdHRvbVxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kRE9NTm9kZShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSB8IERyYWdnYWJsZUNvcmUqLykgLyo6IEhUTUxFbGVtZW50Ki8ge1xuXHQgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcblx0ICBpZiAoIW5vZGUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignPERyYWdnYWJsZUNvcmU+OiBVbm1vdW50ZWQgZHVyaW5nIGV2ZW50IScpO1xuXHQgIH1cblx0ICAvLyAkRmxvd0lnbm9yZSB3ZSBjYW4ndCBhc3NlcnQgb24gSFRNTEVsZW1lbnQgZHVlIHRvIHRlc3RzLi4uIEZJWE1FXG5cdCAgcmV0dXJuIG5vZGU7XG5cdH1cblxuXHQvKmVzbGludCBuby1jb25zb2xlOjAqL1xuXHRmdW5jdGlvbiBsb2coKSB7XG5cdH1cblxuXHQvKjo6IGltcG9ydCB0eXBlIHtFdmVudEhhbmRsZXIsIE1vdXNlVG91Y2hFdmVudH0gZnJvbSAnLi91dGlscy90eXBlcyc7Ki9cblxuXG5cdC8vIFNpbXBsZSBhYnN0cmFjdGlvbiBmb3IgZHJhZ2dpbmcgZXZlbnRzIG5hbWVzLlxuXHQvKjo6IGltcG9ydCB0eXBlIHtFbGVtZW50IGFzIFJlYWN0RWxlbWVudH0gZnJvbSAncmVhY3QnOyovXG5cdHZhciBldmVudHNGb3IgPSB7XG5cdCAgdG91Y2g6IHtcblx0ICAgIHN0YXJ0OiAndG91Y2hzdGFydCcsXG5cdCAgICBtb3ZlOiAndG91Y2htb3ZlJyxcblx0ICAgIHN0b3A6ICd0b3VjaGVuZCdcblx0ICB9LFxuXHQgIG1vdXNlOiB7XG5cdCAgICBzdGFydDogJ21vdXNlZG93bicsXG5cdCAgICBtb3ZlOiAnbW91c2Vtb3ZlJyxcblx0ICAgIHN0b3A6ICdtb3VzZXVwJ1xuXHQgIH1cblx0fTtcblxuXHQvLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cblx0dmFyIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci5tb3VzZTtcblxuXHQvKjo6IHR5cGUgRHJhZ2dhYmxlQ29yZVN0YXRlID0ge1xuXHQgIGRyYWdnaW5nOiBib29sZWFuLFxuXHQgIGxhc3RYOiBudW1iZXIsXG5cdCAgbGFzdFk6IG51bWJlcixcblx0ICB0b3VjaElkZW50aWZpZXI6ID9udW1iZXJcblx0fTsqL1xuXHQvKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZUJvdW5kcyA9IHtcblx0ICBsZWZ0OiBudW1iZXIsXG5cdCAgcmlnaHQ6IG51bWJlcixcblx0ICB0b3A6IG51bWJlcixcblx0ICBib3R0b206IG51bWJlcixcblx0fTsqL1xuXHQvKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZURhdGEgPSB7XG5cdCAgbm9kZTogSFRNTEVsZW1lbnQsXG5cdCAgeDogbnVtYmVyLCB5OiBudW1iZXIsXG5cdCAgZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyLFxuXHQgIGxhc3RYOiBudW1iZXIsIGxhc3RZOiBudW1iZXIsXG5cdH07Ki9cblx0Lyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCwgZGF0YTogRHJhZ2dhYmxlRGF0YSkgPT4gdm9pZDsqL1xuXHQvKjo6IGV4cG9ydCB0eXBlIENvbnRyb2xQb3NpdGlvbiA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn07Ki9cblx0Lyo6OiBleHBvcnQgdHlwZSBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiA9IHt4OiBudW1iZXJ8c3RyaW5nLCB5OiBudW1iZXJ8c3RyaW5nfTsqL1xuXG5cblx0Ly9cblx0Ly8gRGVmaW5lIDxEcmFnZ2FibGVDb3JlPi5cblx0Ly9cblx0Ly8gPERyYWdnYWJsZUNvcmU+IGlzIGZvciBhZHZhbmNlZCB1c2FnZSBvZiA8RHJhZ2dhYmxlPi4gSXQgbWFpbnRhaW5zIG1pbmltYWwgaW50ZXJuYWwgc3RhdGUgc28gaXQgY2FuXG5cdC8vIHdvcmsgd2VsbCB3aXRoIGxpYnJhcmllcyB0aGF0IHJlcXVpcmUgbW9yZSBjb250cm9sIG92ZXIgdGhlIGVsZW1lbnQuXG5cdC8vXG5cblx0Lyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVDb3JlUHJvcHMgPSB7XG5cdCAgYWxsb3dBbnlDbGljazogYm9vbGVhbixcblx0ICBjYW5jZWw6IHN0cmluZyxcblx0ICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG5cdCAgZGlzYWJsZWQ6IGJvb2xlYW4sXG5cdCAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IGJvb2xlYW4sXG5cdCAgb2Zmc2V0UGFyZW50OiBIVE1MRWxlbWVudCxcblx0ICBncmlkOiBbbnVtYmVyLCBudW1iZXJdLFxuXHQgIGhhbmRsZTogc3RyaW5nLFxuXHQgIG9uU3RhcnQ6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcblx0ICBvbkRyYWc6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcblx0ICBvblN0b3A6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcblx0ICBvbk1vdXNlRG93bjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQsXG5cdH07Ki9cblxuXHR2YXIgRHJhZ2dhYmxlQ29yZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG5cdCAgaW5oZXJpdHMoRHJhZ2dhYmxlQ29yZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ICBmdW5jdGlvbiBEcmFnZ2FibGVDb3JlKCkge1xuXHQgICAgdmFyIF9yZWY7XG5cblx0ICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cblx0ICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdnYWJsZUNvcmUpO1xuXG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9yZWYgPSBEcmFnZ2FibGVDb3JlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJhZ2dhYmxlQ29yZSkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuXHQgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cdCAgICAgIC8vIFVzZWQgd2hpbGUgZHJhZ2dpbmcgdG8gZGV0ZXJtaW5lIGRlbHRhcy5cblx0ICAgICAgbGFzdFg6IE5hTiwgbGFzdFk6IE5hTixcblx0ICAgICAgdG91Y2hJZGVudGlmaWVyOiBudWxsXG5cdCAgICB9LCBfdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyBvbiB0b3Agb2YgdGhpcyBvbmUuXG5cdCAgICAgIF90aGlzLnByb3BzLm9uTW91c2VEb3duKGUpO1xuXG5cdCAgICAgIC8vIE9ubHkgYWNjZXB0IGxlZnQtY2xpY2tzLlxuXHQgICAgICBpZiAoIV90aGlzLnByb3BzLmFsbG93QW55Q2xpY2sgJiYgdHlwZW9mIGUuYnV0dG9uID09PSAnbnVtYmVyJyAmJiBlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIC8vIEdldCBub2Rlcy4gQmUgc3VyZSB0byBncmFiIHJlbGF0aXZlIGRvY3VtZW50IChjb3VsZCBiZSBpZnJhbWVkKVxuXHQgICAgICB2YXIgdGhpc05vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZShfdGhpcyk7XG5cdCAgICAgIGlmICghdGhpc05vZGUgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQuYm9keSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignPERyYWdnYWJsZUNvcmU+IG5vdCBtb3VudGVkIG9uIERyYWdTdGFydCEnKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXNOb2RlLm93bmVyRG9jdW1lbnQ7XG5cblx0ICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBoYW5kbGUgb3IgY2FuY2VsIHByb3Agd2FzIHByb3ZpZGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IG1hdGNoLlxuXG5cdCAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCAhKGUudGFyZ2V0IGluc3RhbmNlb2Ygb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5Ob2RlKSB8fCBfdGhpcy5wcm9wcy5oYW5kbGUgJiYgIW1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyhlLnRhcmdldCwgX3RoaXMucHJvcHMuaGFuZGxlLCB0aGlzTm9kZSkgfHwgX3RoaXMucHJvcHMuY2FuY2VsICYmIG1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyhlLnRhcmdldCwgX3RoaXMucHJvcHMuY2FuY2VsLCB0aGlzTm9kZSkpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBTZXQgdG91Y2ggaWRlbnRpZmllciBpbiBjb21wb25lbnQgc3RhdGUgaWYgdGhpcyBpcyBhIHRvdWNoIGV2ZW50LiBUaGlzIGFsbG93cyB1cyB0b1xuXHQgICAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGluZGl2aWR1YWwgdG91Y2hlcyBvbiBtdWx0aXRvdWNoIHNjcmVlbnMgYnkgaWRlbnRpZnlpbmcgd2hpY2hcblx0ICAgICAgLy8gdG91Y2hwb2ludCB3YXMgc2V0IHRvIHRoaXMgZWxlbWVudC5cblx0ICAgICAgdmFyIHRvdWNoSWRlbnRpZmllciA9IGdldFRvdWNoSWRlbnRpZmllcihlKTtcblx0ICAgICAgX3RoaXMuc2V0U3RhdGUoeyB0b3VjaElkZW50aWZpZXI6IHRvdWNoSWRlbnRpZmllciB9KTtcblxuXHQgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG5cdCAgICAgIHZhciBwb3NpdGlvbiA9IGdldENvbnRyb2xQb3NpdGlvbihlLCB0b3VjaElkZW50aWZpZXIsIF90aGlzKTtcblx0ICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHJldHVybjsgLy8gbm90IHBvc3NpYmxlIGJ1dCBzYXRpc2ZpZXMgZmxvd1xuXHQgICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG5cdCAgICAgICAgICB5ID0gcG9zaXRpb24ueTtcblxuXHQgICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgb2JqZWN0IHdpdGggYWxsIHRoZSBkYXRhIHBhcmVudHMgbmVlZCB0byBtYWtlIGEgZGVjaXNpb24gaGVyZS5cblxuXHQgICAgICB2YXIgY29yZUV2ZW50ID0gY3JlYXRlQ29yZURhdGEoX3RoaXMsIHgsIHkpO1xuXG5cdCAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlci4gSWYgaXQgcmV0dXJucyBleHBsaWNpdCBmYWxzZSwgY2FuY2VsLlxuXHQgICAgICBsb2coJ2NhbGxpbmcnLCBfdGhpcy5wcm9wcy5vblN0YXJ0KTtcblx0ICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IF90aGlzLnByb3BzLm9uU3RhcnQoZSwgY29yZUV2ZW50KTtcblx0ICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcblxuXHQgICAgICAvLyBBZGQgYSBzdHlsZSB0byB0aGUgYm9keSB0byBkaXNhYmxlIHVzZXItc2VsZWN0LiBUaGlzIHByZXZlbnRzIHRleHQgZnJvbVxuXHQgICAgICAvLyBiZWluZyBzZWxlY3RlZCBhbGwgb3ZlciB0aGUgcGFnZS5cblx0ICAgICAgaWYgKF90aGlzLnByb3BzLmVuYWJsZVVzZXJTZWxlY3RIYWNrKSBhZGRVc2VyU2VsZWN0U3R5bGVzKG93bmVyRG9jdW1lbnQpO1xuXG5cdCAgICAgIC8vIEluaXRpYXRlIGRyYWdnaW5nLiBTZXQgdGhlIGN1cnJlbnQgeCBhbmQgeSBhcyBvZmZzZXRzXG5cdCAgICAgIC8vIHNvIHdlIGtub3cgaG93IG11Y2ggd2UndmUgbW92ZWQgZHVyaW5nIHRoZSBkcmFnLiBUaGlzIGFsbG93cyB1c1xuXHQgICAgICAvLyB0byBkcmFnIGVsZW1lbnRzIGFyb3VuZCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIG1vdmVkLCB3aXRob3V0IGlzc3VlLlxuXHQgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG5cdCAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG5cblx0ICAgICAgICBsYXN0WDogeCxcblx0ICAgICAgICBsYXN0WTogeVxuXHQgICAgICB9KTtcblxuXHQgICAgICAvLyBBZGQgZXZlbnRzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSBzbyB3ZSBjYXRjaCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UvdG91Y2ggbW92ZXMgb3V0c2lkZSBvZlxuXHQgICAgICAvLyB0aGlzIGVsZW1lbnQuIFdlIHVzZSBkaWZmZXJlbnQgZXZlbnRzIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCB3ZSBoYXZlIGRldGVjdGVkIHRoYXQgdGhpc1xuXHQgICAgICAvLyBpcyBhIHRvdWNoLWNhcGFibGUgZGV2aWNlLlxuXHQgICAgICBhZGRFdmVudChvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3IubW92ZSwgX3RoaXMuaGFuZGxlRHJhZyk7XG5cdCAgICAgIGFkZEV2ZW50KG93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5zdG9wLCBfdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG5cdCAgICB9LCBfdGhpcy5oYW5kbGVEcmFnID0gZnVuY3Rpb24gKGUpIHtcblxuXHQgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBtb2JpbGUgZGV2aWNlcywgbGlrZSBpcGFkL2lwaG9uZS5cblx0ICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNobW92ZScpIGUucHJldmVudERlZmF1bHQoKTtcblxuXHQgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG5cdCAgICAgIHZhciBwb3NpdGlvbiA9IGdldENvbnRyb2xQb3NpdGlvbihlLCBfdGhpcy5zdGF0ZS50b3VjaElkZW50aWZpZXIsIF90aGlzKTtcblx0ICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHJldHVybjtcblx0ICAgICAgdmFyIHggPSBwb3NpdGlvbi54LFxuXHQgICAgICAgICAgeSA9IHBvc2l0aW9uLnk7XG5cblx0ICAgICAgLy8gU25hcCB0byBncmlkIGlmIHByb3AgaGFzIGJlZW4gcHJvdmlkZWRcblxuXHQgICAgICBpZiAoQXJyYXkuaXNBcnJheShfdGhpcy5wcm9wcy5ncmlkKSkge1xuXHQgICAgICAgIHZhciBfZGVsdGFYID0geCAtIF90aGlzLnN0YXRlLmxhc3RYLFxuXHQgICAgICAgICAgICBfZGVsdGFZID0geSAtIF90aGlzLnN0YXRlLmxhc3RZO1xuXG5cdCAgICAgICAgdmFyIF9zbmFwVG9HcmlkID0gc25hcFRvR3JpZChfdGhpcy5wcm9wcy5ncmlkLCBfZGVsdGFYLCBfZGVsdGFZKTtcblxuXHQgICAgICAgIHZhciBfc25hcFRvR3JpZDIgPSBzbGljZWRUb0FycmF5KF9zbmFwVG9HcmlkLCAyKTtcblxuXHQgICAgICAgIF9kZWx0YVggPSBfc25hcFRvR3JpZDJbMF07XG5cdCAgICAgICAgX2RlbHRhWSA9IF9zbmFwVG9HcmlkMlsxXTtcblxuXHQgICAgICAgIGlmICghX2RlbHRhWCAmJiAhX2RlbHRhWSkgcmV0dXJuOyAvLyBza2lwIHVzZWxlc3MgZHJhZ1xuXHQgICAgICAgIHggPSBfdGhpcy5zdGF0ZS5sYXN0WCArIF9kZWx0YVgsIHkgPSBfdGhpcy5zdGF0ZS5sYXN0WSArIF9kZWx0YVk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgY29yZUV2ZW50ID0gY3JlYXRlQ29yZURhdGEoX3RoaXMsIHgsIHkpO1xuXG5cdCAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlci4gSWYgaXQgcmV0dXJucyBleHBsaWNpdCBmYWxzZSwgdHJpZ2dlciBlbmQuXG5cdCAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBfdGhpcy5wcm9wcy5vbkRyYWcoZSwgY29yZUV2ZW50KTtcblx0ICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgLy8gJEZsb3dJZ25vcmVcblx0ICAgICAgICAgIF90aGlzLmhhbmRsZURyYWdTdG9wKG5ldyBNb3VzZUV2ZW50KCdtb3VzZXVwJykpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgLy8gT2xkIGJyb3dzZXJzXG5cdCAgICAgICAgICB2YXIgZXZlbnQgPSAoKGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpIC8qOiBhbnkqLykgLyo6IE1vdXNlVG91Y2hFdmVudCovKTtcblx0ICAgICAgICAgIC8vIEkgc2VlIHdoeSB0aGlzIGluc2FuaXR5IHdhcyBkZXByZWNhdGVkXG5cdCAgICAgICAgICAvLyAkRmxvd0lnbm9yZVxuXHQgICAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoJ21vdXNldXAnLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblx0ICAgICAgICAgIF90aGlzLmhhbmRsZURyYWdTdG9wKGV2ZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuXHQgICAgICAgIGxhc3RYOiB4LFxuXHQgICAgICAgIGxhc3RZOiB5XG5cdCAgICAgIH0pO1xuXHQgICAgfSwgX3RoaXMuaGFuZGxlRHJhZ1N0b3AgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoIV90aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm47XG5cblx0ICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0Q29udHJvbFBvc2l0aW9uKGUsIF90aGlzLnN0YXRlLnRvdWNoSWRlbnRpZmllciwgX3RoaXMpO1xuXHQgICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuXHQgICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG5cdCAgICAgICAgICB5ID0gcG9zaXRpb24ueTtcblxuXHQgICAgICB2YXIgY29yZUV2ZW50ID0gY3JlYXRlQ29yZURhdGEoX3RoaXMsIHgsIHkpO1xuXG5cdCAgICAgIHZhciB0aGlzTm9kZSA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKF90aGlzKTtcblx0ICAgICAgaWYgKHRoaXNOb2RlKSB7XG5cdCAgICAgICAgLy8gUmVtb3ZlIHVzZXItc2VsZWN0IGhhY2tcblx0ICAgICAgICBpZiAoX3RoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXModGhpc05vZGUub3duZXJEb2N1bWVudCk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBSZXNldCB0aGUgZWwuXG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHtcblx0ICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cdCAgICAgICAgbGFzdFg6IE5hTixcblx0ICAgICAgICBsYXN0WTogTmFOXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlclxuXHQgICAgICBfdGhpcy5wcm9wcy5vblN0b3AoZSwgY29yZUV2ZW50KTtcblxuXHQgICAgICBpZiAodGhpc05vZGUpIHtcblx0ICAgICAgICByZW1vdmVFdmVudCh0aGlzTm9kZS5vd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3IubW92ZSwgX3RoaXMuaGFuZGxlRHJhZyk7XG5cdCAgICAgICAgcmVtb3ZlRXZlbnQodGhpc05vZGUub3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIF90aGlzLmhhbmRsZURyYWdTdG9wKTtcblx0ICAgICAgfVxuXHQgICAgfSwgX3RoaXMub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7IC8vIG9uIHRvdWNoc2NyZWVuIGxhcHRvcHMgd2UgY291bGQgc3dpdGNoIGJhY2sgdG8gbW91c2VcblxuXHQgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUpO1xuXHQgICAgfSwgX3RoaXMub25Nb3VzZVVwID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlO1xuXG5cdCAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcblx0ICAgIH0sIF90aGlzLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuXHQgICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IudG91Y2g7XG5cblx0ICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZURyYWdTdGFydChlKTtcblx0ICAgIH0sIF90aGlzLm9uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcblx0ICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuXG5cdCAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcblx0ICAgIH0sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ2xhc3MoRHJhZ2dhYmxlQ29yZSwgW3tcblx0ICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0ICAgICAgLy8gUmVtb3ZlIGFueSBsZWZ0b3ZlciBldmVudCBoYW5kbGVycy4gUmVtb3ZlIGJvdGggdG91Y2ggYW5kIG1vdXNlIGhhbmRsZXJzIGluIGNhc2Vcblx0ICAgICAgLy8gc29tZSBicm93c2VyIHF1aXJrIGNhdXNlZCBhIHRvdWNoIGV2ZW50IHRvIGZpcmUgZHVyaW5nIGEgbW91c2UgbW92ZSwgb3IgdmljZSB2ZXJzYS5cblx0ICAgICAgdmFyIHRoaXNOb2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cdCAgICAgIGlmICh0aGlzTm9kZSkge1xuXHQgICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpc05vZGUub3duZXJEb2N1bWVudDtcblxuXHQgICAgICAgIHJlbW92ZUV2ZW50KG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuXHQgICAgICAgIHJlbW92ZUV2ZW50KG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuXHQgICAgICAgIHJlbW92ZUV2ZW50KG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcblx0ICAgICAgICByZW1vdmVFdmVudChvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2guc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG5cdCAgICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXMob3duZXJEb2N1bWVudCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gU2FtZSBhcyBvbk1vdXNlRG93biAoc3RhcnQgZHJhZyksIGJ1dCBub3cgY29uc2lkZXIgdGhpcyBhIHRvdWNoIGRldmljZS5cblxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3JlbmRlcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuXHQgICAgICAvLyBSZXVzZSB0aGUgY2hpbGQgcHJvdmlkZWRcblx0ICAgICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0Yylcblx0ICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG5cdCAgICAgICAgc3R5bGU6IHN0eWxlSGFja3ModGhpcy5wcm9wcy5jaGlsZHJlbi5wcm9wcy5zdHlsZSksXG5cblx0ICAgICAgICAvLyBOb3RlOiBtb3VzZU1vdmUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBkb2N1bWVudCBzbyBpdCB3aWxsIHN0aWxsIGZ1bmN0aW9uXG5cdCAgICAgICAgLy8gd2hlbiB0aGUgdXNlciBkcmFncyBxdWlja2x5IGFuZCBsZWF2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cblx0ICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5vbk1vdXNlRG93bixcblx0ICAgICAgICBvblRvdWNoU3RhcnQ6IHRoaXMub25Ub3VjaFN0YXJ0LFxuXHQgICAgICAgIG9uTW91c2VVcDogdGhpcy5vbk1vdXNlVXAsXG5cdCAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5vblRvdWNoRW5kXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0ICByZXR1cm4gRHJhZ2dhYmxlQ29yZTtcblx0fShSZWFjdC5Db21wb25lbnQpO1xuXG5cdERyYWdnYWJsZUNvcmUuZGlzcGxheU5hbWUgPSAnRHJhZ2dhYmxlQ29yZSc7XG5cdERyYWdnYWJsZUNvcmUucHJvcFR5cGVzID0ge1xuXHQgIC8qKlxuXHQgICAqIGBhbGxvd0FueUNsaWNrYCBhbGxvd3MgZHJhZ2dpbmcgdXNpbmcgYW55IG1vdXNlIGJ1dHRvbi5cblx0ICAgKiBCeSBkZWZhdWx0LCB3ZSBvbmx5IGFjY2VwdCB0aGUgbGVmdCBidXR0b24uXG5cdCAgICpcblx0ICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuXHQgICAqL1xuXHQgIGFsbG93QW55Q2xpY2s6IHByb3BUeXBlcy5ib29sLFxuXG5cdCAgLyoqXG5cdCAgICogYGRpc2FibGVkYCwgaWYgdHJ1ZSwgc3RvcHMgdGhlIDxEcmFnZ2FibGU+IGZyb20gZHJhZ2dpbmcuIEFsbCBoYW5kbGVycyxcblx0ICAgKiB3aXRoIHRoZSBleGNlcHRpb24gb2YgYG9uTW91c2VEb3duYCwgd2lsbCBub3QgZmlyZS5cblx0ICAgKi9cblx0ICBkaXNhYmxlZDogcHJvcFR5cGVzLmJvb2wsXG5cblx0ICAvKipcblx0ICAgKiBCeSBkZWZhdWx0LCB3ZSBhZGQgJ3VzZXItc2VsZWN0Om5vbmUnIGF0dHJpYnV0ZXMgdG8gdGhlIGRvY3VtZW50IGJvZHlcblx0ICAgKiB0byBwcmV2ZW50IHVnbHkgdGV4dCBzZWxlY3Rpb24gZHVyaW5nIGRyYWcuIElmIHRoaXMgaXMgY2F1c2luZyBwcm9ibGVtc1xuXHQgICAqIGZvciB5b3VyIGFwcCwgc2V0IHRoaXMgdG8gYGZhbHNlYC5cblx0ICAgKi9cblx0ICBlbmFibGVVc2VyU2VsZWN0SGFjazogcHJvcFR5cGVzLmJvb2wsXG5cblx0ICAvKipcblx0ICAgKiBgb2Zmc2V0UGFyZW50YCwgaWYgc2V0LCB1c2VzIHRoZSBwYXNzZWQgRE9NIG5vZGUgdG8gY29tcHV0ZSBkcmFnIG9mZnNldHNcblx0ICAgKiBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXJlbnQgbm9kZS5cblx0ICAgKi9cblx0ICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uIG9mZnNldFBhcmVudChwcm9wcyAvKjogRHJhZ2dhYmxlQ29yZVByb3BzKi8sIHByb3BOYW1lIC8qOiAkS2V5czxEcmFnZ2FibGVDb3JlUHJvcHM+Ki8pIHtcblx0ICAgIGlmIChwcm9wc1twcm9wTmFtZV0gJiYgcHJvcHNbcHJvcE5hbWVdLm5vZGVUeXBlICE9PSAxKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlXFwncyBvZmZzZXRQYXJlbnQgbXVzdCBiZSBhIERPTSBOb2RlLicpO1xuXHQgICAgfVxuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiBgZ3JpZGAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgZHJhZ2dpbmcgc2hvdWxkIHNuYXAgdG8uXG5cdCAgICovXG5cdCAgZ3JpZDogcHJvcFR5cGVzLmFycmF5T2YocHJvcFR5cGVzLm51bWJlciksXG5cblx0ICAvKipcblx0ICAgKiBgc2NhbGVgIHNwZWNpZmllcyB0aGUgc2NhbGUgb2YgdGhlIGFyZWEgeW91IGFyZSBkcmFnZ2luZyBpbnNpZGUgb2YuIEl0IGFsbG93c1xuXHQgICAqIHRoZSBkcmFnIGRlbHRhcyB0byBzY2FsZSBjb3JyZWN0bHkgd2l0aCBob3cgZmFyIHpvb21lZCBpbi9vdXQgeW91IGFyZS5cblx0ICAgKi9cblx0ICBzY2FsZTogcHJvcFR5cGVzLm51bWJlcixcblxuXHQgIC8qKlxuXHQgICAqIGBoYW5kbGVgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgYXMgdGhlIGhhbmRsZSB0aGF0IGluaXRpYXRlcyBkcmFnLlxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgIHJldHVybiAoXG5cdCAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGhhbmRsZT1cIi5oYW5kbGVcIj5cblx0ICAgKiAgICAgICAgICAgICAgPGRpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGFuZGxlXCI+Q2xpY2sgbWUgdG8gZHJhZzwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgICAgPGRpdj5UaGlzIGlzIHNvbWUgb3RoZXIgY29udGVudDwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICA8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgPC9EcmFnZ2FibGU+XG5cdCAgICogICAgICAgICApO1xuXHQgICAqICAgICAgIH1cblx0ICAgKiAgIH0pO1xuXHQgICAqIGBgYFxuXHQgICAqL1xuXHQgIGhhbmRsZTogcHJvcFR5cGVzLnN0cmluZyxcblxuXHQgIC8qKlxuXHQgICAqIGBjYW5jZWxgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgdG8gcHJldmVudCBkcmFnIGluaXRpYWxpemF0aW9uLlxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgICAgcmV0dXJuKFxuXHQgICAqICAgICAgICAgICAgICAgPERyYWdnYWJsZSBjYW5jZWw9XCIuY2FuY2VsXCI+XG5cdCAgICogICAgICAgICAgICAgICAgICAgPGRpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FuY2VsXCI+WW91IGNhbid0IGRyYWcgZnJvbSBoZXJlPC9kaXY+XG5cdCAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2PkRyYWdnaW5nIGhlcmUgd29ya3MgZmluZTwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXHQgICAqICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG5cdCAgICogICAgICAgICAgICk7XG5cdCAgICogICAgICAgfVxuXHQgICAqICAgfSk7XG5cdCAgICogYGBgXG5cdCAgICovXG5cdCAgY2FuY2VsOiBwcm9wVHlwZXMuc3RyaW5nLFxuXG5cdCAgLyoqXG5cdCAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLlxuXHQgICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgZHJhZ2dpbmcgd2lsbCBiZSBjYW5jZWxlZC5cblx0ICAgKi9cblx0ICBvblN0YXJ0OiBwcm9wVHlwZXMuZnVuYyxcblxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB3aGlsZSBkcmFnZ2luZy5cblx0ICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG5cdCAgICovXG5cdCAgb25EcmFnOiBwcm9wVHlwZXMuZnVuYyxcblxuXHQgIC8qKlxuXHQgICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHN0b3BzLlxuXHQgICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgdGhlIGRyYWcgd2lsbCByZW1haW4gYWN0aXZlLlxuXHQgICAqL1xuXHQgIG9uU3RvcDogcHJvcFR5cGVzLmZ1bmMsXG5cblx0ICAvKipcblx0ICAgKiBBIHdvcmthcm91bmQgb3B0aW9uIHdoaWNoIGNhbiBiZSBwYXNzZWQgaWYgb25Nb3VzZURvd24gbmVlZHMgdG8gYmUgYWNjZXNzZWQsXG5cdCAgICogc2luY2UgaXQnbGwgYWx3YXlzIGJlIGJsb2NrZWQgKGFzIHRoZXJlIGlzIGludGVybmFsIHVzZSBvZiBvbk1vdXNlRG93bilcblx0ICAgKi9cblx0ICBvbk1vdXNlRG93bjogcHJvcFR5cGVzLmZ1bmMsXG5cblx0ICAvKipcblx0ICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSBjaGlsZCwgbm90IGhlcmUuXG5cdCAgICovXG5cdCAgY2xhc3NOYW1lOiBkb250U2V0TWUsXG5cdCAgc3R5bGU6IGRvbnRTZXRNZSxcblx0ICB0cmFuc2Zvcm06IGRvbnRTZXRNZVxuXHR9O1xuXHREcmFnZ2FibGVDb3JlLmRlZmF1bHRQcm9wcyA9IHtcblx0ICBhbGxvd0FueUNsaWNrOiBmYWxzZSwgLy8gYnkgZGVmYXVsdCBvbmx5IGFjY2VwdCBsZWZ0IGNsaWNrXG5cdCAgY2FuY2VsOiBudWxsLFxuXHQgIGRpc2FibGVkOiBmYWxzZSxcblx0ICBlbmFibGVVc2VyU2VsZWN0SGFjazogdHJ1ZSxcblx0ICBvZmZzZXRQYXJlbnQ6IG51bGwsXG5cdCAgaGFuZGxlOiBudWxsLFxuXHQgIGdyaWQ6IG51bGwsXG5cdCAgdHJhbnNmb3JtOiBudWxsLFxuXHQgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7fSxcblx0ICBvbkRyYWc6IGZ1bmN0aW9uIG9uRHJhZygpIHt9LFxuXHQgIG9uU3RvcDogZnVuY3Rpb24gb25TdG9wKCkge30sXG5cdCAgb25Nb3VzZURvd246IGZ1bmN0aW9uIG9uTW91c2VEb3duKCkge31cblx0fTtcblxuXHQvKjo6IGltcG9ydCB0eXBlIHtEcmFnZ2FibGVFdmVudEhhbmRsZXJ9IGZyb20gJy4vdXRpbHMvdHlwZXMnOyovXG5cdC8qOjogaW1wb3J0IHR5cGUge0VsZW1lbnQgYXMgUmVhY3RFbGVtZW50fSBmcm9tICdyZWFjdCc7Ki9cblx0Lyo6OiB0eXBlIERyYWdnYWJsZVN0YXRlID0ge1xuXHQgIGRyYWdnaW5nOiBib29sZWFuLFxuXHQgIGRyYWdnZWQ6IGJvb2xlYW4sXG5cdCAgeDogbnVtYmVyLCB5OiBudW1iZXIsXG5cdCAgc2xhY2tYOiBudW1iZXIsIHNsYWNrWTogbnVtYmVyLFxuXHQgIGlzRWxlbWVudFNWRzogYm9vbGVhblxuXHR9OyovXG5cblxuXHQvL1xuXHQvLyBEZWZpbmUgPERyYWdnYWJsZT5cblx0Ly9cblxuXHQvKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZVByb3BzID0ge1xuXHQgIC4uLiRFeGFjdDxEcmFnZ2FibGVDb3JlUHJvcHM+LFxuXHQgIGF4aXM6ICdib3RoJyB8ICd4JyB8ICd5JyB8ICdub25lJyxcblx0ICBib3VuZHM6IERyYWdnYWJsZUJvdW5kcyB8IHN0cmluZyB8IGZhbHNlLFxuXHQgIGRlZmF1bHRDbGFzc05hbWU6IHN0cmluZyxcblx0ICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IHN0cmluZyxcblx0ICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogc3RyaW5nLFxuXHQgIGRlZmF1bHRQb3NpdGlvbjogQ29udHJvbFBvc2l0aW9uLFxuXHQgIHBvc2l0aW9uT2Zmc2V0OiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbixcblx0ICBwb3NpdGlvbjogQ29udHJvbFBvc2l0aW9uLFxuXHQgIHNjYWxlOiBudW1iZXJcblx0fTsqL1xuXG5cdHZhciBEcmFnZ2FibGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuXHQgIGluaGVyaXRzKERyYWdnYWJsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cblx0ICBmdW5jdGlvbiBEcmFnZ2FibGUocHJvcHMgLyo6IERyYWdnYWJsZVByb3BzKi8pIHtcblx0ICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERyYWdnYWJsZSk7XG5cblx0ICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERyYWdnYWJsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERyYWdnYWJsZSkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuXHQgICAgX3RoaXMub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSwgY29yZURhdGEpIHtcblxuXHQgICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG5cdCAgICAgIHZhciBzaG91bGRTdGFydCA9IF90aGlzLnByb3BzLm9uU3RhcnQoZSwgY3JlYXRlRHJhZ2dhYmxlRGF0YShfdGhpcywgY29yZURhdGEpKTtcblx0ICAgICAgLy8gS2lsbHMgc3RhcnQgZXZlbnQgb24gY29yZSBhcyB3ZWxsLCBzbyBtb3ZlIGhhbmRsZXJzIGFyZSBuZXZlciBib3VuZC5cblx0ICAgICAgaWYgKHNob3VsZFN0YXJ0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIF90aGlzLnNldFN0YXRlKHsgZHJhZ2dpbmc6IHRydWUsIGRyYWdnZWQ6IHRydWUgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBfdGhpcy5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgY29yZURhdGEpIHtcblx0ICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIHZhciB1aURhdGEgPSBjcmVhdGVEcmFnZ2FibGVEYXRhKF90aGlzLCBjb3JlRGF0YSk7XG5cblx0ICAgICAgdmFyIG5ld1N0YXRlIC8qOiAkU2hhcGU8RHJhZ2dhYmxlU3RhdGU+Ki8gPSB7XG5cdCAgICAgICAgeDogdWlEYXRhLngsXG5cdCAgICAgICAgeTogdWlEYXRhLnlcblx0ICAgICAgfTtcblxuXHQgICAgICAvLyBLZWVwIHdpdGhpbiBib3VuZHMuXG5cdCAgICAgIGlmIChfdGhpcy5wcm9wcy5ib3VuZHMpIHtcblx0ICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIHggYW5kIHkuXG5cdCAgICAgICAgdmFyIF94ID0gbmV3U3RhdGUueCxcblx0ICAgICAgICAgICAgX3kgPSBuZXdTdGF0ZS55O1xuXG5cdCAgICAgICAgLy8gQWRkIHNsYWNrIHRvIHRoZSB2YWx1ZXMgdXNlZCB0byBjYWxjdWxhdGUgYm91bmQgcG9zaXRpb24uIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBpZlxuXHQgICAgICAgIC8vIHdlIHN0YXJ0IHJlbW92aW5nIHNsYWNrLCB0aGUgZWxlbWVudCB3b24ndCByZWFjdCB0byBpdCByaWdodCBhd2F5IHVudGlsIGl0J3MgYmVlblxuXHQgICAgICAgIC8vIGNvbXBsZXRlbHkgcmVtb3ZlZC5cblxuXHQgICAgICAgIG5ld1N0YXRlLnggKz0gX3RoaXMuc3RhdGUuc2xhY2tYO1xuXHQgICAgICAgIG5ld1N0YXRlLnkgKz0gX3RoaXMuc3RhdGUuc2xhY2tZO1xuXG5cdCAgICAgICAgLy8gR2V0IGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgY2VpbC9mbG9vciB0aGUgeCBhbmQgeSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuXG5cblx0ICAgICAgICB2YXIgX2dldEJvdW5kUG9zaXRpb24gPSBnZXRCb3VuZFBvc2l0aW9uKF90aGlzLCBuZXdTdGF0ZS54LCBuZXdTdGF0ZS55KSxcblx0ICAgICAgICAgICAgX2dldEJvdW5kUG9zaXRpb24yID0gc2xpY2VkVG9BcnJheShfZ2V0Qm91bmRQb3NpdGlvbiwgMiksXG5cdCAgICAgICAgICAgIG5ld1N0YXRlWCA9IF9nZXRCb3VuZFBvc2l0aW9uMlswXSxcblx0ICAgICAgICAgICAgbmV3U3RhdGVZID0gX2dldEJvdW5kUG9zaXRpb24yWzFdO1xuXG5cdCAgICAgICAgbmV3U3RhdGUueCA9IG5ld1N0YXRlWDtcblx0ICAgICAgICBuZXdTdGF0ZS55ID0gbmV3U3RhdGVZO1xuXG5cdCAgICAgICAgLy8gUmVjYWxjdWxhdGUgc2xhY2sgYnkgbm90aW5nIGhvdyBtdWNoIHdhcyBzaGF2ZWQgYnkgdGhlIGJvdW5kUG9zaXRpb24gaGFuZGxlci5cblx0ICAgICAgICBuZXdTdGF0ZS5zbGFja1ggPSBfdGhpcy5zdGF0ZS5zbGFja1ggKyAoX3ggLSBuZXdTdGF0ZS54KTtcblx0ICAgICAgICBuZXdTdGF0ZS5zbGFja1kgPSBfdGhpcy5zdGF0ZS5zbGFja1kgKyAoX3kgLSBuZXdTdGF0ZS55KTtcblxuXHQgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXZlbnQgd2UgZmlyZSB0byByZWZsZWN0IHdoYXQgcmVhbGx5IGhhcHBlbmVkIGFmdGVyIGJvdW5kcyB0b29rIGVmZmVjdC5cblx0ICAgICAgICB1aURhdGEueCA9IG5ld1N0YXRlLng7XG5cdCAgICAgICAgdWlEYXRhLnkgPSBuZXdTdGF0ZS55O1xuXHQgICAgICAgIHVpRGF0YS5kZWx0YVggPSBuZXdTdGF0ZS54IC0gX3RoaXMuc3RhdGUueDtcblx0ICAgICAgICB1aURhdGEuZGVsdGFZID0gbmV3U3RhdGUueSAtIF90aGlzLnN0YXRlLnk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG5cdCAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBfdGhpcy5wcm9wcy5vbkRyYWcoZSwgdWlEYXRhKTtcblx0ICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBfdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG5cdCAgICB9O1xuXG5cdCAgICBfdGhpcy5vbkRyYWdTdG9wID0gZnVuY3Rpb24gKGUsIGNvcmVEYXRhKSB7XG5cdCAgICAgIGlmICghX3RoaXMuc3RhdGUuZHJhZ2dpbmcpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG5cdCAgICAgIHZhciBzaG91bGRTdG9wID0gX3RoaXMucHJvcHMub25TdG9wKGUsIGNyZWF0ZURyYWdnYWJsZURhdGEoX3RoaXMsIGNvcmVEYXRhKSk7XG5cdCAgICAgIGlmIChzaG91bGRTdG9wID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIHZhciBuZXdTdGF0ZSAvKjogJFNoYXBlPERyYWdnYWJsZVN0YXRlPiovID0ge1xuXHQgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcblx0ICAgICAgICBzbGFja1g6IDAsXG5cdCAgICAgICAgc2xhY2tZOiAwXG5cdCAgICAgIH07XG5cblx0ICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgY29tcG9uZW50LCB0aGUgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uIHdpbGwgYmUgdG9cblx0ICAgICAgLy8gcmV2ZXJ0IGJhY2sgdG8gdGhlIG9sZCBwb3NpdGlvbi4gV2UgZXhwZWN0IGEgaGFuZGxlciBvbiBgb25EcmFnU3RvcGAsIGF0IHRoZSBsZWFzdC5cblx0ICAgICAgdmFyIGNvbnRyb2xsZWQgPSBCb29sZWFuKF90aGlzLnByb3BzLnBvc2l0aW9uKTtcblx0ICAgICAgaWYgKGNvbnRyb2xsZWQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMkcHJvcHMkcG9zaXRpb24gPSBfdGhpcy5wcm9wcy5wb3NpdGlvbixcblx0ICAgICAgICAgICAgX3gyID0gX3RoaXMkcHJvcHMkcG9zaXRpb24ueCxcblx0ICAgICAgICAgICAgX3kyID0gX3RoaXMkcHJvcHMkcG9zaXRpb24ueTtcblxuXHQgICAgICAgIG5ld1N0YXRlLnggPSBfeDI7XG5cdCAgICAgICAgbmV3U3RhdGUueSA9IF95Mjtcblx0ICAgICAgfVxuXG5cdCAgICAgIF90aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcblx0ICAgIH07XG5cblx0ICAgIF90aGlzLnN0YXRlID0ge1xuXHQgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgY3VycmVudGx5IGRyYWdnaW5nLlxuXHQgICAgICBkcmFnZ2luZzogZmFsc2UsXG5cblx0ICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgaGF2ZSBiZWVuIGRyYWdnZWQgYmVmb3JlLlxuXHQgICAgICBkcmFnZ2VkOiBmYWxzZSxcblxuXHQgICAgICAvLyBDdXJyZW50IHRyYW5zZm9ybSB4IGFuZCB5LlxuXHQgICAgICB4OiBwcm9wcy5wb3NpdGlvbiA/IHByb3BzLnBvc2l0aW9uLnggOiBwcm9wcy5kZWZhdWx0UG9zaXRpb24ueCxcblx0ICAgICAgeTogcHJvcHMucG9zaXRpb24gPyBwcm9wcy5wb3NpdGlvbi55IDogcHJvcHMuZGVmYXVsdFBvc2l0aW9uLnksXG5cblx0ICAgICAgLy8gVXNlZCBmb3IgY29tcGVuc2F0aW5nIGZvciBvdXQtb2YtYm91bmRzIGRyYWdzXG5cdCAgICAgIHNsYWNrWDogMCwgc2xhY2tZOiAwLFxuXG5cdCAgICAgIC8vIENhbiBvbmx5IGRldGVybWluZSBpZiBTVkcgYWZ0ZXIgbW91bnRpbmdcblx0ICAgICAgaXNFbGVtZW50U1ZHOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cblx0ICBjcmVhdGVDbGFzcyhEcmFnZ2FibGUsIFt7XG5cdCAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0ICAgICAgaWYgKHRoaXMucHJvcHMucG9zaXRpb24gJiYgISh0aGlzLnByb3BzLm9uRHJhZyB8fCB0aGlzLnByb3BzLm9uU3RvcCkpIHtcblx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblx0ICAgICAgICBjb25zb2xlLndhcm4oJ0EgYHBvc2l0aW9uYCB3YXMgYXBwbGllZCB0byB0aGlzIDxEcmFnZ2FibGU+LCB3aXRob3V0IGRyYWcgaGFuZGxlcnMuIFRoaXMgd2lsbCBtYWtlIHRoaXMgJyArICdjb21wb25lbnQgZWZmZWN0aXZlbHkgdW5kcmFnZ2FibGUuIFBsZWFzZSBhdHRhY2ggYG9uRHJhZ2Agb3IgYG9uU3RvcGAgaGFuZGxlcnMgc28geW91IGNhbiBhZGp1c3QgdGhlICcgKyAnYHBvc2l0aW9uYCBvZiB0aGlzIGVsZW1lbnQuJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG5cdCAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaXMgYW4gaW5zdGFuY2VvZiBTVkdFbGVtZW50XG5cdCAgICAgIGlmICh0eXBlb2Ygd2luZG93LlNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQpIHtcblx0ICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNFbGVtZW50U1ZHOiB0cnVlIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMgLyo6IE9iamVjdCovKSB7XG5cdCAgICAgIC8vIFNldCB4L3kgaWYgcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0ICAgICAgaWYgKG5leHRQcm9wcy5wb3NpdGlvbiAmJiAoIXRoaXMucHJvcHMucG9zaXRpb24gfHwgbmV4dFByb3BzLnBvc2l0aW9uLnggIT09IHRoaXMucHJvcHMucG9zaXRpb24ueCB8fCBuZXh0UHJvcHMucG9zaXRpb24ueSAhPT0gdGhpcy5wcm9wcy5wb3NpdGlvbi55KSkge1xuXHQgICAgICAgIHRoaXMuc2V0U3RhdGUoeyB4OiBuZXh0UHJvcHMucG9zaXRpb24ueCwgeTogbmV4dFByb3BzLnBvc2l0aW9uLnkgfSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdCAgICAgIHRoaXMuc2V0U3RhdGUoeyBkcmFnZ2luZzogZmFsc2UgfSk7IC8vIHByZXZlbnRzIGludmFyaWFudCBpZiB1bm1vdW50ZWQgd2hpbGUgZHJhZ2dpbmdcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdyZW5kZXInLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIC8qOiBSZWFjdEVsZW1lbnQ8YW55PiovIHtcblx0ICAgICAgdmFyIF9jbGFzc05hbWVzO1xuXG5cdCAgICAgIHZhciBzdHlsZSA9IHt9LFxuXHQgICAgICAgICAgc3ZnVHJhbnNmb3JtID0gbnVsbDtcblxuXHQgICAgICAvLyBJZiB0aGlzIGlzIGNvbnRyb2xsZWQsIHdlIGRvbid0IHdhbnQgdG8gbW92ZSBpdCAtIHVubGVzcyBpdCdzIGRyYWdnaW5nLlxuXHQgICAgICB2YXIgY29udHJvbGxlZCA9IEJvb2xlYW4odGhpcy5wcm9wcy5wb3NpdGlvbik7XG5cdCAgICAgIHZhciBkcmFnZ2FibGUgPSAhY29udHJvbGxlZCB8fCB0aGlzLnN0YXRlLmRyYWdnaW5nO1xuXG5cdCAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucHJvcHMucG9zaXRpb24gfHwgdGhpcy5wcm9wcy5kZWZhdWx0UG9zaXRpb247XG5cdCAgICAgIHZhciB0cmFuc2Zvcm1PcHRzID0ge1xuXHQgICAgICAgIC8vIFNldCBsZWZ0IGlmIGhvcml6b250YWwgZHJhZyBpcyBlbmFibGVkXG5cdCAgICAgICAgeDogY2FuRHJhZ1godGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS54IDogcG9zaXRpb24ueCxcblxuXHQgICAgICAgIC8vIFNldCB0b3AgaWYgdmVydGljYWwgZHJhZyBpcyBlbmFibGVkXG5cdCAgICAgICAgeTogY2FuRHJhZ1kodGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS55IDogcG9zaXRpb24ueVxuXHQgICAgICB9O1xuXG5cdCAgICAgIC8vIElmIHRoaXMgZWxlbWVudCB3YXMgU1ZHLCB3ZSB1c2UgdGhlIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZS5cblx0ICAgICAgaWYgKHRoaXMuc3RhdGUuaXNFbGVtZW50U1ZHKSB7XG5cdCAgICAgICAgc3ZnVHJhbnNmb3JtID0gY3JlYXRlU1ZHVHJhbnNmb3JtKHRyYW5zZm9ybU9wdHMsIHRoaXMucHJvcHMucG9zaXRpb25PZmZzZXQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIEFkZCBhIENTUyB0cmFuc2Zvcm0gdG8gbW92ZSB0aGUgZWxlbWVudCBhcm91bmQuIFRoaXMgYWxsb3dzIHVzIHRvIG1vdmUgdGhlIGVsZW1lbnQgYXJvdW5kXG5cdCAgICAgICAgLy8gd2l0aG91dCB3b3JyeWluZyBhYm91dCB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZWxhdGl2ZWx5IG9yIGFic29sdXRlbHkgcG9zaXRpb25lZC5cblx0ICAgICAgICAvLyBJZiB0aGUgaXRlbSB5b3UgYXJlIGRyYWdnaW5nIGFscmVhZHkgaGFzIGEgdHJhbnNmb3JtIHNldCwgd3JhcCBpdCBpbiBhIDxzcGFuPiBzbyA8RHJhZ2dhYmxlPlxuXHQgICAgICAgIC8vIGhhcyBhIGNsZWFuIHNsYXRlLlxuXHQgICAgICAgIHN0eWxlID0gY3JlYXRlQ1NTVHJhbnNmb3JtKHRyYW5zZm9ybU9wdHMsIHRoaXMucHJvcHMucG9zaXRpb25PZmZzZXQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG5cdCAgICAgICAgICBkZWZhdWx0Q2xhc3NOYW1lID0gX3Byb3BzLmRlZmF1bHRDbGFzc05hbWUsXG5cdCAgICAgICAgICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmcgPSBfcHJvcHMuZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nLFxuXHQgICAgICAgICAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQgPSBfcHJvcHMuZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ7XG5cblxuXHQgICAgICB2YXIgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG5cdCAgICAgIC8vIE1hcmsgd2l0aCBjbGFzcyB3aGlsZSBkcmFnZ2luZ1xuXHQgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NuYW1lcyhjaGlsZHJlbi5wcm9wcy5jbGFzc05hbWUgfHwgJycsIGRlZmF1bHRDbGFzc05hbWUsIChfY2xhc3NOYW1lcyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nLCB0aGlzLnN0YXRlLmRyYWdnaW5nKSwgZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkLCB0aGlzLnN0YXRlLmRyYWdnZWQpLCBfY2xhc3NOYW1lcykpO1xuXG5cdCAgICAgIC8vIFJldXNlIHRoZSBjaGlsZCBwcm92aWRlZFxuXHQgICAgICAvLyBUaGlzIG1ha2VzIGl0IGZsZXhpYmxlIHRvIHVzZSB3aGF0ZXZlciBlbGVtZW50IGlzIHdhbnRlZCAoZGl2LCB1bCwgZXRjKVxuXHQgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcblx0ICAgICAgICBEcmFnZ2FibGVDb3JlLFxuXHQgICAgICAgIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IG9uU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsIG9uRHJhZzogdGhpcy5vbkRyYWcsIG9uU3RvcDogdGhpcy5vbkRyYWdTdG9wIH0pLFxuXHQgICAgICAgIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuXHQgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG5cdCAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNoaWxkcmVuLnByb3BzLnN0eWxlLCBzdHlsZSksXG5cdCAgICAgICAgICB0cmFuc2Zvcm06IHN2Z1RyYW5zZm9ybVxuXHQgICAgICAgIH0pXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHQgIHJldHVybiBEcmFnZ2FibGU7XG5cdH0oUmVhY3QuQ29tcG9uZW50KTtcblxuXHREcmFnZ2FibGUuZGlzcGxheU5hbWUgPSAnRHJhZ2dhYmxlJztcblx0RHJhZ2dhYmxlLnByb3BUeXBlcyA9IF9leHRlbmRzKHt9LCBEcmFnZ2FibGVDb3JlLnByb3BUeXBlcywge1xuXG5cdCAgLyoqXG5cdCAgICogYGF4aXNgIGRldGVybWluZXMgd2hpY2ggYXhpcyB0aGUgZHJhZ2dhYmxlIGNhbiBtb3ZlLlxuXHQgICAqXG5cdCAgICogIE5vdGUgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgc3RpbGwgcmV0dXJuIGRhdGEgYXMgbm9ybWFsLiBUaGlzIG9ubHlcblx0ICAgKiAgY29udHJvbHMgZmx1c2hpbmcgdG8gdGhlIERPTS5cblx0ICAgKlxuXHQgICAqICdib3RoJyBhbGxvd3MgbW92ZW1lbnQgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlxuXHQgICAqICd4JyBsaW1pdHMgbW92ZW1lbnQgdG8gaG9yaXpvbnRhbCBheGlzLlxuXHQgICAqICd5JyBsaW1pdHMgbW92ZW1lbnQgdG8gdmVydGljYWwgYXhpcy5cblx0ICAgKiAnbm9uZScgbGltaXRzIGFsbCBtb3ZlbWVudC5cblx0ICAgKlxuXHQgICAqIERlZmF1bHRzIHRvICdib3RoJy5cblx0ICAgKi9cblx0ICBheGlzOiBwcm9wVHlwZXMub25lT2YoWydib3RoJywgJ3gnLCAneScsICdub25lJ10pLFxuXG5cdCAgLyoqXG5cdCAgICogYGJvdW5kc2AgZGV0ZXJtaW5lcyB0aGUgcmFuZ2Ugb2YgbW92ZW1lbnQgYXZhaWxhYmxlIHRvIHRoZSBlbGVtZW50LlxuXHQgICAqIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOlxuXHQgICAqXG5cdCAgICogJ3BhcmVudCcgcmVzdHJpY3RzIG1vdmVtZW50IHdpdGhpbiB0aGUgRHJhZ2dhYmxlJ3MgcGFyZW50IG5vZGUuXG5cdCAgICpcblx0ICAgKiBBbHRlcm5hdGl2ZWx5LCBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgYWxsIG9mIHdoaWNoIGFyZSBvcHRpb25hbDpcblx0ICAgKlxuXHQgICAqIHtsZWZ0OiBMRUZUX0JPVU5ELCByaWdodDogUklHSFRfQk9VTkQsIGJvdHRvbTogQk9UVE9NX0JPVU5ELCB0b3A6IFRPUF9CT1VORH1cblx0ICAgKlxuXHQgICAqIEFsbCB2YWx1ZXMgYXJlIGluIHB4LlxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgIHJldHVybiAoXG5cdCAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGJvdW5kcz17e3JpZ2h0OiAzMDAsIGJvdHRvbTogMzAwfX0+XG5cdCAgICogICAgICAgICAgICAgIDxkaXY+Q29udGVudDwvZGl2PlxuXHQgICAqICAgICAgICAgICA8L0RyYWdnYWJsZT5cblx0ICAgKiAgICAgICAgICk7XG5cdCAgICogICAgICAgfVxuXHQgICAqICAgfSk7XG5cdCAgICogYGBgXG5cdCAgICovXG5cdCAgYm91bmRzOiBwcm9wVHlwZXMub25lT2ZUeXBlKFtwcm9wVHlwZXMuc2hhcGUoe1xuXHQgICAgbGVmdDogcHJvcFR5cGVzLm51bWJlcixcblx0ICAgIHJpZ2h0OiBwcm9wVHlwZXMubnVtYmVyLFxuXHQgICAgdG9wOiBwcm9wVHlwZXMubnVtYmVyLFxuXHQgICAgYm90dG9tOiBwcm9wVHlwZXMubnVtYmVyXG5cdCAgfSksIHByb3BUeXBlcy5zdHJpbmcsIHByb3BUeXBlcy5vbmVPZihbZmFsc2VdKV0pLFxuXG5cdCAgZGVmYXVsdENsYXNzTmFtZTogcHJvcFR5cGVzLnN0cmluZyxcblx0ICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IHByb3BUeXBlcy5zdHJpbmcsXG5cdCAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6IHByb3BUeXBlcy5zdHJpbmcsXG5cblx0ICAvKipcblx0ICAgKiBgZGVmYXVsdFBvc2l0aW9uYCBzcGVjaWZpZXMgdGhlIHggYW5kIHkgdGhhdCB0aGUgZHJhZ2dlZCBpdGVtIHNob3VsZCBzdGFydCBhdFxuXHQgICAqXG5cdCAgICogRXhhbXBsZTpcblx0ICAgKlxuXHQgICAqIGBgYGpzeFxuXHQgICAqICAgICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcblx0ICAgKiAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGUgZGVmYXVsdFBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG5cdCAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuXHQgICAqICAgICAgICAgICAgICApO1xuXHQgICAqICAgICAgICAgIH1cblx0ICAgKiAgICAgIH0pO1xuXHQgICAqIGBgYFxuXHQgICAqL1xuXHQgIGRlZmF1bHRQb3NpdGlvbjogcHJvcFR5cGVzLnNoYXBlKHtcblx0ICAgIHg6IHByb3BUeXBlcy5udW1iZXIsXG5cdCAgICB5OiBwcm9wVHlwZXMubnVtYmVyXG5cdCAgfSksXG5cdCAgcG9zaXRpb25PZmZzZXQ6IHByb3BUeXBlcy5zaGFwZSh7XG5cdCAgICB4OiBwcm9wVHlwZXMub25lT2ZUeXBlKFtwcm9wVHlwZXMubnVtYmVyLCBwcm9wVHlwZXMuc3RyaW5nXSksXG5cdCAgICB5OiBwcm9wVHlwZXMub25lT2ZUeXBlKFtwcm9wVHlwZXMubnVtYmVyLCBwcm9wVHlwZXMuc3RyaW5nXSlcblx0ICB9KSxcblxuXHQgIC8qKlxuXHQgICAqIGBwb3NpdGlvbmAsIGlmIHByZXNlbnQsIGRlZmluZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG5cdCAgICpcblx0ICAgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBmb3JtIGVsZW1lbnRzIGluIFJlYWN0IHdvcmsgLSBpZiBubyBgcG9zaXRpb25gIGlzIHN1cHBsaWVkLCB0aGUgY29tcG9uZW50XG5cdCAgICogIGlzIHVuY29udHJvbGxlZC5cblx0ICAgKlxuXHQgICAqIEV4YW1wbGU6XG5cdCAgICpcblx0ICAgKiBgYGBqc3hcblx0ICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgICogICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICogICAgICAgICAgICAgIHJldHVybiAoXG5cdCAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIHBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG5cdCAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cblx0ICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuXHQgICAqICAgICAgICAgICAgICApO1xuXHQgICAqICAgICAgICAgIH1cblx0ICAgKiAgICAgIH0pO1xuXHQgICAqIGBgYFxuXHQgICAqL1xuXHQgIHBvc2l0aW9uOiBwcm9wVHlwZXMuc2hhcGUoe1xuXHQgICAgeDogcHJvcFR5cGVzLm51bWJlcixcblx0ICAgIHk6IHByb3BUeXBlcy5udW1iZXJcblx0ICB9KSxcblxuXHQgIC8qKlxuXHQgICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cblx0ICAgKi9cblx0ICBjbGFzc05hbWU6IGRvbnRTZXRNZSxcblx0ICBzdHlsZTogZG9udFNldE1lLFxuXHQgIHRyYW5zZm9ybTogZG9udFNldE1lXG5cdH0pO1xuXHREcmFnZ2FibGUuZGVmYXVsdFByb3BzID0gX2V4dGVuZHMoe30sIERyYWdnYWJsZUNvcmUuZGVmYXVsdFByb3BzLCB7XG5cdCAgYXhpczogJ2JvdGgnLFxuXHQgIGJvdW5kczogZmFsc2UsXG5cdCAgZGVmYXVsdENsYXNzTmFtZTogJ3JlYWN0LWRyYWdnYWJsZScsXG5cdCAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnaW5nJyxcblx0ICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2VkJyxcblx0ICBkZWZhdWx0UG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuXHQgIHBvc2l0aW9uOiBudWxsLFxuXHQgIHNjYWxlOiAxXG5cdH0pO1xuXG5cdC8vIFByZXZpb3VzIHZlcnNpb25zIG9mIHRoaXMgbGliIGV4cG9ydGVkIDxEcmFnZ2FibGU+IGFzIHRoZSByb290IGV4cG9ydC4gQXMgdG8gbm90IGJyZWFrXG5cdC8vIHRoZW0sIG9yIFR5cGVTY3JpcHQsIHdlIGV4cG9ydCAqYm90aCogYXMgdGhlIHJvb3QgYW5kIGFzICdkZWZhdWx0Jy5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL3JlYWN0LWRyYWdnYWJsZS9wdWxsLzI1NFxuXHQvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvcmVhY3QtZHJhZ2dhYmxlL2lzc3Vlcy8yNjZcblx0RHJhZ2dhYmxlLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5cdERyYWdnYWJsZS5EcmFnZ2FibGVDb3JlID0gRHJhZ2dhYmxlQ29yZTtcblxuXHRyZXR1cm4gRHJhZ2dhYmxlO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtZHJhZ2dhYmxlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZScpKTtcbnZhciBfaW5oZXJpdHNMb29zZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnKSk7XG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZCcpKTtcbnZhciBfZXh0ZW5kcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKSk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0X19kZWZhdWx0ID0gX2ludGVyb3BEZWZhdWx0KFJlYWN0KTtcbnZhciBSZWFjdERPTSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFjdC1kb20nKSk7XG5cbnZhciBidWdmaXhlcyA9IHVuZGVmaW5lZDtcbnZhciBhcHBseUFuaW1hdGVkVmFsdWVzID0gdW5kZWZpbmVkO1xudmFyIGNvbG9yTmFtZXMgPSBbXTtcbnZhciByZXF1ZXN0RnJhbWUgPSBmdW5jdGlvbiByZXF1ZXN0RnJhbWUoY2IpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xufTtcbnZhciBjYW5jZWxGcmFtZSA9IGZ1bmN0aW9uIGNhbmNlbEZyYW1lKGNiKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoY2IpO1xufTtcbnZhciBpbnRlcnBvbGF0aW9uID0gdW5kZWZpbmVkO1xudmFyIG5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59O1xudmFyIGRlZmF1bHRFbGVtZW50ID0gdW5kZWZpbmVkO1xudmFyIGNyZWF0ZUFuaW1hdGVkU3R5bGUgPSB1bmRlZmluZWQ7XG52YXIgaW5qZWN0QXBwbHlBbmltYXRlZFZhbHVlcyA9IGZ1bmN0aW9uIGluamVjdEFwcGx5QW5pbWF0ZWRWYWx1ZXMoZm4sIHRyYW5zZm9ybSkge1xuICByZXR1cm4gYXBwbHlBbmltYXRlZFZhbHVlcyA9IHtcbiAgICBmbjogZm4sXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgfTtcbn07XG52YXIgaW5qZWN0Q29sb3JOYW1lcyA9IGZ1bmN0aW9uIGluamVjdENvbG9yTmFtZXMobmFtZXMpIHtcbiAgcmV0dXJuIGNvbG9yTmFtZXMgPSBuYW1lcztcbn07XG52YXIgaW5qZWN0QnVnZml4ZXMgPSBmdW5jdGlvbiBpbmplY3RCdWdmaXhlcyhmbikge1xuICByZXR1cm4gYnVnZml4ZXMgPSBmbjtcbn07XG52YXIgaW5qZWN0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIGluamVjdEludGVycG9sYXRpb24oY2xzKSB7XG4gIHJldHVybiBpbnRlcnBvbGF0aW9uID0gY2xzO1xufTtcbnZhciBpbmplY3RGcmFtZSA9IGZ1bmN0aW9uIGluamVjdEZyYW1lKHJhZiwgY2FmKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiBfcmVmID0gW3JhZiwgY2FmXSwgcmVxdWVzdEZyYW1lID0gX3JlZlswXSwgY2FuY2VsRnJhbWUgPSBfcmVmWzFdLCBfcmVmO1xufTtcbnZhciBpbmplY3ROb3cgPSBmdW5jdGlvbiBpbmplY3ROb3cobm93Rm4pIHtcbiAgcmV0dXJuIG5vdyA9IG5vd0ZuO1xufTtcbnZhciBpbmplY3REZWZhdWx0RWxlbWVudCA9IGZ1bmN0aW9uIGluamVjdERlZmF1bHRFbGVtZW50KGVsKSB7XG4gIHJldHVybiBkZWZhdWx0RWxlbWVudCA9IGVsO1xufTtcbnZhciBpbmplY3RDcmVhdGVBbmltYXRlZFN0eWxlID0gZnVuY3Rpb24gaW5qZWN0Q3JlYXRlQW5pbWF0ZWRTdHlsZShmYWN0b3J5KSB7XG4gIHJldHVybiBjcmVhdGVBbmltYXRlZFN0eWxlID0gZmFjdG9yeTtcbn07XG5cbnZhciBHbG9iYWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBnZXQgYnVnZml4ZXMgKCkgeyByZXR1cm4gYnVnZml4ZXM7IH0sXG4gIGdldCBhcHBseUFuaW1hdGVkVmFsdWVzICgpIHsgcmV0dXJuIGFwcGx5QW5pbWF0ZWRWYWx1ZXM7IH0sXG4gIGdldCBjb2xvck5hbWVzICgpIHsgcmV0dXJuIGNvbG9yTmFtZXM7IH0sXG4gIGdldCByZXF1ZXN0RnJhbWUgKCkgeyByZXR1cm4gcmVxdWVzdEZyYW1lOyB9LFxuICBnZXQgY2FuY2VsRnJhbWUgKCkgeyByZXR1cm4gY2FuY2VsRnJhbWU7IH0sXG4gIGdldCBpbnRlcnBvbGF0aW9uICgpIHsgcmV0dXJuIGludGVycG9sYXRpb247IH0sXG4gIGdldCBub3cgKCkgeyByZXR1cm4gbm93OyB9LFxuICBnZXQgZGVmYXVsdEVsZW1lbnQgKCkgeyByZXR1cm4gZGVmYXVsdEVsZW1lbnQ7IH0sXG4gIGdldCBjcmVhdGVBbmltYXRlZFN0eWxlICgpIHsgcmV0dXJuIGNyZWF0ZUFuaW1hdGVkU3R5bGU7IH0sXG4gIGluamVjdEFwcGx5QW5pbWF0ZWRWYWx1ZXM6IGluamVjdEFwcGx5QW5pbWF0ZWRWYWx1ZXMsXG4gIGluamVjdENvbG9yTmFtZXM6IGluamVjdENvbG9yTmFtZXMsXG4gIGluamVjdEJ1Z2ZpeGVzOiBpbmplY3RCdWdmaXhlcyxcbiAgaW5qZWN0SW50ZXJwb2xhdGlvbjogaW5qZWN0SW50ZXJwb2xhdGlvbixcbiAgaW5qZWN0RnJhbWU6IGluamVjdEZyYW1lLFxuICBpbmplY3ROb3c6IGluamVjdE5vdyxcbiAgaW5qZWN0RGVmYXVsdEVsZW1lbnQ6IGluamVjdERlZmF1bHRFbGVtZW50LFxuICBpbmplY3RDcmVhdGVBbmltYXRlZFN0eWxlOiBpbmplY3RDcmVhdGVBbmltYXRlZFN0eWxlXG59KTtcblxudmFyIEFuaW1hdGVkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0ZWQoKSB7fVxuXG4gIHZhciBfcHJvdG8gPSBBbmltYXRlZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHt9O1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7fTtcblxuICBfcHJvdG8uZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHt9O1xuXG4gIF9wcm90by5nZXRBbmltYXRlZFZhbHVlID0gZnVuY3Rpb24gZ2V0QW5pbWF0ZWRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICB9O1xuXG4gIF9wcm90by5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7fTtcblxuICBfcHJvdG8ucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCkge307XG5cbiAgX3Byb3RvLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRlZDtcbn0oKTtcblxudmFyIGdldFZhbHVlcyA9IGZ1bmN0aW9uIGdldFZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIG9iamVjdFtrXTtcbiAgfSk7XG59O1xuXG52YXIgQW5pbWF0ZWRXaXRoQ2hpbGRyZW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BbmltYXRlZCkge1xuICBfaW5oZXJpdHNMb29zZShBbmltYXRlZFdpdGhDaGlsZHJlbiwgX0FuaW1hdGVkKTtcblxuICBmdW5jdGlvbiBBbmltYXRlZFdpdGhDaGlsZHJlbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQW5pbWF0ZWQuY2FsbC5hcHBseShfQW5pbWF0ZWQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIF90aGlzLmdldENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRQYXlsb2FkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICBpbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4ICE9PSB2b2lkIDAgJiYgX3RoaXMucGF5bG9hZCA/IF90aGlzLnBheWxvYWRbaW5kZXhdIDogX3RoaXMucGF5bG9hZCB8fCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFuaW1hdGVkV2l0aENoaWxkcmVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgdGhpcy5hdHRhY2goKTtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB0aGlzLmRldGFjaCgpO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRlZFdpdGhDaGlsZHJlbjtcbn0oQW5pbWF0ZWQpO1xudmFyIEFuaW1hdGVkQXJyYXlXaXRoQ2hpbGRyZW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BbmltYXRlZFdpdGhDaGlsZHJlbikge1xuICBfaW5oZXJpdHNMb29zZShBbmltYXRlZEFycmF5V2l0aENoaWxkcmVuLCBfQW5pbWF0ZWRXaXRoQ2hpbGRyZW4pO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGVkQXJyYXlXaXRoQ2hpbGRyZW4oKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIF90aGlzMiA9IF9BbmltYXRlZFdpdGhDaGlsZHJlbi5jYWxsLmFwcGx5KF9BbmltYXRlZFdpdGhDaGlsZHJlbiwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpczIucGF5bG9hZCA9IFtdO1xuXG4gICAgX3RoaXMyLmdldEFuaW1hdGVkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLmdldFZhbHVlKCk7XG4gICAgfTtcblxuICAgIF90aGlzMi5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnBheWxvYWQuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEFuaW1hdGVkICYmIHAuYWRkQ2hpbGQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpczIuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5wYXlsb2FkLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBBbmltYXRlZCAmJiBwLnJlbW92ZUNoaWxkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBBbmltYXRlZEFycmF5V2l0aENoaWxkcmVuO1xufShBbmltYXRlZFdpdGhDaGlsZHJlbik7XG52YXIgQW5pbWF0ZWRPYmplY3RXaXRoQ2hpbGRyZW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BbmltYXRlZFdpdGhDaGlsZHJlbjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQW5pbWF0ZWRPYmplY3RXaXRoQ2hpbGRyZW4sIF9BbmltYXRlZFdpdGhDaGlsZHJlbjIpO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGVkT2JqZWN0V2l0aENoaWxkcmVuKCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfQW5pbWF0ZWRXaXRoQ2hpbGRyZW4yLmNhbGwuYXBwbHkoX0FuaW1hdGVkV2l0aENoaWxkcmVuMiwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpczMucGF5bG9hZCA9IHt9O1xuXG4gICAgX3RoaXMzLmdldEFuaW1hdGVkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLmdldFZhbHVlKHRydWUpO1xuICAgIH07XG5cbiAgICBfdGhpczMuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlcyhfdGhpczMucGF5bG9hZCkuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcyBpbnN0YW5jZW9mIEFuaW1hdGVkICYmIHMuYWRkQ2hpbGQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpczMuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlcyhfdGhpczMucGF5bG9hZCkuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcyBpbnN0YW5jZW9mIEFuaW1hdGVkICYmIHMucmVtb3ZlQ2hpbGQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBBbmltYXRlZE9iamVjdFdpdGhDaGlsZHJlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGFuaW1hdGVkKSB7XG4gICAgaWYgKGFuaW1hdGVkID09PSB2b2lkIDApIHtcbiAgICAgIGFuaW1hdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnBheWxvYWQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGF5bG9hZFtrZXldO1xuICAgICAgaWYgKGFuaW1hdGVkICYmICEodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRlZCkpIGNvbnRpbnVlO1xuICAgICAgcGF5bG9hZFtrZXldID0gdmFsdWUgaW5zdGFuY2VvZiBBbmltYXRlZCA/IHZhbHVlW2FuaW1hdGVkID8gJ2dldEFuaW1hdGVkVmFsdWUnIDogJ2dldFZhbHVlJ10oKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRlZE9iamVjdFdpdGhDaGlsZHJlbjtcbn0oQW5pbWF0ZWRXaXRoQ2hpbGRyZW4pO1xuXG52YXIgQW5pbWF0ZWRTdHlsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0FuaW1hdGVkT2JqZWN0V2l0aENoKSB7XG4gIF9pbmhlcml0c0xvb3NlKEFuaW1hdGVkU3R5bGUsIF9BbmltYXRlZE9iamVjdFdpdGhDaCk7XG5cbiAgZnVuY3Rpb24gQW5pbWF0ZWRTdHlsZShzdHlsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0FuaW1hdGVkT2JqZWN0V2l0aENoLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIGlmIChzdHlsZS50cmFuc2Zvcm0gJiYgIShzdHlsZS50cmFuc2Zvcm0gaW5zdGFuY2VvZiBBbmltYXRlZCkpIHN0eWxlID0gYXBwbHlBbmltYXRlZFZhbHVlcy50cmFuc2Zvcm0oc3R5bGUpO1xuICAgIF90aGlzLnBheWxvYWQgPSBzdHlsZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQW5pbWF0ZWRTdHlsZTtcbn0oQW5pbWF0ZWRPYmplY3RXaXRoQ2hpbGRyZW4pO1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbnZhciBjb2xvcnMgPSB7XG4gIHRyYW5zcGFyZW50OiAweDAwMDAwMDAwLFxuICBhbGljZWJsdWU6IDB4ZjBmOGZmZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDdmZixcbiAgYXF1YTogMHgwMGZmZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDRmZixcbiAgYXp1cmU6IDB4ZjBmZmZmZmYsXG4gIGJlaWdlOiAweGY1ZjVkY2ZmLFxuICBiaXNxdWU6IDB4ZmZlNGM0ZmYsXG4gIGJsYWNrOiAweDAwMDAwMGZmLFxuICBibGFuY2hlZGFsbW9uZDogMHhmZmViY2RmZixcbiAgYmx1ZTogMHgwMDAwZmZmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTJmZixcbiAgYnJvd246IDB4YTUyYTJhZmYsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODdmZixcbiAgYnVybnRzaWVubmE6IDB4ZWE3ZTVkZmYsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTBmZixcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDBmZixcbiAgY2hvY29sYXRlOiAweGQyNjkxZWZmLFxuICBjb3JhbDogMHhmZjdmNTBmZixcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkZmYsXG4gIGNvcm5zaWxrOiAweGZmZjhkY2ZmLFxuICBjcmltc29uOiAweGRjMTQzY2ZmLFxuICBjeWFuOiAweDAwZmZmZmZmLFxuICBkYXJrYmx1ZTogMHgwMDAwOGJmZixcbiAgZGFya2N5YW46IDB4MDA4YjhiZmYsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiZmYsXG4gIGRhcmtncmF5OiAweGE5YTlhOWZmLFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwZmYsXG4gIGRhcmtncmV5OiAweGE5YTlhOWZmLFxuICBkYXJra2hha2k6IDB4YmRiNzZiZmYsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YmZmLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmZmZixcbiAgZGFya29yYW5nZTogMHhmZjhjMDBmZixcbiAgZGFya29yY2hpZDogMHg5OTMyY2NmZixcbiAgZGFya3JlZDogMHg4YjAwMDBmZixcbiAgZGFya3NhbG1vbjogMHhlOTk2N2FmZixcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZmZmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YmZmLFxuICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZmZmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZmZmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMWZmLFxuICBkYXJrdmlvbGV0OiAweDk0MDBkM2ZmLFxuICBkZWVwcGluazogMHhmZjE0OTNmZixcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmZmYsXG4gIGRpbWdyYXk6IDB4Njk2OTY5ZmYsXG4gIGRpbWdyZXk6IDB4Njk2OTY5ZmYsXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmZmYsXG4gIGZpcmVicmljazogMHhiMjIyMjJmZixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwZmYsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMmZmLFxuICBmdWNoc2lhOiAweGZmMDBmZmZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjZmYsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmZmYsXG4gIGdvbGQ6IDB4ZmZkNzAwZmYsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjBmZixcbiAgZ3JheTogMHg4MDgwODBmZixcbiAgZ3JlZW46IDB4MDA4MDAwZmYsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZmZmLFxuICBncmV5OiAweDgwODA4MGZmLFxuICBob25leWRldzogMHhmMGZmZjBmZixcbiAgaG90cGluazogMHhmZjY5YjRmZixcbiAgaW5kaWFucmVkOiAweGNkNWM1Y2ZmLFxuICBpbmRpZ286IDB4NGIwMDgyZmYsXG4gIGl2b3J5OiAweGZmZmZmMGZmLFxuICBraGFraTogMHhmMGU2OGNmZixcbiAgbGF2ZW5kZXI6IDB4ZTZlNmZhZmYsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1ZmYsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDBmZixcbiAgbGVtb25jaGlmZm9uOiAweGZmZmFjZGZmLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2ZmYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwZmYsXG4gIGxpZ2h0Y3lhbjogMHhlMGZmZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyZmYsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDNmZixcbiAgbGlnaHRncmVlbjogMHg5MGVlOTBmZixcbiAgbGlnaHRncmV5OiAweGQzZDNkM2ZmLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxZmYsXG4gIGxpZ2h0c2FsbW9uOiAweGZmYTA3YWZmLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYWZmLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhZmYsXG4gIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OWZmLFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTlmZixcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlZmYsXG4gIGxpZ2h0eWVsbG93OiAweGZmZmZlMGZmLFxuICBsaW1lOiAweDAwZmYwMGZmLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyZmYsXG4gIGxpbmVuOiAweGZhZjBlNmZmLFxuICBtYWdlbnRhOiAweGZmMDBmZmZmLFxuICBtYXJvb246IDB4ODAwMDAwZmYsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhZmYsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkZmYsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDNmZixcbiAgbWVkaXVtcHVycGxlOiAweDkzNzBkYmZmLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzFmZixcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZWZmLFxuICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWFmZixcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjY2ZmLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1ZmYsXG4gIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzBmZixcbiAgbWludGNyZWFtOiAweGY1ZmZmYWZmLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxZmYsXG4gIG1vY2Nhc2luOiAweGZmZTRiNWZmLFxuICBuYXZham93aGl0ZTogMHhmZmRlYWRmZixcbiAgbmF2eTogMHgwMDAwODBmZixcbiAgb2xkbGFjZTogMHhmZGY1ZTZmZixcbiAgb2xpdmU6IDB4ODA4MDAwZmYsXG4gIG9saXZlZHJhYjogMHg2YjhlMjNmZixcbiAgb3JhbmdlOiAweGZmYTUwMGZmLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwZmYsXG4gIG9yY2hpZDogMHhkYTcwZDZmZixcbiAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWFmZixcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OGZmLFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZWZmLFxuICBwYWxldmlvbGV0cmVkOiAweGRiNzA5M2ZmLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNWZmLFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5ZmYsXG4gIHBlcnU6IDB4Y2Q4NTNmZmYsXG4gIHBpbms6IDB4ZmZjMGNiZmYsXG4gIHBsdW06IDB4ZGRhMGRkZmYsXG4gIHBvd2RlcmJsdWU6IDB4YjBlMGU2ZmYsXG4gIHB1cnBsZTogMHg4MDAwODBmZixcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTlmZixcbiAgcmVkOiAweGZmMDAwMGZmLFxuICByb3N5YnJvd246IDB4YmM4ZjhmZmYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTFmZixcbiAgc2FkZGxlYnJvd246IDB4OGI0NTEzZmYsXG4gIHNhbG1vbjogMHhmYTgwNzJmZixcbiAgc2FuZHlicm93bjogMHhmNGE0NjBmZixcbiAgc2VhZ3JlZW46IDB4MmU4YjU3ZmYsXG4gIHNlYXNoZWxsOiAweGZmZjVlZWZmLFxuICBzaWVubmE6IDB4YTA1MjJkZmYsXG4gIHNpbHZlcjogMHhjMGMwYzBmZixcbiAgc2t5Ymx1ZTogMHg4N2NlZWJmZixcbiAgc2xhdGVibHVlOiAweDZhNWFjZGZmLFxuICBzbGF0ZWdyYXk6IDB4NzA4MDkwZmYsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTBmZixcbiAgc25vdzogMHhmZmZhZmFmZixcbiAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmZmYsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjRmZixcbiAgdGFuOiAweGQyYjQ4Y2ZmLFxuICB0ZWFsOiAweDAwODA4MGZmLFxuICB0aGlzdGxlOiAweGQ4YmZkOGZmLFxuICB0b21hdG86IDB4ZmY2MzQ3ZmYsXG4gIHR1cnF1b2lzZTogMHg0MGUwZDBmZixcbiAgdmlvbGV0OiAweGVlODJlZWZmLFxuICB3aGVhdDogMHhmNWRlYjNmZixcbiAgd2hpdGU6IDB4ZmZmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1ZmYsXG4gIHllbGxvdzogMHhmZmZmMDBmZixcbiAgeWVsbG93Z3JlZW46IDB4OWFjZDMyZmZcbn07XG5cbnZhciBJbnRlcnBvbGF0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbigpIHt9XG5cbiAgLy8gRGVmYXVsdCBjb25maWcgPSBjb25maWcsIGFyZ3NcbiAgLy8gU2hvcnQgY29uZmlnICAgPSByYW5nZSwgb3V0cHV0LCBleHRyYXBvbGF0ZVxuICBJbnRlcnBvbGF0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShjb25maWcsIG91dHB1dCwgZXh0cmEpIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGNvbmZpZztlbHNlIGlmIChpbnRlcnBvbGF0aW9uICYmIGNvbmZpZy5vdXRwdXQgJiYgdHlwZW9mIGNvbmZpZy5vdXRwdXRbMF0gPT09ICdzdHJpbmcnKSByZXR1cm4gaW50ZXJwb2xhdGlvbihjb25maWcpO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkgcmV0dXJuIEludGVycG9sYXRpb24uY3JlYXRlKHtcbiAgICAgIHJhbmdlOiBjb25maWcsXG4gICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgIGV4dHJhcG9sYXRlOiBleHRyYSB8fCAnZXh0ZW5kJ1xuICAgIH0pO1xuICAgIHZhciBvdXRwdXRSYW5nZSA9IGNvbmZpZy5vdXRwdXQ7XG4gICAgdmFyIGlucHV0UmFuZ2UgPSBjb25maWcucmFuZ2UgfHwgWzAsIDFdO1xuXG4gICAgdmFyIGVhc2luZyA9IGNvbmZpZy5lYXNpbmcgfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICB2YXIgZXh0cmFwb2xhdGVMZWZ0ID0gJ2V4dGVuZCc7XG4gICAgdmFyIG1hcCA9IGNvbmZpZy5tYXA7XG4gICAgaWYgKGNvbmZpZy5leHRyYXBvbGF0ZUxlZnQgIT09IHVuZGVmaW5lZCkgZXh0cmFwb2xhdGVMZWZ0ID0gY29uZmlnLmV4dHJhcG9sYXRlTGVmdDtlbHNlIGlmIChjb25maWcuZXh0cmFwb2xhdGUgIT09IHVuZGVmaW5lZCkgZXh0cmFwb2xhdGVMZWZ0ID0gY29uZmlnLmV4dHJhcG9sYXRlO1xuICAgIHZhciBleHRyYXBvbGF0ZVJpZ2h0ID0gJ2V4dGVuZCc7XG4gICAgaWYgKGNvbmZpZy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIGV4dHJhcG9sYXRlUmlnaHQgPSBjb25maWcuZXh0cmFwb2xhdGVSaWdodDtlbHNlIGlmIChjb25maWcuZXh0cmFwb2xhdGUgIT09IHVuZGVmaW5lZCkgZXh0cmFwb2xhdGVSaWdodCA9IGNvbmZpZy5leHRyYXBvbGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICB2YXIgcmFuZ2UgPSBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpO1xuICAgICAgcmV0dXJuIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdLCBvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV0sIGVhc2luZywgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBtYXApO1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEludGVycG9sYXRpb247XG59KCk7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dE1pbiwgaW5wdXRNYXgsIG91dHB1dE1pbiwgb3V0cHV0TWF4LCBlYXNpbmcsIGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgbWFwKSB7XG4gIHZhciByZXN1bHQgPSBtYXAgPyBtYXAoaW5wdXQpIDogaW5wdXQ7IC8vIEV4dHJhcG9sYXRlXG5cbiAgaWYgKHJlc3VsdCA8IGlucHV0TWluKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gJ2lkZW50aXR5JykgcmV0dXJuIHJlc3VsdDtlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09ICdjbGFtcCcpIHJlc3VsdCA9IGlucHV0TWluO1xuICB9XG5cbiAgaWYgKHJlc3VsdCA+IGlucHV0TWF4KSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09ICdpZGVudGl0eScpIHJldHVybiByZXN1bHQ7ZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gJ2NsYW1wJykgcmVzdWx0ID0gaW5wdXRNYXg7XG4gIH1cblxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHJldHVybiBvdXRwdXRNaW47XG4gIGlmIChpbnB1dE1pbiA9PT0gaW5wdXRNYXgpIHJldHVybiBpbnB1dCA8PSBpbnB1dE1pbiA/IG91dHB1dE1pbiA6IG91dHB1dE1heDsgLy8gSW5wdXQgUmFuZ2VcblxuICBpZiAoaW5wdXRNaW4gPT09IC1JbmZpbml0eSkgcmVzdWx0ID0gLXJlc3VsdDtlbHNlIGlmIChpbnB1dE1heCA9PT0gSW5maW5pdHkpIHJlc3VsdCA9IHJlc3VsdCAtIGlucHV0TWluO2Vsc2UgcmVzdWx0ID0gKHJlc3VsdCAtIGlucHV0TWluKSAvIChpbnB1dE1heCAtIGlucHV0TWluKTsgLy8gRWFzaW5nXG5cbiAgcmVzdWx0ID0gZWFzaW5nKHJlc3VsdCk7IC8vIE91dHB1dCBSYW5nZVxuXG4gIGlmIChvdXRwdXRNaW4gPT09IC1JbmZpbml0eSkgcmVzdWx0ID0gLXJlc3VsdDtlbHNlIGlmIChvdXRwdXRNYXggPT09IEluZmluaXR5KSByZXN1bHQgPSByZXN1bHQgKyBvdXRwdXRNaW47ZWxzZSByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgaW5wdXRSYW5nZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gaSAtIDE7XG59XG5cbi8vIGNvbnN0IElOVEVHRVIgPSAnWy0rXT9cXFxcZCsnO1xudmFyIE5VTUJFUiA9ICdbLStdP1xcXFxkKlxcXFwuP1xcXFxkKyc7XG52YXIgUEVSQ0VOVEFHRSA9IE5VTUJFUiArICclJztcblxuZnVuY3Rpb24gY2FsbCgpIHtcbiAgcmV0dXJuICdcXFxcKFxcXFxzKignICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcpXFxcXHMqLFxcXFxzKignKSArICcpXFxcXHMqXFxcXCknO1xufVxuXG52YXIgcmdiID0gbmV3IFJlZ0V4cCgncmdiJyArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xudmFyIHJnYmEgPSBuZXcgUmVnRXhwKCdyZ2JhJyArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG52YXIgaHNsID0gbmV3IFJlZ0V4cCgnaHNsJyArIGNhbGwoTlVNQkVSLCBQRVJDRU5UQUdFLCBQRVJDRU5UQUdFKSk7XG52YXIgaHNsYSA9IG5ldyBSZWdFeHAoJ2hzbGEnICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xudmFyIGhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbnZhciBoZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xudmFyIGhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG52YXIgaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcblxuLypcbmh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1jb21tdW5pdHkvbm9ybWFsaXplLWNzcy1jb2xvclxuXG5CU0QgMy1DbGF1c2UgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTYsIFJlYWN0IENvbW11bml0eVxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG5tb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbkFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbklNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbkRBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG5TRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUlxuQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSxcbk9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG5PRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIHZhciBtYXRjaDtcblxuICBpZiAodHlwZW9mIGNvbG9yID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBjb2xvciA+Pj4gMCA9PT0gY29sb3IgJiYgY29sb3IgPj0gMCAmJiBjb2xvciA8PSAweGZmZmZmZmZmID8gY29sb3IgOiBudWxsO1xuICB9IC8vIE9yZGVyZWQgYmFzZWQgb24gb2NjdXJyZW5jZXMgb24gRmFjZWJvb2sgY29kZWJhc2VcblxuXG4gIGlmIChtYXRjaCA9IGhleDYuZXhlYyhjb2xvcikpIHJldHVybiBwYXJzZUludChtYXRjaFsxXSArICdmZicsIDE2KSA+Pj4gMDtcbiAgaWYgKGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShjb2xvcikpIHJldHVybiBjb2xvcnNbY29sb3JdO1xuXG4gIGlmIChtYXRjaCA9IHJnYi5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgLy8gclxuICAgIHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IC8vIGdcbiAgICBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IC8vIGJcbiAgICAweDAwMDAwMGZmKSA+Pj4gLy8gYVxuICAgIDA7XG4gIH1cblxuICBpZiAobWF0Y2ggPSByZ2JhLmV4ZWMoY29sb3IpKSB7XG4gICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCAvLyByXG4gICAgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgLy8gZ1xuICAgIHBhcnNlMjU1KG1hdGNoWzNdKSA8PCA4IHwgLy8gYlxuICAgIHBhcnNlMShtYXRjaFs0XSkpID4+PiAvLyBhXG4gICAgMDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhleDMuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIC8vIHJcbiAgICBtYXRjaFsyXSArIG1hdGNoWzJdICsgLy8gZ1xuICAgIG1hdGNoWzNdICsgbWF0Y2hbM10gKyAvLyBiXG4gICAgJ2ZmJywgLy8gYVxuICAgIDE2KSA+Pj4gMDtcbiAgfSAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLTQvI2hleC1ub3RhdGlvblxuXG5cbiAgaWYgKG1hdGNoID0gaGV4OC5leGVjKGNvbG9yKSkgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxNikgPj4+IDA7XG5cbiAgaWYgKG1hdGNoID0gaGV4NC5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgLy8gclxuICAgIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyAvLyBnXG4gICAgbWF0Y2hbM10gKyBtYXRjaFszXSArIC8vIGJcbiAgICBtYXRjaFs0XSArIG1hdGNoWzRdLCAvLyBhXG4gICAgMTYpID4+PiAwO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIC8vIGhcbiAgICBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCAvLyBzXG4gICAgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSAvLyBsXG4gICAgKSB8IDB4MDAwMDAwZmYpID4+PiAvLyBhXG4gICAgMDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgLy8gaFxuICAgIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIC8vIHNcbiAgICBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pIC8vIGxcbiAgICApIHwgcGFyc2UxKG1hdGNoWzRdKSkgPj4+IC8vIGFcbiAgICAwO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHQgKz0gMTtcbiAgaWYgKHQgPiAxKSB0IC09IDE7XG4gIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIHZhciBwID0gMiAqIGwgLSBxO1xuICB2YXIgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgdmFyIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICB2YXIgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiICogMjU1KSA8PCA4O1xufVxuXG5mdW5jdGlvbiBwYXJzZTI1NShzdHIpIHtcbiAgdmFyIGludCA9IHBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaW50IDwgMCkgcmV0dXJuIDA7XG4gIGlmIChpbnQgPiAyNTUpIHJldHVybiAyNTU7XG4gIHJldHVybiBpbnQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlMzYwKHN0cikge1xuICB2YXIgaW50ID0gcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gKGludCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgdmFyIG51bSA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHJldHVybiAwO1xuICBpZiAobnVtID4gMSkgcmV0dXJuIDI1NTtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQZXJjZW50YWdlKHN0cikge1xuICAvLyBwYXJzZUZsb2F0IGNvbnZlbmllbnRseSBpZ25vcmVzIHRoZSBmaW5hbCAlXG4gIHZhciBpbnQgPSBwYXJzZUZsb2F0KHN0cik7XG4gIGlmIChpbnQgPCAwKSByZXR1cm4gMDtcbiAgaWYgKGludCA+IDEwMCkgcmV0dXJuIDE7XG4gIHJldHVybiBpbnQgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGNvbG9yVG9SZ2JhKGlucHV0KSB7XG4gIHZhciBpbnQzMkNvbG9yID0gbm9ybWFsaXplQ29sb3IoaW5wdXQpO1xuICBpZiAoaW50MzJDb2xvciA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICBpbnQzMkNvbG9yID0gaW50MzJDb2xvciB8fCAwO1xuICB2YXIgciA9IChpbnQzMkNvbG9yICYgMHhmZjAwMDAwMCkgPj4+IDI0O1xuICB2YXIgZyA9IChpbnQzMkNvbG9yICYgMHgwMGZmMDAwMCkgPj4+IDE2O1xuICB2YXIgYiA9IChpbnQzMkNvbG9yICYgMHgwMDAwZmYwMCkgPj4+IDg7XG4gIHZhciBhID0gKGludDMyQ29sb3IgJiAweDAwMDAwMGZmKSAvIDI1NTtcbiAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiwgXCIgKyBnICsgXCIsIFwiICsgYiArIFwiLCBcIiArIGEgKyBcIilcIjtcbn0gLy8gUHJvYmxlbTogaHR0cHM6Ly9naXRodWIuY29tL2FuaW1hdGVkanMvYW5pbWF0ZWQvcHVsbC8xMDJcbi8vIFNvbHV0aW9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Mzg1NjUvcGFyc2luZy1zY2llbnRpZmljLW5vdGF0aW9uLXNlbnNpYmx5LzY1ODY2MlxuXG5cbnZhciBzdHJpbmdTaGFwZVJlZ2V4ID0gL1srXFwtXT8oPzowfFsxLTldXFxkKikoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nOyAvLyBDb3ZlcnMgcmdiLCByZ2JhLCBoc2wsIGhzbGFcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vb2xtb2tyYW1lci84MmNjY2U2NzNmODZkYjdjZGE1ZVxuXG52YXIgY29sb3JSZWdleCA9IC8oIyg/OlswLTlhLWZdezJ9KXsyLDR9fCgjWzAtOWEtZl17M30pfChyZ2J8aHNsKWE/XFwoKC0/XFxkKyU/WyxcXHNdKyl7MiwzfVxccypbXFxkXFwuXSslP1xcKSkvZ2k7IC8vIENvdmVycyBjb2xvciBuYW1lcyAodHJhbnNwYXJlbnQsIGJsdWUsIGV0Yy4pXG5cbnZhciBjb2xvck5hbWVzUmVnZXggPSBuZXcgUmVnRXhwKFwiKFwiICsgT2JqZWN0LmtleXMoY29sb3JzKS5qb2luKCd8JykgKyBcIilcIiwgJ2cnKTtcbi8qKlxuICogU3VwcG9ydHMgc3RyaW5nIHNoYXBlcyBieSBleHRyYWN0aW5nIG51bWJlcnMgc28gbmV3IHZhbHVlcyBjYW4gYmUgY29tcHV0ZWQsXG4gKiBhbmQgcmVjb21iaW5lcyB0aG9zZSB2YWx1ZXMgaW50byBuZXcgc3RyaW5ncyBvZiB0aGUgc2FtZSBzaGFwZS4gIFN1cHBvcnRzXG4gKiB0aGluZ3MgbGlrZTpcbiAqXG4gKiAgIHJnYmEoMTIzLCA0MiwgOTksIDAuMzYpICAgICAgICAgICAvLyBjb2xvcnNcbiAqICAgLTQ1ZGVnICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyB3aXRoIHVuaXRzXG4gKiAgIDAgMnB4IDJweCAwcHggcmdiYSgwLCAwLCAwLCAwLjEyKSAvLyBib3ggc2hhZG93c1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29uZmlnKSB7XG4gIC8vIFJlcGxhY2UgY29sb3JzIHdpdGggcmdiYVxuICB2YXIgb3V0cHV0UmFuZ2UgPSBjb25maWcub3V0cHV0Lm1hcChmdW5jdGlvbiAocmFuZ2VWYWx1ZSkge1xuICAgIHJldHVybiByYW5nZVZhbHVlLnJlcGxhY2UoY29sb3JSZWdleCwgY29sb3JUb1JnYmEpO1xuICB9KS5tYXAoZnVuY3Rpb24gKHJhbmdlVmFsdWUpIHtcbiAgICByZXR1cm4gcmFuZ2VWYWx1ZS5yZXBsYWNlKGNvbG9yTmFtZXNSZWdleCwgY29sb3JUb1JnYmEpO1xuICB9KTsgLy8gLT5cbiAgLy8gW1xuICAvLyAgIFswLCA1MF0sXG4gIC8vICAgWzEwMCwgMTUwXSxcbiAgLy8gICBbMjAwLCAyNTBdLFxuICAvLyAgIFswLCAwLjVdLFxuICAvLyBdXG5cbiAgdmFyIG91dHB1dFJhbmdlcyA9IG91dHB1dFJhbmdlWzBdLm1hdGNoKHN0cmluZ1NoYXBlUmVnZXgpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgb3V0cHV0UmFuZ2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZS5tYXRjaChzdHJpbmdTaGFwZVJlZ2V4KS5mb3JFYWNoKGZ1bmN0aW9uIChudW1iZXIsIGkpIHtcbiAgICAgIHJldHVybiBvdXRwdXRSYW5nZXNbaV0ucHVzaCgrbnVtYmVyKTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBpbnRlcnBvbGF0aW9ucyA9IG91dHB1dFJhbmdlWzBdLm1hdGNoKHN0cmluZ1NoYXBlUmVnZXgpLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICByZXR1cm4gSW50ZXJwb2xhdGlvbi5jcmVhdGUoX2V4dGVuZHMoe30sIGNvbmZpZywge1xuICAgICAgb3V0cHV0OiBvdXRwdXRSYW5nZXNbaV1cbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBvdXRwdXRSYW5nZVswXSAvLyAncmdiYSgwLCAxMDAsIDIwMCwgMCknXG4gICAgLy8gLT5cbiAgICAvLyAncmdiYSgke2ludGVycG9sYXRpb25zWzBdKGlucHV0KX0sICR7aW50ZXJwb2xhdGlvbnNbMV0oaW5wdXQpfSwgLi4uJ1xuICAgIC5yZXBsYWNlKHN0cmluZ1NoYXBlUmVnZXgsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnRlcnBvbGF0aW9uc1tpKytdKGlucHV0KTtcbiAgICB9KSAvLyByZ2JhIHJlcXVpcmVzIHRoYXQgdGhlIHIsZyxiIGFyZSBpbnRlZ2Vycy4uLi4gc28gd2Ugd2FudCB0byByb3VuZCB0aGVtLCBidXQgd2UgKmRvbnQqIHdhbnQgdG9cbiAgICAvLyByb3VuZCB0aGUgb3BhY2l0eSAoNHRoIGNvbHVtbikuXG4gICAgLnJlcGxhY2UoL3JnYmFcXCgoWzAtOVxcLi1dKyksIChbMC05XFwuLV0rKSwgKFswLTlcXC4tXSspLCAoWzAtOVxcLi1dKylcXCkvZ2ksIGZ1bmN0aW9uIChfLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgcmV0dXJuIFwicmdiYShcIiArIE1hdGgucm91bmQocDEpICsgXCIsIFwiICsgTWF0aC5yb3VuZChwMikgKyBcIiwgXCIgKyBNYXRoLnJvdW5kKHAzKSArIFwiLCBcIiArIHA0ICsgXCIpXCI7XG4gICAgfSk7XG4gIH07XG59XG5cbnZhciBBbmltYXRlZEludGVycG9sYXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BbmltYXRlZEFycmF5V2l0aENoaSkge1xuICBfaW5oZXJpdHNMb29zZShBbmltYXRlZEludGVycG9sYXRpb24sIF9BbmltYXRlZEFycmF5V2l0aENoaSk7XG5cbiAgZnVuY3Rpb24gQW5pbWF0ZWRJbnRlcnBvbGF0aW9uKHBhcmVudHMsIF9jb25maWcsIF9hcmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9BbmltYXRlZEFycmF5V2l0aENoaS5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczI7XG5cbiAgICAgIHJldHVybiAoX3RoaXMyID0gX3RoaXMpLmNhbGMuYXBwbHkoX3RoaXMyLCBfdGhpcy5wYXlsb2FkLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmdldFZhbHVlKCk7XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIF90aGlzLnVwZGF0ZUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIGFyZykge1xuICAgICAgcmV0dXJuIF90aGlzLmNhbGMgPSBJbnRlcnBvbGF0aW9uLmNyZWF0ZShjb25maWcsIGFyZyk7XG4gICAgfTtcblxuICAgIF90aGlzLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGNvbmZpZywgYXJnKSB7XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGVkSW50ZXJwb2xhdGlvbihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgY29uZmlnLCBhcmcpO1xuICAgIH07XG5cbiAgICBfdGhpcy5wYXlsb2FkID0gLy8gQW5pbWF0ZWRBcnJheXMgc2hvdWxkIHVuZm9sZCwgZXhjZXB0IEFuaW1hdGVkSW50ZXJwb2xhdGlvbiB3aGljaCBpcyB0YWtlbiBhcyBpc1xuICAgIHBhcmVudHMgaW5zdGFuY2VvZiBBbmltYXRlZEFycmF5V2l0aENoaWxkcmVuICYmICFwYXJlbnRzLnVwZGF0ZUNvbmZpZyA/IHBhcmVudHMucGF5bG9hZCA6IEFycmF5LmlzQXJyYXkocGFyZW50cykgPyBwYXJlbnRzIDogW3BhcmVudHNdO1xuICAgIF90aGlzLmNhbGMgPSBJbnRlcnBvbGF0aW9uLmNyZWF0ZShfY29uZmlnLCBfYXJnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQW5pbWF0ZWRJbnRlcnBvbGF0aW9uO1xufShBbmltYXRlZEFycmF5V2l0aENoaWxkcmVuKTtcbnZhciBpbnRlcnBvbGF0ZSQxID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUocGFyZW50cywgY29uZmlnLCBhcmcpIHtcbiAgcmV0dXJuIHBhcmVudHMgJiYgbmV3IEFuaW1hdGVkSW50ZXJwb2xhdGlvbihwYXJlbnRzLCBjb25maWcsIGFyZyk7XG59O1xuXG4vKipcbiAqIEFuaW1hdGVkIHdvcmtzIGJ5IGJ1aWxkaW5nIGEgZGlyZWN0ZWQgYWN5Y2xpYyBncmFwaCBvZiBkZXBlbmRlbmNpZXNcbiAqIHRyYW5zcGFyZW50bHkgd2hlbiB5b3UgcmVuZGVyIHlvdXIgQW5pbWF0ZWQgY29tcG9uZW50cy5cbiAqXG4gKiAgICAgICAgICAgICAgIG5ldyBBbmltYXRlZC5WYWx1ZSgwKVxuICogICAgIC5pbnRlcnBvbGF0ZSgpICAgICAgICAuaW50ZXJwb2xhdGUoKSAgICBuZXcgQW5pbWF0ZWQuVmFsdWUoMSlcbiAqICAgICAgICAgb3BhY2l0eSAgICAgICAgICAgICAgIHRyYW5zbGF0ZVkgICAgICBzY2FsZVxuICogICAgICAgICAgc3R5bGUgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtXG4gKiAgICAgICAgIFZpZXcjMjM0ICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmlldyMxMjNcbiAqXG4gKiBBKSBUb3AgRG93biBwaGFzZVxuICogV2hlbiBhbiBBbmltYXRlZC5WYWx1ZSBpcyB1cGRhdGVkLCB3ZSByZWN1cnNpdmVseSBnbyBkb3duIHRocm91Z2ggdGhpc1xuICogZ3JhcGggaW4gb3JkZXIgdG8gZmluZCBsZWFmIG5vZGVzOiB0aGUgdmlld3MgdGhhdCB3ZSBmbGFnIGFzIG5lZWRpbmdcbiAqIGFuIHVwZGF0ZS5cbiAqXG4gKiBCKSBCb3R0b20gVXAgcGhhc2VcbiAqIFdoZW4gYSB2aWV3IGlzIGZsYWdnZWQgYXMgbmVlZGluZyBhbiB1cGRhdGUsIHdlIHJlY3Vyc2l2ZWx5IGdvIGJhY2sgdXBcbiAqIGluIG9yZGVyIHRvIGJ1aWxkIHRoZSBuZXcgdmFsdWUgdGhhdCBpdCBuZWVkcy4gVGhlIHJlYXNvbiB3aHkgd2UgbmVlZFxuICogdGhpcyB0d28tcGhhc2VzIHByb2Nlc3MgaXMgdG8gZGVhbCB3aXRoIGNvbXBvc2l0ZSBwcm9wcyBzdWNoIGFzXG4gKiB0cmFuc2Zvcm0gd2hpY2ggY2FuIHJlY2VpdmUgdmFsdWVzIGZyb20gbXVsdGlwbGUgcGFyZW50cy5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kQW5pbWF0ZWRTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIGlmICh0eXBlb2Ygbm9kZS51cGRhdGUgPT09ICdmdW5jdGlvbicpIHN0eWxlcy5hZGQobm9kZSk7ZWxzZSBub2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZmluZEFuaW1hdGVkU3R5bGVzKGNoaWxkLCBzdHlsZXMpO1xuICB9KTtcbn1cbi8qKlxuICogU3RhbmRhcmQgdmFsdWUgZm9yIGRyaXZpbmcgYW5pbWF0aW9ucy4gIE9uZSBgQW5pbWF0ZWQuVmFsdWVgIGNhbiBkcml2ZVxuICogbXVsdGlwbGUgcHJvcGVydGllcyBpbiBhIHN5bmNocm9uaXplZCBmYXNoaW9uLCBidXQgY2FuIG9ubHkgYmUgZHJpdmVuIGJ5IG9uZVxuICogbWVjaGFuaXNtIGF0IGEgdGltZS4gIFVzaW5nIGEgbmV3IG1lY2hhbmlzbSAoZS5nLiBzdGFydGluZyBhIG5ldyBhbmltYXRpb24sXG4gKiBvciBjYWxsaW5nIGBzZXRWYWx1ZWApIHdpbGwgc3RvcCBhbnkgcHJldmlvdXMgb25lcy5cbiAqL1xuXG5cbnZhciBBbmltYXRlZFZhbHVlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQW5pbWF0ZWRXaXRoQ2hpbGRyZW4pIHtcbiAgX2luaGVyaXRzTG9vc2UoQW5pbWF0ZWRWYWx1ZSwgX0FuaW1hdGVkV2l0aENoaWxkcmVuKTtcblxuICBmdW5jdGlvbiBBbmltYXRlZFZhbHVlKF92YWx1ZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0FuaW1hdGVkV2l0aENoaWxkcmVuLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBmbHVzaCkge1xuICAgICAgaWYgKGZsdXNoID09PSB2b2lkIDApIHtcbiAgICAgICAgZmx1c2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKGZsdXNoKSBfdGhpcy5mbHVzaCgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy52YWx1ZTtcbiAgICB9O1xuXG4gICAgX3RoaXMudXBkYXRlU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZpbmRBbmltYXRlZFN0eWxlcyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgX3RoaXMuYW5pbWF0ZWRTdHlsZXMpO1xuICAgIH07XG5cbiAgICBfdGhpcy51cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF90aGlzLmZsdXNoKF90aGlzLnZhbHVlID0gdmFsdWUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChjb25maWcsIGFyZykge1xuICAgICAgcmV0dXJuIG5ldyBBbmltYXRlZEludGVycG9sYXRpb24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGNvbmZpZywgYXJnKTtcbiAgICB9O1xuXG4gICAgX3RoaXMudmFsdWUgPSBfdmFsdWU7XG4gICAgX3RoaXMuYW5pbWF0ZWRTdHlsZXMgPSBuZXcgU2V0KCk7XG4gICAgX3RoaXMuZG9uZSA9IGZhbHNlO1xuICAgIF90aGlzLnN0YXJ0UG9zaXRpb24gPSBfdmFsdWU7XG4gICAgX3RoaXMubGFzdFBvc2l0aW9uID0gX3ZhbHVlO1xuICAgIF90aGlzLmxhc3RWZWxvY2l0eSA9IHVuZGVmaW5lZDtcbiAgICBfdGhpcy5sYXN0VGltZSA9IHVuZGVmaW5lZDtcbiAgICBfdGhpcy5jb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBbmltYXRlZFZhbHVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRlZFN0eWxlcy5zaXplID09PSAwKSB0aGlzLnVwZGF0ZVN0eWxlcygpO1xuICAgIHRoaXMuYW5pbWF0ZWRTdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0ZWRTdHlsZSkge1xuICAgICAgcmV0dXJuIGFuaW1hdGVkU3R5bGUudXBkYXRlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnByZXBhcmUgPSBmdW5jdGlvbiBwcmVwYXJlKGNvbnRyb2xsZXIpIHtcbiAgICAvLyBWYWx1ZXMgc3RheSBsb3lhbCB0byB0aGVpciBvcmlnaW5hbCBjb250cm9sbGVyLCB0aGlzIGlzIGFsc28gYSB3YXkgdG9cbiAgICAvLyBkZXRlY3QgdHJhaWxpbmcgdmFsdWVzIG9yaWdpbmF0aW5nIGZyb20gYSBmb3JlaWduIGNvbnRyb2xsZXJcbiAgICBpZiAodGhpcy5jb250cm9sbGVyID09PSB1bmRlZmluZWQpIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgICBpZiAodGhpcy5jb250cm9sbGVyID09PSBjb250cm9sbGVyKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5sYXN0VmVsb2NpdHkgPSBjb250cm9sbGVyLmlzQWN0aXZlID8gdGhpcy5sYXN0VmVsb2NpdHkgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RUaW1lID0gY29udHJvbGxlci5pc0FjdGl2ZSA/IHRoaXMubGFzdFRpbWUgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuYW5pbWF0ZWRTdHlsZXMuY2xlYXIoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGVkVmFsdWU7XG59KEFuaW1hdGVkV2l0aENoaWxkcmVuKTtcblxudmFyIEFuaW1hdGVkQXJyYXkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BbmltYXRlZEFycmF5V2l0aENoaSkge1xuICBfaW5oZXJpdHNMb29zZShBbmltYXRlZEFycmF5LCBfQW5pbWF0ZWRBcnJheVdpdGhDaGkpO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGVkQXJyYXkoYXJyYXkpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9BbmltYXRlZEFycmF5V2l0aENoaS5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZmx1c2gpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZsdXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IF90aGlzLnBheWxvYWQubGVuZ3RoKSB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBheWxvYWRbaV0uc2V0VmFsdWUodiwgZmx1c2gpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBfdGhpcy5wYXlsb2FkLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnBheWxvYWRbaV0uc2V0VmFsdWUodmFsdWUsIGZsdXNoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wYXlsb2FkLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi5nZXRWYWx1ZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGNvbmZpZywgYXJnKSB7XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGVkSW50ZXJwb2xhdGlvbihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgY29uZmlnLCBhcmcpO1xuICAgIH07XG5cbiAgICBfdGhpcy5wYXlsb2FkID0gYXJyYXkubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGVkVmFsdWUobik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEFuaW1hdGVkQXJyYXk7XG59KEFuaW1hdGVkQXJyYXlXaXRoQ2hpbGRyZW4pO1xuXG5mdW5jdGlvbiB3aXRoRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5mdW5jdGlvbiB0b0FycmF5KGEpIHtcbiAgcmV0dXJuIGEgIT09IHZvaWQgMCA/IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdIDogW107XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwoYSwgYikge1xuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInKSByZXR1cm4gYSA9PT0gYjtcbiAgdmFyIGk7XG5cbiAgZm9yIChpIGluIGEpIHtcbiAgICBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGkgaW4gYikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaSA9PT0gdm9pZCAwID8gYSA9PT0gYiA6IHRydWU7XG59XG5mdW5jdGlvbiBjYWxsUHJvcChvYmopIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgPyBvYmouYXBwbHkodm9pZCAwLCBhcmdzKSA6IG9iajtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlcyQxKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gb2JqZWN0W2tdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZvcndhcmRQcm9wcyhwcm9wcykge1xuICB2YXIgdG8gPSBwcm9wcy50byxcbiAgICAgIGZyb20gPSBwcm9wcy5mcm9tLFxuICAgICAgY29uZmlnID0gcHJvcHMuY29uZmlnLFxuICAgICAgbmF0aXZlID0gcHJvcHMubmF0aXZlLFxuICAgICAgb25TdGFydCA9IHByb3BzLm9uU3RhcnQsXG4gICAgICBvblJlc3QgPSBwcm9wcy5vblJlc3QsXG4gICAgICBvbkZyYW1lID0gcHJvcHMub25GcmFtZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICByZXNldCA9IHByb3BzLnJlc2V0LFxuICAgICAgcmV2ZXJzZSA9IHByb3BzLnJldmVyc2UsXG4gICAgICBmb3JjZSA9IHByb3BzLmZvcmNlLFxuICAgICAgaW1tZWRpYXRlID0gcHJvcHMuaW1tZWRpYXRlLFxuICAgICAgaW1wbCA9IHByb3BzLmltcGwsXG4gICAgICBpbmplY3QgPSBwcm9wcy5pbmplY3QsXG4gICAgICBkZWxheSA9IHByb3BzLmRlbGF5LFxuICAgICAgYXR0YWNoID0gcHJvcHMuYXR0YWNoLFxuICAgICAgZGVzdHJveWVkID0gcHJvcHMuZGVzdHJveWVkLFxuICAgICAgaW50ZXJwb2xhdGVUbyA9IHByb3BzLmludGVycG9sYXRlVG8sXG4gICAgICBhdXRvU3RhcnQgPSBwcm9wcy5hdXRvU3RhcnQsXG4gICAgICByZWYgPSBwcm9wcy5yZWYsXG4gICAgICBmb3J3YXJkID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcInRvXCIsIFwiZnJvbVwiLCBcImNvbmZpZ1wiLCBcIm5hdGl2ZVwiLCBcIm9uU3RhcnRcIiwgXCJvblJlc3RcIiwgXCJvbkZyYW1lXCIsIFwiY2hpbGRyZW5cIiwgXCJyZXNldFwiLCBcInJldmVyc2VcIiwgXCJmb3JjZVwiLCBcImltbWVkaWF0ZVwiLCBcImltcGxcIiwgXCJpbmplY3RcIiwgXCJkZWxheVwiLCBcImF0dGFjaFwiLCBcImRlc3Ryb3llZFwiLCBcImludGVycG9sYXRlVG9cIiwgXCJhdXRvU3RhcnRcIiwgXCJyZWZcIl0pO1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUbyhwcm9wcykge1xuICB2YXIgZm9yd2FyZCA9IGdldEZvcndhcmRQcm9wcyhwcm9wcyk7XG4gIHZhciByZXN0ID0gT2JqZWN0LmtleXMocHJvcHMpLnJlZHVjZShmdW5jdGlvbiAoYSwgaykge1xuICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICByZXR1cm4gZm9yd2FyZFtrXSAhPT0gdm9pZCAwID8gYSA6IF9leHRlbmRzKHt9LCBhLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltrXSA9IHByb3BzW2tdLCBfZXh0ZW5kczIpKTtcbiAgfSwge30pO1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIHRvOiBmb3J3YXJkXG4gIH0sIHJlc3QpO1xufVxuZnVuY3Rpb24gY29udmVydFRvQW5pbWF0ZWRWYWx1ZShhY2MsIF9yZWYpIHtcbiAgdmFyIF9leHRlbmRzMztcblxuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICB2YWx1ZSA9IF9yZWZbMV07XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tuYW1lXSA9IG5ldyAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBBbmltYXRlZEFycmF5IDogQW5pbWF0ZWRWYWx1ZSkodmFsdWUpLCBfZXh0ZW5kczMpKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWYWx1ZXMocHJvcHMpIHtcbiAgdmFyIGZyb20gPSBwcm9wcy5mcm9tLFxuICAgICAgdG8gPSBwcm9wcy50byxcbiAgICAgIG5hdGl2ZSA9IHByb3BzLm5hdGl2ZTtcbiAgdmFyIGFsbFByb3BzID0gT2JqZWN0LmVudHJpZXMoX2V4dGVuZHMoe30sIGZyb20sIHRvKSk7XG4gIHJldHVybiBuYXRpdmUgPyBhbGxQcm9wcy5yZWR1Y2UoY29udmVydFRvQW5pbWF0ZWRWYWx1ZSwge30pIDogX2V4dGVuZHMoe30sIGZyb20sIHRvKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVJlZihyZWYsIGZvcndhcmQpIHtcbiAgaWYgKGZvcndhcmQpIHtcbiAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb24sIGFzc3VtZSBpdCdzIGEgcmVmIGNhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBmb3J3YXJkID09PSAnZnVuY3Rpb24nKSBmb3J3YXJkKHJlZik7ZWxzZSBpZiAodHlwZW9mIGZvcndhcmQgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBJZiBpdCdzIGFuIG9iamVjdCBhbmQgaGFzIGEgJ2N1cnJlbnQnIHByb3BlcnR5LCBhc3N1bWUgaXQncyBhIHJlZiBvYmplY3RcbiAgICAgIGZvcndhcmQuY3VycmVudCA9IHJlZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVmO1xufVxuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09ICdhdXRvJztcbn07XG5cbnZhciBvdmVyd3JpdGUgPSBmdW5jdGlvbiBvdmVyd3JpdGUod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGFjYywgX3JlZikge1xuICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbbmFtZV0gPSB2YWx1ZSA9PT0gJ2F1dG8nID8gfm5hbWUuaW5kZXhPZignaGVpZ2h0JykgPyBoZWlnaHQgOiB3aWR0aCA6IHZhbHVlLCBfZXh0ZW5kczIpKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGZpeEF1dG8ocHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBmcm9tID0gcHJvcHMuZnJvbSxcbiAgICAgIHRvID0gcHJvcHMudG8sXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuOyAvLyBEcnktcm91dGUgcHJvcHMgYmFjayBpZiBub3RoaW5nJ3MgdXNpbmcgJ2F1dG8nIGluIHRoZXJlXG4gIC8vIFRPRE86IGRlYWwgd2l0aCBcIm51bGxcIlxuXG4gIGlmICghKGdldFZhbHVlcyQxKHRvKS5zb21lKGNoZWNrKSB8fCBnZXRWYWx1ZXMkMShmcm9tKS5zb21lKGNoZWNrKSkpIHJldHVybjsgLy8gRmV0Y2ggcmVuZGVyIHYtZG9tXG5cbiAgdmFyIGVsZW1lbnQgPSBjaGlsZHJlbihjb252ZXJ0VmFsdWVzKHByb3BzKSk7IC8vIEEgc3ByaW5nIGNhbiByZXR1cm4gdW5kZWZpbmVkL251bGwsIGNoZWNrIGFnYWluc3QgdGhhdCAoIzE1MylcblxuICBpZiAoIWVsZW1lbnQpIHJldHVybjsgLy8gT3IgaXQgY291bGQgYmUgYW4gYXJyYXkgKCMzNDYpIC4uLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSBlbGVtZW50ID0ge1xuICAgIHR5cGU6ICdkaXYnLFxuICAgIHByb3BzOiB7XG4gICAgICBjaGlsZHJlbjogZWxlbWVudFxuICAgIH0gLy8gRXh0cmFjdCBzdHlsZXNcblxuICB9O1xuICB2YXIgZWxlbWVudFN0eWxlcyA9IGVsZW1lbnQucHJvcHMuc3R5bGU7IC8vIFJldHVybiB2LmRvbSB3aXRoIGluamVjdGVkIHJlZlxuXG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGVsZW1lbnQudHlwZSwgX2V4dGVuZHMoe1xuICAgIGtleTogZWxlbWVudC5rZXkgPyBlbGVtZW50LmtleSA6IHVuZGVmaW5lZFxuICB9LCBlbGVtZW50LnByb3BzLCB7XG4gICAgc3R5bGU6IF9leHRlbmRzKHt9LCBlbGVtZW50U3R5bGVzLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG4gICAgfSksXG4gICAgcmVmOiBmdW5jdGlvbiByZWYoX3JlZjIpIHtcbiAgICAgIGlmIChfcmVmMikge1xuICAgICAgICAvLyBPbmNlIGl0J3MgcmVuZGVyZWQgb3V0LCBmZXRjaCBib3VuZHMgKG1pbnVzIHBhZGRpbmcvbWFyZ2luL2JvcmRlcnMpXG4gICAgICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoX3JlZjIpO1xuICAgICAgICB2YXIgd2lkdGgsIGhlaWdodDtcbiAgICAgICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgICAgICBpZiAoY3MuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcbiAgICAgICAgICB3aWR0aCA9IG5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gbm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBhZGRpbmdYID0gcGFyc2VGbG9hdChjcy5wYWRkaW5nTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoY3MucGFkZGluZ1JpZ2h0IHx8IDApO1xuICAgICAgICAgIHZhciBwYWRkaW5nWSA9IHBhcnNlRmxvYXQoY3MucGFkZGluZ1RvcCB8fCAwKSArIHBhcnNlRmxvYXQoY3MucGFkZGluZ0JvdHRvbSB8fCAwKTtcbiAgICAgICAgICB2YXIgYm9yZGVyWCA9IHBhcnNlRmxvYXQoY3MuYm9yZGVyTGVmdFdpZHRoIHx8IDApICsgcGFyc2VGbG9hdChjcy5ib3JkZXJSaWdodFdpZHRoIHx8IDApO1xuICAgICAgICAgIHZhciBib3JkZXJZID0gcGFyc2VGbG9hdChjcy5ib3JkZXJUb3BXaWR0aCB8fCAwKSArIHBhcnNlRmxvYXQoY3MuYm9yZGVyQm90dG9tV2lkdGggfHwgMCk7XG4gICAgICAgICAgd2lkdGggPSBub2RlLm9mZnNldFdpZHRoIC0gcGFkZGluZ1ggLSBib3JkZXJYO1xuICAgICAgICAgIGhlaWdodCA9IG5vZGUub2Zmc2V0SGVpZ2h0IC0gcGFkZGluZ1kgLSBib3JkZXJZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnZlcnQgPSBvdmVyd3JpdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNhbGxiYWNrKF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIGZyb206IE9iamVjdC5lbnRyaWVzKGZyb20pLnJlZHVjZShjb252ZXJ0LCBmcm9tKSxcbiAgICAgICAgICB0bzogT2JqZWN0LmVudHJpZXModG8pLnJlZHVjZShjb252ZXJ0LCB0bylcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xufVxuXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGNvbHVtbnM6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxudmFyIHByZWZpeEtleSA9IGZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01zJywgJ01veicsICdPJ107XG5pc1VuaXRsZXNzTnVtYmVyID0gT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcmV0dXJuIGFjY1twcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBhY2NbcHJvcF07XG4gIH0pO1xuICByZXR1cm4gYWNjO1xufSwgaXNVbml0bGVzc051bWJlcik7XG5cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnKSByZXR1cm4gJyc7XG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIGF0dHJpYnV0ZUNhY2hlID0ge307XG5pbmplY3RDcmVhdGVBbmltYXRlZFN0eWxlKGZ1bmN0aW9uIChzdHlsZSkge1xuICByZXR1cm4gbmV3IEFuaW1hdGVkU3R5bGUoc3R5bGUpO1xufSk7XG5pbmplY3REZWZhdWx0RWxlbWVudCgnZGl2Jyk7XG5pbmplY3RJbnRlcnBvbGF0aW9uKGNyZWF0ZUludGVycG9sYXRpb24pO1xuaW5qZWN0Q29sb3JOYW1lcyhjb2xvcnMpO1xuaW5qZWN0QnVnZml4ZXMoZml4QXV0byk7XG5pbmplY3RBcHBseUFuaW1hdGVkVmFsdWVzKGZ1bmN0aW9uIChpbnN0YW5jZSwgcHJvcHMpIHtcbiAgaWYgKGluc3RhbmNlLm5vZGVUeXBlICYmIGluc3RhbmNlLnNldEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHNjcm9sbFRvcCA9IHByb3BzLnNjcm9sbFRvcCxcbiAgICAgICAgc2Nyb2xsTGVmdCA9IHByb3BzLnNjcm9sbExlZnQsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wic3R5bGVcIiwgXCJjaGlsZHJlblwiLCBcInNjcm9sbFRvcFwiLCBcInNjcm9sbExlZnRcIl0pO1xuXG4gICAgaWYgKHNjcm9sbFRvcCAhPT0gdm9pZCAwKSBpbnN0YW5jZS5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgaWYgKHNjcm9sbExlZnQgIT09IHZvaWQgMCkgaW5zdGFuY2Uuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7IC8vIFNldCB0ZXh0Q29udGVudCwgaWYgY2hpbGRyZW4gaXMgYW4gYW5pbWF0YWJsZSB2YWx1ZVxuXG4gICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIGluc3RhbmNlLnRleHRDb250ZW50ID0gY2hpbGRyZW47IC8vIFNldCBzdHlsZXMgLi4uXG5cbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICAgIGlmICghc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkgY29udGludWU7XG4gICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIGluc3RhbmNlLnN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7ZWxzZSBpbnN0YW5jZS5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9IC8vIFNldCBhdHRyaWJ1dGVzIC4uLlxuXG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIEF0dHJpYnV0ZXMgYXJlIHdyaXR0ZW4gaW4gZGFzaCBjYXNlXG4gICAgICB2YXIgZGFzaENhc2UgPSBhdHRyaWJ1dGVDYWNoZVtuYW1lXSB8fCAoYXR0cmlidXRlQ2FjaGVbbmFtZV0gPSBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuICctJyArIG4udG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pKTtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0QXR0cmlidXRlKGRhc2hDYXNlKSAhPT0gJ3VuZGVmaW5lZCcpIGluc3RhbmNlLnNldEF0dHJpYnV0ZShkYXNoQ2FzZSwgYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufSwgZnVuY3Rpb24gKHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZTtcbn0pO1xuXG52YXIgYWN0aXZlID0gZmFsc2U7XG52YXIgY29udHJvbGxlcnMgPSBuZXcgU2V0KCk7XG5cbnZhciBmcmFtZUxvb3AgPSBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gIHZhciB0aW1lID0gbm93KCk7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gY29udHJvbGxlcnMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY29udHJvbGxlciA9IF9yZWY7XG4gICAgdmFyIGlzRG9uZSA9IHRydWU7XG4gICAgdmFyIG5vQ2hhbmdlID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGNvbmZpZ0lkeCA9IDA7IGNvbmZpZ0lkeCA8IGNvbnRyb2xsZXIuY29uZmlncy5sZW5ndGg7IGNvbmZpZ0lkeCsrKSB7XG4gICAgICB2YXIgY29uZmlnID0gY29udHJvbGxlci5jb25maWdzW2NvbmZpZ0lkeF07XG4gICAgICB2YXIgZW5kT2ZBbmltYXRpb24gPSB2b2lkIDAsXG4gICAgICAgICAgbGFzdFRpbWUgPSB2b2lkIDA7XG5cbiAgICAgIGZvciAodmFyIHZhbElkeCA9IDA7IHZhbElkeCA8IGNvbmZpZy5hbmltYXRlZFZhbHVlcy5sZW5ndGg7IHZhbElkeCsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSBjb25maWcuYW5pbWF0ZWRWYWx1ZXNbdmFsSWR4XTsgLy8gSWYgYW4gYW5pbWF0aW9uIGlzIGRvbmUsIHNraXAsIHVudGlsIGFsbCBvZiB0aGVtIGNvbmNsdWRlXG5cbiAgICAgICAgaWYgKGFuaW1hdGlvbi5kb25lKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGZyb20gPSBjb25maWcuZnJvbVZhbHVlc1t2YWxJZHhdO1xuICAgICAgICB2YXIgdG8gPSBjb25maWcudG9WYWx1ZXNbdmFsSWR4XTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYW5pbWF0aW9uLmxhc3RQb3NpdGlvbjtcbiAgICAgICAgdmFyIGlzQW5pbWF0ZWQgPSB0byBpbnN0YW5jZW9mIEFuaW1hdGVkO1xuXG4gICAgICAgIHZhciBfdmVsb2NpdHkgPSBBcnJheS5pc0FycmF5KGNvbmZpZy5pbml0aWFsVmVsb2NpdHkpID8gY29uZmlnLmluaXRpYWxWZWxvY2l0eVt2YWxJZHhdIDogY29uZmlnLmluaXRpYWxWZWxvY2l0eTtcblxuICAgICAgICBpZiAoaXNBbmltYXRlZCkgdG8gPSB0by5nZXRWYWx1ZSgpOyAvLyBDb25jbHVkZSBhbmltYXRpb24gaWYgaXQncyBlaXRoZXIgaW1tZWRpYXRlLCBvciBmcm9tLXZhbHVlcyBtYXRjaCBlbmQtc3RhdGVcblxuICAgICAgICBpZiAoY29uZmlnLmltbWVkaWF0ZSB8fCAhaXNBbmltYXRlZCAmJiAhY29uZmlnLmRlY2F5ICYmIGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZVZhbHVlKHRvKTtcbiAgICAgICAgICBhbmltYXRpb24uZG9uZSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gRG9pbmcgZGVsYXkgaGVyZSBpbnN0ZWFkIG9mIHNldFRpbWVvdXQgaXMgb25lIGFzeW5jIHdvcnJ5IGxlc3NcblxuXG4gICAgICAgIGlmIChjb25maWcuZGVsYXkgJiYgdGltZSAtIGNvbnRyb2xsZXIuc3RhcnRUaW1lIDwgY29uZmlnLmRlbGF5KSB7XG4gICAgICAgICAgaXNEb25lID0gZmFsc2U7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gRmxhZyBjaGFuZ2VcblxuXG4gICAgICAgIG5vQ2hhbmdlID0gZmFsc2U7IC8vIEJyZWFrIGFuaW1hdGlvbiB3aGVuIHN0cmluZyB2YWx1ZXMgYXJlIGludm9sdmVkXG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZVZhbHVlKHRvKTtcbiAgICAgICAgICBhbmltYXRpb24uZG9uZSA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmR1cmF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAvKiogRHVyYXRpb24gZWFzaW5nICovXG4gICAgICAgICAgcG9zaXRpb24gPSBmcm9tICsgY29uZmlnLmVhc2luZygodGltZSAtIGNvbnRyb2xsZXIuc3RhcnRUaW1lIC0gY29uZmlnLmRlbGF5KSAvIGNvbmZpZy5kdXJhdGlvbikgKiAodG8gLSBmcm9tKTtcbiAgICAgICAgICBlbmRPZkFuaW1hdGlvbiA9IHRpbWUgPj0gY29udHJvbGxlci5zdGFydFRpbWUgKyBjb25maWcuZGVsYXkgKyBjb25maWcuZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmRlY2F5KSB7XG4gICAgICAgICAgLyoqIERlY2F5IGVhc2luZyAqL1xuICAgICAgICAgIHBvc2l0aW9uID0gZnJvbSArIF92ZWxvY2l0eSAvICgxIC0gMC45OTgpICogKDEgLSBNYXRoLmV4cCgtKDEgLSAwLjk5OCkgKiAodGltZSAtIGNvbnRyb2xsZXIuc3RhcnRUaW1lKSkpO1xuICAgICAgICAgIGVuZE9mQW5pbWF0aW9uID0gTWF0aC5hYnMoYW5pbWF0aW9uLmxhc3RQb3NpdGlvbiAtIHBvc2l0aW9uKSA8IDAuMTtcbiAgICAgICAgICBpZiAoZW5kT2ZBbmltYXRpb24pIHRvID0gcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyoqIFNwcmluZyBlYXNpbmcgKi9cbiAgICAgICAgICBsYXN0VGltZSA9IGFuaW1hdGlvbi5sYXN0VGltZSAhPT0gdm9pZCAwID8gYW5pbWF0aW9uLmxhc3RUaW1lIDogdGltZTtcbiAgICAgICAgICBfdmVsb2NpdHkgPSBhbmltYXRpb24ubGFzdFZlbG9jaXR5ICE9PSB2b2lkIDAgPyBhbmltYXRpb24ubGFzdFZlbG9jaXR5IDogY29uZmlnLmluaXRpYWxWZWxvY2l0eTsgLy8gSWYgd2UgbG9zdCBhIGxvdCBvZiBmcmFtZXMganVzdCBqdW1wIHRvIHRoZSBlbmQuXG5cbiAgICAgICAgICBpZiAodGltZSA+IGxhc3RUaW1lICsgNjQpIGxhc3RUaW1lID0gdGltZTsgLy8gaHR0cDovL2dhZmZlcm9uZ2FtZXMuY29tL2dhbWUtcGh5c2ljcy9maXgteW91ci10aW1lc3RlcC9cblxuICAgICAgICAgIHZhciBudW1TdGVwcyA9IE1hdGguZmxvb3IodGltZSAtIGxhc3RUaW1lKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU3RlcHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGZvcmNlID0gLWNvbmZpZy50ZW5zaW9uICogKHBvc2l0aW9uIC0gdG8pO1xuICAgICAgICAgICAgdmFyIGRhbXBpbmcgPSAtY29uZmlnLmZyaWN0aW9uICogX3ZlbG9jaXR5O1xuICAgICAgICAgICAgdmFyIGFjY2VsZXJhdGlvbiA9IChmb3JjZSArIGRhbXBpbmcpIC8gY29uZmlnLm1hc3M7XG4gICAgICAgICAgICBfdmVsb2NpdHkgPSBfdmVsb2NpdHkgKyBhY2NlbGVyYXRpb24gKiAxIC8gMTAwMDtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKyBfdmVsb2NpdHkgKiAxIC8gMTAwMDtcbiAgICAgICAgICB9IC8vIENvbmRpdGlvbnMgZm9yIHN0b3BwaW5nIHRoZSBzcHJpbmcgYW5pbWF0aW9uXG5cblxuICAgICAgICAgIHZhciBpc092ZXJzaG9vdGluZyA9IGNvbmZpZy5jbGFtcCAmJiBjb25maWcudGVuc2lvbiAhPT0gMCA/IGZyb20gPCB0byA/IHBvc2l0aW9uID4gdG8gOiBwb3NpdGlvbiA8IHRvIDogZmFsc2U7XG4gICAgICAgICAgdmFyIGlzVmVsb2NpdHkgPSBNYXRoLmFicyhfdmVsb2NpdHkpIDw9IGNvbmZpZy5wcmVjaXNpb247XG4gICAgICAgICAgdmFyIGlzRGlzcGxhY2VtZW50ID0gY29uZmlnLnRlbnNpb24gIT09IDAgPyBNYXRoLmFicyh0byAtIHBvc2l0aW9uKSA8PSBjb25maWcucHJlY2lzaW9uIDogdHJ1ZTtcbiAgICAgICAgICBlbmRPZkFuaW1hdGlvbiA9IGlzT3ZlcnNob290aW5nIHx8IGlzVmVsb2NpdHkgJiYgaXNEaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgYW5pbWF0aW9uLmxhc3RWZWxvY2l0eSA9IF92ZWxvY2l0eTtcbiAgICAgICAgICBhbmltYXRpb24ubGFzdFRpbWUgPSB0aW1lO1xuICAgICAgICB9IC8vIFRyYWlscyBhcmVuJ3QgZG9uZSB1bnRpbCB0aGVpciBwYXJlbnRzIGNvbmNsdWRlXG5cblxuICAgICAgICBpZiAoaXNBbmltYXRlZCAmJiAhY29uZmlnLnRvVmFsdWVzW3ZhbElkeF0uZG9uZSkgZW5kT2ZBbmltYXRpb24gPSBmYWxzZTtcblxuICAgICAgICBpZiAoZW5kT2ZBbmltYXRpb24pIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBlbmQgdXAgd2l0aCBhIHJvdW5kIHZhbHVlXG4gICAgICAgICAgaWYgKGFuaW1hdGlvbi52YWx1ZSAhPT0gdG8pIHBvc2l0aW9uID0gdG87XG4gICAgICAgICAgYW5pbWF0aW9uLmRvbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaXNEb25lID0gZmFsc2U7XG5cbiAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZVZhbHVlKHBvc2l0aW9uKTtcbiAgICAgICAgYW5pbWF0aW9uLmxhc3RQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgfSAvLyBLZWVwIHRyYWNrIG9mIHVwZGF0ZWQgdmFsdWVzIG9ubHkgd2hlbiBuZWNlc3NhcnlcblxuXG4gICAgICBpZiAoY29udHJvbGxlci5wcm9wcy5vbkZyYW1lIHx8ICFjb250cm9sbGVyLnByb3BzLm5hdGl2ZSkgY29udHJvbGxlci5hbmltYXRlZFByb3BzW2NvbmZpZy5uYW1lXSA9IGNvbmZpZy5pbnRlcnBvbGF0aW9uLmdldFZhbHVlKCk7XG4gICAgfSAvLyBVcGRhdGUgY2FsbGJhY2tzIGluIHRoZSBlbmQgb2YgdGhlIGZyYW1lXG5cblxuICAgIGlmIChjb250cm9sbGVyLnByb3BzLm9uRnJhbWUgfHwgIWNvbnRyb2xsZXIucHJvcHMubmF0aXZlKSB7XG4gICAgICBpZiAoIWNvbnRyb2xsZXIucHJvcHMubmF0aXZlICYmIGNvbnRyb2xsZXIub25VcGRhdGUpIGNvbnRyb2xsZXIub25VcGRhdGUoKTtcbiAgICAgIGlmIChjb250cm9sbGVyLnByb3BzLm9uRnJhbWUpIGNvbnRyb2xsZXIucHJvcHMub25GcmFtZShjb250cm9sbGVyLmFuaW1hdGVkUHJvcHMpO1xuICAgIH0gLy8gRWl0aGVyIGNhbGwgb25FbmQgb3IgbmV4dCBmcmFtZVxuXG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICBjb250cm9sbGVycy5kZWxldGUoY29udHJvbGxlcik7XG4gICAgICBjb250cm9sbGVyLmRlYm91bmNlZE9uRW5kKHtcbiAgICAgICAgZmluaXNoZWQ6IHRydWUsXG4gICAgICAgIG5vQ2hhbmdlOiBub0NoYW5nZVxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIExvb3Agb3ZlciBhcyBsb25nIGFzIHRoZXJlIGFyZSBjb250cm9sbGVycyAuLi5cblxuXG4gIGlmIChjb250cm9sbGVycy5zaXplKSByZXF1ZXN0RnJhbWUoZnJhbWVMb29wKTtlbHNlIGFjdGl2ZSA9IGZhbHNlO1xufTtcblxudmFyIGFkZENvbnRyb2xsZXIgPSBmdW5jdGlvbiBhZGRDb250cm9sbGVyKGNvbnRyb2xsZXIpIHtcbiAgaWYgKCFjb250cm9sbGVycy5oYXMoY29udHJvbGxlcikpIHtcbiAgICBjb250cm9sbGVycy5hZGQoY29udHJvbGxlcik7XG4gICAgaWYgKCFhY3RpdmUpIHJlcXVlc3RGcmFtZShmcmFtZUxvb3ApO1xuICAgIGFjdGl2ZSA9IHRydWU7XG4gIH1cbn07XG5cbnZhciByZW1vdmVDb250cm9sbGVyID0gZnVuY3Rpb24gcmVtb3ZlQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gIGlmIChjb250cm9sbGVycy5oYXMoY29udHJvbGxlcikpIHtcbiAgICBjb250cm9sbGVycy5kZWxldGUoY29udHJvbGxlcik7XG4gIH1cbn07XG5cbnZhciBDb250cm9sbGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29udHJvbGxlcihwcm9wcywgY29uZmlnKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgY29uZmlnID0ge1xuICAgICAgICBuYXRpdmU6IHRydWUsXG4gICAgICAgIGludGVycG9sYXRlVG86IHRydWUsXG4gICAgICAgIGF1dG9TdGFydDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmdldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5uYXRpdmUgPyBfdGhpcy5pbnRlcnBvbGF0aW9ucyA6IF90aGlzLmFuaW1hdGVkUHJvcHM7XG4gICAgfTtcblxuICAgIHRoaXMuZGVwZW5kZW50cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5oYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgIHRoaXMubWVyZ2VkID0ge307XG4gICAgdGhpcy5hbmltYXRpb25zID0ge307XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9ucyA9IHt9O1xuICAgIHRoaXMuYW5pbWF0ZWRQcm9wcyA9IHt9O1xuICAgIHRoaXMuY29uZmlncyA9IFtdO1xuICAgIHRoaXMuZnJhbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYXN0VGltZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVwZGF0ZShfZXh0ZW5kcyh7fSwgcHJvcHMsIGNvbmZpZykpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMucHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgcHJvcHMpO1xuXG4gICAgdmFyIF9yZWYgPSB0aGlzLnByb3BzLmludGVycG9sYXRlVG8gPyBpbnRlcnBvbGF0ZVRvKHRoaXMucHJvcHMpIDogdGhpcy5wcm9wcyxcbiAgICAgICAgX3JlZiRmcm9tID0gX3JlZi5mcm9tLFxuICAgICAgICBmcm9tID0gX3JlZiRmcm9tID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkZnJvbSxcbiAgICAgICAgX3JlZiR0byA9IF9yZWYudG8sXG4gICAgICAgIHRvID0gX3JlZiR0byA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHRvLFxuICAgICAgICBfcmVmJGNvbmZpZyA9IF9yZWYuY29uZmlnLFxuICAgICAgICBjb25maWcgPSBfcmVmJGNvbmZpZyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJGNvbmZpZyxcbiAgICAgICAgX3JlZiRkZWxheSA9IF9yZWYuZGVsYXksXG4gICAgICAgIGRlbGF5ID0gX3JlZiRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkZGVsYXksXG4gICAgICAgIHJldmVyc2UgPSBfcmVmLnJldmVyc2UsXG4gICAgICAgIGF0dGFjaCA9IF9yZWYuYXR0YWNoLFxuICAgICAgICByZXNldCA9IF9yZWYucmVzZXQsXG4gICAgICAgIGltbWVkaWF0ZSA9IF9yZWYuaW1tZWRpYXRlLFxuICAgICAgICBhdXRvU3RhcnQgPSBfcmVmLmF1dG9TdGFydCxcbiAgICAgICAgcmVmID0gX3JlZi5yZWY7IC8vIFJldmVyc2UgdmFsdWVzIHdoZW4gcmVxdWVzdGVkXG5cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICB2YXIgX3JlZjIgPSBbdG8sIGZyb21dO1xuICAgICAgZnJvbSA9IF9yZWYyWzBdO1xuICAgICAgdG8gPSBfcmVmMlsxXTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0NoYW5nZWQgPSBmYWxzZTsgLy8gQXR0YWNobWVudCBoYW5kbGluZywgdHJhaWxlZCBzcHJpbmdzIGNhbiBcImF0dGFjaFwiIHRoZW1zZWx2ZXMgdG8gYSBwcmV2aW91cyBzcHJpbmdcblxuICAgIHZhciB0YXJnZXQgPSBhdHRhY2ggJiYgYXR0YWNoKHRoaXMpOyAvLyBSZXNldCBtZXJnZWQgcHJvcHMgd2hlbiBuZWNlc3NhcnlcblxuICAgIHZhciBleHRyYSA9IHJlc2V0ID8ge30gOiB0aGlzLm1lcmdlZDsgLy8gVGhpcyB3aWxsIGNvbGxlY3QgYWxsIHByb3BzIHRoYXQgd2VyZSBldmVyIHNldFxuXG4gICAgdGhpcy5tZXJnZWQgPSBfZXh0ZW5kcyh7fSwgZnJvbSwgZXh0cmEsIHRvKTsgLy8gUmVkdWNlcyBpbnB1dCB7IG5hbWU6IHZhbHVlIH0gcGFpcnMgaW50byBhbmltYXRlZCB2YWx1ZXNcblxuICAgIHRoaXMuYW5pbWF0aW9ucyA9IE9iamVjdC5lbnRyaWVzKHRoaXMubWVyZ2VkKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZjMsIGkpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZjNbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmM1sxXTtcbiAgICAgIC8vIElzc3VlIGNhY2hlZCBlbnRyaWVzLCBleGNlcHQgb24gcmVzZXRcbiAgICAgIHZhciBlbnRyeSA9ICFyZXNldCAmJiBhY2NbbmFtZV0gfHwge307IC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgdmFsdWUgaXMgc3VwcG9zZWQgdG8gYmVcblxuICAgICAgdmFyIGlzTnVtYmVyID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIXZhbHVlLnN0YXJ0c1dpdGgoJyMnKSAmJiAhL1xcZC8udGVzdCh2YWx1ZSkgJiYgIWNvbG9yTmFtZXNbdmFsdWVdO1xuICAgICAgdmFyIGlzQXJyYXkgPSAhaXNOdW1iZXIgJiYgIWlzU3RyaW5nICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgdmFyIGZyb21WYWx1ZSA9IGZyb21bbmFtZV0gIT09IHVuZGVmaW5lZCA/IGZyb21bbmFtZV0gOiB2YWx1ZTtcbiAgICAgIHZhciB0b1ZhbHVlID0gaXNOdW1iZXIgfHwgaXNBcnJheSA/IHZhbHVlIDogaXNTdHJpbmcgPyB2YWx1ZSA6IDE7XG4gICAgICB2YXIgdG9Db25maWcgPSBjYWxsUHJvcChjb25maWcsIG5hbWUpO1xuICAgICAgaWYgKHRhcmdldCkgdG9WYWx1ZSA9IHRhcmdldC5hbmltYXRpb25zW25hbWVdLnBhcmVudDsgLy8gRGV0ZWN0IGNoYW5nZXMsIGFuaW1hdGVkIHZhbHVlcyB3aWxsIGJlIGNoZWNrZWQgaW4gdGhlIHJhZi1sb29wXG5cbiAgICAgIGlmICh0b0NvbmZpZy5kZWNheSAhPT0gdm9pZCAwIHx8ICFzaGFsbG93RXF1YWwoZW50cnkuY2hhbmdlcywgdmFsdWUpKSB7XG4gICAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgICAgX3RoaXMyLmhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB2YXIgcGFyZW50LCBpbnRlcnBvbGF0aW9uJCQxO1xuICAgICAgICBpZiAoaXNOdW1iZXIgfHwgaXNTdHJpbmcpIHBhcmVudCA9IGludGVycG9sYXRpb24kJDEgPSBlbnRyeS5wYXJlbnQgfHwgbmV3IEFuaW1hdGVkVmFsdWUoZnJvbVZhbHVlKTtlbHNlIGlmIChpc0FycmF5KSBwYXJlbnQgPSBpbnRlcnBvbGF0aW9uJCQxID0gZW50cnkucGFyZW50IHx8IG5ldyBBbmltYXRlZEFycmF5KGZyb21WYWx1ZSk7ZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5pbnRlcnBvbGF0aW9uICYmIGVudHJ5LmludGVycG9sYXRpb24uY2FsYyhlbnRyeS5wYXJlbnQudmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gZW50cnkucGFyZW50O1xuICAgICAgICAgICAgcGFyZW50LnNldFZhbHVlKDAsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2UgcGFyZW50ID0gbmV3IEFuaW1hdGVkVmFsdWUoMCk7XG5cbiAgICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICBvdXRwdXQ6IFtwcmV2ICE9PSB2b2lkIDAgPyBwcmV2IDogZnJvbVZhbHVlLCB2YWx1ZV1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGVudHJ5LmludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb24kJDEgPSBlbnRyeS5pbnRlcnBvbGF0aW9uO1xuICAgICAgICAgICAgZW50cnkuaW50ZXJwb2xhdGlvbi51cGRhdGVDb25maWcocmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpbnRlcnBvbGF0aW9uJCQxID0gcGFyZW50LmludGVycG9sYXRlKHJhbmdlKTtcbiAgICAgICAgfSAvLyBTZXQgaW1tZWRpYXRlIHZhbHVlc1xuXG4gICAgICAgIGlmIChjYWxsUHJvcChpbW1lZGlhdGUsIG5hbWUpKSBwYXJlbnQuc2V0VmFsdWUodmFsdWUsIGZhbHNlKTsgLy8gUmVzZXQgYW5pbWF0ZWQgdmFsdWVzXG5cbiAgICAgICAgdmFyIGFuaW1hdGVkVmFsdWVzID0gdG9BcnJheShwYXJlbnQuZ2V0UGF5bG9hZCgpKTtcbiAgICAgICAgYW5pbWF0ZWRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUucHJlcGFyZShfdGhpczIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhY2MsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW25hbWVdID0gX2V4dGVuZHMoe30sIGVudHJ5LCB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBpbnRlcnBvbGF0aW9uJCQxLFxuICAgICAgICAgIGFuaW1hdGVkVmFsdWVzOiBhbmltYXRlZFZhbHVlcyxcbiAgICAgICAgICBjaGFuZ2VzOiB2YWx1ZSxcbiAgICAgICAgICBmcm9tVmFsdWVzOiB0b0FycmF5KHBhcmVudC5nZXRWYWx1ZSgpKSxcbiAgICAgICAgICB0b1ZhbHVlczogdG9BcnJheSh0YXJnZXQgPyB0b1ZhbHVlLmdldFBheWxvYWQoKSA6IHRvVmFsdWUpLFxuICAgICAgICAgIGltbWVkaWF0ZTogY2FsbFByb3AoaW1tZWRpYXRlLCBuYW1lKSxcbiAgICAgICAgICBkZWxheTogd2l0aERlZmF1bHQodG9Db25maWcuZGVsYXksIGRlbGF5IHx8IDApLFxuICAgICAgICAgIGluaXRpYWxWZWxvY2l0eTogd2l0aERlZmF1bHQodG9Db25maWcudmVsb2NpdHksIDApLFxuICAgICAgICAgIGNsYW1wOiB3aXRoRGVmYXVsdCh0b0NvbmZpZy5jbGFtcCwgZmFsc2UpLFxuICAgICAgICAgIHByZWNpc2lvbjogd2l0aERlZmF1bHQodG9Db25maWcucHJlY2lzaW9uLCAwLjAxKSxcbiAgICAgICAgICB0ZW5zaW9uOiB3aXRoRGVmYXVsdCh0b0NvbmZpZy50ZW5zaW9uLCAxNzApLFxuICAgICAgICAgIGZyaWN0aW9uOiB3aXRoRGVmYXVsdCh0b0NvbmZpZy5mcmljdGlvbiwgMjYpLFxuICAgICAgICAgIG1hc3M6IHdpdGhEZWZhdWx0KHRvQ29uZmlnLm1hc3MsIDEpLFxuICAgICAgICAgIGR1cmF0aW9uOiB0b0NvbmZpZy5kdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IHdpdGhEZWZhdWx0KHRvQ29uZmlnLmVhc2luZywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRlY2F5OiB0b0NvbmZpZy5kZWNheVxuICAgICAgICB9KSwgX2V4dGVuZHMyKSk7XG4gICAgICB9IGVsc2UgcmV0dXJuIGFjYztcbiAgICB9LCB0aGlzLmFuaW1hdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMuaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5jb25maWdzID0gZ2V0VmFsdWVzJDEodGhpcy5hbmltYXRpb25zKTtcbiAgICAgIHRoaXMuYW5pbWF0ZWRQcm9wcyA9IHt9O1xuICAgICAgdGhpcy5pbnRlcnBvbGF0aW9ucyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hbmltYXRpb25zKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbnNba2V5XSA9IHRoaXMuYW5pbWF0aW9uc1trZXldLmludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMuYW5pbWF0ZWRQcm9wc1trZXldID0gdGhpcy5hbmltYXRpb25zW2tleV0uaW50ZXJwb2xhdGlvbi5nZXRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gVE9ETzogY2xlYW4gdXAgcmVmIGluIGNvbnRyb2xsZXJcblxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YXJ0ID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHN0YXJ0W19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZiAmJiAoYXV0b1N0YXJ0IHx8IHN0YXJ0Lmxlbmd0aCkpIHRoaXMuc3RhcnQuYXBwbHkodGhpcywgc3RhcnQpO1xuICAgIHZhciBvbkVuZCA9IHN0YXJ0WzBdLFxuICAgICAgICBvblVwZGF0ZSA9IHN0YXJ0WzFdO1xuICAgIHRoaXMub25FbmQgPSB0eXBlb2Ygb25FbmQgPT09ICdmdW5jdGlvbicgJiYgb25FbmQ7XG4gICAgdGhpcy5vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KG9uRW5kLCBvblVwZGF0ZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdGhpcy5zdGFydFRpbWUgPSBub3coKTtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSkgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5vbkVuZCA9IHR5cGVvZiBvbkVuZCA9PT0gJ2Z1bmN0aW9uJyAmJiBvbkVuZDtcbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGU7XG4gICAgaWYgKHRoaXMucHJvcHMub25TdGFydCkgdGhpcy5wcm9wcy5vblN0YXJ0KCk7XG4gICAgYWRkQ29udHJvbGxlcih0aGlzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgcmV0dXJuIF90aGlzMy5yZXNvbHZlID0gcmVzO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5zdG9wID0gZnVuY3Rpb24gc3RvcChmaW5pc2hlZCkge1xuICAgIGlmIChmaW5pc2hlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGNvbGxlY3RlZCBjaGFuZ2VzIHNpbmNlIHRoZSBhbmltYXRpb24gaGFzIGJlZW4gc3RvcHBlZCBjb2xkIHR1cmtleVxuICAgIGlmIChmaW5pc2hlZCkgZ2V0VmFsdWVzJDEodGhpcy5hbmltYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gYS5jaGFuZ2VzID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHRoaXMuZGVib3VuY2VkT25FbmQoe1xuICAgICAgZmluaXNoZWQ6IGZpbmlzaGVkXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHJlbW92ZUNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgIHRoaXMubWVyZ2VkID0ge307XG4gICAgdGhpcy5hbmltYXRpb25zID0ge307XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9ucyA9IHt9O1xuICAgIHRoaXMuYW5pbWF0ZWRQcm9wcyA9IHt9O1xuICAgIHRoaXMuY29uZmlncyA9IFtdO1xuICB9O1xuXG4gIF9wcm90by5kZWJvdW5jZWRPbkVuZCA9IGZ1bmN0aW9uIGRlYm91bmNlZE9uRW5kKHJlc3VsdCkge1xuICAgIHJlbW92ZUNvbnRyb2xsZXIodGhpcyk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHZhciBvbkVuZCA9IHRoaXMub25FbmQ7XG4gICAgdGhpcy5vbkVuZCA9IG51bGw7XG4gICAgaWYgKG9uRW5kKSBvbkVuZChyZXN1bHQpO1xuICAgIGlmICh0aGlzLnJlc29sdmUpIHRoaXMucmVzb2x2ZSgpO1xuICAgIHRoaXMucmVzb2x2ZSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRyb2xsZXI7XG59KCk7XG5cbnZhciBBbmltYXRlZFByb3BzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQW5pbWF0ZWRPYmplY3RXaXRoQ2gpIHtcbiAgX2luaGVyaXRzTG9vc2UoQW5pbWF0ZWRQcm9wcywgX0FuaW1hdGVkT2JqZWN0V2l0aENoKTtcblxuICBmdW5jdGlvbiBBbmltYXRlZFByb3BzKHByb3BzLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0FuaW1hdGVkT2JqZWN0V2l0aENoLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBpZiAocHJvcHMuc3R5bGUpIHByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzdHlsZTogY3JlYXRlQW5pbWF0ZWRTdHlsZShwcm9wcy5zdHlsZSlcbiAgICB9KTtcbiAgICBfdGhpcy5wYXlsb2FkID0gcHJvcHM7XG4gICAgX3RoaXMudXBkYXRlID0gY2FsbGJhY2s7XG5cbiAgICBfdGhpcy5hdHRhY2goKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBBbmltYXRlZFByb3BzO1xufShBbmltYXRlZE9iamVjdFdpdGhDaGlsZHJlbik7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGVkQ29tcG9uZW50KENvbXBvbmVudCkge1xuICB2YXIgQW5pbWF0ZWRDb21wb25lbnQgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQW5pbWF0ZWRDb21wb25lbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQW5pbWF0ZWRDb21wb25lbnQocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgICAgX3RoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5ub2RlKSB7XG4gICAgICAgICAgdmFyIGRpZFVwZGF0ZSA9IGFwcGx5QW5pbWF0ZWRWYWx1ZXMuZm4oX3RoaXMubm9kZSwgX3RoaXMucHJvcHNBbmltYXRlZC5nZXRBbmltYXRlZFZhbHVlKCksIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgICAgICBpZiAoZGlkVXBkYXRlID09PSBmYWxzZSkgX3RoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuYXR0YWNoUHJvcHMocHJvcHMpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEFuaW1hdGVkQ29tcG9uZW50LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5wcm9wc0FuaW1hdGVkICYmIHRoaXMucHJvcHNBbmltYXRlZC5kZXRhY2goKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnNldE5hdGl2ZVByb3BzID0gZnVuY3Rpb24gc2V0TmF0aXZlUHJvcHMocHJvcHMpIHtcbiAgICAgIHZhciBkaWRVcGRhdGUgPSBhcHBseUFuaW1hdGVkVmFsdWVzLmZuKHRoaXMubm9kZSwgcHJvcHMsIHRoaXMpO1xuICAgICAgaWYgKGRpZFVwZGF0ZSA9PT0gZmFsc2UpIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9IC8vIFRoZSBzeXN0ZW0gaXMgYmVzdCBkZXNpZ25lZCB3aGVuIHNldE5hdGl2ZVByb3BzIGlzIGltcGxlbWVudGVkLiBJdCBpc1xuICAgIC8vIGFibGUgdG8gYXZvaWQgcmUtcmVuZGVyaW5nIGFuZCBkaXJlY3RseSBzZXQgdGhlIGF0dHJpYnV0ZXMgdGhhdFxuICAgIC8vIGNoYW5nZWQuIEhvd2V2ZXIsIHNldE5hdGl2ZVByb3BzIGNhbiBvbmx5IGJlIGltcGxlbWVudGVkIG9uIGxlYWZcbiAgICAvLyBuYXRpdmUgY29tcG9uZW50cy4gSWYgeW91IHdhbnQgdG8gYW5pbWF0ZSBhIGNvbXBvc2l0ZSBjb21wb25lbnQsIHlvdVxuICAgIC8vIG5lZWQgdG8gcmUtcmVuZGVyIGl0LiBJbiB0aGlzIGNhc2UsIHdlIGhhdmUgYSBmYWxsYmFjayB0aGF0IHVzZXNcbiAgICAvLyBmb3JjZVVwZGF0ZS5cbiAgICA7XG5cbiAgICBfcHJvdG8uYXR0YWNoUHJvcHMgPSBmdW5jdGlvbiBhdHRhY2hQcm9wcyhfcmVmKSB7XG4gICAgICB2YXIgZm9yd2FyZFJlZiA9IF9yZWYuZm9yd2FyZFJlZixcbiAgICAgICAgICBuZXh0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJmb3J3YXJkUmVmXCJdKTtcblxuICAgICAgdmFyIG9sZFByb3BzQW5pbWF0ZWQgPSB0aGlzLnByb3BzQW5pbWF0ZWQ7XG4gICAgICB0aGlzLnByb3BzQW5pbWF0ZWQgPSBuZXcgQW5pbWF0ZWRQcm9wcyhuZXh0UHJvcHMsIHRoaXMuY2FsbGJhY2spOyAvLyBXaGVuIHlvdSBjYWxsIGRldGFjaCwgaXQgcmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBwYXJlbnQgbGlzdFxuICAgICAgLy8gb2YgY2hpbGRyZW4uIElmIGl0IGdvZXMgdG8gMCwgdGhlbiB0aGUgcGFyZW50IGFsc28gZGV0YWNoZXMgaXRzZWxmXG4gICAgICAvLyBhbmQgc28gb24uXG4gICAgICAvLyBBbiBvcHRpbWl6YXRpb24gaXMgdG8gYXR0YWNoIHRoZSBuZXcgZWxlbWVudHMgYW5kIFRIRU4gZGV0YWNoIHRoZSBvbGRcbiAgICAgIC8vIG9uZXMgaW5zdGVhZCBvZiBkZXRhY2hpbmcgYW5kIFRIRU4gYXR0YWNoaW5nLlxuICAgICAgLy8gVGhpcyB3YXkgdGhlIGludGVybWVkaWF0ZSBzdGF0ZSBpc24ndCB0byBnbyB0byAwIGFuZCB0cmlnZ2VyXG4gICAgICAvLyB0aGlzIGV4cGVuc2l2ZSByZWN1cnNpdmUgZGV0YWNoaW5nIHRvIHRoZW4gcmUtYXR0YWNoIGV2ZXJ5dGhpbmcgb25cbiAgICAgIC8vIHRoZSB2ZXJ5IG5leHQgb3BlcmF0aW9uLlxuXG4gICAgICBvbGRQcm9wc0FuaW1hdGVkICYmIG9sZFByb3BzQW5pbWF0ZWQuZGV0YWNoKCk7XG4gICAgfTtcblxuICAgIF9wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUocHJvcHMpIHtcbiAgICAgIHZhciBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgICAgIG5leHRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJzdHlsZVwiXSk7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY3VycmVudFN0eWxlID0gX3RoaXMkcHJvcHMuc3R5bGUsXG4gICAgICAgICAgY3VycmVudFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcInN0eWxlXCJdKTtcblxuICAgICAgaWYgKCFzaGFsbG93RXF1YWwoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoY3VycmVudFN0eWxlLCBzdHlsZSkpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hQcm9wcyhwcm9wcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIF90aGlzJHByb3BzQW5pbWF0ZWQkZyA9IHRoaXMucHJvcHNBbmltYXRlZC5nZXRWYWx1ZSgpLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF90aGlzJHByb3BzQW5pbWF0ZWQkZy5zY3JvbGxUb3AsXG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IF90aGlzJHByb3BzQW5pbWF0ZWQkZy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIGFuaW1hdGVkUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wc0FuaW1hdGVkJGcsIFtcInNjcm9sbFRvcFwiLCBcInNjcm9sbExlZnRcIl0pO1xuXG4gICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCBhbmltYXRlZFByb3BzLCB7XG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLm5vZGUgPSBoYW5kbGVSZWYobm9kZSwgX3RoaXMyLnByb3BzLmZvcndhcmRSZWYpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBBbmltYXRlZENvbXBvbmVudDtcbiAgfShSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQpO1xuXG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0ZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgZm9yd2FyZFJlZjogcmVmXG4gICAgfSkpO1xuICB9KTtcbn1cblxudmFyIGNvbmZpZyA9IHtcbiAgZGVmYXVsdDoge1xuICAgIHRlbnNpb246IDE3MCxcbiAgICBmcmljdGlvbjogMjZcbiAgfSxcbiAgZ2VudGxlOiB7XG4gICAgdGVuc2lvbjogMTIwLFxuICAgIGZyaWN0aW9uOiAxNFxuICB9LFxuICB3b2JibHk6IHtcbiAgICB0ZW5zaW9uOiAxODAsXG4gICAgZnJpY3Rpb246IDEyXG4gIH0sXG4gIHN0aWZmOiB7XG4gICAgdGVuc2lvbjogMjEwLFxuICAgIGZyaWN0aW9uOiAyMFxuICB9LFxuICBzbG93OiB7XG4gICAgdGVuc2lvbjogMjgwLFxuICAgIGZyaWN0aW9uOiA2MFxuICB9LFxuICBtb2xhc3Nlczoge1xuICAgIHRlbnNpb246IDI4MCxcbiAgICBmcmljdGlvbjogMTIwXG4gIH1cbn07XG5cbnZhciBTcHJpbmcgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3ByaW5nLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTcHJpbmcoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBsYXN0UHJvcHM6IHtcbiAgICAgICAgZnJvbToge30sXG4gICAgICAgIHRvOiB7fVxuICAgICAgfSxcbiAgICAgIHByb3BzQ2hhbmdlZDogZmFsc2UsXG4gICAgICBpbnRlcm5hbDogZmFsc2VcbiAgICB9O1xuICAgIF90aGlzLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcihudWxsLCBudWxsKTtcbiAgICBfdGhpcy5kaWRVcGRhdGUgPSBmYWxzZTtcbiAgICBfdGhpcy5kaWRJbmplY3QgPSBmYWxzZTtcbiAgICBfdGhpcy5maW5pc2hlZCA9IHRydWU7XG5cbiAgICBfdGhpcy5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB2YXIgd2FzTW91bnRlZCA9IF90aGlzLm1vdW50ZWQ7XG5cbiAgICAgIF90aGlzLmNvbnRyb2xsZXIuc3RhcnQoZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5maW5pc2goX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAgd2FzTW91bnRlZDogd2FzTW91bnRlZFxuICAgICAgICB9KSk7XG4gICAgICB9LCBfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmNvbnRyb2xsZXIuc3RvcCh0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLm1vdW50ZWQgJiYgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpbnRlcm5hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgZmluaXNoZWQgPSBfcmVmLmZpbmlzaGVkLFxuICAgICAgICAgIG5vQ2hhbmdlID0gX3JlZi5ub0NoYW5nZSxcbiAgICAgICAgICB3YXNNb3VudGVkID0gX3JlZi53YXNNb3VudGVkO1xuICAgICAgX3RoaXMuZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoX3RoaXMubW91bnRlZCAmJiBmaW5pc2hlZCkge1xuICAgICAgICAvLyBPbmx5IGNhbGwgb25SZXN0IGlmIGVpdGhlciB3ZSAqd2VyZSogbW91bnRlZCwgb3Igd2hlbiB0aGVyZSB3ZXJlIGNoYW5nZXNcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uUmVzdCAmJiAod2FzTW91bnRlZCB8fCAhbm9DaGFuZ2UpKSBfdGhpcy5wcm9wcy5vblJlc3QoX3RoaXMuY29udHJvbGxlci5tZXJnZWQpOyAvLyBSZXN0b3JlIGVuZC1zdGF0ZVxuXG4gICAgICAgIGlmIChfdGhpcy5tb3VudGVkICYmIF90aGlzLmRpZEluamVjdCkge1xuICAgICAgICAgIF90aGlzLmFmdGVySW5qZWN0ID0gY29udmVydFZhbHVlcyhfdGhpcy5wcm9wcyk7XG5cbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpbnRlcm5hbDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIElmIHdlIGhhdmUgYW4gaW5qZWN0IG9yIHZhbHVlcyB0byBhcHBseSBhZnRlciB0aGUgYW5pbWF0aW9uIHdlIHBpbmcgaGVyZVxuXG5cbiAgICAgICAgaWYgKF90aGlzLm1vdW50ZWQgJiYgKF90aGlzLmRpZEluamVjdCB8fCBfdGhpcy5wcm9wcy5hZnRlcikpIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbnRlcm5hbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuZGlkSW5qZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTcHJpbmcucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGNvbXBvbmVudERpZFVwZGF0ZSBpc24ndCBjYWxsZWQgb24gbW91bnQsIHdlIGNhbGwgaXQgaGVyZSB0byBzdGFydCBhbmltYXRpbmdcbiAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSgpO1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgLy8gU3RvcCBhbGwgb25nb2luZyBhbmltdGlvbnNcbiAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3AoKTtcbiAgfTtcblxuICBTcHJpbmcuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBfcmVmMikge1xuICAgIHZhciBpbnRlcm5hbCA9IF9yZWYyLmludGVybmFsLFxuICAgICAgICBsYXN0UHJvcHMgPSBfcmVmMi5sYXN0UHJvcHM7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIHRlc3QgYWdhaW5zdCBwcm9wcyB0aGF0IGNvdWxkIGFsdGVyIHRoZSBhbmltYXRpb25cbiAgICB2YXIgZnJvbSA9IHByb3BzLmZyb20sXG4gICAgICAgIHRvID0gcHJvcHMudG8sXG4gICAgICAgIHJlc2V0ID0gcHJvcHMucmVzZXQsXG4gICAgICAgIGZvcmNlID0gcHJvcHMuZm9yY2U7XG4gICAgdmFyIHByb3BzQ2hhbmdlZCA9ICFzaGFsbG93RXF1YWwodG8sIGxhc3RQcm9wcy50bykgfHwgIXNoYWxsb3dFcXVhbChmcm9tLCBsYXN0UHJvcHMuZnJvbSkgfHwgcmVzZXQgJiYgIWludGVybmFsIHx8IGZvcmNlICYmICFpbnRlcm5hbDtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcHNDaGFuZ2VkOiBwcm9wc0NoYW5nZWQsXG4gICAgICBsYXN0UHJvcHM6IHByb3BzLFxuICAgICAgaW50ZXJuYWw6IGZhbHNlXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgcHJvcHNDaGFuZ2VkID0gdGhpcy5zdGF0ZS5wcm9wc0NoYW5nZWQ7IC8vIEluamVjdCBwaGFzZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEhhbmRsZSBpbmplY3RlZCBmcmFtZXMsIGZvciBpbnN0YW5jZSB0YXJnZXRzL3dlYi9maXgtYXV0b1xuICAgIC8vIEFuIGluamVjdCB3aWxsIHJldHVybiBhbiBpbnRlcm1lZGlhcnkgUmVhY3Qgbm9kZSB3aGljaCBtZWFzdXJlcyBpdHNlbGYgb3V0XG4gICAgLy8gLi4gYW5kIHJldHVybnMgYSBjYWxsYmFjayB3aGVuIHRoZSB2YWx1ZXMgc291Z2h0IGFmdGVyIGFyZSByZWFkeSwgdXN1YWxseSBcImF1dG9cIi5cblxuICAgIGlmICh0aGlzLnByb3BzLmluamVjdCAmJiBwcm9wc0NoYW5nZWQgJiYgIXRoaXMuaW5qZWN0UHJvcHMpIHtcbiAgICAgIHZhciBmcmFtZSA9IHRoaXMucHJvcHMuaW5qZWN0KHRoaXMucHJvcHMsIGZ1bmN0aW9uIChpbmplY3RQcm9wcykge1xuICAgICAgICAvLyBUaGUgaW5qZWN0IGZyYW1lIGhhcyByZW5kZXJlZCwgbm93IGxldCdzIHVwZGF0ZSBhbmltYXRpb25zLi4uXG4gICAgICAgIF90aGlzMi5pbmplY3RQcm9wcyA9IGluamVjdFByb3BzO1xuXG4gICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW50ZXJuYWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gUmVuZGVyIG91dCBpbmplY3RlZCBmcmFtZVxuXG4gICAgICBpZiAoZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICB9IC8vIFVwZGF0ZSBwaGFzZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICBpZiAodGhpcy5pbmplY3RQcm9wcyB8fCBwcm9wc0NoYW5nZWQpIHtcbiAgICAgIC8vIFdlIGNhbiBwb3RlbnRpYWxseSBjYXVzZSBzZXRTdGF0ZSwgYnV0IHdlJ3JlIGluc2lkZSByZW5kZXIsIHRoZSBmbGFnIHByZXZlbnRzIHRoYXRcbiAgICAgIHRoaXMuZGlkSW5qZWN0ID0gZmFsc2U7IC8vIFVwZGF0ZSBhbmltYXRpb25zLCB0aGlzIHR1cm5zIGZyb20vdG8gcHJvcHMgaW50byBBbmltYXRlZFZhbHVlc1xuICAgICAgLy8gQW4gdXBkYXRlIGNhbiBvY2N1ciBvbiBpbmplY3RlZCBwcm9wcywgb3Igd2hlbiBvd24tcHJvcHMgaGF2ZSBjaGFuZ2VkLlxuXG4gICAgICBpZiAodGhpcy5pbmplY3RQcm9wcykge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIudXBkYXRlKHRoaXMuaW5qZWN0UHJvcHMpOyAvLyBkaWRJbmplY3QgaXMgbmVlZGVkLCBiZWNhdXNlIHRoZXJlIHdpbGwgYmUgYSAzcmQgc3RhZ2UsIHdoZXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgLy8gLi4gd2lsbCBiZSByZXN0b3JlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGZpbmlzaGVkLiBXaGVuIHNvbWVvbmUgYW5pbWF0ZXMgdG93YXJkc1xuICAgICAgICAvLyAuLiBcImF1dG9cIiwgdGhlIGVuZC1yZXN1bHQgc2hvdWxkIGJlIFwiYXV0b1wiLCBub3QgXCIxOTk5cHhcIiwgd2hpY2ggd291bGQgYmxvY2sgbmVzdGVkXG4gICAgICAgIC8vIC4uIGhlaWdodC93aWR0aCBjaGFuZ2VzLlxuXG4gICAgICAgIHRoaXMuZGlkSW5qZWN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcHNDaGFuZ2VkKSB0aGlzLmNvbnRyb2xsZXIudXBkYXRlKHRoaXMucHJvcHMpOyAvLyBGbGFnIGFuIHVwZGF0ZSB0aGF0IG9jY3VyZWQsIGNvbXBvbmVudERpZFVwZGF0ZSB3aWxsIHN0YXJ0IHRoZSBhbmltYXRpb24gbGF0ZXIgb25cblxuXG4gICAgICB0aGlzLmRpZFVwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLmFmdGVySW5qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbmplY3RQcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB9IC8vIFJlbmRlciBwaGFzZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJlbmRlciBvdXQgcmF3IHZhbHVlcyBvciBBbmltYXRlZFZhbHVlcyBkZXBlbmRpbmcgb24gXCJuYXRpdmVcIlxuXG5cbiAgICB2YXIgdmFsdWVzID0gX2V4dGVuZHMoe30sIHRoaXMuY29udHJvbGxlci5nZXRWYWx1ZXMoKSwgdGhpcy5hZnRlckluamVjdCk7XG5cbiAgICBpZiAodGhpcy5maW5pc2hlZCkgdmFsdWVzID0gX2V4dGVuZHMoe30sIHZhbHVlcywgdGhpcy5wcm9wcy5hZnRlcik7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID8gY2hpbGRyZW4odmFsdWVzKSA6IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBUaGUgYW5pbWF0aW9uIGhhcyB0byBzdGFydCAqYWZ0ZXIqIHJlbmRlciwgc2luY2UgYXQgdGhhdCBwb2ludCB0aGUgc2NlbmVcbiAgICAvLyAuLiBncmFwaCBzaG91bGQgYmUgZXN0YWJsaXNoZWQsIHNvIHdlIGRvIGl0IGhlcmUuIFVuZm9ydHVuYXRlbGx5LCBub24tbmF0aXZlXG4gICAgLy8gLi4gYW5pbWF0aW9ucyBhcyB3ZWxsIGFzIFwiYXV0b1wiLWluamVjdHMgY2FsbCBmb3JjZVVwZGF0ZSwgc28gaXQncyBjYXVzaW5nIGEgbG9vcC5cbiAgICAvLyAuLiBkaWRVcGRhdGUgcHJldmVudHMgdGhhdCBhcyBpdCBnZXRzIHNldCBvbmx5IG9uIHByb3AgY2hhbmdlcy5cbiAgICBpZiAodGhpcy5kaWRVcGRhdGUpIHRoaXMuc3RhcnQoKTtcbiAgICB0aGlzLmRpZFVwZGF0ZSA9IGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBTcHJpbmc7XG59KFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCk7XG5cblNwcmluZy5kZWZhdWx0UHJvcHMgPSB7XG4gIGZyb206IHt9LFxuICB0bzoge30sXG4gIGNvbmZpZzogY29uZmlnLmRlZmF1bHQsXG4gIG5hdGl2ZTogZmFsc2UsXG4gIGltbWVkaWF0ZTogZmFsc2UsXG4gIHJlc2V0OiBmYWxzZSxcbiAgZm9yY2U6IGZhbHNlLFxuICBpbmplY3Q6IGJ1Z2ZpeGVzXG59O1xuXG52YXIgVHJhaWwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYWlsLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhaWwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JFB1cmVDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkUHVyZUNvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5maXJzdCA9IHRydWU7XG4gICAgX3RoaXMuaW5zdGFuY2VzID0gbmV3IFNldCgpO1xuXG4gICAgX3RoaXMuaG9vayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW5kZXgsIGxlbmd0aCwgcmV2ZXJzZSkge1xuICAgICAgLy8gQWRkIGluc3RhbmNlIHRvIHNldFxuICAgICAgX3RoaXMuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7IC8vIFJldHVybiB1bmRlZmluZWQgb24gdGhlIGZpcnN0IGluZGV4IGFuZCBmcm9tIHRoZW4gb24gdGhlIHByZXZpb3VzIGluc3RhbmNlXG5cblxuICAgICAgaWYgKHJldmVyc2UgPyBpbmRleCA9PT0gbGVuZ3RoIC0gMSA6IGluZGV4ID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO2Vsc2UgcmV0dXJuIEFycmF5LmZyb20oX3RoaXMuaW5zdGFuY2VzKVtyZXZlcnNlID8gaW5kZXggKyAxIDogaW5kZXggLSAxXTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRyYWlsLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaXRlbXMgPSBfdGhpcyRwcm9wcy5pdGVtcyxcbiAgICAgICAgX2NoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIF90aGlzJHByb3BzJGZyb20gPSBfdGhpcyRwcm9wcy5mcm9tLFxuICAgICAgICBmcm9tID0gX3RoaXMkcHJvcHMkZnJvbSA9PT0gdm9pZCAwID8ge30gOiBfdGhpcyRwcm9wcyRmcm9tLFxuICAgICAgICBpbml0aWFsID0gX3RoaXMkcHJvcHMuaW5pdGlhbCxcbiAgICAgICAgcmV2ZXJzZSA9IF90aGlzJHByb3BzLnJldmVyc2UsXG4gICAgICAgIGtleXMgPSBfdGhpcyRwcm9wcy5rZXlzLFxuICAgICAgICBkZWxheSA9IF90aGlzJHByb3BzLmRlbGF5LFxuICAgICAgICBvblJlc3QgPSBfdGhpcyRwcm9wcy5vblJlc3QsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcIml0ZW1zXCIsIFwiY2hpbGRyZW5cIiwgXCJmcm9tXCIsIFwiaW5pdGlhbFwiLCBcInJldmVyc2VcIiwgXCJrZXlzXCIsIFwiZGVsYXlcIiwgXCJvblJlc3RcIl0pO1xuXG4gICAgdmFyIGFycmF5ID0gdG9BcnJheShpdGVtcyk7XG4gICAgcmV0dXJuIHRvQXJyYXkoYXJyYXkpLm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3ByaW5nLCBfZXh0ZW5kcyh7XG4gICAgICAgIG9uUmVzdDogaSA9PT0gMCA/IG9uUmVzdCA6IG51bGwsXG4gICAgICAgIGtleTogdHlwZW9mIGtleXMgPT09ICdmdW5jdGlvbicgPyBrZXlzKGl0ZW0pIDogdG9BcnJheShrZXlzKVtpXSxcbiAgICAgICAgZnJvbTogX3RoaXMyLmZpcnN0ICYmIGluaXRpYWwgIT09IHZvaWQgMCA/IGluaXRpYWwgfHwge30gOiBmcm9tXG4gICAgICB9LCBwcm9wcywge1xuICAgICAgICBkZWxheTogaSA9PT0gMCAmJiBkZWxheSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24gYXR0YWNoKGluc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5ob29rKGluc3RhbmNlLCBpLCBhcnJheS5sZW5ndGgsIHJldmVyc2UpO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4ocHJvcHMpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfY2hpbGRyZW4oaXRlbSwgaSk7XG5cbiAgICAgICAgICByZXR1cm4gY2hpbGQgPyBjaGlsZChwcm9wcykgOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB0aGlzLmZpcnN0ID0gZmFsc2U7XG4gICAgaWYgKHByZXZQcm9wcy5pdGVtcyAhPT0gdGhpcy5wcm9wcy5pdGVtcykgdGhpcy5pbnN0YW5jZXMuY2xlYXIoKTtcbiAgfTtcblxuICByZXR1cm4gVHJhaWw7XG59KFJlYWN0X19kZWZhdWx0LlB1cmVDb21wb25lbnQpO1xuXG5UcmFpbC5kZWZhdWx0UHJvcHMgPSB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXRlbSkge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG59O1xuXG52YXIgREVGQVVMVCA9ICdfX2RlZmF1bHQnO1xuXG52YXIgS2V5ZnJhbWVzSW1wbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoS2V5ZnJhbWVzSW1wbCwgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lc0ltcGwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JFB1cmVDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkUHVyZUNvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5ndWlkID0gMDtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHByb3BzOiB7fSxcbiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIGxhc3Q6IHRydWUsXG4gICAgICBpbmRleDogMFxuICAgIH07XG5cbiAgICBfdGhpcy5uZXh0ID0gZnVuY3Rpb24gKHByb3BzLCBsYXN0LCBpbmRleCkge1xuICAgICAgaWYgKGxhc3QgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfdGhpcy5tb3VudGVkICYmIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgbGFzdDogbGFzdCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVzSW1wbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSh7fSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91cykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgc3RhdGVzID0gX3RoaXMkcHJvcHMuc3RhdGVzLFxuICAgICAgICBmID0gX3RoaXMkcHJvcHMuZmlsdGVyLFxuICAgICAgICBzdGF0ZSA9IF90aGlzJHByb3BzLnN0YXRlO1xuXG4gICAgaWYgKHByZXZpb3VzLnN0YXRlICE9PSB0aGlzLnByb3BzLnN0YXRlIHx8IHRoaXMucHJvcHMucmVzZXQgJiYgIXRoaXMucnVubmluZyB8fCAhc2hhbGxvd0VxdWFsKHN0YXRlc1tzdGF0ZV0sIHByZXZpb3VzLnN0YXRlc1twcmV2aW91cy5zdGF0ZV0pKSB7XG4gICAgICBpZiAoc3RhdGVzICYmIHN0YXRlICYmIHN0YXRlc1tzdGF0ZV0pIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbG9jYWxJZCA9ICsrX3RoaXMyLmd1aWQ7XG4gICAgICAgICAgdmFyIHNsb3RzID0gc3RhdGVzW3N0YXRlXTtcblxuICAgICAgICAgIGlmIChzbG90cykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2xvdHMpKSB7XG4gICAgICAgICAgICAgIHZhciBxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBpbmRleCA9PT0gc2xvdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBxID0gcS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbElkID09PSBfdGhpczIuZ3VpZCAmJiBfdGhpczIubmV4dChmKHNsb3QpLCBsYXN0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzbG90cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgICBzbG90cyggLy8gbmV4dFxuICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvcHMsIGxhc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICBsYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsSWQgPT09IF90aGlzMi5ndWlkICYmIF90aGlzMi5uZXh0KGYocHJvcHMpLCBsYXN0LCBpbmRleCsrKTtcbiAgICAgICAgICAgICAgfSwgLy8gY2FuY2VsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuaW5zdGFuY2UgJiYgX3RoaXMyLmluc3RhbmNlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgLy8gb3ducHJvcHNcbiAgICAgICAgICAgICAgX3RoaXMyLnByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzMi5uZXh0KGYoc3RhdGVzW3N0YXRlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHByb3BzID0gX3RoaXMkc3RhdGUucHJvcHMsXG4gICAgICAgIHJlc29sdmUgPSBfdGhpcyRzdGF0ZS5yZXNvbHZlLFxuICAgICAgICBsYXN0ID0gX3RoaXMkc3RhdGUubGFzdCxcbiAgICAgICAgaW5kZXggPSBfdGhpcyRzdGF0ZS5pbmRleDtcbiAgICBpZiAoIXByb3BzIHx8IE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIHN0YXRlID0gX3RoaXMkcHJvcHMyLnN0YXRlLFxuICAgICAgICBmaWx0ZXIgPSBfdGhpcyRwcm9wczIuZmlsdGVyLFxuICAgICAgICBzdGF0ZXMgPSBfdGhpcyRwcm9wczIuc3RhdGVzLFxuICAgICAgICBjb25maWcgPSBfdGhpcyRwcm9wczIuY29uZmlnLFxuICAgICAgICBDb21wb25lbnQgPSBfdGhpcyRwcm9wczIucHJpbWl0aXZlLFxuICAgICAgICBfb25SZXN0ID0gX3RoaXMkcHJvcHMyLm9uUmVzdCxcbiAgICAgICAgZm9yd2FyZFJlZiA9IF90aGlzJHByb3BzMi5mb3J3YXJkUmVmLFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMyLCBbXCJzdGF0ZVwiLCBcImZpbHRlclwiLCBcInN0YXRlc1wiLCBcImNvbmZpZ1wiLCBcInByaW1pdGl2ZVwiLCBcIm9uUmVzdFwiLCBcImZvcndhcmRSZWZcIl0pOyAvLyBBcnJheWVkIGNvbmZpZ3MgbmVlZCBhbiBpbmRleCB0byBwcm9jZXNzXG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIGNvbmZpZyA9IGNvbmZpZ1tpbmRleF07XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuaW5zdGFuY2UgPSBoYW5kbGVSZWYoX3JlZiwgZm9yd2FyZFJlZik7XG4gICAgICB9LFxuICAgICAgY29uZmlnOiBjb25maWdcbiAgICB9LCByZXN0LCBwcm9wcywge1xuICAgICAgb25SZXN0OiBmdW5jdGlvbiBvblJlc3QoYXJncykge1xuICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICBpZiAoX29uUmVzdCAmJiBsYXN0KSBfb25SZXN0KGFyZ3MpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzSW1wbDtcbn0oUmVhY3RfX2RlZmF1bHQuUHVyZUNvbXBvbmVudCk7XG5cbktleWZyYW1lc0ltcGwuZGVmYXVsdFByb3BzID0ge1xuICBzdGF0ZTogREVGQVVMVFxufTtcbnZhciBLZXlmcmFtZXMgPSBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEtleWZyYW1lc0ltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGZvcndhcmRSZWY6IHJlZlxuICB9KSk7XG59KTtcblxuS2V5ZnJhbWVzLmNyZWF0ZSA9IGZ1bmN0aW9uIChwcmltaXRpdmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZXMsIGZpbHRlcikge1xuICAgIHZhciBfc3RhdGVzO1xuXG4gICAgaWYgKGZpbHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoc3RhdGVzKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3RhdGVzID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkoc3RhdGVzKSkgc3RhdGVzID0gKF9zdGF0ZXMgPSB7fSwgX3N0YXRlc1tERUZBVUxUXSA9IHN0YXRlcywgX3N0YXRlcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoS2V5ZnJhbWVzSW1wbCwgX2V4dGVuZHMoe1xuICAgICAgICBwcmltaXRpdmU6IHByaW1pdGl2ZSxcbiAgICAgICAgc3RhdGVzOiBzdGF0ZXMsXG4gICAgICAgIGZpbHRlcjogZmlsdGVyXG4gICAgICB9LCBwcm9wcykpO1xuICAgIH07XG4gIH07XG59O1xuXG5LZXlmcmFtZXMuU3ByaW5nID0gZnVuY3Rpb24gKHN0YXRlcykge1xuICByZXR1cm4gS2V5ZnJhbWVzLmNyZWF0ZShTcHJpbmcpKHN0YXRlcywgaW50ZXJwb2xhdGVUbyk7XG59O1xuXG5LZXlmcmFtZXMuVHJhaWwgPSBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gIHJldHVybiBLZXlmcmFtZXMuY3JlYXRlKFRyYWlsKShzdGF0ZXMsIGludGVycG9sYXRlVG8pO1xufTtcblxudmFyIGd1aWQgPSAwO1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KHByb3BzKSB7XG4gIHZhciBpdGVtcyA9IHByb3BzLml0ZW1zLFxuICAgICAga2V5cyA9IHByb3BzLmtleXMsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIFtcIml0ZW1zXCIsIFwia2V5c1wiXSk7XG5cbiAgaXRlbXMgPSB0b0FycmF5KGl0ZW1zICE9PSB2b2lkIDAgPyBpdGVtcyA6IG51bGwpO1xuICBrZXlzID0gdHlwZW9mIGtleXMgPT09ICdmdW5jdGlvbicgPyBpdGVtcy5tYXAoa2V5cykgOiB0b0FycmF5KGtleXMpOyAvLyBNYWtlIHN1cmUgbnVtZXJpYyBrZXlzIGFyZSBpbnRlcnByZXRlZCBhcyBTdHJpbmdzICg1ICE9PSBcIjVcIilcblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGl0ZW1zOiBpdGVtcyxcbiAgICBrZXlzOiBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGtleSk7XG4gICAgfSlcbiAgfSwgcmVzdCk7XG59O1xuXG52YXIgVHJhbnNpdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbiwgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24ocHJldlByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkUHVyZUNvbXBvbmVudC5jYWxsKHRoaXMsIHByZXZQcm9wcykgfHwgdGhpcztcblxuICAgIF90aGlzLmRlc3Ryb3lJdGVtID0gZnVuY3Rpb24gKGl0ZW0sIGtleSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgb25SZXN0ID0gX3RoaXMkcHJvcHMub25SZXN0LFxuICAgICAgICAgICAgb25EZXN0cm95ZWQgPSBfdGhpcyRwcm9wcy5vbkRlc3Ryb3llZDtcblxuICAgICAgICBpZiAoX3RoaXMubW91bnRlZCkge1xuICAgICAgICAgIG9uRGVzdHJveWVkICYmIG9uRGVzdHJveWVkKGl0ZW0pO1xuXG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBkZWxldGVkID0gX3JlZi5kZWxldGVkO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGVsZXRlZDogZGVsZXRlZC5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5rZXkgIT09IGtleTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvblJlc3QgJiYgb25SZXN0KGl0ZW0sIHN0YXRlLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGZpcnN0OiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbnM6IFtdLFxuICAgICAgY3VycmVudDoge30sXG4gICAgICBkZWxldGVkOiBbXSxcbiAgICAgIHByZXZQcm9wczogcHJldlByb3BzXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUcmFuc2l0aW9uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgZmlyc3QgPSBfcmVmMi5maXJzdCxcbiAgICAgICAgcHJldlByb3BzID0gX3JlZjIucHJldlByb3BzLFxuICAgICAgICBzdGF0ZSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBbXCJmaXJzdFwiLCBcInByZXZQcm9wc1wiXSk7XG5cbiAgICB2YXIgX2dldCA9IGdldChwcm9wcyksXG4gICAgICAgIGl0ZW1zID0gX2dldC5pdGVtcyxcbiAgICAgICAga2V5cyA9IF9nZXQua2V5cyxcbiAgICAgICAgaW5pdGlhbCA9IF9nZXQuaW5pdGlhbCxcbiAgICAgICAgZnJvbSA9IF9nZXQuZnJvbSxcbiAgICAgICAgZW50ZXIgPSBfZ2V0LmVudGVyLFxuICAgICAgICBsZWF2ZSA9IF9nZXQubGVhdmUsXG4gICAgICAgIHVwZGF0ZSA9IF9nZXQudXBkYXRlLFxuICAgICAgICBfZ2V0JHRyYWlsID0gX2dldC50cmFpbCxcbiAgICAgICAgdHJhaWwgPSBfZ2V0JHRyYWlsID09PSB2b2lkIDAgPyAwIDogX2dldCR0cmFpbCxcbiAgICAgICAgdW5pcXVlID0gX2dldC51bmlxdWUsXG4gICAgICAgIGNvbmZpZyA9IF9nZXQuY29uZmlnO1xuXG4gICAgdmFyIF9nZXQyID0gZ2V0KHByZXZQcm9wcyksXG4gICAgICAgIF9rZXlzID0gX2dldDIua2V5cyxcbiAgICAgICAgX2l0ZW1zID0gX2dldDIuaXRlbXM7XG5cbiAgICB2YXIgY3VycmVudCA9IF9leHRlbmRzKHt9LCBzdGF0ZS5jdXJyZW50KTtcblxuICAgIHZhciBkZWxldGVkID0gW10uY29uY2F0KHN0YXRlLmRlbGV0ZWQpOyAvLyBDb21wYXJlIG5leHQga2V5cyB3aXRoIGN1cnJlbnQga2V5c1xuXG4gICAgdmFyIGN1cnJlbnRLZXlzID0gT2JqZWN0LmtleXMoY3VycmVudCk7XG4gICAgdmFyIGN1cnJlbnRTZXQgPSBuZXcgU2V0KGN1cnJlbnRLZXlzKTtcbiAgICB2YXIgbmV4dFNldCA9IG5ldyBTZXQoa2V5cyk7XG4gICAgdmFyIGFkZGVkID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAhY3VycmVudFNldC5oYXMoaXRlbSk7XG4gICAgfSk7XG4gICAgdmFyIHJlbW92ZWQgPSBzdGF0ZS50cmFuc2l0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAhaXRlbS5kZXN0cm95ZWQgJiYgIW5leHRTZXQuaGFzKGl0ZW0ub3JpZ2luYWxLZXkpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkub3JpZ2luYWxLZXk7XG4gICAgfSk7XG4gICAgdmFyIHVwZGF0ZWQgPSBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTZXQuaGFzKGl0ZW0pO1xuICAgIH0pO1xuICAgIHZhciBkZWxheSA9IDA7XG4gICAgYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvLyBJbiB1bmlxdWUgbW9kZSwgcmVtb3ZlIGZhZGluZyBvdXQgdHJhbnNpdGlvbnMgaWYgdGhlaXIga2V5IGNvbWVzIGluIGFnYWluXG4gICAgICBpZiAodW5pcXVlICYmIGRlbGV0ZWQuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5vcmlnaW5hbEtleSA9PT0ga2V5O1xuICAgICAgfSkpIGRlbGV0ZWQgPSBkZWxldGVkLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vcmlnaW5hbEtleSAhPT0ga2V5O1xuICAgICAgfSk7XG4gICAgICB2YXIga2V5SW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIHZhciBpdGVtID0gaXRlbXNba2V5SW5kZXhdO1xuICAgICAgdmFyIHN0YXRlID0gJ2VudGVyJztcbiAgICAgIGN1cnJlbnRba2V5XSA9IHtcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBvcmlnaW5hbEtleToga2V5LFxuICAgICAgICBrZXk6IHVuaXF1ZSA/IFN0cmluZyhrZXkpIDogZ3VpZCsrLFxuICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICB0cmFpbDogZGVsYXkgPSBkZWxheSArIHRyYWlsLFxuICAgICAgICBjb25maWc6IGNhbGxQcm9wKGNvbmZpZywgaXRlbSwgc3RhdGUpLFxuICAgICAgICBmcm9tOiBjYWxsUHJvcChmaXJzdCA/IGluaXRpYWwgIT09IHZvaWQgMCA/IGluaXRpYWwgfHwge30gOiBmcm9tIDogZnJvbSwgaXRlbSksXG4gICAgICAgIHRvOiBjYWxsUHJvcChlbnRlciwgaXRlbSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBrZXlJbmRleCA9IF9rZXlzLmluZGV4T2Yoa2V5KTtcblxuICAgICAgdmFyIGl0ZW0gPSBfaXRlbXNba2V5SW5kZXhdO1xuICAgICAgdmFyIHN0YXRlID0gJ2xlYXZlJztcbiAgICAgIGRlbGV0ZWQucHVzaChfZXh0ZW5kcyh7fSwgY3VycmVudFtrZXldLCB7XG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgZGVzdHJveWVkOiB0cnVlLFxuICAgICAgICBsZWZ0OiBfa2V5c1tNYXRoLm1heCgwLCBrZXlJbmRleCAtIDEpXSxcbiAgICAgICAgcmlnaHQ6IF9rZXlzW01hdGgubWluKF9rZXlzLmxlbmd0aCwga2V5SW5kZXggKyAxKV0sXG4gICAgICAgIHRyYWlsOiBkZWxheSA9IGRlbGF5ICsgdHJhaWwsXG4gICAgICAgIGNvbmZpZzogY2FsbFByb3AoY29uZmlnLCBpdGVtLCBzdGF0ZSksXG4gICAgICAgIHRvOiBjYWxsUHJvcChsZWF2ZSwgaXRlbSlcbiAgICAgIH0pKTtcbiAgICAgIGRlbGV0ZSBjdXJyZW50W2tleV07XG4gICAgfSk7XG4gICAgdXBkYXRlZC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBrZXlJbmRleCA9IGtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtc1trZXlJbmRleF07XG4gICAgICB2YXIgc3RhdGUgPSAndXBkYXRlJztcbiAgICAgIGN1cnJlbnRba2V5XSA9IF9leHRlbmRzKHt9LCBjdXJyZW50W2tleV0sIHtcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICB0cmFpbDogZGVsYXkgPSBkZWxheSArIHRyYWlsLFxuICAgICAgICBjb25maWc6IGNhbGxQcm9wKGNvbmZpZywgaXRlbSwgc3RhdGUpLFxuICAgICAgICB0bzogY2FsbFByb3AodXBkYXRlLCBpdGVtKVxuICAgICAgfSk7XG4gICAgfSk7IC8vIFRoaXMgdHJpZXMgdG8gcmVzdG9yZSBvcmRlciBmb3IgZGVsZXRlZCBpdGVtcyBieSBmaW5kaW5nIHRoZWlyIGxhc3Qga25vd24gc2libGluZ3NcblxuICAgIHZhciBvdXQgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gY3VycmVudFtrZXldO1xuICAgIH0pO1xuICAgIGRlbGV0ZWQuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBsZWZ0ID0gX3JlZjMubGVmdCxcbiAgICAgICAgICByaWdodCA9IF9yZWYzLnJpZ2h0LFxuICAgICAgICAgIHRyYW5zaXRpb24gPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMywgW1wibGVmdFwiLCBcInJpZ2h0XCJdKTtcblxuICAgICAgdmFyIHBvczsgLy8gV2FzIGl0IHRoZSBlbGVtZW50IG9uIHRoZSBsZWZ0LCBpZiB5ZXMsIG1vdmUgdGhlcmUgLi4uXG5cbiAgICAgIGlmICgocG9zID0gb3V0LmZpbmRJbmRleChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vcmlnaW5hbEtleSA9PT0gbGVmdDtcbiAgICAgIH0pKSAhPT0gLTEpIHBvcyArPSAxOyAvLyBPciBob3cgYWJvdXQgdGhlIGVsZW1lbnQgb24gdGhlIHJpZ2h0IC4uLlxuXG4gICAgICBpZiAocG9zID09PSAtMSkgcG9zID0gb3V0LmZpbmRJbmRleChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vcmlnaW5hbEtleSA9PT0gcmlnaHQ7XG4gICAgICB9KTsgLy8gTWF5YmUgd2UnbGwgZmluZCBpdCBpbiB0aGUgbGlzdCBvZiBkZWxldGVkIGl0ZW1zXG5cbiAgICAgIGlmIChwb3MgPT09IC0xKSBwb3MgPSBkZWxldGVkLmZpbmRJbmRleChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vcmlnaW5hbEtleSA9PT0gbGVmdDtcbiAgICAgIH0pOyAvLyBDaGVja2luZyByaWdodCBzaWRlIGFzIHdlbGxcblxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHBvcyA9IGRlbGV0ZWQuZmluZEluZGV4KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lm9yaWdpbmFsS2V5ID09PSByaWdodDtcbiAgICAgIH0pOyAvLyBBbmQgaWYgbm90aGluZyBlbHNlIGhlbHBzLCBtb3ZlIGl0IHRvIHRoZSBzdGFydCDCr1xcXyjjg4QpXy/Cr1xuXG4gICAgICBwb3MgPSBNYXRoLm1heCgwLCBwb3MpO1xuICAgICAgb3V0ID0gW10uY29uY2F0KG91dC5zbGljZSgwLCBwb3MpLCBbdHJhbnNpdGlvbl0sIG91dC5zbGljZShwb3MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IGZpcnN0ICYmIGFkZGVkLmxlbmd0aCA9PT0gMCxcbiAgICAgIHRyYW5zaXRpb25zOiBvdXQsXG4gICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgZGVsZXRlZDogZGVsZXRlZCxcbiAgICAgIHByZXZQcm9wczogcHJvcHNcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaW5pdGlhbCA9IF90aGlzJHByb3BzMi5pbml0aWFsLFxuICAgICAgICBfdGhpcyRwcm9wczIkZnJvbSA9IF90aGlzJHByb3BzMi5mcm9tLFxuICAgICAgICBfdGhpcyRwcm9wczIkZW50ZXIgPSBfdGhpcyRwcm9wczIuZW50ZXIsXG4gICAgICAgIF90aGlzJHByb3BzMiRsZWF2ZSA9IF90aGlzJHByb3BzMi5sZWF2ZSxcbiAgICAgICAgX3RoaXMkcHJvcHMyJHVwZGF0ZSA9IF90aGlzJHByb3BzMi51cGRhdGUsXG4gICAgICAgIG9uRGVzdHJveWVkID0gX3RoaXMkcHJvcHMyLm9uRGVzdHJveWVkLFxuICAgICAgICBrZXlzID0gX3RoaXMkcHJvcHMyLmtleXMsXG4gICAgICAgIGl0ZW1zID0gX3RoaXMkcHJvcHMyLml0ZW1zLFxuICAgICAgICBvbkZyYW1lID0gX3RoaXMkcHJvcHMyLm9uRnJhbWUsXG4gICAgICAgIG9uUmVzdCA9IF90aGlzJHByb3BzMi5vblJlc3QsXG4gICAgICAgIG9uU3RhcnQgPSBfdGhpcyRwcm9wczIub25TdGFydCxcbiAgICAgICAgdHJhaWwgPSBfdGhpcyRwcm9wczIudHJhaWwsXG4gICAgICAgIGNvbmZpZyA9IF90aGlzJHByb3BzMi5jb25maWcsXG4gICAgICAgIF9jaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbixcbiAgICAgICAgdW5pcXVlID0gX3RoaXMkcHJvcHMyLnVuaXF1ZSxcbiAgICAgICAgcmVzZXQgPSBfdGhpcyRwcm9wczIucmVzZXQsXG4gICAgICAgIGV4dHJhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMyLCBbXCJpbml0aWFsXCIsIFwiZnJvbVwiLCBcImVudGVyXCIsIFwibGVhdmVcIiwgXCJ1cGRhdGVcIiwgXCJvbkRlc3Ryb3llZFwiLCBcImtleXNcIiwgXCJpdGVtc1wiLCBcIm9uRnJhbWVcIiwgXCJvblJlc3RcIiwgXCJvblN0YXJ0XCIsIFwidHJhaWxcIiwgXCJjb25maWdcIiwgXCJjaGlsZHJlblwiLCBcInVuaXF1ZVwiLCBcInJlc2V0XCJdKTtcblxuICAgIHJldHVybiB0aGlzLnN0YXRlLnRyYW5zaXRpb25zLm1hcChmdW5jdGlvbiAoX3JlZjQsIGkpIHtcbiAgICAgIHZhciBfcmVmNTtcblxuICAgICAgdmFyIHN0YXRlID0gX3JlZjQuc3RhdGUsXG4gICAgICAgICAga2V5ID0gX3JlZjQua2V5LFxuICAgICAgICAgIGl0ZW0gPSBfcmVmNC5pdGVtLFxuICAgICAgICAgIGZyb20gPSBfcmVmNC5mcm9tLFxuICAgICAgICAgIHRvID0gX3JlZjQudG8sXG4gICAgICAgICAgdHJhaWwgPSBfcmVmNC50cmFpbCxcbiAgICAgICAgICBjb25maWcgPSBfcmVmNC5jb25maWcsXG4gICAgICAgICAgZGVzdHJveWVkID0gX3JlZjQuZGVzdHJveWVkO1xuICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoS2V5ZnJhbWVzLCBfZXh0ZW5kcyh7XG4gICAgICAgIHJlc2V0OiByZXNldCAmJiBzdGF0ZSA9PT0gJ2VudGVyJyxcbiAgICAgICAgcHJpbWl0aXZlOiBTcHJpbmcsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgZmlsdGVyOiBpbnRlcnBvbGF0ZVRvLFxuICAgICAgICBzdGF0ZXM6IChfcmVmNSA9IHt9LCBfcmVmNVtzdGF0ZV0gPSB0bywgX3JlZjUpLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgb25SZXN0OiBkZXN0cm95ZWQgPyBfdGhpczIuZGVzdHJveUl0ZW0oaXRlbSwga2V5LCBzdGF0ZSkgOiBvblJlc3QgJiYgZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgIHJldHVybiBvblJlc3QoaXRlbSwgc3RhdGUsIHZhbHVlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RhcnQ6IG9uU3RhcnQgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvblN0YXJ0KGl0ZW0sIHN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25GcmFtZTogb25GcmFtZSAmJiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG9uRnJhbWUoaXRlbSwgc3RhdGUsIHZhbHVlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGF5OiB0cmFpbCxcbiAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgIH0sIGV4dHJhLCB7XG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihwcm9wcykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9jaGlsZHJlbihpdGVtLCBzdGF0ZSwgaSk7XG5cbiAgICAgICAgICByZXR1cm4gY2hpbGQgPyBjaGlsZChwcm9wcykgOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb247XG59KFJlYWN0X19kZWZhdWx0LlB1cmVDb21wb25lbnQpO1xuXG5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0sXG4gIHVuaXF1ZTogZmFsc2UsXG4gIHJlc2V0OiBmYWxzZVxufTtcblxudmFyIGRvbUVsZW1lbnRzID0gWydhJywgJ2FiYnInLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiYXNlJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtJywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbGluaycsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ21ldGVyJywgJ25hdicsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BhcmFtJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFuJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInLCAvLyBTVkdcbidjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N2ZycsICd0ZXh0JywgJ3RzcGFuJ107XG52YXIgZXh0ZW5kZWRBbmltYXRlZCA9IGRvbUVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlbGVtZW50KSB7XG4gIGFjY1tlbGVtZW50XSA9IGNyZWF0ZUFuaW1hdGVkQ29tcG9uZW50KGVsZW1lbnQpO1xuICByZXR1cm4gYWNjO1xufSwgY3JlYXRlQW5pbWF0ZWRDb21wb25lbnQpO1xuXG5leHBvcnRzLlNwcmluZyA9IFNwcmluZztcbmV4cG9ydHMuS2V5ZnJhbWVzID0gS2V5ZnJhbWVzO1xuZXhwb3J0cy5UcmFuc2l0aW9uID0gVHJhbnNpdGlvbjtcbmV4cG9ydHMuVHJhaWwgPSBUcmFpbDtcbmV4cG9ydHMuQ29udHJvbGxlciA9IENvbnRyb2xsZXI7XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcbmV4cG9ydHMuYW5pbWF0ZWQgPSBleHRlbmRlZEFuaW1hdGVkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlJDE7XG5leHBvcnRzLkdsb2JhbHMgPSBHbG9iYWxzO1xuIiwiLyohXG4gKiBVQVBhcnNlci5qcyB2MC43LjI0XG4gKiBMaWdodHdlaWdodCBKYXZhU2NyaXB0LWJhc2VkIFVzZXItQWdlbnQgc3RyaW5nIHBhcnNlclxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhaXNhbG1hbi91YS1wYXJzZXItanNcbiAqXG4gKiBDb3B5cmlnaHQgwqkgMjAxMi0yMDIxIEZhaXNhbCBTYWxtYW4gPGZAZmFpc2FsbWFuLmNvbT5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gKi9cbihmdW5jdGlvbih3aW5kb3csdW5kZWZpbmVkKXtcInVzZSBzdHJpY3RcIjt2YXIgTElCVkVSU0lPTj1cIjAuNy4yNFwiLEVNUFRZPVwiXCIsVU5LTk9XTj1cIj9cIixGVU5DX1RZUEU9XCJmdW5jdGlvblwiLFVOREVGX1RZUEU9XCJ1bmRlZmluZWRcIixPQkpfVFlQRT1cIm9iamVjdFwiLFNUUl9UWVBFPVwic3RyaW5nXCIsTUFKT1I9XCJtYWpvclwiLE1PREVMPVwibW9kZWxcIixOQU1FPVwibmFtZVwiLFRZUEU9XCJ0eXBlXCIsVkVORE9SPVwidmVuZG9yXCIsVkVSU0lPTj1cInZlcnNpb25cIixBUkNISVRFQ1RVUkU9XCJhcmNoaXRlY3R1cmVcIixDT05TT0xFPVwiY29uc29sZVwiLE1PQklMRT1cIm1vYmlsZVwiLFRBQkxFVD1cInRhYmxldFwiLFNNQVJUVFY9XCJzbWFydHR2XCIsV0VBUkFCTEU9XCJ3ZWFyYWJsZVwiLEVNQkVEREVEPVwiZW1iZWRkZWRcIjt2YXIgdXRpbD17ZXh0ZW5kOmZ1bmN0aW9uKHJlZ2V4ZXMsZXh0ZW5zaW9ucyl7dmFyIG1lcmdlZFJlZ2V4ZXM9e307Zm9yKHZhciBpIGluIHJlZ2V4ZXMpe2lmKGV4dGVuc2lvbnNbaV0mJmV4dGVuc2lvbnNbaV0ubGVuZ3RoJTI9PT0wKXttZXJnZWRSZWdleGVzW2ldPWV4dGVuc2lvbnNbaV0uY29uY2F0KHJlZ2V4ZXNbaV0pfWVsc2V7bWVyZ2VkUmVnZXhlc1tpXT1yZWdleGVzW2ldfX1yZXR1cm4gbWVyZ2VkUmVnZXhlc30saGFzOmZ1bmN0aW9uKHN0cjEsc3RyMil7aWYodHlwZW9mIHN0cjE9PT1cInN0cmluZ1wiKXtyZXR1cm4gc3RyMi50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyMS50b0xvd2VyQ2FzZSgpKSE9PS0xfWVsc2V7cmV0dXJuIGZhbHNlfX0sbG93ZXJpemU6ZnVuY3Rpb24oc3RyKXtyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCl9LG1ham9yOmZ1bmN0aW9uKHZlcnNpb24pe3JldHVybiB0eXBlb2YgdmVyc2lvbj09PVNUUl9UWVBFP3ZlcnNpb24ucmVwbGFjZSgvW15cXGRcXC5dL2csXCJcIikuc3BsaXQoXCIuXCIpWzBdOnVuZGVmaW5lZH0sdHJpbTpmdW5jdGlvbihzdHIpe3JldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXCJcIil9fTt2YXIgbWFwcGVyPXtyZ3g6ZnVuY3Rpb24odWEsYXJyYXlzKXt2YXIgaT0wLGosayxwLHEsbWF0Y2hlcyxtYXRjaDt3aGlsZShpPGFycmF5cy5sZW5ndGgmJiFtYXRjaGVzKXt2YXIgcmVnZXg9YXJyYXlzW2ldLHByb3BzPWFycmF5c1tpKzFdO2o9az0wO3doaWxlKGo8cmVnZXgubGVuZ3RoJiYhbWF0Y2hlcyl7bWF0Y2hlcz1yZWdleFtqKytdLmV4ZWModWEpO2lmKCEhbWF0Y2hlcyl7Zm9yKHA9MDtwPHByb3BzLmxlbmd0aDtwKyspe21hdGNoPW1hdGNoZXNbKytrXTtxPXByb3BzW3BdO2lmKHR5cGVvZiBxPT09T0JKX1RZUEUmJnEubGVuZ3RoPjApe2lmKHEubGVuZ3RoPT0yKXtpZih0eXBlb2YgcVsxXT09RlVOQ19UWVBFKXt0aGlzW3FbMF1dPXFbMV0uY2FsbCh0aGlzLG1hdGNoKX1lbHNle3RoaXNbcVswXV09cVsxXX19ZWxzZSBpZihxLmxlbmd0aD09Myl7aWYodHlwZW9mIHFbMV09PT1GVU5DX1RZUEUmJiEocVsxXS5leGVjJiZxWzFdLnRlc3QpKXt0aGlzW3FbMF1dPW1hdGNoP3FbMV0uY2FsbCh0aGlzLG1hdGNoLHFbMl0pOnVuZGVmaW5lZH1lbHNle3RoaXNbcVswXV09bWF0Y2g/bWF0Y2gucmVwbGFjZShxWzFdLHFbMl0pOnVuZGVmaW5lZH19ZWxzZSBpZihxLmxlbmd0aD09NCl7dGhpc1txWzBdXT1tYXRjaD9xWzNdLmNhbGwodGhpcyxtYXRjaC5yZXBsYWNlKHFbMV0scVsyXSkpOnVuZGVmaW5lZH19ZWxzZXt0aGlzW3FdPW1hdGNoP21hdGNoOnVuZGVmaW5lZH19fX1pKz0yfX0sc3RyOmZ1bmN0aW9uKHN0cixtYXApe2Zvcih2YXIgaSBpbiBtYXApe2lmKHR5cGVvZiBtYXBbaV09PT1PQkpfVFlQRSYmbWFwW2ldLmxlbmd0aD4wKXtmb3IodmFyIGo9MDtqPG1hcFtpXS5sZW5ndGg7aisrKXtpZih1dGlsLmhhcyhtYXBbaV1bal0sc3RyKSl7cmV0dXJuIGk9PT1VTktOT1dOP3VuZGVmaW5lZDppfX19ZWxzZSBpZih1dGlsLmhhcyhtYXBbaV0sc3RyKSl7cmV0dXJuIGk9PT1VTktOT1dOP3VuZGVmaW5lZDppfX1yZXR1cm4gc3RyfX07dmFyIG1hcHM9e2Jyb3dzZXI6e29sZHNhZmFyaTp7dmVyc2lvbjp7XCIxLjBcIjpcIi84XCIsMS4yOlwiLzFcIiwxLjM6XCIvM1wiLFwiMi4wXCI6XCIvNDEyXCIsXCIyLjAuMlwiOlwiLzQxNlwiLFwiMi4wLjNcIjpcIi80MTdcIixcIjIuMC40XCI6XCIvNDE5XCIsXCI/XCI6XCIvXCJ9fX0sZGV2aWNlOnthbWF6b246e21vZGVsOntcIkZpcmUgUGhvbmVcIjpbXCJTRFwiLFwiS0ZcIl19fSxzcHJpbnQ6e21vZGVsOntcIkV2byBTaGlmdCA0R1wiOlwiNzM3M0tUXCJ9LHZlbmRvcjp7SFRDOlwiQVBBXCIsU3ByaW50OlwiU3ByaW50XCJ9fX0sb3M6e3dpbmRvd3M6e3ZlcnNpb246e01FOlwiNC45MFwiLFwiTlQgMy4xMVwiOlwiTlQzLjUxXCIsXCJOVCA0LjBcIjpcIk5UNC4wXCIsMjAwMDpcIk5UIDUuMFwiLFhQOltcIk5UIDUuMVwiLFwiTlQgNS4yXCJdLFZpc3RhOlwiTlQgNi4wXCIsNzpcIk5UIDYuMVwiLDg6XCJOVCA2LjJcIiw4LjE6XCJOVCA2LjNcIiwxMDpbXCJOVCA2LjRcIixcIk5UIDEwLjBcIl0sUlQ6XCJBUk1cIn19fX07dmFyIHJlZ2V4ZXM9e2Jyb3dzZXI6W1svKG9wZXJhXFxzbWluaSlcXC8oW1xcd1xcLi1dKykvaSwvKG9wZXJhXFxzW21vYmlsZXRhYl17Myw2fSkuK3ZlcnNpb25cXC8oW1xcd1xcLi1dKykvaSwvKG9wZXJhKS4rdmVyc2lvblxcLyhbXFx3XFwuXSspL2ksLyhvcGVyYSlbXFwvXFxzXSsoW1xcd1xcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXSxbLyhvcGlvcylbXFwvXFxzXSsoW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJPcGVyYSBNaW5pXCJdLFZFUlNJT05dLFsvXFxzKG9wcilcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJPcGVyYVwiXSxWRVJTSU9OXSxbLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaSwvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC9cXHNdPyhbXFx3XFwuXSopL2ksLyhhdmFudFxcc3xpZW1vYmlsZXxzbGltKSg/OmJyb3dzZXIpP1tcXC9cXHNdPyhbXFx3XFwuXSopL2ksLyhiaWR1YnJvd3NlcnxiYWlkdWJyb3dzZXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSwvKD86bXN8XFwoKShpZSlcXHMoW1xcd1xcLl0rKS9pLC8ocmVrb25xKVxcLyhbXFx3XFwuXSopL2ksLyhjaHJvbWl1bXxmbG9ja3xyb2NrbWVsdHxtaWRvcml8ZXBpcGhhbnl8c2lsa3xza3lmaXJlfG92aWJyb3dzZXJ8Ym9sdHxpcm9ufHZpdmFsZGl8aXJpZGl1bXxwaGFudG9tanN8Ym93c2VyfHF1YXJrfHF1cHppbGxhfGZhbGtvbilcXC8oW1xcd1xcLi1dKykvaV0sW05BTUUsVkVSU0lPTl0sWy8oa29ucXVlcm9yKVxcLyhbXFx3XFwuXSspL2ldLFtbTkFNRSxcIktvbnF1ZXJvclwiXSxWRVJTSU9OXSxbLyh0cmlkZW50KS4rcnZbOlxcc10oW1xcd1xcLl17MSw5fSkuK2xpa2VcXHNnZWNrby9pXSxbW05BTUUsXCJJRVwiXSxWRVJTSU9OXSxbLyhlZGdlfGVkZ2lvc3xlZGdhfGVkZylcXC8oKFxcZCspP1tcXHdcXC5dKykvaV0sW1tOQU1FLFwiRWRnZVwiXSxWRVJTSU9OXSxbLyh5YWJyb3dzZXIpXFwvKFtcXHdcXC5dKykvaV0sW1tOQU1FLFwiWWFuZGV4XCJdLFZFUlNJT05dLFsvKEF2YXN0KVxcLyhbXFx3XFwuXSspL2ldLFtbTkFNRSxcIkF2YXN0IFNlY3VyZSBCcm93c2VyXCJdLFZFUlNJT05dLFsvKEFWRylcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJBVkcgU2VjdXJlIEJyb3dzZXJcIl0sVkVSU0lPTl0sWy8ocHVmZmluKVxcLyhbXFx3XFwuXSspL2ldLFtbTkFNRSxcIlB1ZmZpblwiXSxWRVJTSU9OXSxbLyhmb2N1cylcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJGaXJlZm94IEZvY3VzXCJdLFZFUlNJT05dLFsvKG9wdClcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJPcGVyYSBUb3VjaFwiXSxWRVJTSU9OXSxbLygoPzpbXFxzXFwvXSl1Yz9cXHM/YnJvd3NlcnwoPzpqdWMuKyl1Y3dlYilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJVQ0Jyb3dzZXJcIl0sVkVSU0lPTl0sWy8oY29tb2RvX2RyYWdvbilcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsL18vZyxcIiBcIl0sVkVSU0lPTl0sWy8od2luZG93c3dlY2hhdCBxYmNvcmUpXFwvKFtcXHdcXC5dKykvaV0sW1tOQU1FLFwiV2VDaGF0KFdpbikgRGVza3RvcFwiXSxWRVJTSU9OXSxbLyhtaWNyb21lc3NlbmdlcilcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJXZUNoYXRcIl0sVkVSU0lPTl0sWy8oYnJhdmUpXFwvKFtcXHdcXC5dKykvaV0sW1tOQU1FLFwiQnJhdmVcIl0sVkVSU0lPTl0sWy8od2hhbGUpXFwvKFtcXHdcXC5dKykvaV0sW1tOQU1FLFwiV2hhbGVcIl0sVkVSU0lPTl0sWy8ocXFicm93c2VybGl0ZSlcXC8oW1xcd1xcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXSxbLyhRUSlcXC8oW1xcZFxcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXSxbL20/KHFxYnJvd3NlcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXSxbLyhiYWlkdWJveGFwcClbXFwvXFxzXT8oW1xcd1xcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXSxbLygyMzQ1RXhwbG9yZXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaV0sW05BTUUsVkVSU0lPTl0sWy8oTWV0YVNyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2ldLFtOQU1FXSxbLyhMQkJST1dTRVIpL2ldLFtOQU1FXSxbL3hpYW9taVxcL21pdWlicm93c2VyXFwvKFtcXHdcXC5dKykvaV0sW1ZFUlNJT04sW05BTUUsXCJNSVVJIEJyb3dzZXJcIl1dLFsvO2ZiYXZcXC8oW1xcd1xcLl0rKTsvaV0sW1ZFUlNJT04sW05BTUUsXCJGYWNlYm9va1wiXV0sWy9GQkFOXFwvRkJJT1N8RkJfSUFCXFwvRkI0QS9pXSxbW05BTUUsXCJGYWNlYm9va1wiXV0sWy9zYWZhcmlcXHMobGluZSlcXC8oW1xcd1xcLl0rKS9pLC9hbmRyb2lkLisobGluZSlcXC8oW1xcd1xcLl0rKVxcL2lhYi9pXSxbTkFNRSxWRVJTSU9OXSxbL2hlYWRsZXNzY2hyb21lKD86XFwvKFtcXHdcXC5dKyl8XFxzKS9pXSxbVkVSU0lPTixbTkFNRSxcIkNocm9tZSBIZWFkbGVzc1wiXV0sWy9cXHN3dlxcKS4rKGNocm9tZSlcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsLyguKykvLFwiJDEgV2ViVmlld1wiXSxWRVJTSU9OXSxbLygoPzpvY3VsdXN8c2Ftc3VuZylicm93c2VyKVxcLyhbXFx3XFwuXSspL2ldLFtbTkFNRSwvKC4rKD86Z3x1cykpKC4rKS8sXCIkMSAkMlwiXSxWRVJTSU9OXSxbL2FuZHJvaWQuK3ZlcnNpb25cXC8oW1xcd1xcLl0rKVxccysoPzptb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkqL2ldLFtWRVJTSU9OLFtOQU1FLFwiQW5kcm9pZCBCcm93c2VyXCJdXSxbLyhjb2NfY29jX2Jyb3dzZXIpXFwvKFtcXHdcXC5dKykvaV0sW1tOQU1FLFwiQ29jIENvY1wiXSxWRVJTSU9OXSxbLyhzYWlsZmlzaGJyb3dzZXIpXFwvKFtcXHdcXC5dKykvaV0sW1tOQU1FLFwiU2FpbGZpc2ggQnJvd3NlclwiXSxWRVJTSU9OXSxbLyhjaHJvbWV8b21uaXdlYnxhcm9yYXxbdGl6ZW5va2FdezV9XFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXSxbLyhkb2xmaW4pXFwvKFtcXHdcXC5dKykvaV0sW1tOQU1FLFwiRG9scGhpblwiXSxWRVJTSU9OXSxbLyhxaWh1fHFoYnJvd3NlcnxxaWhvb2Jyb3dzZXJ8MzYwYnJvd3NlcikvaV0sW1tOQU1FLFwiMzYwIEJyb3dzZXJcIl1dLFsvKCg/OmFuZHJvaWQuKyljcm1vfGNyaW9zKVxcLyhbXFx3XFwuXSspL2ldLFtbTkFNRSxcIkNocm9tZVwiXSxWRVJTSU9OXSxbLyhjb2FzdClcXC8oW1xcd1xcLl0rKS9pXSxbW05BTUUsXCJPcGVyYSBDb2FzdFwiXSxWRVJTSU9OXSxbL2Z4aW9zXFwvKFtcXHdcXC4tXSspL2ldLFtWRVJTSU9OLFtOQU1FLFwiRmlyZWZveFwiXV0sWy92ZXJzaW9uXFwvKFtcXHdcXC5dKylcXHMuKm1vYmlsZVxcL1xcdytcXHMoc2FmYXJpKS9pXSxbVkVSU0lPTixbTkFNRSxcIk1vYmlsZSBTYWZhcmlcIl1dLFsvdmVyc2lvblxcLyhbXFx3XFwuXSspXFxzLioobW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpL2ldLFtWRVJTSU9OLE5BTUVdLFsvd2Via2l0Lis/KGdzYSlcXC8oW1xcd1xcLl0rKVxccy4qKG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2ldLFtbTkFNRSxcIkdTQVwiXSxWRVJTSU9OXSxbL3dlYmtpdC4rPyhtb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkoXFwvW1xcd1xcLl0rKS9pXSxbTkFNRSxbVkVSU0lPTixtYXBwZXIuc3RyLG1hcHMuYnJvd3Nlci5vbGRzYWZhcmkudmVyc2lvbl1dLFsvKHdlYmtpdHxraHRtbClcXC8oW1xcd1xcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXSxbLyhuYXZpZ2F0b3J8bmV0c2NhcGUpXFwvKFtcXHdcXC4tXSspL2ldLFtbTkFNRSxcIk5ldHNjYXBlXCJdLFZFUlNJT05dLFsvKHN3aWZ0Zm94KS9pLC8oaWNlZHJhZ29ufGljZXdlYXNlbHxjYW1pbm98Y2hpbWVyYXxmZW5uZWN8bWFlbW9cXHNicm93c2VyfG1pbmltb3xjb25rZXJvcilbXFwvXFxzXT8oW1xcd1xcLlxcK10rKS9pLC8oZmlyZWZveHxzZWFtb25rZXl8ay1tZWxlb258aWNlY2F0fGljZWFwZXxmaXJlYmlyZHxwaG9lbml4fHBhbGVtb29ufGJhc2lsaXNrfHdhdGVyZm94KVxcLyhbXFx3XFwuLV0rKSQvaSwvKGZpcmVmb3gpXFwvKFtcXHdcXC5dKylcXHNbXFx3XFxzXFwtXStcXC9bXFx3XFwuXSskL2ksLyhtb3ppbGxhKVxcLyhbXFx3XFwuXSspXFxzLitydlxcOi4rZ2Vja29cXC9cXGQrL2ksLyhwb2xhcmlzfGx5bnh8ZGlsbG98aWNhYnxkb3Jpc3xhbWF5YXx3M218bmV0c3VyZnxzbGVpcG5pcilbXFwvXFxzXT8oW1xcd1xcLl0rKS9pLC8obGlua3MpXFxzXFwoKFtcXHdcXC5dKykvaSwvKGdvYnJvd3NlcilcXC8/KFtcXHdcXC5dKikvaSwvKGljZVxccz9icm93c2VyKVxcL3Y/KFtcXHdcXC5fXSspL2ksLyhtb3NhaWMpW1xcL1xcc10oW1xcd1xcLl0rKS9pXSxbTkFNRSxWRVJTSU9OXV0sY3B1OltbLyg/OihhbWR8eCg/Oig/Ojg2fDY0KVtfLV0pP3x3b3d8d2luKTY0KVs7XFwpXS9pXSxbW0FSQ0hJVEVDVFVSRSxcImFtZDY0XCJdXSxbLyhpYTMyKD89OykpL2ldLFtbQVJDSElURUNUVVJFLHV0aWwubG93ZXJpemVdXSxbLygoPzppWzM0Nl18eCk4NilbO1xcKV0vaV0sW1tBUkNISVRFQ1RVUkUsXCJpYTMyXCJdXSxbL3dpbmRvd3NcXHMoY2V8bW9iaWxlKTtcXHNwcGM7L2ldLFtbQVJDSElURUNUVVJFLFwiYXJtXCJdXSxbLygoPzpwcGN8cG93ZXJwYykoPzo2NCk/KSg/Olxcc21hY3w7fFxcKSkvaV0sW1tBUkNISVRFQ1RVUkUsL293ZXIvLFwiXCIsdXRpbC5sb3dlcml6ZV1dLFsvKHN1bjRcXHcpWztcXCldL2ldLFtbQVJDSElURUNUVVJFLFwic3BhcmNcIl1dLFsvKCg/OmF2cjMyfGlhNjQoPz07KSl8NjhrKD89XFwpKXxhcm0oPzo2NHwoPz12XFxkK1s7bF0pKXwoPz1hdG1lbFxccylhdnJ8KD86aXJpeHxtaXBzfHNwYXJjKSg/OjY0KT8oPz07KXxwYS1yaXNjKS9pXSxbW0FSQ0hJVEVDVFVSRSx1dGlsLmxvd2VyaXplXV1dLGRldmljZTpbWy9cXCgoaXBhZHxwbGF5Ym9vayk7W1xcd1xcc1xcKSw7LV0rKHJpbXxhcHBsZSkvaV0sW01PREVMLFZFTkRPUixbVFlQRSxUQUJMRVRdXSxbL2FwcGxlY29yZW1lZGlhXFwvW1xcd1xcLl0rIFxcKChpcGFkKS9dLFtNT0RFTCxbVkVORE9SLFwiQXBwbGVcIl0sW1RZUEUsVEFCTEVUXV0sWy8oYXBwbGVcXHN7MCwxfXR2KS9pXSxbW01PREVMLFwiQXBwbGUgVFZcIl0sW1ZFTkRPUixcIkFwcGxlXCJdLFtUWVBFLFNNQVJUVFZdXSxbLyhhcmNob3MpXFxzKGdhbWVwYWQyPykvaSwvKGhwKS4rKHRvdWNocGFkKS9pLC8oaHApLisodGFibGV0KS9pLC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksL1xccyhub29rKVtcXHdcXHNdK2J1aWxkXFwvKFxcdyspL2ksLyhkZWxsKVxccyhzdHJlYVtrcHJcXHNcXGRdKltcXGRrb10pL2ldLFtWRU5ET1IsTU9ERUwsW1RZUEUsVEFCTEVUXV0sWy8oa2ZbQS16XSspKFxcc2J1aWxkXFwvfFxcKSkuK3NpbGtcXC8vaV0sW01PREVMLFtWRU5ET1IsXCJBbWF6b25cIl0sW1RZUEUsVEFCTEVUXV0sWy8oc2R8a2YpWzAzNDloaWpvcnN0dXddKyhcXHNidWlsZFxcL3xcXCkpLitzaWxrXFwvL2ldLFtbTU9ERUwsbWFwcGVyLnN0cixtYXBzLmRldmljZS5hbWF6b24ubW9kZWxdLFtWRU5ET1IsXCJBbWF6b25cIl0sW1RZUEUsTU9CSUxFXV0sWy9hbmRyb2lkLithZnQoW1xcd10pKFxcc2J1aWxkXFwvfFxcKSkvaV0sW01PREVMLFtWRU5ET1IsXCJBbWF6b25cIl0sW1RZUEUsU01BUlRUVl1dLFsvXFwoKGlwW2hvbmVkfFxcc1xcdypdKyk7LisoYXBwbGUpL2ldLFtNT0RFTCxWRU5ET1IsW1RZUEUsTU9CSUxFXV0sWy9cXCgoaXBbaG9uZWR8XFxzXFx3Kl0rKTsvaV0sW01PREVMLFtWRU5ET1IsXCJBcHBsZVwiXSxbVFlQRSxNT0JJTEVdXSxbLyhibGFja2JlcnJ5KVtcXHMtXT8oXFx3KykvaSwvKGJsYWNrYmVycnl8YmVucXxwYWxtKD89XFwtKXxzb255ZXJpY3Nzb258YWNlcnxhc3VzfGRlbGx8bWVpenV8bW90b3JvbGF8cG9seXRyb24pW1xcc18tXT8oW1xcdy1dKikvaSwvKGhwKVxccyhbXFx3XFxzXStcXHcpL2ksLyhhc3VzKS0/KFxcdyspL2ldLFtWRU5ET1IsTU9ERUwsW1RZUEUsTU9CSUxFXV0sWy9cXChiYjEwO1xccyhcXHcrKS9pXSxbTU9ERUwsW1ZFTkRPUixcIkJsYWNrQmVycnlcIl0sW1RZUEUsTU9CSUxFXV0sWy9hbmRyb2lkLisodHJhbnNmb1twcmltZVxcc117NCwxMH1cXHNcXHcrfGVlZXBjfHNsaWRlclxcc1xcdyt8bmV4dXMgN3xwYWRmb25lfHAwMGMpL2ldLFtNT0RFTCxbVkVORE9SLFwiQXN1c1wiXSxbVFlQRSxUQUJMRVRdXSxbLyhzb255KVxccyh0YWJsZXRcXHNbcHNdKVxcc2J1aWxkXFwvL2ksLyhzb255KT8oPzpzZ3AuKylcXHNidWlsZFxcLy9pXSxbW1ZFTkRPUixcIlNvbnlcIl0sW01PREVMLFwiWHBlcmlhIFRhYmxldFwiXSxbVFlQRSxUQUJMRVRdXSxbL2FuZHJvaWQuK1xccyhbYy1nXVxcZHs0fXxzb1stbF1cXHcrKSg/PVxcc2J1aWxkXFwvfFxcKS4rY2hyb21lXFwvKD8hWzEtNl17MCwxfVxcZFxcLikpL2ldLFtNT0RFTCxbVkVORE9SLFwiU29ueVwiXSxbVFlQRSxNT0JJTEVdXSxbL1xccyhvdXlhKVxccy9pLC8obmludGVuZG8pXFxzKFt3aWRzM3VdKykvaV0sW1ZFTkRPUixNT0RFTCxbVFlQRSxDT05TT0xFXV0sWy9hbmRyb2lkLis7XFxzKHNoaWVsZClcXHNidWlsZC9pXSxbTU9ERUwsW1ZFTkRPUixcIk52aWRpYVwiXSxbVFlQRSxDT05TT0xFXV0sWy8ocGxheXN0YXRpb25cXHNbMzRwb3J0YWJsZXZpXSspL2ldLFtNT0RFTCxbVkVORE9SLFwiU29ueVwiXSxbVFlQRSxDT05TT0xFXV0sWy8oc3ByaW50XFxzKFxcdyspKS9pXSxbW1ZFTkRPUixtYXBwZXIuc3RyLG1hcHMuZGV2aWNlLnNwcmludC52ZW5kb3JdLFtNT0RFTCxtYXBwZXIuc3RyLG1hcHMuZGV2aWNlLnNwcmludC5tb2RlbF0sW1RZUEUsTU9CSUxFXV0sWy8oaHRjKVs7X1xccy1dezEsMn0oW1xcd1xcc10rKD89XFwpfFxcc2J1aWxkKXxcXHcrKS9pLC8oenRlKS0oXFx3KikvaSwvKGFsY2F0ZWx8Z2Vla3NwaG9uZXxuZXhpYW58cGFuYXNvbmljfCg/PTtcXHMpc29ueSlbX1xccy1dPyhbXFx3LV0qKS9pXSxbVkVORE9SLFtNT0RFTCwvXy9nLFwiIFwiXSxbVFlQRSxNT0JJTEVdXSxbLyhuZXh1c1xcczkpL2ldLFtNT0RFTCxbVkVORE9SLFwiSFRDXCJdLFtUWVBFLFRBQkxFVF1dLFsvZFxcL2h1YXdlaShbXFx3XFxzLV0rKVs7XFwpXS9pLC9hbmRyb2lkLitcXHMobmV4dXNcXHM2cHx2b2ctW2F0XT9sXFxkXFxkfGFuZS1bYXRdP2xbeFxcZF1cXGR8ZW1sLWE/bFxcZFxcZGE/fGx5YS1bYXRdP2xcXGRbXFxkY118Y2x0LWE/bFxcZFxcZGk/KS9pXSxbTU9ERUwsW1ZFTkRPUixcIkh1YXdlaVwiXSxbVFlQRSxNT0JJTEVdXSxbL2FuZHJvaWQuKyhiYWgyPy1hP1tsd11cXGR7Mn0pL2ldLFtNT0RFTCxbVkVORE9SLFwiSHVhd2VpXCJdLFtUWVBFLFRBQkxFVF1dLFsvKG1pY3Jvc29mdCk7XFxzKGx1bWlhW1xcc1xcd10rKS9pXSxbVkVORE9SLE1PREVMLFtUWVBFLE1PQklMRV1dLFsvW1xcc1xcKDtdKHhib3goPzpcXHNvbmUpPylbXFxzXFwpO10vaV0sW01PREVMLFtWRU5ET1IsXCJNaWNyb3NvZnRcIl0sW1RZUEUsQ09OU09MRV1dLFsvKGtpblxcLltvbmV0d117M30pL2ldLFtbTU9ERUwsL1xcLi9nLFwiIFwiXSxbVkVORE9SLFwiTWljcm9zb2Z0XCJdLFtUWVBFLE1PQklMRV1dLFsvXFxzKG1pbGVzdG9uZXxkcm9pZCg/OlsyLTR4XXxcXHMoPzpiaW9uaWN8eDJ8cHJvfHJhenIpKT86PyhcXHM0Zyk/KVtcXHdcXHNdK2J1aWxkXFwvL2ksL21vdFtcXHMtXT8oXFx3KikvaSwvKFhUXFxkezMsNH0pIGJ1aWxkXFwvL2ksLyhuZXh1c1xcczYpL2ldLFtNT0RFTCxbVkVORE9SLFwiTW90b3JvbGFcIl0sW1RZUEUsTU9CSUxFXV0sWy9hbmRyb2lkLitcXHMobXo2MFxcZHx4b29tW1xcczJdezAsMn0pXFxzYnVpbGRcXC8vaV0sW01PREVMLFtWRU5ET1IsXCJNb3Rvcm9sYVwiXSxbVFlQRSxUQUJMRVRdXSxbL2hiYnR2XFwvXFxkK1xcLlxcZCtcXC5cXGQrXFxzK1xcKFtcXHdcXHNdKjtcXHMqKFxcd1teO10qKTsoW147XSopL2ldLFtbVkVORE9SLHV0aWwudHJpbV0sW01PREVMLHV0aWwudHJpbV0sW1RZUEUsU01BUlRUVl1dLFsvaGJidHYuK21hcGxlOyhcXGQrKS9pXSxbW01PREVMLC9eLyxcIlNtYXJ0VFZcIl0sW1ZFTkRPUixcIlNhbXN1bmdcIl0sW1RZUEUsU01BUlRUVl1dLFsvXFwoZHR2W1xcKTtdLisoYXF1b3MpL2ldLFtNT0RFTCxbVkVORE9SLFwiU2hhcnBcIl0sW1RZUEUsU01BUlRUVl1dLFsvYW5kcm9pZC4rKChzY2gtaVs4OV0wXFxkfHNody1tMzgwc3xTTS1QNjA1fFNNLVA2MTB8U00tUDU4N3xndC1wXFxkezR9fGd0LW5cXGQrfHNnaC10OFs1Nl05fG5leHVzIDEwKSkvaSwvKChTTS1UXFx3KykpL2ldLFtbVkVORE9SLFwiU2Ftc3VuZ1wiXSxNT0RFTCxbVFlQRSxUQUJMRVRdXSxbL3NtYXJ0LXR2Lisoc2Ftc3VuZykvaV0sW1ZFTkRPUixbVFlQRSxTTUFSVFRWXSxNT0RFTF0sWy8oKHNbY2dwXWgtXFx3K3xndC1cXHcrfGdhbGF4eVxcc25leHVzfHNtLVxcd1tcXHdcXGRdKykpL2ksLyhzYW1bc3VuZ10qKVtcXHMtXSooXFx3Ky0/W1xcdy1dKikvaSwvc2VjLSgoc2doXFx3KykpL2ldLFtbVkVORE9SLFwiU2Ftc3VuZ1wiXSxNT0RFTCxbVFlQRSxNT0JJTEVdXSxbL3NpZS0oXFx3KikvaV0sW01PREVMLFtWRU5ET1IsXCJTaWVtZW5zXCJdLFtUWVBFLE1PQklMRV1dLFsvKG1hZW1vfG5va2lhKS4qKG45MDB8bHVtaWFcXHNcXGQrKS9pLC8obm9raWEpW1xcc18tXT8oW1xcdy1dKikvaV0sW1tWRU5ET1IsXCJOb2tpYVwiXSxNT0RFTCxbVFlQRSxNT0JJTEVdXSxbL2FuZHJvaWRbeFxcZFxcLlxccztdK1xccyhbYWJdWzEtN11cXC0/WzAxNzhhXVxcZFxcZD8pL2ldLFtNT0RFTCxbVkVORE9SLFwiQWNlclwiXSxbVFlQRSxUQUJMRVRdXSxbL2FuZHJvaWQuKyhbdmxda1xcLT9cXGR7M30pXFxzK2J1aWxkL2ldLFtNT0RFTCxbVkVORE9SLFwiTEdcIl0sW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkXFxzM1xcLltcXHNcXHc7LV17MTB9KGxnPyktKFswNmN2OV17Myw0fSkvaV0sW1tWRU5ET1IsXCJMR1wiXSxNT0RFTCxbVFlQRSxUQUJMRVRdXSxbL2xpbnV4O1xcc25ldGNhc3QuK3NtYXJ0dHYvaSwvbGdcXHNuZXRjYXN0XFwudHYtMjAxXFxkL2ldLFtbVkVORE9SLFwiTEdcIl0sTU9ERUwsW1RZUEUsU01BUlRUVl1dLFsvKG5leHVzXFxzWzQ1XSkvaSwvbGdbZTtcXHNcXC8tXSsoXFx3KikvaSwvYW5kcm9pZC4rbGcoXFwtP1tcXGRcXHddKylcXHMrYnVpbGQvaV0sW01PREVMLFtWRU5ET1IsXCJMR1wiXSxbVFlQRSxNT0JJTEVdXSxbLyhsZW5vdm8pXFxzPyhzKD86NTAwMHw2MDAwKSg/OltcXHctXSspfHRhYig/OltcXHNcXHddKykpL2ldLFtWRU5ET1IsTU9ERUwsW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLisoaWRlYXRhYlthLXowLTlcXC1cXHNdKykvaV0sW01PREVMLFtWRU5ET1IsXCJMZW5vdm9cIl0sW1RZUEUsVEFCTEVUXV0sWy8obGVub3ZvKVtfXFxzLV0/KFtcXHctXSspL2ldLFtWRU5ET1IsTU9ERUwsW1RZUEUsTU9CSUxFXV0sWy9saW51eDsuKygoam9sbGEpKTsvaV0sW1ZFTkRPUixNT0RFTCxbVFlQRSxNT0JJTEVdXSxbLygocGViYmxlKSlhcHBcXC9bXFxkXFwuXStcXHMvaV0sW1ZFTkRPUixNT0RFTCxbVFlQRSxXRUFSQUJMRV1dLFsvYW5kcm9pZC4rO1xccyhvcHBvKVxccz8oW1xcd1xcc10rKVxcc2J1aWxkL2ldLFtWRU5ET1IsTU9ERUwsW1RZUEUsTU9CSUxFXV0sWy9jcmtleS9pXSxbW01PREVMLFwiQ2hyb21lY2FzdFwiXSxbVkVORE9SLFwiR29vZ2xlXCJdLFtUWVBFLFNNQVJUVFZdXSxbL2FuZHJvaWQuKztcXHMoZ2xhc3MpXFxzXFxkL2ldLFtNT0RFTCxbVkVORE9SLFwiR29vZ2xlXCJdLFtUWVBFLFdFQVJBQkxFXV0sWy9hbmRyb2lkLis7XFxzKHBpeGVsIGMpW1xccyldL2ldLFtNT0RFTCxbVkVORE9SLFwiR29vZ2xlXCJdLFtUWVBFLFRBQkxFVF1dLFsvYW5kcm9pZC4rO1xccyhwaXhlbCggWzItOV1hPyk/KCB4bCk/KVtcXHMpXS9pXSxbTU9ERUwsW1ZFTkRPUixcIkdvb2dsZVwiXSxbVFlQRSxNT0JJTEVdXSxbL2FuZHJvaWQuKztcXHMoXFx3KylcXHMrYnVpbGRcXC9obVxcMS9pLC9hbmRyb2lkLisoaG1bXFxzXFwtX10/bm90ZT9bXFxzX10/KD86XFxkXFx3KT8pXFxzYnVpbGQvaSwvYW5kcm9pZC4rKHJlZG1pW1xcc1xcLV9dPyg/Om5vdGV8ayk/KD86W1xcc19dP1tcXHdcXHNdKykpKD86XFxzYnVpbGR8XFwpKS9pLC9hbmRyb2lkLisobWlbXFxzXFwtX10/KD86YVxcZHxvbmV8b25lW1xcc19dcGx1c3xub3RlIGx0ZSk/W1xcc19dPyg/OlxcZD9cXHc/KVtcXHNfXT8oPzpwbHVzKT8pXFxzYnVpbGQvaV0sW1tNT0RFTCwvXy9nLFwiIFwiXSxbVkVORE9SLFwiWGlhb21pXCJdLFtUWVBFLE1PQklMRV1dLFsvYW5kcm9pZC4rKG1pW1xcc1xcLV9dPyg/OnBhZCkoPzpbXFxzX10/W1xcd1xcc10rKSkoPzpcXHNidWlsZHxcXCkpL2ldLFtbTU9ERUwsL18vZyxcIiBcIl0sW1ZFTkRPUixcIlhpYW9taVwiXSxbVFlQRSxUQUJMRVRdXSxbL2FuZHJvaWQuKztcXHMobVsxLTVdXFxzbm90ZSlcXHNidWlsZC9pXSxbTU9ERUwsW1ZFTkRPUixcIk1laXp1XCJdLFtUWVBFLE1PQklMRV1dLFsvKG16KS0oW1xcdy1dezIsfSkvaV0sW1tWRU5ET1IsXCJNZWl6dVwiXSxNT0RFTCxbVFlQRSxNT0JJTEVdXSxbL2FuZHJvaWQuK2EwMDAoMSlcXHMrYnVpbGQvaSwvYW5kcm9pZC4rb25lcGx1c1xccyhhXFxkezR9KVtcXHMpXS9pXSxbTU9ERUwsW1ZFTkRPUixcIk9uZVBsdXNcIl0sW1RZUEUsTU9CSUxFXV0sWy9hbmRyb2lkLitbO1xcL11cXHMqKFJDVFtcXGRcXHddKylcXHMrYnVpbGQvaV0sW01PREVMLFtWRU5ET1IsXCJSQ0FcIl0sW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLitbO1xcL1xcc10oVmVudWVbXFxkXFxzXXsyLDd9KVxccytidWlsZC9pXSxbTU9ERUwsW1ZFTkRPUixcIkRlbGxcIl0sW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLitbO1xcL11cXHMqKFFbVHxNXVtcXGRcXHddKylcXHMrYnVpbGQvaV0sW01PREVMLFtWRU5ET1IsXCJWZXJpem9uXCJdLFtUWVBFLFRBQkxFVF1dLFsvYW5kcm9pZC4rWztcXC9dXFxzKyhCYXJuZXNbJlxcc10rTm9ibGVcXHMrfEJOW1JUXSkoXFxTKD86LipcXFMpPylcXHMrYnVpbGQvaV0sW1tWRU5ET1IsXCJCYXJuZXMgJiBOb2JsZVwiXSxNT0RFTCxbVFlQRSxUQUJMRVRdXSxbL2FuZHJvaWQuK1s7XFwvXVxccysoVE1cXGR7M30uKlxcYilcXHMrYnVpbGQvaV0sW01PREVMLFtWRU5ET1IsXCJOdVZpc2lvblwiXSxbVFlQRSxUQUJMRVRdXSxbL2FuZHJvaWQuKztcXHMoazg4KVxcc2J1aWxkL2ldLFtNT0RFTCxbVkVORE9SLFwiWlRFXCJdLFtUWVBFLFRBQkxFVF1dLFsvYW5kcm9pZC4rWztcXC9dXFxzKihnZW5cXGR7M30pXFxzK2J1aWxkLio0OWgvaV0sW01PREVMLFtWRU5ET1IsXCJTd2lzc1wiXSxbVFlQRSxNT0JJTEVdXSxbL2FuZHJvaWQuK1s7XFwvXVxccyooenVyXFxkezN9KVxccytidWlsZC9pXSxbTU9ERUwsW1ZFTkRPUixcIlN3aXNzXCJdLFtUWVBFLFRBQkxFVF1dLFsvYW5kcm9pZC4rWztcXC9dXFxzKigoWmVraSk/VEIuKlxcYilcXHMrYnVpbGQvaV0sW01PREVMLFtWRU5ET1IsXCJaZWtpXCJdLFtUWVBFLFRBQkxFVF1dLFsvKGFuZHJvaWQpLitbO1xcL11cXHMrKFtZUl1cXGR7Mn0pXFxzK2J1aWxkL2ksL2FuZHJvaWQuK1s7XFwvXVxccysoRHJhZ29uW1xcLVxcc10rVG91Y2hcXHMrfERUKShcXHd7NX0pXFxzYnVpbGQvaV0sW1tWRU5ET1IsXCJEcmFnb24gVG91Y2hcIl0sTU9ERUwsW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLitbO1xcL11cXHMqKE5TLT9cXHd7MCw5fSlcXHNidWlsZC9pXSxbTU9ERUwsW1ZFTkRPUixcIkluc2lnbmlhXCJdLFtUWVBFLFRBQkxFVF1dLFsvYW5kcm9pZC4rWztcXC9dXFxzKigoTlh8TmV4dCktP1xcd3swLDl9KVxccytidWlsZC9pXSxbTU9ERUwsW1ZFTkRPUixcIk5leHRCb29rXCJdLFtUWVBFLFRBQkxFVF1dLFsvYW5kcm9pZC4rWztcXC9dXFxzKihYdHJlbWVcXF8pPyhWKDFbMDQ1XXwyWzAxNV18MzB8NDB8NjB8N1swNV18OTApKVxccytidWlsZC9pXSxbW1ZFTkRPUixcIlZvaWNlXCJdLE1PREVMLFtUWVBFLE1PQklMRV1dLFsvYW5kcm9pZC4rWztcXC9dXFxzKihMVlRFTFxcLSk/KFYxWzEyXSlcXHMrYnVpbGQvaV0sW1tWRU5ET1IsXCJMdlRlbFwiXSxNT0RFTCxbVFlQRSxNT0JJTEVdXSxbL2FuZHJvaWQuKztcXHMoUEgtMSlcXHMvaV0sW01PREVMLFtWRU5ET1IsXCJFc3NlbnRpYWxcIl0sW1RZUEUsTU9CSUxFXV0sWy9hbmRyb2lkLitbO1xcL11cXHMqKFYoMTAwTUR8NzAwTkF8NzAxMXw5MTdHKS4qXFxiKVxccytidWlsZC9pXSxbTU9ERUwsW1ZFTkRPUixcIkVudml6ZW5cIl0sW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLitbO1xcL11cXHMqKExlW1xcc1xcLV0rUGFuKVtcXHNcXC1dKyhcXHd7MSw5fSlcXHMrYnVpbGQvaV0sW1ZFTkRPUixNT0RFTCxbVFlQRSxUQUJMRVRdXSxbL2FuZHJvaWQuK1s7XFwvXVxccyooVHJpb1tcXHNcXHdcXC1cXC5dKylcXHMrYnVpbGQvaV0sW01PREVMLFtWRU5ET1IsXCJNYWNoU3BlZWRcIl0sW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLitbO1xcL11cXHMqKFRyaW5pdHkpW1xcLVxcc10qKFRcXGR7M30pXFxzK2J1aWxkL2ldLFtWRU5ET1IsTU9ERUwsW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLitbO1xcL11cXHMqVFVfKDE0OTEpXFxzK2J1aWxkL2ldLFtNT0RFTCxbVkVORE9SLFwiUm90b3JcIl0sW1RZUEUsVEFCTEVUXV0sWy9hbmRyb2lkLisoR2lnYXNldClbXFxzXFwtXSsoUVxcd3sxLDl9KVxccytidWlsZC9pXSxbVkVORE9SLE1PREVMLFtUWVBFLFRBQkxFVF1dLFsvYW5kcm9pZCAuKz87IChbXjtdKz8pKD86IGJ1aWxkfFxcKSBhcHBsZXdlYmtpdCkuKz8gbW9iaWxlIHNhZmFyaS9pXSxbTU9ERUwsW1RZUEUsTU9CSUxFXV0sWy9hbmRyb2lkIC4rPztcXHMoW147XSs/KSg/OiBidWlsZHxcXCkgYXBwbGV3ZWJraXQpLis/KD8hIG1vYmlsZSkgc2FmYXJpL2ldLFtNT0RFTCxbVFlQRSxUQUJMRVRdXSxbL1xccyh0YWJsZXR8dGFiKVs7XFwvXS9pLC9cXHMobW9iaWxlKSg/Ols7XFwvXXxcXHNzYWZhcmkpL2ldLFtbVFlQRSx1dGlsLmxvd2VyaXplXSxWRU5ET1IsTU9ERUxdLFsvW1xcc1xcL1xcKF0oc21hcnQtP3R2KVs7XFwpXS9pXSxbW1RZUEUsU01BUlRUVl1dLFsvKGFuZHJvaWRbXFx3XFwuXFxzXFwtXXswLDl9KTsuK2J1aWxkL2ldLFtNT0RFTCxbVkVORE9SLFwiR2VuZXJpY1wiXV0sWy8ocGhvbmUpL2ldLFtbVFlQRSxNT0JJTEVdXV0sZW5naW5lOltbL3dpbmRvd3MuK1xcc2VkZ2VcXC8oW1xcd1xcLl0rKS9pXSxbVkVSU0lPTixbTkFNRSxcIkVkZ2VIVE1MXCJdXSxbL3dlYmtpdFxcLzUzN1xcLjM2LitjaHJvbWVcXC8oPyEyNykoW1xcd1xcLl0rKS9pXSxbVkVSU0lPTixbTkFNRSxcIkJsaW5rXCJdXSxbLyhwcmVzdG8pXFwvKFtcXHdcXC5dKykvaSwvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M218Z29hbm5hKVxcLyhbXFx3XFwuXSspL2ksLyhraHRtbHx0YXNtYW58bGlua3MpW1xcL1xcc11cXCg/KFtcXHdcXC5dKykvaSwvKGljYWIpW1xcL1xcc10oWzIzXVxcLltcXGRcXC5dKykvaV0sW05BTUUsVkVSU0lPTl0sWy9ydlxcOihbXFx3XFwuXXsxLDl9KS4rKGdlY2tvKS9pXSxbVkVSU0lPTixOQU1FXV0sb3M6W1svKHhib3gpO1xccyt4Ym94XFxzKFteXFwpO10rKS9pLC9taWNyb3NvZnRcXHMod2luZG93cylcXHModmlzdGF8eHApL2ldLFtOQU1FLFZFUlNJT05dLFsvKHdpbmRvd3MpXFxzbnRcXHM2XFwuMjtcXHMoYXJtKS9pLC8od2luZG93c1xcc3Bob25lKD86XFxzb3MpKilbXFxzXFwvXT8oW1xcZFxcLlxcc1xcd10qKS9pLC8od2luZG93c1xcc21vYmlsZXx3aW5kb3dzKVtcXHNcXC9dPyhbbnRjZVxcZFxcLlxcc10rXFx3KS9pXSxbTkFNRSxbVkVSU0lPTixtYXBwZXIuc3RyLG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sWy8od2luKD89M3w5fG4pfHdpblxcczl4XFxzKShbbnRcXGRcXC5dKykvaV0sW1tOQU1FLFwiV2luZG93c1wiXSxbVkVSU0lPTixtYXBwZXIuc3RyLG1hcHMub3Mud2luZG93cy52ZXJzaW9uXV0sWy9cXCgoYmIpKDEwKTsvaV0sW1tOQU1FLFwiQmxhY2tCZXJyeVwiXSxWRVJTSU9OXSxbLyhibGFja2JlcnJ5KVxcdypcXC8/KFtcXHdcXC5dKikvaSwvKHRpemVufGthaW9zKVtcXC9cXHNdKFtcXHdcXC5dKykvaSwvKGFuZHJvaWR8d2Vib3N8cGFsbVxcc29zfHFueHxiYWRhfHJpbVxcc3RhYmxldFxcc29zfG1lZWdvfHNhaWxmaXNofGNvbnRpa2kpW1xcL1xccy1dPyhbXFx3XFwuXSopL2ldLFtOQU1FLFZFUlNJT05dLFsvKHN5bWJpYW5cXHM/b3N8c3ltYm9zfHM2MCg/PTspKVtcXC9cXHMtXT8oW1xcd1xcLl0qKS9pXSxbW05BTUUsXCJTeW1iaWFuXCJdLFZFUlNJT05dLFsvXFwoKHNlcmllczQwKTsvaV0sW05BTUVdLFsvbW96aWxsYS4rXFwobW9iaWxlOy4rZ2Vja28uK2ZpcmVmb3gvaV0sW1tOQU1FLFwiRmlyZWZveCBPU1wiXSxWRVJTSU9OXSxbL2Nya2V5XFwvKFtcXGRcXC5dKykvaV0sW1ZFUlNJT04sW05BTUUsXCJDaHJvbWVjYXN0XCJdXSxbLyhuaW50ZW5kb3xwbGF5c3RhdGlvbilcXHMoW3dpZHMzNHBvcnRhYmxldnVdKykvaSwvKG1pbnQpW1xcL1xcc1xcKF0/KFxcdyopL2ksLyhtYWdlaWF8dmVjdG9ybGludXgpWztcXHNdL2ksLyhqb2xpfFtreGxuXT91YnVudHV8ZGViaWFufHN1c2V8b3BlbnN1c2V8Z2VudG9vfCg/PVxccylhcmNofHNsYWNrd2FyZXxmZWRvcmF8bWFuZHJpdmF8Y2VudG9zfHBjbGludXhvc3xyZWRoYXR8emVud2Fsa3xsaW5wdXMpW1xcL1xccy1dPyg/IWNocm9tKShbXFx3XFwuLV0qKS9pLC8oaHVyZHxsaW51eClcXHM/KFtcXHdcXC5dKikvaSwvKGdudSlcXHM/KFtcXHdcXC5dKikvaV0sW05BTUUsVkVSU0lPTl0sWy8oY3JvcylcXHNbXFx3XStcXHMoW1xcd1xcLl0rXFx3KS9pXSxbW05BTUUsXCJDaHJvbWl1bSBPU1wiXSxWRVJTSU9OXSxbLyhzdW5vcylcXHM/KFtcXHdcXC5cXGRdKikvaV0sW1tOQU1FLFwiU29sYXJpc1wiXSxWRVJTSU9OXSxbL1xccyhbZnJlbnRvcGMtXXswLDR9YnNkfGRyYWdvbmZseSlcXHM/KFtcXHdcXC5dKikvaV0sW05BTUUsVkVSU0lPTl0sWy8oaGFpa3UpXFxzKFxcdyspL2ldLFtOQU1FLFZFUlNJT05dLFsvY2ZuZXR3b3JrXFwvLitkYXJ3aW4vaSwvaXBbaG9uZWFkXXsyLDR9KD86Lipvc1xccyhbXFx3XSspXFxzbGlrZVxcc21hY3w7XFxzb3BlcmEpL2ldLFtbVkVSU0lPTiwvXy9nLFwiLlwiXSxbTkFNRSxcImlPU1wiXV0sWy8obWFjXFxzb3NcXHN4KVxccz8oW1xcd1xcc1xcLl0qKS9pLC8obWFjaW50b3NofG1hYyg/PV9wb3dlcnBjKVxccykvaV0sW1tOQU1FLFwiTWFjIE9TXCJdLFtWRVJTSU9OLC9fL2csXCIuXCJdXSxbLygoPzpvcGVuKT9zb2xhcmlzKVtcXC9cXHMtXT8oW1xcd1xcLl0qKS9pLC8oYWl4KVxccygoXFxkKSg/PVxcLnxcXCl8XFxzKVtcXHdcXC5dKSovaSwvKHBsYW5cXHM5fG1pbml4fGJlb3N8b3NcXC8yfGFtaWdhb3N8bW9ycGhvc3xyaXNjXFxzb3N8b3BlbnZtc3xmdWNoc2lhKS9pLC8odW5peClcXHM/KFtcXHdcXC5dKikvaV0sW05BTUUsVkVSU0lPTl1dfTt2YXIgVUFQYXJzZXI9ZnVuY3Rpb24odWFzdHJpbmcsZXh0ZW5zaW9ucyl7aWYodHlwZW9mIHVhc3RyaW5nPT09XCJvYmplY3RcIil7ZXh0ZW5zaW9ucz11YXN0cmluZzt1YXN0cmluZz11bmRlZmluZWR9aWYoISh0aGlzIGluc3RhbmNlb2YgVUFQYXJzZXIpKXtyZXR1cm4gbmV3IFVBUGFyc2VyKHVhc3RyaW5nLGV4dGVuc2lvbnMpLmdldFJlc3VsdCgpfXZhciB1YT11YXN0cmluZ3x8KHdpbmRvdyYmd2luZG93Lm5hdmlnYXRvciYmd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ/d2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ6RU1QVFkpO3ZhciByZ3htYXA9ZXh0ZW5zaW9ucz91dGlsLmV4dGVuZChyZWdleGVzLGV4dGVuc2lvbnMpOnJlZ2V4ZXM7dGhpcy5nZXRCcm93c2VyPWZ1bmN0aW9uKCl7dmFyIGJyb3dzZXI9e25hbWU6dW5kZWZpbmVkLHZlcnNpb246dW5kZWZpbmVkfTttYXBwZXIucmd4LmNhbGwoYnJvd3Nlcix1YSxyZ3htYXAuYnJvd3Nlcik7YnJvd3Nlci5tYWpvcj11dGlsLm1ham9yKGJyb3dzZXIudmVyc2lvbik7cmV0dXJuIGJyb3dzZXJ9O3RoaXMuZ2V0Q1BVPWZ1bmN0aW9uKCl7dmFyIGNwdT17YXJjaGl0ZWN0dXJlOnVuZGVmaW5lZH07bWFwcGVyLnJneC5jYWxsKGNwdSx1YSxyZ3htYXAuY3B1KTtyZXR1cm4gY3B1fTt0aGlzLmdldERldmljZT1mdW5jdGlvbigpe3ZhciBkZXZpY2U9e3ZlbmRvcjp1bmRlZmluZWQsbW9kZWw6dW5kZWZpbmVkLHR5cGU6dW5kZWZpbmVkfTttYXBwZXIucmd4LmNhbGwoZGV2aWNlLHVhLHJneG1hcC5kZXZpY2UpO3JldHVybiBkZXZpY2V9O3RoaXMuZ2V0RW5naW5lPWZ1bmN0aW9uKCl7dmFyIGVuZ2luZT17bmFtZTp1bmRlZmluZWQsdmVyc2lvbjp1bmRlZmluZWR9O21hcHBlci5yZ3guY2FsbChlbmdpbmUsdWEscmd4bWFwLmVuZ2luZSk7cmV0dXJuIGVuZ2luZX07dGhpcy5nZXRPUz1mdW5jdGlvbigpe3ZhciBvcz17bmFtZTp1bmRlZmluZWQsdmVyc2lvbjp1bmRlZmluZWR9O21hcHBlci5yZ3guY2FsbChvcyx1YSxyZ3htYXAub3MpO3JldHVybiBvc307dGhpcy5nZXRSZXN1bHQ9ZnVuY3Rpb24oKXtyZXR1cm57dWE6dGhpcy5nZXRVQSgpLGJyb3dzZXI6dGhpcy5nZXRCcm93c2VyKCksZW5naW5lOnRoaXMuZ2V0RW5naW5lKCksb3M6dGhpcy5nZXRPUygpLGRldmljZTp0aGlzLmdldERldmljZSgpLGNwdTp0aGlzLmdldENQVSgpfX07dGhpcy5nZXRVQT1mdW5jdGlvbigpe3JldHVybiB1YX07dGhpcy5zZXRVQT1mdW5jdGlvbih1YXN0cmluZyl7dWE9dWFzdHJpbmc7cmV0dXJuIHRoaXN9O3JldHVybiB0aGlzfTtVQVBhcnNlci5WRVJTSU9OPUxJQlZFUlNJT047VUFQYXJzZXIuQlJPV1NFUj17TkFNRTpOQU1FLE1BSk9SOk1BSk9SLFZFUlNJT046VkVSU0lPTn07VUFQYXJzZXIuQ1BVPXtBUkNISVRFQ1RVUkU6QVJDSElURUNUVVJFfTtVQVBhcnNlci5ERVZJQ0U9e01PREVMOk1PREVMLFZFTkRPUjpWRU5ET1IsVFlQRTpUWVBFLENPTlNPTEU6Q09OU09MRSxNT0JJTEU6TU9CSUxFLFNNQVJUVFY6U01BUlRUVixUQUJMRVQ6VEFCTEVULFdFQVJBQkxFOldFQVJBQkxFLEVNQkVEREVEOkVNQkVEREVEfTtVQVBhcnNlci5FTkdJTkU9e05BTUU6TkFNRSxWRVJTSU9OOlZFUlNJT059O1VBUGFyc2VyLk9TPXtOQU1FOk5BTUUsVkVSU0lPTjpWRVJTSU9OfTtpZih0eXBlb2YgZXhwb3J0cyE9PVVOREVGX1RZUEUpe2lmKHR5cGVvZiBtb2R1bGUhPT1VTkRFRl9UWVBFJiZtb2R1bGUuZXhwb3J0cyl7ZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1VQVBhcnNlcn1leHBvcnRzLlVBUGFyc2VyPVVBUGFyc2VyfWVsc2V7aWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIFVBUGFyc2VyfSl9ZWxzZSBpZih3aW5kb3cpe3dpbmRvdy5VQVBhcnNlcj1VQVBhcnNlcn19dmFyICQ9d2luZG93JiYod2luZG93LmpRdWVyeXx8d2luZG93LlplcHRvKTtpZigkJiYhJC51YSl7dmFyIHBhcnNlcj1uZXcgVUFQYXJzZXI7JC51YT1wYXJzZXIuZ2V0UmVzdWx0KCk7JC51YS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gcGFyc2VyLmdldFVBKCl9OyQudWEuc2V0PWZ1bmN0aW9uKHVhc3RyaW5nKXtwYXJzZXIuc2V0VUEodWFzdHJpbmcpO3ZhciByZXN1bHQ9cGFyc2VyLmdldFJlc3VsdCgpO2Zvcih2YXIgcHJvcCBpbiByZXN1bHQpeyQudWFbcHJvcF09cmVzdWx0W3Byb3BdfX19fSkodHlwZW9mIHdpbmRvdz09PVwib2JqZWN0XCI/d2luZG93OnRoaXMpOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmV4cG9ydCBjb25zdCBDbG9zZUljb24gPSAoKSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxzdmdcclxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXHJcbiAgICAgIHdpZHRoPVwiMTAuMDAzXCJcclxuICAgICAgaGVpZ2h0PVwiMTBcIlxyXG4gICAgICB2aWV3Qm94PVwiMCAwIDEwLjAwMyAxMFwiXHJcbiAgICA+XHJcbiAgICAgIDxwYXRoXHJcbiAgICAgICAgZGF0YS1uYW1lPVwiX2lvbmljb25zX3N2Z19pb3MtY2xvc2UgKDUpXCJcclxuICAgICAgICBkPVwiTTE2Ni42ODYsMTY1LjU1bDMuNTczLTMuNTczYS44MzcuODM3LDAsMCwwLTEuMTg0LTEuMTg0bC0zLjU3MywzLjU3My0zLjU3My0zLjU3M2EuODM3LjgzNywwLDEsMC0xLjE4NCwxLjE4NGwzLjU3MywzLjU3My0zLjU3MywzLjU3M2EuODM3LjgzNywwLDAsMCwxLjE4NCwxLjE4NGwzLjU3My0zLjU3MywzLjU3MywzLjU3M2EuODM3LjgzNywwLDAsMCwxLjE4NC0xLjE4NFpcIlxyXG4gICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMTYwLjUgLTE2MC41NSlcIlxyXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxyXG4gICAgICAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuZXhwb3J0IGNvbnN0IExvbmdBcnJvd0xlZnQgPSAoeyAuLi5wcm9wcyB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxzdmdcclxuICAgICAgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xyXG4gICAgICB3aWR0aD0nMTInXHJcbiAgICAgIGhlaWdodD0nOC4wMDMnXHJcbiAgICAgIHZpZXdCb3g9JzAgMCAxMiA4LjAwMydcclxuICAgICAgey4uLnByb3BzfVxyXG4gICAgPlxyXG4gICAgICA8cGF0aFxyXG4gICAgICAgIGRhdGEtbmFtZT0nX2lvbmljb25zX3N2Z19pb3MtYXJyb3ctcm91bmQtYmFjayAoMiknXHJcbiAgICAgICAgZD0nTTExNi40NDcsMTYwLjE3N2EuNTQ1LjU0NSwwLDAsMSwwLC43NjdsLTIuNTMsMi41MzhoOS42NDFhLjU0Mi41NDIsMCwwLDEsMCwxLjA4NGgtOS42NDFsMi41MzQsMi41MzhhLjU0OS41NDksMCwwLDEsMCwuNzY3LjU0LjU0LDAsMCwxLS43NjMsMGwtMy40MzUtMy40NmEuNjA4LjYwOCwwLDAsMS0uMTEzLS4xNzEuNTE3LjUxNywwLDAsMS0uMDQyLS4yMDguNTQzLjU0MywwLDAsMSwuMTU0LS4zNzlsMy40MzUtMy40NkEuNTMxLjUzMSwwLDAsMSwxMTYuNDQ3LDE2MC4xNzdaJ1xyXG4gICAgICAgIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xMTIuMSAtMTYwLjAyMyknXHJcbiAgICAgICAgZmlsbD0nY3VycmVudENvbG9yJ1xyXG4gICAgICAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufTtcclxuIiwiaW1wb3J0IFJlYWN0LCB7IEZyYWdtZW50IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmNEcmF3ZXIgZnJvbSAncmMtZHJhd2VyJztcclxuXHJcbnR5cGUgRHJhd2VyUHJvcHMgPSB7XHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xyXG4gIGNoaWxkcmVuPzogYW55O1xyXG4gIGNsb3NlQnV0dG9uPzogYW55O1xyXG4gIGNsb3NlQnV0dG9uU3R5bGU/OiBhbnk7XHJcbiAgZHJhd2VySGFuZGxlcjogYW55O1xyXG4gIHRvZ2dsZUhhbmRsZXI6IGFueTtcclxuICBvcGVuOiBhbnk7XHJcbiAgd2lkdGg/OiBzdHJpbmc7XHJcbiAgcGxhY2VtZW50PzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd0b3AnIHwgJ2JvdHRvbSc7XHJcbn07XHJcblxyXG5jb25zdCBEcmF3ZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PERyYXdlclByb3BzPiA9ICh7XHJcbiAgY2xhc3NOYW1lLFxyXG4gIGNoaWxkcmVuLFxyXG4gIGNsb3NlQnV0dG9uLFxyXG4gIGNsb3NlQnV0dG9uU3R5bGUsXHJcbiAgZHJhd2VySGFuZGxlcixcclxuICB0b2dnbGVIYW5kbGVyLFxyXG4gIG9wZW4sXHJcbiAgd2lkdGgsXHJcbiAgcGxhY2VtZW50LFxyXG4gIC4uLnByb3BzXHJcbn0pID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPEZyYWdtZW50PlxyXG4gICAgICA8UmNEcmF3ZXJcclxuICAgICAgICBvcGVuPXtvcGVufVxyXG4gICAgICAgIG9uQ2xvc2U9e3RvZ2dsZUhhbmRsZXJ9XHJcbiAgICAgICAgY2xhc3NOYW1lPXtgZHJhd2VyICR7Y2xhc3NOYW1lID8gY2xhc3NOYW1lIDogJyd9YC50cmltKCl9XHJcbiAgICAgICAgd2lkdGg9e3dpZHRofVxyXG4gICAgICAgIHBsYWNlbWVudD17cGxhY2VtZW50fVxyXG4gICAgICAgIGhhbmRsZXI9e2ZhbHNlfVxyXG4gICAgICAgIGxldmVsPXtudWxsfVxyXG4gICAgICAgIGR1cmF0aW9uPVwiLjRzXCJcclxuICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgID5cclxuICAgICAgICB7Y2xvc2VCdXR0b24gJiYgKFxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJkcmF3ZXJfX2Nsb3NlXCJcclxuICAgICAgICAgICAgb25DbGljaz17dG9nZ2xlSGFuZGxlcn1cclxuICAgICAgICAgICAgc3R5bGU9e2Nsb3NlQnV0dG9uU3R5bGV9XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIHtjbG9zZUJ1dHRvbn1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcblxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgPC9SY0RyYXdlcj5cclxuICAgICAgPGRpdlxyXG4gICAgICAgIGNsYXNzTmFtZT1cImRyYXdlcl9faGFuZGxlclwiXHJcbiAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogJ2lubGluZS1ibG9jaycgfX1cclxuICAgICAgICBvbkNsaWNrPXt0b2dnbGVIYW5kbGVyfVxyXG4gICAgICA+XHJcbiAgICAgICAge2RyYXdlckhhbmRsZXJ9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9GcmFnbWVudD5cclxuICApO1xyXG59O1xyXG5cclxuRHJhd2VyLmRlZmF1bHRQcm9wcyA9IHtcclxuICB3aWR0aDogJzMwMHB4JyxcclxuICBwbGFjZW1lbnQ6ICdsZWZ0JyxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERyYXdlcjtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInO1xyXG4vLyBAdHMtaWdub3JlXHJcbmltcG9ydCB7IG9wZW5Nb2RhbCwgY2xvc2VNb2RhbCB9IGZyb20gJ0ByZWRxL3JldXNlLW1vZGFsJztcclxuaW1wb3J0IE1vYmlsZVNpZGViYXIgZnJvbSAnLi9Nb2JpbGVTaWRlYmFyJztcclxuaW1wb3J0IHtcclxuICAgIE1vYmlsZUhlYWRlcldyYXBwZXIsXHJcbiAgICBNb2JpbGVIZWFkZXJJbm5lcldyYXBwZXIsXHJcbiAgICBEcmF3ZXJXcmFwcGVyLFxyXG4gICAgTG9nb1dyYXBwZXIsXHJcbiAgICBTZWFyY2hXcmFwcGVyLFxyXG4gICAgU2VhcmNoTW9kYWxXcmFwcGVyLFxyXG4gICAgU2VhcmNoTW9kYWxDbG9zZSxcclxufSBmcm9tICcuL2hlYWRlci5zdHlsZSc7XHJcbmltcG9ydCBTZWFyY2ggZnJvbSAnLi9zZWFyY2gvc2VhcmNoJztcclxuaW1wb3J0IExvZ29JbWFnZSBmcm9tICcuLi8uLi8uLi9hc3NldHMvaW1hZ2VzL2xvZ28uc3ZnJztcclxuXHJcbmltcG9ydCB7IFNlYXJjaEljb24gfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvaWNvbnMvU2VhcmNoSWNvbic7XHJcbmltcG9ydCB7IExvbmdBcnJvd0xlZnQgfSBmcm9tICcuLi8uLi8uLi9hc3NldHMvaWNvbnMvTG9uZ0Fycm93TGVmdCc7XHJcbmltcG9ydCBMb2dvIGZyb20gJy4uL2xvZ28vbG9nbyc7XHJcbmltcG9ydCBDdXJyZW5jeVN3aXRjaGVyIGZyb20gJy4vbWVudS9jdXJyZW5jeS1zd2l0Y2hlci9DdXJyZW5jeVN3aXRjaGVyJztcclxudHlwZSBNb2JpbGVIZWFkZXJQcm9wcyA9IHtcclxuICAgIGNsYXNzTmFtZT86IHN0cmluZztcclxuICAgIGNsb3NlU2VhcmNoPzogYW55O1xyXG59O1xyXG5cclxuY29uc3QgU2VhcmNoTW9kYWw6IFJlYWN0LkZDPHt9PiA9ICgpID0+IHtcclxuICAgIGNvbnN0IG9uU3VibWl0ID0gKCkgPT4ge1xyXG4gICAgICAgIGNsb3NlTW9kYWwoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxTZWFyY2hNb2RhbFdyYXBwZXI+XHJcbiAgICAgICAgICAgIDxTZWFyY2hNb2RhbENsb3NlIHR5cGU9XCJzdWJtaXRcIiBvbkNsaWNrPXsoKSA9PiBjbG9zZU1vZGFsKCl9PlxyXG4gICAgICAgICAgICAgICAgPExvbmdBcnJvd0xlZnQgLz5cclxuICAgICAgICAgICAgPC9TZWFyY2hNb2RhbENsb3NlPlxyXG4gICAgICAgICAgICA8U2VhcmNoXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJoZWFkZXItbW9kYWwtc2VhcmNoXCJcclxuICAgICAgICAgICAgICAgIHNob3dCdXR0b25UZXh0PXtmYWxzZX1cclxuICAgICAgICAgICAgICAgIG9uU3VibWl0PXtvblN1Ym1pdH1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICA8L1NlYXJjaE1vZGFsV3JhcHBlcj5cclxuICAgICk7XHJcbn07XHJcblxyXG5jb25zdCBNb2JpbGVIZWFkZXI6IFJlYWN0LkZDPE1vYmlsZUhlYWRlclByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlU2VhcmNoTW9kYWwgPSAoKSA9PiB7XHJcbiAgICAgICAgb3Blbk1vZGFsKHtcclxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVSZXNpemluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdzZWFyY2gtbW9kYWwtbW9iaWxlJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VPbkNsaWNrT3V0c2lkZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogU2VhcmNoTW9kYWwsXHJcbiAgICAgICAgICAgIGNsb3NlQ29tcG9uZW50OiAoKSA9PiA8ZGl2IC8+LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TW9iaWxlSGVhZGVyV3JhcHBlcj5cclxuXHJcbiAgICAgICAgICAgIDxNb2JpbGVIZWFkZXJJbm5lcldyYXBwZXIgY2xhc3NOYW1lPXtjbGFzc05hbWV9ID5cclxuICAgICAgICAgICAgICAgIDxEcmF3ZXJXcmFwcGVyPlxyXG4gICAgICAgICAgICAgICAgICAgIDxNb2JpbGVTaWRlYmFyIC8+XHJcbiAgICAgICAgICAgICAgICA8L0RyYXdlcldyYXBwZXI+XHJcbiAgICAgICAgICAgICAgICA8TG9nb1dyYXBwZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgPExvZ28gaW1hZ2VVcmw9e0xvZ29JbWFnZX0gYWx0PVwiV2lzZWNhcnQgLSBMb2dvXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvTG9nb1dyYXBwZXI+XHJcbiAgICAgICAgICAgICAgICA8Q3VycmVuY3lTd2l0Y2hlciAvPlxyXG5cclxuICAgICAgICAgICAgICAgIDxTZWFyY2hXcmFwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlU2VhcmNoTW9kYWx9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwic2VhcmNoSWNvbldyYXBwZXJcIlxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIDxTZWFyY2hJY29uIC8+XHJcbiAgICAgICAgICAgICAgICA8L1NlYXJjaFdyYXBwZXI+XHJcblxyXG4gICAgICAgICAgICA8L01vYmlsZUhlYWRlcklubmVyV3JhcHBlcj5cclxuICAgICAgICA8L01vYmlsZUhlYWRlcldyYXBwZXI+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTW9iaWxlSGVhZGVyO1xyXG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGV9IGZyb20gJ3JlYWN0JztcclxuLy8gQHRzLWlnbm9yZVxyXG5pbXBvcnQgUm91dGVyIGZyb20gJ25leHQvcm91dGVyJztcclxuaW1wb3J0IERyYXdlciBmcm9tICcuLi9kcmF3ZXIvZHJhd2VyJztcclxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnLi4vLi4vT3RoZXJzL2J1dHRvbi9idXR0b24nO1xyXG5pbXBvcnQgTmF2TGluayBmcm9tICcuLi9uYXYtbGluay9uYXYtbGluayc7XHJcbmltcG9ydCB7IENsb3NlSWNvbiB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9pY29ucy9DbG9zZUljb24nO1xyXG5pbXBvcnQge1xyXG4gIEhhbWJ1cmdlckljb24sXHJcbiAgRHJhd2VyQ29udGVudFdyYXBwZXIsXHJcbiAgRHJhd2VyQ2xvc2UsXHJcbiAgRHJhd2VyUHJvZmlsZSxcclxuICBMb2dvdXRWaWV3LFxyXG4gIExvZ2luVmlldyxcclxuICBVc2VyQXZhdGFyLFxyXG4gIFVzZXJEZXRhaWxzLFxyXG4gIERyYXdlck1lbnUsXHJcbiAgRHJhd2VyTWVudUl0ZW0sXHJcbiAgVXNlck9wdGlvbk1lbnUsIERyYXdlckJvZHksXHJcbn0gZnJvbSAnLi9oZWFkZXIuc3R5bGUnO1xyXG5pbXBvcnQgVXNlckltYWdlIGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9pbWFnZXMvdXNlci5qcGcnO1xyXG5pbXBvcnQge1xyXG4gIE1PQklMRV9EUkFXRVJfTUVOVSxcclxuICBQUk9GSUxFX1BBR0UsXHJcbn0gZnJvbSAnLi9zaXRlLW5hdmlnYXRpb24nO1xyXG5pbXBvcnQge3VzZURpc3BhdGNoLHVzZVNlbGVjdG9yfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcclxuaW1wb3J0IHtsb2dvdXR9IGZyb20gXCJAL3JlZHV4L2FjdGlvbnMvZ2xvYmFsQWN0aW9uc1wiO1xyXG5pbXBvcnQge1Njcm9sbGJhcn0gZnJvbSBcIkAvY29tcG9uZW50cy9TY3JvbGxiYXJcIjtcclxuXHJcbmNvbnN0IE1vYmlsZVNpZGViYXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gIGNvbnN0IGRpc3BhdGNoPXVzZURpc3BhdGNoKClcclxuICAvL2dldHRpbmcgdXNlclxyXG4gIGNvbnN0IHtpc0F1dGhlbnRpY2F0ZWQsdXNlcn0gPSB1c2VTZWxlY3Rvcigoc3RhdGU6YW55KSA9PiBzdGF0ZS5nbG9iYWxSZWR1Y2VyKTtcclxuXHJcbiAgICAvL3RvZ2dsZSBzdGF0ZVxyXG4gIGNvbnN0W3RvZ2dsZSxzZXRUb2dnbGVdPXVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKVxyXG4gIC8vaGFyZGNvZGVkIGF1dGhlbnRpY2F0aW9uXHJcbiAgLy8gVG9nZ2xlIGRyYXdlclxyXG4gIGNvbnN0IHRvZ2dsZUhhbmRsZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgIHNldFRvZ2dsZSghdG9nZ2xlKVxyXG4gICAgfSwgW3RvZ2dsZV0pO1xyXG5cclxuICBjb25zdCBoYW5kbGVMb2dvdXQgPSAoKSA9PiB7XHJcbiAgICBkaXNwYXRjaChsb2dvdXQoKSlcclxuICB9O1xyXG5cclxuICBjb25zdCBzaWduSW5PdXRGb3JtID0gKCkgPT4ge1xyXG5cclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgICA8RHJhd2VyXHJcbiAgICAgICAgICB3aWR0aD1cIjMxNnB4XCJcclxuICAgICAgICAgIGRyYXdlckhhbmRsZXI9e1xyXG4gICAgICAgICAgICA8SGFtYnVyZ2VySWNvbj5cclxuICAgICAgICAgICAgICA8c3BhbiAvPlxyXG4gICAgICAgICAgICAgIDxzcGFuIC8+XHJcbiAgICAgICAgICAgICAgPHNwYW4gLz5cclxuICAgICAgICAgICAgICA8c3BhbiAvPlxyXG4gICAgICAgICAgICA8L0hhbWJ1cmdlckljb24+XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvcGVuPXt0b2dnbGV9XHJcbiAgICAgICAgICB0b2dnbGVIYW5kbGVyPXt0b2dnbGVIYW5kbGVyfVxyXG4gICAgICAgICAgY2xvc2VCdXR0b249e1xyXG4gICAgICAgICAgICA8RHJhd2VyQ2xvc2U+XHJcbiAgICAgICAgICAgICAgPENsb3NlSWNvbiAvPlxyXG4gICAgICAgICAgICA8L0RyYXdlckNsb3NlPlxyXG4gICAgICAgICAgfVxyXG4gICAgICA+XHJcbiAgICAgICAgPFNjcm9sbGJhciBzdHlsZT17e2hlaWdodDpcIjEwMHZoXCJ9fT5cclxuICAgICAgICAgIDxEcmF3ZXJDb250ZW50V3JhcHBlcj5cclxuICAgICAgICAgICAgPERyYXdlclByb2ZpbGU+XHJcbiAgICAgICAgICAgICAge2lzQXV0aGVudGljYXRlZCYmdXNlciA/IChcclxuICAgICAgICAgICAgICAgICAgPExvZ2luVmlldz5cclxuICAgICAgICAgICAgICAgICAgICA8VXNlckF2YXRhcj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtVc2VySW1hZ2V9IGFsdD1cInVzZXJfYXZhdGFyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8L1VzZXJBdmF0YXI+XHJcbiAgICAgICAgICAgICAgICAgICAgPFVzZXJEZXRhaWxzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGgzPnt1c2VyLmZpcnN0TmFtZSArICcgJysgdXNlci5sYXN0TmFtZX08L2gzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3VzZXIuZW1haWx9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvVXNlckRldGFpbHM+XHJcbiAgICAgICAgICAgICAgICAgIDwvTG9naW5WaWV3PlxyXG4gICAgICAgICAgICAgICkgOiAoXHJcbiAgICAgICAgICAgICAgICAgIDxMb2dvdXRWaWV3PlxyXG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gdmFyaWFudD1cInByaW1hcnlcIiBvbkNsaWNrPXtzaWduSW5PdXRGb3JtfT5cclxuICAgICAgICAgICAgICAgICAgICAgIExvZ2luL1JlZ2lzdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDwvTG9nb3V0Vmlldz5cclxuICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICA8L0RyYXdlclByb2ZpbGU+XHJcblxyXG4gICAgICAgICAgICA8RHJhd2VyTWVudT5cclxuICAgICAgICAgICAgICB7TU9CSUxFX0RSQVdFUl9NRU5VLm1hcCgoaXRlbSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICA8RHJhd2VyTWVudUl0ZW0ga2V5PXtpdGVtLmlkfT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dG9nZ2xlSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj17aXRlbS5ocmVmfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17aXRlbS5kZWZhdWx0TWVzc2FnZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZHJhd2VyX21lbnVfaXRlbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgPC9EcmF3ZXJNZW51SXRlbT5cclxuICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgPC9EcmF3ZXJNZW51PlxyXG5cclxuICAgICAgICAgICAge2lzQXV0aGVudGljYXRlZCAmJiAoXHJcbiAgICAgICAgICAgICAgICA8VXNlck9wdGlvbk1lbnU+XHJcbiAgICAgICAgICAgICAgICAgIDxEcmF3ZXJNZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgICA8TmF2TGlua1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmPXtQUk9GSUxFX1BBR0V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPVwiWW91ciBBY2NvdW50IFNldHRpbmdzXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZHJhd2VyX21lbnVfaXRlbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgPC9EcmF3ZXJNZW51SXRlbT5cclxuICAgICAgICAgICAgICAgICAgPERyYXdlck1lbnVJdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17aGFuZGxlTG9nb3V0fSBjbGFzc05hbWU9XCJkcmF3ZXJfbWVudV9pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImxvZ291dEJ0blwiPlxyXG4gICAgICAgICAgICAgICAgICAgIExvZ291dFxyXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDwvRHJhd2VyTWVudUl0ZW0+XHJcbiAgICAgICAgICAgICAgICA8L1VzZXJPcHRpb25NZW51PlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgPC9EcmF3ZXJDb250ZW50V3JhcHBlcj5cclxuICAgICAgICA8L1Njcm9sbGJhcj5cclxuICAgICAgPC9EcmF3ZXI+XHJcblxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNb2JpbGVTaWRlYmFyO1xyXG4iLCJpbXBvcnQgeyBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudCB9IGZyb20gJ292ZXJsYXlzY3JvbGxiYXJzLXJlYWN0JztcclxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgJ292ZXJsYXlzY3JvbGxiYXJzL2Nzcy9PdmVybGF5U2Nyb2xsYmFycy5jc3MnO1xyXG5cclxudHlwZSBTY3JvbGxiYXJQcm9wcyA9IHtcclxuICAgIGNsYXNzTmFtZT86IHN0cmluZztcclxuICAgIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XHJcbiAgICBvcHRpb25zPzogYW55O1xyXG4gICAgc3R5bGU/OiBhbnk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgU2Nyb2xsYmFyOiBSZWFjdC5GQzxTY3JvbGxiYXJQcm9wcz4gPSAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3BzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudFxyXG4gICAgICAgICAgICBvcHRpb25zPXt7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGAke2NsYXNzTmFtZX0gb3MtdGhlbWUtdGhpbmAsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b0hpZGU6ICdsZWF2ZScsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxyXG4gICAgICAgICAgICB7Li4ucHJvcHN9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9PdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudD5cclxuICAgICk7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=